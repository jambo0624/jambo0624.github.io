<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You should know</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jambo0624.github.io/"/>
  <updated>2020-08-12T14:32:06.607Z</updated>
  <id>https://jambo0624.github.io/</id>
  
  <author>
    <name>Jambo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>how-program-works</title>
    <link href="https://jambo0624.github.io/2020-07-26-how-program-works.html"/>
    <id>https://jambo0624.github.io/2020-07-26-how-program-works.html</id>
    <published>2020-07-26T07:47:59.000Z</published>
    <updated>2020-08-12T14:32:06.607Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是《程序是怎么跑起来的》读书笔记。<br>在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。<br>下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: </p><a id="more"></a><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>程序是由指令和数据构成的。<br>CPU所负责的就是解释和运行最终转换成机器语言的程序内容。<br>从功能方面来看， CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。<br><strong>寄存器</strong> 可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。<br><strong>控制器</strong> 负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。<br><strong>运算器</strong> 负责运算从内存读入寄存器的数据。<br><strong>时钟</strong> 负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。</p><p>汇编语言 (assembly) 采用助记符 (memonic) 来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符，助记符通常为指令功能的英语单词的简写。<br>通常我们将汇编语言编写的程序转化成机器语言的过程称为 <strong>汇编</strong> ；反之，机器语言程序转化成汇编语言程序的过程则称为 <strong>反汇编</strong> 。  </p><p>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器 (基址，变址，通用) 一般有多个。<br>CPU每执行一个指令，程序计数器的值就会自动加1。也就是说，<strong>程序计数器</strong> 决定着程序的流程。<br><strong>标志寄存器</strong> 实现了对程序的流程控制。<br>函数调用处理是通过把程序计数器的值设定成函数的<strong>存储地址</strong>来实现的。<br>函数调用使用的是call指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call指令会把 <strong>调用函数后要执行的指令地址</strong> 存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行<code>return</code>命令。<code>return</code>命令的功能是把保存在栈中的地址设定到程序计数器中。  </p><p>第一张结束了，通过第一章。我们要知道几个基本的知识:</p><ol><li>程序就是数据和指令</li><li><code>高级编程语言</code>-&gt;<code>汇编语言</code>-&gt;<code>机器语言</code></li></ol><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>因为 IC 的所有引脚，只有直流电压 0V 或 5V 两个状态。所以，决定了计算机的信息数据只能用二进制数来处理。<br>计算机处理信息的最小单位——位，就相当于二进制中的一位。位的英文 <code>bit</code> 是二进制数位<code>(binary digit)</code>的缩写。<br>8位二进制数被称为一个 <strong>字节</strong> 。字节是最基本的信息计量单位。位是最小单位，字节是基本单位。   </p><p>二进制数的值转换成十进制数的值，只需将二进制数的各数位的值和 <strong>位权</strong> 相乘，然后将相乘的结果相加即可。<br><strong>移位运算</strong> 指的是将二进制数值的各数位进行左右移位 (shift=移位) 的运算。移位有左移 &lt;&lt; (向高位方向) 和右移 &gt;&gt; (向低位方向) 两种。      </p><p>为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加1。<strong>将二进制数的值取反后加1的结果，和原来的值相加，结果为 0</strong><br>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为<strong>逻辑右移</strong>。<br>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值 (0或1) 。这就称为<strong>算术右移</strong>。如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2、1/4、1/8等的数值运算。如果是正数，只需在最高位补0即可。<br>只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式 (逻辑左移) 还是相乘运算 (算术左移) ，都只需在空出来的低位补 0 即可。   </p><p><strong>符号扩充</strong>就是指在保持值不变的前提下将其转换成16位和32位的二进制数。也就是说，不管是正数还是用补数表示的负数，都只需用符号位的值 (0或者1) 填充高位即可。     </p><p>计算机能处理的运算，大体可分为<strong>算术运算</strong>和<strong>逻辑运算</strong>。算术运算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算，包括逻辑非（NOT运算）、逻辑与（AND运算）、逻辑或（OR运算）和逻辑异或（XOR运算）四种。  </p><h3 id="计算机中进行小数计算时出错的原因"><a href="#计算机中进行小数计算时出错的原因" class="headerlink" title="计算机中进行小数计算时出错的原因"></a>计算机中进行小数计算时出错的原因</h3><p>经典面试题目: 0.1 + 0.2 = ?<br>是因为 <strong>“有一些十进制数的小数无法转换成二进制数”</strong>    </p><p><strong>双精度浮点数</strong> 类型用64位、<strong>单精度浮点数</strong> 类型用32位来表示全体小数<br><strong>浮点数</strong> 是指用符号、尾数、基数和指数这四部分来表示的小数<br>64: 1位符号，11位指数，52位尾数<br>32: 1位符号，8位指数，23位尾数</p><p>如何避免计算机计算出错  </p><blockquote><p>首先是回避策略，即无视这些错误。根据程序目的的不同，有时一些微小的偏差并不会造成什么问题。<br>把小数转换成整数来计算。计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题。</p></blockquote><p>在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD方法，以确保最终得到准确的数值。BCD (Binary Coded Decimal) 是一种使用二进制表示十进制的方法。  </p><p>在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。因此，在实际程序中，也经常会用十六进制数来代替二进制数。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><strong>内存</strong> 实际上是一种名为内存IC的电子元件。内存IC中有<code>电源</code>、<code>地址信号</code>、<code>数据信号</code>、<code>控制信号</code>等用于输入输出的大量引脚（IC的引脚），通过为其指定地址（address），来进行数据的读写。  </p><p>编程语言中的<strong>数据类型</strong>表示存储的是何种类型的数据。<br>从内存来看，就是占用的内存大小的意思。<br>即使是物理上以1个字节为单位来逐一读写数据的内存，在程序中，通过指定其类型（变量的数据类型等），也能实现以特定字节数为单位来进行读写。      </p><p><strong>指针</strong>也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写。   </p><p>数组是高效实用内存的基础。<br><strong>数组</strong>是指多个同样数据类型的数据在内存中连续排列的形式。<br>作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引<code>(index)</code>。<br>指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由<strong>编译器</strong>自动实现的。<br>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。  </p><p><strong>栈</strong>用的是<code>LIFO</code>（Last Input First Out，后入先出）方式，而队列用的则是<code>FIFO</code>（First Input First Out，先入先出）方式。<br><strong>队列</strong>一般是以<code>环状缓冲区</code>（ring buffer）的方式来实现的  </p><p>在数组的各个元素中，除了数据的值之外，通过为其附带上下一个元素的索引，即可实现<strong>链表</strong>。使用<strong>链表</strong>来追加或删除数据则毫不费事。   </p><h3 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h3><blockquote><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。即使CPU可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低。总之，存储在磁盘中的程序需要读入到内存后才能运行。</p></blockquote><p>磁盘缓存 (disk cache) 指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。使用磁盘缓存可以大大改善磁盘数据的访问速度<br>虚拟内存 (virtual memory) 是指把磁盘的一部分作为假想的内存来使用。<br>虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的。也就是说，为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。    </p><p>节约内存的编程方法<br>(1) 通过DLL文件实现函数共有<br>DLL（Dynamic Link Library）文件，顾名思义，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。此外，还有一个需要大家注意的地方，那就是多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。<br>Windows的操作系统本身也是多个DLL文件的集合体。有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。<br>(2) 通过调用_stdcall来减小程序文件的大小<br><strong>栈清理处理</strong>是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。<br>该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。<br>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。这时所使用的就是_stdcall。<br>在函数前加上_stdcall，就可以把栈清理处理变为在被调用函数一方进行。</p><p>磁盘的物理结构<br>扇区是对磁盘进行物理读写的最小单位。<br>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用1簇的空间。这样一来，所有的文件都会占用1簇的整数倍的磁盘空间。<br>以簇为单位进行读写时，1簇中没有填满的区域会保持不被使用的状态。虽然这看起来是有点浪费，不过该机制就是如此规定的，所以我们也没有什么好办法。另外，如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。由于在磁盘表面上，表示扇区区分的领域是必要的，因此，如果簇的容量过小，磁盘的整体容量也会减少。扇区和簇的大小，是由处理速度和存储容量的平衡来决定的。   </p><h3 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h3><p>RLE算法: 把文件内容用<code>数据×重复次数</code>的形式来表示的压缩方法称为RLE (Run Length Encoding，行程长度编码) 算法。<br>在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE算法可以发挥不错的效果，但它并不适合文本文件的压缩。   </p><p><strong>莫尔斯编码</strong>是根据日常文本中各字符的出现频率来决定表示各字符的编码的数据长度的。<br>使用<strong>哈夫曼树</strong>后，出现频率越高的数据所占用的数据位数就越少，而且数据的区分也可以很清晰地实现。   </p><h3 id="程序是在何种环境中运行的"><a href="#程序是在何种环境中运行的" class="headerlink" title="程序是在何种环境中运行的"></a>程序是在何种环境中运行的</h3><p>应用的运行环境，是指<code>操作系统</code>和<code>计算机本身(硬件)</code>的种类   </p><p>机器语言的程序称为<strong>本地代码</strong> (native code)<br>程序员用C语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为<strong>源代码</strong>。    </p><p>应用程序向操作系统传递指令的途径称为API (ApplicationProgramming Interface)<br>BIOS (BasicInput/Output System)。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。<br><strong>引导程序</strong>是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。   </p><h3 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h3><p>源代码完成后，就可以编译生成可执行文件了。负责实现该功能的是编译器。<br><code>Dump</code> 是指把文件的内容，每个字节用2位十六进制数来表示的方式。</p><p>能够把C语言等高级编程语言编写的源代码转换成本地代码的程序称为<strong>编译器</strong>。<br>但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p><p>编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理。<br>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行连接的程序就称为<strong>链接器</strong>（linkage editor或连结器）  </p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ilink32 -Tpe -c -x -aa c0w32.obj Sample1.obj, Sample1.exe, ,</span><br><span class="line">import32.lib cw32.lib</span><br></pre></td></tr></table></figure><p>c0w32.obj这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的<strong>启动</strong>。<br>因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来。     </p><p>像import32.lib及cw32.lib这样的文件称为库文件。<br><strong>库文件</strong>指的是把多个目标文件集成保存到一个文件中的形式。<br><strong>链接器</strong>指定<strong>库文件</strong>后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件。    </p><p><code>sprintf()</code>等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为<code>标准函数</code>。<br>之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这一过程。   </p><p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL（Dynamic Link Library）文件的特殊库文件中。<br>就如Dynamic这一名称所表示的那样，DLL文件是程序运行时动态结合的文件。  </p><p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为<strong>静态链接库</strong>。<br>静态（static=静态的）同动态（dynamic=动态的）是相反的意思。存储着<code>sprintf()</code>的目标文件的cw32lib就是静态链接库。<br><code>sprintf()</code>提供了通过指定格式把数值转换成字符串的功能。   </p><p>那就是EXE文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在EXE文件的开头，追加转换内存地址所需的必要信息。这个信息称为<strong>再配置信息</strong>。<br>EXE文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离。   </p><p>EXE文件的内容分为再配置信息、变量组和函数组<br>当程序加载到内存后，除此之外还会额外生成两个组，那就是栈和堆。<br><strong>栈</strong>是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域。<br><strong>堆</strong>是用来存储程序运行时的任意数据及对象的内存领域<br>EXE文件中并不存在栈及堆的组。栈和堆需要的内存空间是在EXE文件加载到内存后开始运行时得到分配的。<br>因而，内存中的程序，就是由<code>用于变量的内存空间</code>、<code>用于函数的内存空间</code>、<code>用于栈的内存空间</code>、<code>用于堆的内存空间</code>这4部分构成的。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。不过，在内存的使用方法上，二者存在些许不同。栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。与此相对，堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。<br><strong>栈</strong>中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。<br>与此相对，<strong>堆</strong>的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。<br>如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为<strong>内存泄露</strong>（memory leak）   </p><blockquote><p>Q：编译器和解释器有什么不同？<br>A：<strong>编译器</strong>是在运行前对所有源代码进行解释处理的。而<strong>解释器</strong>则是在运行时对源代码的内容一行一行地进行解释处理的。<br>Q：“分割编译”指的是什么？<br>A：将整个程序分为多个源代码来编写，然后分别进行编译，最后链接成一个EXE文件。这样每个源代码都相对变短，便于程序管理。<br>Q：“Build”指的是什么？<br>A：根据开发工具种类的不同，有的编译器可以通过选择“Build”菜单来生成EXE文件。这种情况下，<strong><code>Build</code>指的是连续执行编译和链接</strong>。<br>Q：使用DLL文件的好处是什么？<br>A: DLL文件中的函数可以被多个程序共用。因此，借助该功能可以节约内存和磁盘。此外，在对函数的内容进行修正时，还不需要重新链接（静态链接）使用这个函数的程序。<br>Q：不链接导入库的话就无法调用DLL文件中的函数吗？<br>A：通过使用LoadLibrary()及GetProcAddress()这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。不过使用导入库更简单一些。<br>Q：“叠加链接”这个术语指的是什么？<br>A：将不会同时执行的函数，交替加载到同一个地址中运行。通过使用“叠加链接器”这一特殊的链接器即可实现。在计算机中配置的内存容量不多的MS-DOS时代，经常使用叠加链接。</p></blockquote><p>IDE: Integrated Development Environment，即继承了变成所需的各种工具的开发软件。<br>CPU: Central Processing Unit (中央处理器)<br>IC: Integrated Circuit (集成电路)<br>DLL: Dynamic Link Library</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是《程序是怎么跑起来的》读书笔记。&lt;br&gt;在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。&lt;br&gt;下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: &lt;/p&gt;
    
    </summary>
    
    
      <category term="program" scheme="https://jambo0624.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://jambo0624.github.io/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>CodeStandard</title>
    <link href="https://jambo0624.github.io/2020-07-19-code-standard.html"/>
    <id>https://jambo0624.github.io/2020-07-19-code-standard.html</id>
    <published>2020-07-19T03:16:16.000Z</published>
    <updated>2020-08-12T14:31:54.468Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：</p><ul><li>谨记代码是给人看的，它们只是恰巧能跑而已<a id="more"></a></li></ul><h4 id="能愿动词说明"><a href="#能愿动词说明" class="headerlink" title="能愿动词说明"></a>能愿动词说明</h4><p> 本文统一采用以下几个能愿动词作为规范的约束强度。</p><ul><li><code>必须（Must）</code>：只能这样做，请无条件遵守</li><li><code>绝不（Must Not）</code>：严令禁止，在任何情况下都不能这么做</li><li><code>应该（Should）</code>：强烈建议这样做，但是并不强求</li><li><code>不应该（Should Not）</code>：强烈建议不这样做，但是并不强求</li><li><code>可以（May）</code>：你可以按照自己的喜好去做</li></ul><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><p>下面几个词组指代四种命名风格。</p><ul><li><code>camelCase</code>：小驼峰</li><li><code>PascalCase</code>：大驼峰</li><li><code>kebab-case</code>：小写 + 中划线</li><li><code>kebab_ase</code>：小写 + 下划线</li></ul><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h3 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h3><h4 id="lang属性"><a href="#lang属性" class="headerlink" title="lang属性"></a>lang属性</h4><p>html 标签 <strong>必须</strong> 设置 lang 属性，此属性值 <strong>应该</strong> 与目标用户的第一语言保持一致。<br>当使用i18n等工具进行页面语言的切换时，此属性值也 <strong>应该</strong> 一并切换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh_CN"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="img-标签的-alt-属性"><a href="#img-标签的-alt-属性" class="headerlink" title="img 标签的 alt 属性"></a>img 标签的 alt 属性</h4><p>每一个 img 标签都 <strong>应该</strong> 有一个 alt 属性， 且它的内容 <strong>应该</strong> 尽可能详尽地描述这张图片的作用。<br>它除了能提供信息以及更好的 seo 之外，还能帮助视障人士。</p><h4 id="中文和西文之间的空格"><a href="#中文和西文之间的空格" class="headerlink" title="中文和西文之间的空格"></a>中文和西文之间的空格</h4><p>页面上的中文和西文（数字）之间 <strong>必须</strong> 有一个空格。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia是混成词，分别取自于网站核心技术Wiki以及英文中百科全书之意的encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia 是混成词，分别取自于网站核心技术 Wiki 以及英文中百科全书之意的 encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>皇后乐队是英国摇滚乐乐队，成立于 1970 年。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><h4 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h4><p><strong>必须</strong> 在所有样式文件前引入 <a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a> 用于消除各个浏览器之间的差异。<br>对于不同的项目，<strong>应该</strong> 根据需求设立 reset 样式集，并在 Normalize.css 之后引入。 Reset 样式集应该秉承最小化原则。</p><h4 id="简化版的CSS-BEM"><a href="#简化版的CSS-BEM" class="headerlink" title="简化版的CSS BEM"></a>简化版的CSS BEM</h4><p><a href="http://getbem.com/introduction/" target="_blank" rel="noopener">CSS BEM</a>是一种可以有效降低样式冲突概率的 css 选择器方法，但这种风格的代码对绝大部分项目来说是 too heavy 的。<br>这里提出一种简化的方案，只有”层级”和”断字”的概念。使用中划线 <code>-</code> 表示层级，使用下划线 <code>_</code> 表示断字。项目 <strong>必须</strong> 严格遵守该规范。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-img"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-login"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-sign_up"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>如果项目要使用 Css 预处理器， <strong>应该</strong>优先使用 Sass，且 <strong>必须</strong> 使用 Scss 语法。使用 Scss 语法对上方的 html 代码进行选择会变得非常简单易行。<br>每一个 Scss 选择器后面 <strong>必须</strong> 有一个空行。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  &amp;-logo &#123;</span><br><span class="line">    &amp;-<span class="selector-tag">img</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    &amp;-text &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &amp;-navbar &#123;</span><br><span class="line">    &amp;-item &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &amp;-login &#123;&#125;</span><br><span class="line">    &amp;-sign_up &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择器命名"><a href="#选择器命名" class="headerlink" title="选择器命名"></a>选择器命名</h4><p>选择器命名的第一要务是见名知意。</p><ul><li>对于一些常见的、约定俗成的单词简写，<strong>可以</strong> 使用简写形式。如：<code>description</code>-&gt;<code>desc</code></li><li><strong>绝不</strong> 使用简写后有多种释义，或是简写后无法辨别含义的单词简写。如：<code>description</code>-&gt;<code>des</code>,<code>fc</code></li><li>嵌套层级 <strong>不应该</strong> 过深，当出现三到四层嵌套后，可以使用全新的选择器名称。如：<code>.page-header-logo{ .title ...}</code></li></ul><h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>所有项目都 <strong>应该</strong> 使用 Babel 进行转义，而源码都 <strong>应该</strong> 拥抱已经发布的 ECMAScript 特性。</p><h4 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h4><p>所有项目都 <strong>应该</strong> 使用 ESLint 进行代码格式检查。</p><h4 id="const-let-和-var"><a href="#const-let-和-var" class="headerlink" title="const, let 和 var"></a>const, let 和 var</h4><p><code>const</code> <strong>必须</strong> 是第一公民，次之是 <code>let</code>。被 Babel (或其他转义工具)转义的项目中 <strong>绝不</strong> 出现 <code>var</code>。</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>变量命名的第一要务是见名知意。</p><ul><li>布尔型的变量 <strong>应该</strong> 以 <code>is</code> 或 <code>flag</code> 开头。如：<code>isVisible</code></li><li>数值类型的变量 <strong>必须</strong> 采用复数形式的名词。如：<code>users</code>,<code>categories</code></li><li>对于单复同行的数值型变量，<strong>应该</strong> 添加其他的单词进行辅助释义。如：<code>newsList</code></li><li>对象类型的变量 <strong>必须</strong> 采用单数形式的名词。如:<code>user</code></li><li>函数 (方法) 命名 <strong>必须</strong> 是以动词开头的 camelCase 风格。如: <code>createUser</code>, <code>validateForm</code></li><li>对于项目中约定的常量 (如配置项等)，<strong>应该</strong> 使用 PASCAL_CASE 风格。如: <code>HEADER_MENU</code>, <code>PRIMARY_COLOR</code></li><li>类( Class )的名称 <strong>必须</strong> 采用 PascalCase 形式，且 <strong>应该</strong> 拟人化。如: <code>Permission</code>, <code>FormValidator</code></li><li>任何变量的命名都 <strong>不应该</strong> 过于生僻和抽象</li></ul><h4 id="一些推荐使用的函数首部动词"><a href="#一些推荐使用的函数首部动词" class="headerlink" title="一些推荐使用的函数首部动词"></a>一些推荐使用的函数首部动词</h4><ul><li><code>do</code>/<code>deal</code>：做某些事情</li><li><code>go</code>：跳转、前往</li><li><code>get</code>/<code>fetch</code>：获取某些事物</li><li><code>set</code>：设置某些事物</li><li><code>make</code>/<code>create</code>：创建</li><li><code>edit</code>/<code>update</code>：编辑</li><li><code>delete</code>/<code>destory</code>：删除</li><li><code>handle</code>：被其他操作触发了</li></ul><h4 id="Restful-Actions"><a href="#Restful-Actions" class="headerlink" title="Restful Actions"></a>Restful Actions</h4><p>对于项目中的接口，<strong>应该</strong> 将 ajax 请求拆分为请求函数以实现复用以及提高项目的可维护性。<br>如果接口使用 Restful API，那么前端对应的方法名 <strong>可以</strong> 按照下面的规范来进行命名。</p><ul><li><code>get</code> <code>/books</code>=&gt;<code>reqFetchBooks</code></li><li><code>get</code> <code>/books/:id</code>=&gt;<code>reqShowBooks</code></li><li><code>post</code> <code>/books</code>=&gt;<code>reqCreateBooks</code></li><li><code>post,put,patch</code> <code>/books/:id</code>=&gt;<code>reqUpdateBooks</code></li><li><code>delete</code> <code>/books/:id</code>=&gt;<code>reqDestoryBooks</code></li></ul><h4 id="数组的循环"><a href="#数组的循环" class="headerlink" title="数组的循环"></a>数组的循环</h4><p>在使用循环时， <strong>不应该</strong> 使用<code>item</code>作为数组的元素名，而 <strong>应该</strong> 使用数组的单数形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">books.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; &#125;);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">books.map(<span class="function"><span class="params">book</span> =&gt;</span> &#123; &#125;);</span><br><span class="line">newsList.map(<span class="function"><span class="params">news</span> =&gt;</span> &#123; &#125;)</span><br></pre></td></tr></table></figure><h4 id="if的处理"><a href="#if的处理" class="headerlink" title="if的处理"></a>if的处理</h4><p>每一个<code>if</code>都 <strong>必须</strong> 囊括所有情况，也就是说每一种逻辑都可以被 if 处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125; <span class="keyword">else</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>部分<code>if else</code>逻辑 <strong>可以</strong> 通过及时 <code>return</code> 减少嵌套层数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// correct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (a !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br></pre></td></tr></table></figure><p>过多的<code>!a || b</code> <strong>应该</strong> 被转换为<code>!(a &amp;&amp; b)</code>，这种逻辑更符合直觉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not bad</span></span><br><span class="line"><span class="keyword">if</span> (!a || !b) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (!(a &amp;&amp; b)) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>注释本身 <strong>不应该</strong> 对变量或方法本身是做什么的进行解释。这要求变量命名尽可能得见名知意。</li></ul><h3 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h3><p><strong>NOTICE HERE</strong>： Vue 的相关规范全部基于官方的<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">风格指南</a>， 并在此基础上进行了一些修改和约束。</p><h4 id="组件文件命名"><a href="#组件文件命名" class="headerlink" title="组件文件命名"></a>组件文件命名</h4><ul><li>页面、路由相关的组件 <strong>应该</strong> 使用一个单词命名</li><li>非页面、路由相关的组件 <strong>应该</strong> 使用<code>PascalCase</code>风格命名</li><li>组件 <strong>应该</strong> 拟人化。如：<code>UserCreator</code>,<code>Selector</code></li></ul><h4 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h4><p>如果文件夹内拥有<code>index.vue</code>，那么引入时 <strong>应该</strong> 省略 index 字样， 并在末尾添加 <code>/</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/'</span></span><br></pre></td></tr></table></figure><p>引入组件时，模块名 <strong>必须</strong> 为 <code>PascalCase</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="根标签书写规范"><a href="#根标签书写规范" class="headerlink" title="根标签书写规范"></a>根标签书写规范</h4><p>vue 文件中的标签书写顺序 <strong>必须</strong> 为：</p><ol><li><code>&lt;template&gt;&lt;/template&gt;</code></li><li><code>&lt;script&gt;&lt;/script&gt;</code></li><li><code>&lt;style&gt;&lt;/style&gt;</code></li></ol><h3 id="lt-template-gt-lt-template-gt-根标签"><a href="#lt-template-gt-lt-template-gt-根标签" class="headerlink" title="&lt;template&gt;&lt;/template&gt;根标签"></a><code>&lt;template&gt;&lt;/template&gt;</code>根标签</h3><p>每一个根标签下的顶级元素都 <strong>必须</strong> 有一个与当前文件名对应的 css 选择器。在本规范中， <strong>应该</strong> 使用<code>文件名</code>的<code>kebab_case</code>结构作为该 css 选择器。如：<code>SelectorGender</code>-&gt;<code>selector_gender</code><br>如果为了进一步降低组件间的样式冲突的可能性， <strong>可以</strong> 使用 <code>文件夹层级</code> + <code>文件名</code> 共同组装成根组件的根选择器。假定有以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- common &lt;dir&gt;</span><br><span class="line">|  |-- selectors &lt;dir&gt;</span><br><span class="line">|  |  |-- SelectorGender &lt;file&gt;</span><br></pre></td></tr></table></figure><p>那么其对应的唯一 css 选择器名应该为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;common-selectors-selector_gender&quot;&gt;</span><br><span class="line">     &lt;!--    --&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-script-gt-lt-script-gt-根标签"><a href="#lt-script-gt-lt-script-gt-根标签" class="headerlink" title="&lt;script&gt;&lt;/script&gt;根标签"></a><code>&lt;script&gt;&lt;/script&gt;</code>根标签</h3><p>实例选项顺序<br>组件实例中的选项顺序 <strong>必须</strong> 按照 vue 风格指南的要求进行排版</p><ol><li><code>el</code></li><li><code>name</code></li><li><code>parent</code></li><li><code>functional</code></li><li><code>delemiters</code></li><li><code>comments</code></li><li><code>components</code></li><li><code>directives</code></li><li><code>filters</code></li><li><code>extends</code></li><li><code>mixins</code></li><li><code>inheritAttrs</code></li><li><code>model</code></li><li><code>props/prosData</code></li><li><code>data</code></li><li><code>computed</code></li><li><code>watch</code></li><li><code>beforeCreated</code></li><li><code>created</code></li><li><code>beforeMounted</code></li><li><code>mounted</code></li><li><code>beforeUpdate</code></li><li><code>updated</code></li><li><code>activated</code></li><li><code>deactivated</code></li><li><code>beforeDestory</code></li><li><code>destoryed</code></li><li><code>methods</code></li><li><code>template/render</code></li><li><code>renderError</code></li></ol><h4 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h4><p>各个选项间 <strong>必须</strong> 间隔一个空行，而内部的值或方法不空行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Demo'</span>,</span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tableData: <span class="string">''</span>,</span><br><span class="line">      userInfo: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    getTableData () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getUserInfo () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：name"><a href="#实例选项：name" class="headerlink" title="实例选项：name"></a>实例选项：<code>name</code></h4><p>每一个组件 <strong>必须</strong> 有一个 <code>name</code> 实例选项，其值 <strong>必须</strong> 为被其他组件引入时的模块名。如果你的组件命名完全符合本规范，那么一般情况下，此属性的值应与组件的文件名保持一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file name: MyComponent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// worst</span></span><br><span class="line">  <span class="comment">// no name</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'my-component'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'myComponent'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  name: <span class="string">'MyComponent'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * use this component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'../common/MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="实例选项：props"><a href="#实例选项：props" class="headerlink" title="实例选项：props"></a>实例选项：<code>props</code></h4><p>组件需要的参数，都 <strong>应该</strong> 拥有完善的验证规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    demo:&#123;</span><br><span class="line">      type: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="params">val</span> =&gt;</span> [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'first'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="string">'second'</span>].includes(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：data"><a href="#实例选项：data" class="headerlink" title="实例选项：data"></a>实例选项：<code>data</code></h4><ul><li><strong>不应该</strong> 使用 <code>Vue.set()</code> 方式为组件扩展响应式的 data</li><li><strong>应该</strong> 将一些同属于某一块页面元素的 data 合并为对象的形式，避免 data 的扁平化</li><li>每一个 data 都 <strong>必须</strong> 是被使用到的</li></ul><h4 id="实例选项-生命周期函数"><a href="#实例选项-生命周期函数" class="headerlink" title="实例选项: 生命周期函数"></a>实例选项: 生命周期函数</h4><p>生命周期函数内 <strong>不应该</strong> 直接书写过多的业务逻辑。如果逻辑过多，<strong>应该</strong> 在 methods 中定义独立的函数并在生命周期函数中进行调用。</p><h3 id="lt-style-gt-lt-style-gt-根标签"><a href="#lt-style-gt-lt-style-gt-根标签" class="headerlink" title="&lt;style&gt;&lt;/style&gt;根标签"></a><code>&lt;style&gt;&lt;/style&gt;</code>根标签</h3><ul><li><strong>必须</strong> 添加 scoped 属性</li><li><strong>必须</strong> 使用 sass 预处理器，并且使用 scss 语法</li><li>所有的组件内样式 <strong>必须</strong> 被该组件的唯一 css 选择器包裹<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"selector_gender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.selector_gender</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* ... */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="关于命名的（最佳）实践"><a href="#关于命名的（最佳）实践" class="headerlink" title="关于命名的（最佳）实践"></a>关于命名的（最佳）实践</h3><ul><li>在 Dom 上绑定的事件回调方法 <strong>应该</strong> 使用<code>on</code>+<code>动词</code>+<code>名词</code>形式。如：<code>@click=&quot;onCreateUser&quot;</code></li><li>子组件 emit 的事件名称 <strong>应该</strong> 使用 <code>动词的一般现在时</code>。如：<code>@click</code>,<code>@submit</code></li><li>子组件 emit 的事件回调方法 <strong>应该</strong> 使用<code>handle</code>+<code>名词</code>+<code>动词过去式</code>形式。如：<code>@submit=&quot;handleUserCreated&quot;</code></li><li><strong>应该</strong> 正确使用<code>or</code>和<code>and</code>。详见下方示例<br>一个完整的例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"users"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onCreateUser"</span>&gt;</span>Create User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onEditUser(scope.row)"</span>&gt;</span>Edit User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">:loading</span>=<span class="string">"isDeletingUser"</span> @<span class="attr">click</span>=<span class="string">"onDeleteUser(scope.row)"</span>&gt;</span>Delete User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">user-creator-and-editor</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ref</span>=<span class="string">"userCreatorAndEditor"</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">submit</span>=<span class="string">"handleUserCreatedOrEdited"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user-creator-and-editor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> UserCreatorAndEditor <span class="keyword">from</span> <span class="string">'./UserCreatorAndEditor'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; reqDestoryUser &#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'Users'</span>,</span></span><br><span class="line"></span><br><span class="line">    components: &#123; UserCreatorAndEditor &#125;,</span><br><span class="line"></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        isDeletingUser: <span class="literal">false</span>,</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">      onCreateUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'create'</span> &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      onEditUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'edit'</span>, userId: id &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      handleUserCreatedOrEdited(result) &#123;</span><br><span class="line">        if(result) &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line">        &#125;     </span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="keyword">async</span> onDeleteUser(&#123; id &#125;) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">await</span> reqDestoryUser(id);</span></span><br><span class="line"><span class="actionscript">           <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">finally</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">false</span></span></span><br><span class="line">        &#125;   </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>每个方法和变量都见名知意，并且永不重复！</li></ul><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><p><strong>不应该</strong> 使用路由大量传递参数,请尽可能地保证<code>clean and beautiful</code>。</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p><strong>应该</strong> 使用<code>module</code>组织 vuex，而非全部注册在顶级。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>绝不</strong> 给 Vue 挂载大体量的插件或扩展， <strong>应该</strong> 在需要用到的页面进行按需引入</li><li><strong>不应该</strong> 直接选取某个 dom 元素进行直接的 dom 操作( Echarts 等插件除外)</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>项目的技术文档 <strong>必须</strong> 使用 Markdown 格式编写。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><ul><li>英文文档 <strong>必须</strong> 使用半角标点符号</li><li>中文文档中以下标点符号 <strong>必须</strong> 使用半角，并在其后添加一个空格<ul><li>引号: <code>&quot;&quot;</code></li><li>冒号: <code>:</code></li><li>感叹号: <code>!</code></li><li>问号: <code>?</code></li><li>所有的括号: <code>() [] {}</code></li></ul></li><li>中文文档中以下标点符号 <strong>必须</strong> 使用全角，其后不需要添加空格<ul><li>逗号: <code>，</code></li><li>句号: <code>。</code></li><li>省略号: <code>……</code></li></ul></li></ul><h3 id="Markdown-语法约束"><a href="#Markdown-语法约束" class="headerlink" title="Markdown 语法约束"></a>Markdown 语法约束</h3><ul><li><strong>必须</strong> 有且仅有一个一级标题</li><li>标题的层级最多 <strong>不应该</strong> 超过三级</li><li>句子的末尾 <strong>必须</strong> 有句号</li><li>无序列表和有序列表的末尾 <strong>不应该</strong> 添加句号</li><li><strong>应该</strong> 优先选用无需列表而非有序列表</li><li>用于表明格式的关键字符 <strong>必须</strong> 前后各留一个空格</li><li>标题与段落之间 <strong>必须</strong> 前后各留一个空行</li></ul><h3 id="的，得，地"><a href="#的，得，地" class="headerlink" title="的，得，地"></a>的，得，地</h3><p><strong>必须</strong> 正确使用<code>的</code>，<code>得</code>，<code>地</code>。</p><h3 id="项目版本"><a href="#项目版本" class="headerlink" title="项目版本"></a>项目版本</h3><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>项目开发过程中的版本迭代 <strong>应该</strong> 遵循类似 npm 的版本定义方法。即:</p><ul><li><code>1.1.1</code> -&gt; <code>1.1.2</code>: 向下兼容的问题修复</li><li><code>1.1.1</code> -&gt; <code>1.2.1</code>: 向下兼容的功能迭代</li><li><code>1.1.1</code> -&gt; <code>2.1.1</code>: 发生了非向下兼容的功能迭代</li></ul><h4 id="版本迭代及分支管理"><a href="#版本迭代及分支管理" class="headerlink" title="版本迭代及分支管理"></a>版本迭代及分支管理</h4><ul><li><code>master</code>分支 <strong>必须</strong> 对应线上代码</li><li>对于开发告一段落，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><ul><li>安装依赖时 <strong>必须</strong> 按照功能严格区分生产环境依赖和开发环境依赖</li><li><strong>绝不</strong> 遗留未被使用的依赖。如果不使用某个依赖时， <strong>必须</strong> 第一时间进行卸载</li><li><strong>绝不</strong> 在未获得其他开发人员同意的情况下升级依赖版本</li><li><strong>应该</strong> 优先使用使用量大、受众面广的依赖</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="使用If"><a href="#使用If" class="headerlink" title="使用If"></a>使用If</h4><p>Windows 下的 Git 默认使用<code>crlf</code>作为换行符，甚至会将<code>lf</code>转换为<code>crlf</code>。本规范要求所有的换行都 <strong>必须</strong> 使用<code>lf</code>风格。</p><p>Q: 安装 Git 时，忘记去勾了 crlf 自动替换的选项，怎么办？<br>A: 执行以下命令:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.eol lf</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><ul><li>开发分支 <strong>必须</strong> 是<code>develop</code></li><li>功能分支 <strong>必须</strong> 以<code>feature/</code>开头。如: <code>feature/user_system</code></li><li>开发完毕，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h4 id="Merge-Request-Pull-Request"><a href="#Merge-Request-Pull-Request" class="headerlink" title="Merge Request(Pull Request)"></a>Merge Request(Pull Request)</h4><p>每一次分支合并都 <strong>必须</strong> 发起一个<code>Merge Request</code>，并且交由他人评审。</p><h3 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h3><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><ul><li><code>src</code><ul><li><code>api</code>: 存放 API 资源</li><li><code>assets</code>: 存放需要被 Webpack 处理的静态资源</li><li><code>components</code>: 存放于项目无关的公共组件。理论上这些组件可以被任何项目直接使用</li><li><code>config</code>: 存放一些项目配置文件</li><li><code>models</code>: 存放前端的数据模型。如果项目使用了 Typescript， 理论上不需要设置改目录</li><li><code>router</code>: Vue 路由</li><li><code>store</code>: Vuex。 <strong>应该</strong> 只包含<code>modules</code>和<code>index.js</code>，保证 vuex 所有功能都尽可能按照模块划分<ul><li><code>modules</code>: Vuex 的模块</li><li><code>index.js</code></li></ul></li><li><code>styles</code>: 存放全局样式。样式文件 <strong>必须</strong> 使用 Scss 进行组织; 作为子文件的样式文件 <strong>必须</strong> 使用 <code>_</code>开头<ul><li><code>_common.scss</code>: 公共样式文件</li><li><code>_hack.scss</code>: 对各种组件库或其他样式进行加强修改。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>_mixins.scss</code>: 提供全局的 Scss Mixins</li><li><code>_reset.scss</code>: 对页面样式进行重置。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>main.scss</code>: 按照一定的顺序注册全部样式文件。被<code>main.js</code>引入</li><li><code>resource.scss</code>: 被<code>scss-loader</code>处理，注册全局可用的 Scss 资源</li></ul></li><li><code>utils</code>: 各种工具<ul><li><code>http.js</code>: 请求层。<strong>必须</strong> 优先使用<code>axios</code></li></ul></li><li><code>views</code>: 视图层</li><li><code>App.vue</code></li><li><code>main.js</code>: 文件内容 <strong>必须</strong> 尽可能短小且清晰</li></ul></li><li><code>.editorconfig</code></li><li><code>.prettierignore</code></li><li><code>.prettierrc.js</code></li><li><code>.prettierrc.js</code></li><li><code>CHANGELOG.md</code>: 项目更新日志。在每一次上线前都 <strong>必须</strong> 进行补全</li><li><code>README.md</code>: 用来说明项目，以及帮助其他人快速上手项目</li></ul><h4 id="main-scss-组织"><a href="#main-scss-组织" class="headerlink" title="main.scss 组织"></a>main.scss 组织</h4><p>由于样式存在后者覆盖前者的问题，因此 main.scss <strong>必须</strong> 按照一定的顺序进行组织。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络资源 (network resources)</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">"https://fonts.googleapis.com/css?family=Nunito"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地资源 (local resources)。如: 变量，mixin，图标</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"iconfont"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式重置 (reset)。推荐优先使用 normalize.css，自己书写的 reset 文件的内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~normalize.css/normalize.css"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"reset"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方库 (libraries)</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~element-ui/packages/theme-chalk/src/index"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~swiper/css/swiper"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共样式 (common)。如果有需要的话，给公共样式加入一个前缀以作区分，如 ` g-container `</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"common"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图 (views)。对于一个 vue 项目，可能不需要引入视图内的样式</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/layout/home"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/widgets/header"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强行重置某些样式 (hack)。内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"hack"</span>;</span><br></pre></td></tr></table></figure><h4 id="Scss全局资源"><a href="#Scss全局资源" class="headerlink" title="Scss全局资源"></a>Scss全局资源</h4><blockquote><p>参考官方文档: <a href="https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项</a></p></blockquote><p>在<code>src/styles/</code>目录下创建<code>resources.scss</code>文件，用于存放全局可以使用的样式资源，如变量，mixin 等。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br></pre></td></tr></table></figure><p>在<code>vue.config.js</code>中进行了配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: <span class="string">`@import "@/styles/resources.scss";`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Editorconfig"><a href="#Editorconfig" class="headerlink" title="Editorconfig"></a>Editorconfig</h3><p>每一个项目都 <strong>必须</strong> 添加<code>Editorconfig</code>文件，并且每一个开发人员的编辑器都 <strong>必须</strong> 安装该插件。<br>下面是一份推荐使用的 editorconfig 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset = utf<span class="number">-8</span></span><br><span class="line">end_of_line = lf</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = <span class="number">2</span></span><br><span class="line">tab_width = <span class="number">2</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p>所有项目都 <strong>必须</strong> 使用<code>Prettier</code>进行代码的格式化。<br>下面是一份推荐使用的 prettier 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line">modules.export = &#123;</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: <span class="string">"*.&#123;js,ts,jsx,tsx,vue&#125;"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        singleQuote: <span class="literal">true</span>,</span><br><span class="line">        printWidth: <span class="number">100</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谨记代码是给人看的，它们只是恰巧能跑而已
    
    </summary>
    
    
      <category term="standard" scheme="https://jambo0624.github.io/categories/standard/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="standard" scheme="https://jambo0624.github.io/tags/standard/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题的处理</title>
    <link href="https://jambo0624.github.io/2019-02-20-cross-domain.html"/>
    <id>https://jambo0624.github.io/2019-02-20-cross-domain.html</id>
    <published>2019-02-20T04:04:40.000Z</published>
    <updated>2020-09-22T07:32:21.009Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下跨域问题处理的过程。</p><a id="more"></a><p>实际场景<br>需求主要是一个话题互动页面，在评论框中需满足能够上传图片的要求，需求看似平平常常，处理起来也没什么太大的问题，那就开干吧。</p><p>页面依赖的插件<br><code>zepto.js</code><br><code>plupload.js</code></p><p>实际场景的代码片段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 评论框中的 dom 结构</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-reply-modal-uploadimg j-post-reply-modal-uploadimg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"plupload-content j-plupload-content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"plupload-content-btn j-plupload-content-btn"</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span><span class="comment">&lt;!-- 上传的按钮dom --&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"plupload-content-success j-plupload-content-success"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"success-img j-success-img"</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"delete-img j-delete-img"</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 plupload 上传图片插件事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> uploader = <span class="keyword">new</span> plupload.Uploader(&#123;</span><br><span class="line">    runtimes: <span class="string">'html5,html4,flash,silverlight'</span>,</span><br><span class="line">    browse_button: $(<span class="string">'.j-plupload-content-btn'</span>),</span><br><span class="line">    url: uploadImgAPI,  <span class="comment">// 在本地选择文件后通过请求上传图片信息到服务器的url</span></span><br><span class="line">    flash_swf_url: <span class="string">'../assets/scripts/upload/moxie.swf'</span>,</span><br><span class="line">    silverlight_xap_url: <span class="string">'../assets/scripts/upload/moxie.xap'</span>,</span><br><span class="line">    headers: &#123;&#125;,</span><br><span class="line">    chunk_size: <span class="number">0</span>,</span><br><span class="line">    max_retries: <span class="number">1</span>,</span><br><span class="line">    file_data_name: <span class="string">'file'</span>,</span><br><span class="line">    multi_selection: <span class="literal">false</span>,</span><br><span class="line">    multipart: <span class="literal">true</span>,</span><br><span class="line">    required_features: &#123;</span><br><span class="line">      send_browser_cookies: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    filters: &#123;</span><br><span class="line">      mime_types: [</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">'Image files'</span>, <span class="attr">extensions</span>: <span class="string">'jpg,jpeg,png,gif'</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">      prevent_duplicates: <span class="literal">false</span>,</span><br><span class="line">      max_file_size: <span class="string">'10240kb'</span>,</span><br><span class="line">      max_file_count: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    init: &#123;</span><br><span class="line">      Init: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化执行的操作</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      FilesAdded: <span class="function">(<span class="params">up, files</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 上传队列数据加载完后执行start对数据进行上传</span></span><br><span class="line">        uploader.start();</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      FileUploaded: <span class="function">(<span class="params">up, files, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在数据通过接口上传完后处理当前数据在页面上的显示</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Error</span>: <span class="function">(<span class="params">up, err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 上传图片过程中出现错误可以在这里操作</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'---'</span>, up, err);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  uploader.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，结果报错。为什么上传图片到服务器不成功？<br>报错如下：<br><img src="https://s1.ax1x.com/2020/09/22/wLLoy6.jpg" alt="wLLoy6.jpg"></p><p>很明显，这是跨域的报错。<br>一个域名地址的组成：</p><table><thead><tr><th>http://</th><th>www.</th><th>xxx.com</th><th>:8080</th><th>files/filsname</th></tr></thead><tbody><tr><td>协议</td><td>子域名</td><td>主域名</td><td>端口号</td><td>请求资源地址</td></tr></tbody></table><p>当协议、子域名、主域名、端口号中任一不相同时都不能算做同域，在不同域之间互相请求资源时就算作‘跨域’</p><p>常见跨域处理<br><strong>1.常见的 jsonp 跨域</strong><br>虽然在页面上调用不同域的接口不被允许，但是调用不同域的资源(如js脚本)是被允许的，jsonp 则正是利用这个特性来进行跨域数据请求处理。<br>比如在 <code>a.html</code> 页面上，它里面的代码需要利用 ajax 获取不同域上的 json 数据，假设数据地址是 <code>http://b.com/data.php</code><br>那么 <code>a.html</code> 中的代码可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">jsonData</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理获取的 json 数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src='http:/</span><span class="regexp">/b.com/</span>data.php?jsonpcallback=doSomething<span class="string">'&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>因为后端代码是当做一个js文件来引入的，则它必须返回的是一个能执行的js文件，即后端代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;php?</span><br><span class="line">  $jsonpcallback = $_GET[<span class="string">'jsonpcallback'</span>];</span><br><span class="line">  $data = array(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line">  echo $jsonpcallback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>最终页面上会输出<code>doSomething([‘a’,’b’,’c’])</code>，即这样我们就可以通过jsonp获取跨域的请求数据了。</p><p><strong>2.XHR2(html5)处理跨域方式</strong><br>html5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能，这个功能就很方便，在所有的现代浏览器中基本上已经全部支持，如果是开发 h5 页面的话基本上不用考虑支持的问题<br>在使用的时候客户端不用做任何事情，只需要服务端修改支持跨域的几个请求头即可:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Credentials'</span>:<span class="string">'true'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Headers'</span>:<span class="string">'x-requested-with'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Methods'</span>:<span class="string">'POST, GET, OPTIONS, PUT, DELETE, HEAD'</span></span><br></pre></td></tr></table></figure><p>这些请求头设置可以根据自己的需要按需设置。</p><p>因为兼容性要求不高，自己直接采用了最新的XHR2跨域的处理方式，后端修改支持即可</p><p>但是由于奇葩的测试环境和线上环境，这里的跨域在当前梳理的时候一直不能成功，检查：<br>后端添加允许跨域已完成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'特定的网站地址'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Credentials'</span>:<span class="string">'true'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Headers'</span>:<span class="string">'x-requested-with'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Methods'</span>:<span class="string">'POST, GET, OPTIONS, PUT, DELETE, HEAD'</span></span><br></pre></td></tr></table></figure><p>正常情况，前端此时不需要做其他设置是能够成功发送请求的，但是这里就是不讲道理<br>和后端沟通后得知，请求已经成功，但是他们的验证用户是否登录是直接校验的请求带回的 cookie 中是否有用户标识</p><p>查看请求如下<br><img src="https://s1.ax1x.com/2020/09/22/wLv8hQ.jpg" alt="wLv8hQ.jpg"><br>cookie情况如下<br><img src="https://s1.ax1x.com/2020/09/22/wLvJpj.jpg" alt="wLvJpj.jpg"></p><p>从图中可见， cookie 存在，而 cookie 本来在请求是是会自动将值带上的，但是在域不同的时候肯定是不会自动将值加入<br>那么这里就是这个原因造成的，但是在js代码中处理了一波 cookie 的 domain 是允许跨域的地址后再次发起请求<br>问题依旧存在，请求如图：<br><img src="https://s1.ax1x.com/2020/09/22/wLzWFO.jpg" alt="wLzWFO.jpg"></p><p>option 请求简单理解：例如在接口发起post请求处于跨域情况下，首先会自动发送一个option请求到服务器进行确认<br>如果成功，就再发起一次本来是post请求到服务器且服务器返回成功信息<br>若服务器不允许，那么这里就拜拜咯，下面的操作仍然不能继续</p><p>这里有一个需要注意的点，这个时候前端是无能为力的，需要后端将option请求的操作进行一个处理，让此操作也能成功跨域，并且上图中的 origin 一定注意，也要设置成允许跨域的地址(允许所有就是*，特定某个地址就设置成具体的某个地址)</p><p>经过前后端共同努力，问题最终得到了解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下跨域问题处理的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="ajax" scheme="https://jambo0624.github.io/tags/ajax/"/>
    
      <category term="jsonp" scheme="https://jambo0624.github.io/tags/jsonp/"/>
    
      <category term="CORS" scheme="https://jambo0624.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>记录type为file的input要点击两次才弹出选择文件窗口</title>
    <link href="https://jambo0624.github.io/2019-01-17-input-file-bug.html"/>
    <id>https://jambo0624.github.io/2019-01-17-input-file-bug.html</id>
    <published>2019-01-17T11:04:40.000Z</published>
    <updated>2020-09-22T07:31:32.568Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下遇到的一个问题。<br>背景是这样的，工作中遇到了一个需要处理上传图片的场景。插件使用 plupload.js ，最先找官方网站代码参考了一番。</p><a id="more"></a><p>官网的测试代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"filelist"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"plupload-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"browse"</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>[点击上传文件]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span> -- <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"start-upload"</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>[Start Upload]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">"console"</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moxie.swf,moxie.xap这两个文件也是从官网下载</span></span><br><span class="line"><span class="keyword">var</span> uploader = <span class="keyword">new</span> plupload.Uploader(&#123;</span><br><span class="line">    runtimes : <span class="string">'html5,html4,flash,silverlight'</span>,</span><br><span class="line">    browse_button: <span class="string">'browse'</span>,</span><br><span class="line">    url: <span class="string">''</span>,</span><br><span class="line">    flash_swf_url: <span class="string">'../js/moxie.swf'</span>,</span><br><span class="line">    silverlight_xap_url: <span class="string">'../js/moxie.xap'</span>,</span><br><span class="line">    chunk_size: <span class="number">0</span>,</span><br><span class="line">    max_retries: <span class="number">1</span>,</span><br><span class="line">    multi_selection: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    filters: &#123;</span><br><span class="line">      mime_types : [],</span><br><span class="line">      prevent_duplicates: <span class="literal">true</span>,</span><br><span class="line">      max_file_size: <span class="string">'10240kb'</span>,</span><br><span class="line">      max_file_count: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">uploader.init();</span><br><span class="line"></span><br><span class="line">uploader.bind(<span class="string">'FilesAdded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">up, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html = <span class="string">''</span>;</span><br><span class="line">    plupload.each(files, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">      html += <span class="string">'&lt;li id="'</span> + file.id + <span class="string">'"&gt;'</span> + file.name + <span class="string">' ('</span> + plupload.formatSize(file.size) + <span class="string">') &lt;b&gt;&lt;/b&gt;&lt;/li&gt;'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'filelist'</span>).innerHTML += html;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">uploader.bind(<span class="string">'UploadProgress'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">up, file</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(file.id).getElementsByTagName(<span class="string">'b'</span>)[<span class="number">0</span>].innerHTML = <span class="string">'&lt;span&gt;'</span> + file.percent + <span class="string">"%&lt;/span&gt;"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">uploader.bind(<span class="string">'Error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">up, err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'console'</span>).innerHTML += <span class="string">"\nError #"</span> + err.code + <span class="string">": "</span> + err.message;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start-upload'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  uploader.start();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>实际使用</strong></p><ul><li>引入plupload.full.min.js并开始使用</li><li>在官网将此插件代码下载到本地，在项目中引入*.js，然后依次将测试中的代码复制到正式项目，启动运行</li><li>此时发现无论如何点击上传文件打开选择文件夹按钮始终没生效，点击没有任何反应</li><li>通过断点依次执行，OK，页面没有任何异常，该执行的都执行了，但是就是没有打开选择文件夹按钮</li><li>通过仔细观察发现，双击打开选择文件夹按钮就能成功打开当前选择文件夹</li><li>这是因为 plupload.js 文件有一个 browse_button 属性，它的作用是触发文件选择对话框的DOM元素，当点击该元素后便后弹出文件选择对话框。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"html5_1c14fq5te5gq90lpa1j2q8ip4_container"</span> <span class="attr">class</span>=<span class="string">"moxie-shim moxie-shim-html5"</span> <span class="attr">style</span>=<span class="string">"position: absolute;top: 0px;left: 0px;width: 100%;height: 100%;overflow: hidden;z-index: 1;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"html5_1c14fq5te5gq90lpa1j2q8ip4"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">style</span>=<span class="string">"font-size: 999px; opacity: 0; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;"</span> <span class="attr">accept</span>=<span class="string">""</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>发现此时的 div 已经浮动并且其width、height值都等于0，则input的width、height在此时100%的情况下也等于0，导致点击我们自己设置的上传按钮时不能够触发当前的file，就不会触发打开选择文件夹事件</li><li>简单有效的方法是给此 div 重置一个样式让其覆盖在我们自定义的点击按钮上，让其透明，不是真正的display:none，此时点击就没问题了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下遇到的一个问题。&lt;br&gt;背景是这样的，工作中遇到了一个需要处理上传图片的场景。插件使用 plupload.js ，最先找官方网站代码参考了一番。&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jambo0624.github.io/categories/html/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="input" scheme="https://jambo0624.github.io/tags/input/"/>
    
      <category term="file" scheme="https://jambo0624.github.io/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的js (上卷)--对象原型</title>
    <link href="https://jambo0624.github.io/2018-11-18-dont-know-js-first2.html"/>
    <id>https://jambo0624.github.io/2018-11-18-dont-know-js-first2.html</id>
    <published>2018-11-18T02:33:20.000Z</published>
    <updated>2020-09-24T09:21:51.032Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《你不知道的javaScript》系列书籍，这里做一些记录。<br>上卷主要分两部分，分别是作用域和闭包，this 和 对象原型。<br>这篇文章主要介绍对象原型这部分。</p><a id="more"></a><h1 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象可以通过两种形式定义：声明（文字）形式和构造形式。</p><p>对象是JavaScript的基础。在JavaScript中一共有六种主要类型（术语是“语言类型”）：</p><blockquote><p>string<br>number<br>boolean<br>null<br>undefined<br>object  </p></blockquote><p><strong>ES6 新增基本类型 Symbol</strong><br>注意，简单基本类型（string、boolean、number、null和undefined）本身并不是对象。<br>null有时会被当作一种对象类型，但是这其实只是语言本身的一个bug，即对null执行typeof null时会返回字符串”object”。实际上，null本身是基本类型</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>有些内置对象的名字看起来和简单基础类型一样，不过实际上它们的关系更复杂</p><blockquote><p>String<br>Number<br>Boolean<br>Object<br>Function<br>Array<br>Date<br>RegExp<br>Error </p></blockquote><p>这些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class），比如Java中的String类。<br>但是在JavaScript中，它们实际上只是一些内置函数。<br>这些内置函数可以当作构造函数（由new产生的函数调用）来使用，从而可以构造一个对应子类型的新对象。<br>举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">'I am a string'</span></span><br><span class="line"><span class="keyword">typeof</span> strPrimitive <span class="comment">// 'string'</span></span><br><span class="line">strPrimitive <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'I am a string'</span>)</span><br><span class="line"><span class="keyword">typeof</span> strObject <span class="comment">// 'object'</span></span><br><span class="line">strObject <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 sub-type 对象</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(strObject) <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure><p>思考下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">'I am a string'</span></span><br><span class="line"><span class="built_in">console</span>.log(strPrimitive.length) <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(strPrimitive.charAt(<span class="number">3</span>)) <span class="comment">// 'm'</span></span><br></pre></td></tr></table></figure><p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为<strong>引擎自动把字面量转换成String对象</strong>，所以可以访问属性和方法。</p><h2 id="对象里的内容相关"><a href="#对象里的内容相关" class="headerlink" title="对象里的内容相关"></a>对象里的内容相关</h2><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>对于JSON安全（也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，有一种巧妙的复制方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(someObj))</span><br></pre></td></tr></table></figure><p>ES6还定义了<code>Object.assign(..)</code>方法来实现浅复制<br><code>Object.assign(..)</code>方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。<br>它会遍历一个或多个源对象的所有<strong>可枚举</strong>（enumerable）的<strong>自有键</strong>（owned key）并把它们复制（使用=操作符赋值）到目标对象，最后返回目标对象，就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> anotherObject = &#123; <span class="attr">c</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">var</span> anotherArray = []</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: anotherObject, <span class="comment">// 引用，不是副本</span></span><br><span class="line">  c: anotherArray, <span class="comment">// 另一个引用</span></span><br><span class="line">  d: anotherFunction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, myObject)</span><br><span class="line"></span><br><span class="line">newObj.a <span class="comment">// 2</span></span><br><span class="line">newObj.b === anotherObject <span class="comment">// true</span></span><br><span class="line">newObj.c === anotherArray <span class="comment">// true</span></span><br><span class="line">newObj.d === anotherFunction <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>但是需要注意的一点是，由于Object.assign(..)就是使用=操作符来赋值，所以源对象属性的一些特性（比如writable）不会被复制到目标对象。</strong></p><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   value: 2,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject,<span class="string">"a"</span>,&#123;</span><br><span class="line">  writable:<span class="literal">false</span>,</span><br><span class="line">  configurable:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多个</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(myObject,&#123;</span><br><span class="line">  id:&#123;</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  name:&#123;</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>configurable 是类似于其他两个状态的锁。把configurable修改成false是单向操作，无法撤销！<br>同时 configurable 为 false的话，也<strong>无法删除</strong>这个<strong>属性</strong><br>要注意有一个小小的例外：即便属性是configurable:false，我们还是可以把writable的状态由true改为false，但是无法由false改为true。</p><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>很重要的一点是，所有的方法创建的都是浅不变性，也就是说，它们只会影响目标对象和它的直接属性。<br>如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的：</p><p>1．对象常量<br>结合writable:false和configurable:false就可以创建一个真正的常量属性（不可修改、重定义或者删除）</p><p>2．禁止扩展<br>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(..)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(myObject)</span><br><span class="line"></span><br><span class="line">myObject.b = <span class="number">3</span></span><br><span class="line">myObject.b <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 在非严格模式下，创建属性b会静默失败。在严格模式下，将会抛出TypeError错误</span></span><br></pre></td></tr></table></figure><p>3．密封<br>Object.seal(..)会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..)并把所有现有属性标记为configurable:false。<br>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）</p><p>4．冻结<br>Object.freeze(..)会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..)并把所有“数据访问”属性标记为writable:false，这样就无法修改它们的值。<br>这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的</p><h3 id="get-和-set"><a href="#get-和-set" class="headerlink" title="get 和 set"></a>get 和 set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="keyword">get</span> a() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.a &#125;</span><br><span class="line">  <span class="keyword">set</span> a(val) &#123; <span class="keyword">this</span>.a = val*<span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.a = <span class="number">2</span></span><br><span class="line">myObject.a <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际的 get 和 set</span></span><br><span class="line"><span class="keyword">var</span> eric = &#123; <span class="attr">id</span>:<span class="number">1001</span>, <span class="attr">name</span>:<span class="string">"埃里克"</span>, <span class="attr">_age</span>:<span class="number">21</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(eric,&#123;</span><br><span class="line">    _age:&#123; <span class="attr">enumerable</span>:<span class="literal">false</span>, <span class="attr">configurable</span>:<span class="literal">false</span> &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"自动调用age的get()"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._age;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"自动调用age的set()"</span>);</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= <span class="number">18</span> &amp;&amp; value &lt;= <span class="number">65</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._age = value;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"年龄必须介于18~65之间"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(eric.age);</span><br><span class="line">eric.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(eric);</span><br><span class="line">eric.age = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p><strong>in &amp; <code>hasOwnProperty(..)</code></strong><br>in操作符 <strong>会检查</strong> 属性是否在对象及其原型链中<br>相比之下，<code>hasOwnProperty(..)</code>只会检查属性是否在myObject对象中，<strong>不会检查</strong> 原型链</p><p>看起来in操作符可以检查容器内是否有某个值，但是它实际上<strong>检查的是某个属性名</strong>是否存在。<br>对于数组来说这个区别非常重要，4 in [2, 4, 6]的结果并不是你期待的True，因为[2, 4, 6]这个数组中包含的属性名是0、1、2，没有4。</p><p><strong>可枚举</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">'a'</span>, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">'b'</span>, &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line">myObject.b <span class="comment">// 3</span></span><br><span class="line">(<span class="string">'b'</span> <span class="keyword">in</span> myObject) <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">'b'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> myObject)&#123;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k, myObject[k])</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="comment">// 'a' 2  </span></span><br><span class="line"><span class="comment">// 没有b，因为 for in 只遍历可枚举属性</span></span><br></pre></td></tr></table></figure><p>在数组上应用for..in循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。<br>最好只在对象上应用for..in循环，如果要遍历数组就使用传统的for循环来遍历数值索引</p><p><strong>另外一些可枚举 API</strong><br>obj.propertyIsEnumerable(..)会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足enumerable:true</p><p>Object.keys(..)会返回一个数组，包含所有可枚举属性<br>Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举<br>Object.keys(..)和Object.getOwnPropertyNames(..)都只会查找对象直接包含的属性</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>非常重要的一点是，我们讨论的父类和子类并不是实例。<br>父类和子类的比喻容易造成一些误解，实际上我们应当把父类和子类称为父类DNA和子类DNA</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Enemy</span>(<span class="params">fname,speed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fname = fname;</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">&#125;</span><br><span class="line">Enemy.prototype.fly = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.fname&#125;</span>以时速<span class="subst">$&#123;<span class="keyword">this</span>.speed&#125;</span>飞行`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plane</span>(<span class="params">fname,speed,score</span>) </span>&#123;</span><br><span class="line">    Enemy.call(<span class="keyword">this</span>,fname,speed)</span><br><span class="line">    <span class="comment">// 下面这样写，会导致 log(undefined以时速undefined飞行)</span></span><br><span class="line">    <span class="comment">// Enemy(fname,speed)</span></span><br><span class="line">    <span class="keyword">this</span>.score = score</span><br><span class="line">&#125;</span><br><span class="line">Plane.prototype.getScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`击落<span class="subst">$&#123;<span class="keyword">this</span>.fname&#125;</span>得<span class="subst">$&#123;<span class="keyword">this</span>.score&#125;</span>分`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Plane.prototype, Enemy.prototype)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f16 = <span class="keyword">new</span> Plane(<span class="string">"F16"</span>,<span class="number">1000</span>,<span class="number">5</span>)</span><br><span class="line">f16.fly();</span><br><span class="line">f16.getScore();</span><br><span class="line"><span class="built_in">console</span>.log(f16);</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一个函数，不同情况下表现出不同的状态     </p><ol><li>重载: 根据传入参数的不同，会返回不同的结果     </li><li>重写(override): 如果子对象觉得从父对象继承来的成员不好用，可在子对象本地定义同名成员，来覆盖父对象的成员。<br>如：顶级对象的toString()和 数组的toString()实现不一样的效果     </li></ol><p><strong>笔试题目: 判断一个对象是不是数组，共有几种方法:</strong><br>typeof仅能区分原始类型和function，无法进一步区分每种对象的类型     </p><ol><li>判断原型对象:<br> <code>obj.__proto__==Array.prototype</code><br> <code>Array.prototype.isPrototypeOf(obj)</code>     </li><li>判断构造函数:<br> <code>obj.constructor==Array</code><br> <code>obj instanceof Array</code><br> obj(是)Array的一个实例吗？<br> 问题: 以上两种方式，检查不严格，可能被篡改     </li><li>判断隐藏的class属性:<br> <code>Object.prototype.toString.call(obj1)</code>  this-&gt;obj1.class     </li><li><code>Array.isArray(obj)</code><br> 直接返回bool值<br> 原理同方法3，也是严格的检查     </li></ol><p><strong>小结</strong><br>传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。<br>多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。<br>JavaScript并不会（像类那样）自动创建对象的副本。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。<br><strong>几乎</strong>所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值。</p><p>所有普通的[[Prototype]]链最终都会指向内置的Object.prototype</p><p>根据理解总结几点：</p><blockquote><p>1.原型链的尽头（root）是Object.prototype。所有对象均从Object.prototype继承属性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__  <span class="comment">// null</span></span><br></pre></td></tr></table></figure><blockquote><p>2.Function.prototype和Function.<strong>proto</strong>为同一对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>.__proto__  <span class="comment">// true  </span></span><br><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Object</span>.__proto__  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Array</span>.__proto__  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 这意味着： Object/Array/String等等构造函数本质上和Function一样，均继承于Function.prototype。</span></span><br></pre></td></tr></table></figure><blockquote><p>3.Function.prototype直接继承root（Object.prototype）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// </span></span><br><span class="line">   <span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">// false</span></span><br><span class="line">   <span class="comment">// 通过这点我们可以弄清继承的原型链：</span></span><br><span class="line">   <span class="comment">// Object.prototype(root)&lt;---Function.prototype&lt;---Function|Object|Array...</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">以上3点比较容易理解，或者说规范里就这样定义的。由以上3点导出我们最后的问题：`</span><span class="built_in">Object</span><span class="string">`和`</span><span class="built_in">Function</span><span class="string">`的鸡和蛋的问题。</span></span><br><span class="line"><span class="string">回答这个问题，必须首先更深入一层去理解`</span><span class="built_in">Function</span>.prototype<span class="string">`这个对象，因为它是导致`</span><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span><span class="string">`和`</span><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span><span class="string">`都为`</span><span class="literal">true</span><span class="string">`的原因。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">看 ES 规范，得出：</span></span><br><span class="line"><span class="string">+ `</span><span class="built_in">Function</span>.prototype<span class="string">`是个不同于一般函数（对象）的函数（对象）。</span></span><br><span class="line"><span class="string">   + `</span><span class="built_in">Function</span>.prototype<span class="string">`像普通函数一样可以调用，但总是返回`</span><span class="literal">undefined</span><span class="string">`。</span></span><br><span class="line"><span class="string">   + 普通函数实际上是`</span><span class="built_in">Function</span><span class="string">`的实例，即普通函数继承于`</span><span class="built_in">Function</span>.prototype<span class="string">`，也就是 `</span>func.__proto__ === <span class="built_in">Function</span>.prototype<span class="string">`</span></span><br><span class="line"><span class="string">   + `</span><span class="built_in">Function</span>.prototype<span class="string">`继承于`</span><span class="built_in">Object</span>.prototype<span class="string">`，并且**没有`</span>prototype<span class="string">`这个属性**。`</span>func.prototype<span class="string">`是普通对象，`</span><span class="built_in">Function</span>.prototype.prototype<span class="string">`是`</span><span class="literal">null</span><span class="string">`。</span></span><br><span class="line"><span class="string">   + 所以，`</span><span class="built_in">Function</span>.prototype<span class="string">`其实是个另类的函数，可以独立于/先于`</span><span class="built_in">Function</span><span class="string">`产生。</span></span><br><span class="line"><span class="string">+ `</span><span class="built_in">Object</span><span class="string">`本身是个（构造）函数，是`</span><span class="built_in">Function</span><span class="string">`的实例，即`</span><span class="built_in">Object</span>.__proto__<span class="string">`就是`</span><span class="built_in">Function</span>.prototype<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**最后总结：先有Object.prototype（原型链顶端），Function.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承Function.prototype而产生。**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 原型本质</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt; 对象之间并非从属关系，而是委托关系，js中委托关系正是通过`</span><span class="built_in">Object</span>.create()<span class="string">`完成</span></span><br><span class="line"><span class="string">&gt; `</span><span class="built_in">Object</span>.create()<span class="string">`方法创建一个新对象，使用现有的对象来提供新创建的对象的`</span>__proto__<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">下面放两段代码，方便比较**类**和**委托**思维模型</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// 类/继承模型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.me = who;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.identify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  Foo.call( <span class="keyword">this</span>, who );</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create( Foo.prototype );</span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar( <span class="string">"b1"</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar( <span class="string">"b2"</span> );</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 委托模型</span></span><br><span class="line">Foo = &#123;</span><br><span class="line">  init(who) &#123;</span><br><span class="line">    <span class="keyword">this</span>.me = who;</span><br><span class="line">  &#125;,</span><br><span class="line">  identify() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bar = <span class="built_in">Object</span>.create( Foo );</span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Object</span>.create( Bar );</span><br><span class="line">b1.init( <span class="string">"b1"</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Object</span>.create( Bar );</span><br><span class="line">b2.init( <span class="string">"b2"</span> );</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure><p>类风格的代码强调的是实体与实体之间的关系，委托风格的代码强调的是对象之间的关联关系；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看《你不知道的javaScript》系列书籍，这里做一些记录。&lt;br&gt;上卷主要分两部分，分别是作用域和闭包，this 和 对象原型。&lt;br&gt;这篇文章主要介绍对象原型这部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的js (上卷)</title>
    <link href="https://jambo0624.github.io/2018-11-17-dont-know-js-first.html"/>
    <id>https://jambo0624.github.io/2018-11-17-dont-know-js-first.html</id>
    <published>2018-11-17T13:03:27.000Z</published>
    <updated>2020-09-24T02:03:38.393Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《你不知道的javaScript》系列书籍，这里做一些记录。<br>上卷主要分两部分，分别是作用域和闭包，this 和 对象原型。<br>下面我就分别介绍这两部分的内容。</p><a id="more"></a><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h2><p><strong>作用域</strong>是为了存储变量，并且之后可以方便地找到这些变量所设计的一套良好的规则；也可以说是根据名称查找变量的一套规则。</p><h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>当你看见var a = 2；这段程序时，很可能认为这是一句声明。<br>事实上编译器会进行如下处理。</p><ul><li>遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。</li><li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（查看1.3节）。如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会举手示意并抛出一个异常！</li></ul><p><strong>总结</strong>：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p><h3 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h3><p>查找变量的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。<br>当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。<br>下面有一个示例来具体分清 LHS 和 RHS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> a </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c= foo(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>1．找出所有的LHS查询（这里有3处！）<br><code>c=.. a=1 b=..</code><br>2．找出所有的RHS查询（这里有4处！）<br><code>foo(2..  =a  a.. ..b</code></p><h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p>当一个块或函数嵌套在另一个块或函数中时，就发生了<strong>作用域的嵌套</strong>。因此，在<strong>当前</strong>作用域中无法找到某个变量时，引擎就会在<strong>外层</strong>嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是<strong>全局</strong>作用域）为止。也就是所谓的<strong>作用域链</strong>。</p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作<strong>遮蔽效应</strong>（内部的标识符“遮蔽”了外部的标识符）</p><p><strong>欺骗词法作用域</strong>下面两种方法不提倡使用</p><blockquote><p>eval函数，修改词法作用域<br>with关键字，创建词法作用域</p></blockquote><h2 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h2><p>函数的块级作用域是从最小特权原则中引申出来的，也叫最小授权或<strong>最小暴露原则</strong>。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。<br>另一个好处就是可以<strong>规避冲突</strong>。“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。</p><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><blockquote><p>let 的「创建」过程被提升了，但是初始化没有提升。所以 let 会有暂时死区<br>var 的「创建」和「初始化」都被提升了。<br>function 的「创建」「初始化」和「赋值」都被提升了。所以同名时，函数权重最重</p></blockquote><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包，有权访问另外一个函数的变量标识符的函数。<br>比较常见的一个闭包问题，就是for循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现每一次输出的都是6。是因为所有的回调函数回在循环结束后才会执行（event loop）</p><p>解决办法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// IIFE 闭包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, j*<span class="number">1000</span>);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6 let 闭包 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(i);</span><br><span class="line">   &#125;, i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码的 mdn 解释</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">let</span> j = i;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(j);</span><br><span class="line">   &#125;, j*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个闭包常用的场景，就是<strong>模块暴露</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coolModule</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">'cool'</span></span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(another.join(<span class="string">' ! '</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doAnother: doAnother</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = coolModule()</span><br><span class="line"></span><br><span class="line">foo.doSomething() <span class="comment">// cool</span></span><br><span class="line">foo.doAnother() <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure><h1 id="this-和-对象原型"><a href="#this-和-对象原型" class="headerlink" title="this 和 对象原型"></a>this 和 对象原型</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。<br>找到之后就可以顺序应用下面这四条规则来判断this的绑定对象。优先级由低到高<br>1．由new调用？绑定到新创建的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bar.a)<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>2．由call或者apply（或者bind）调用？绑定到指定的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.call(obj)</span><br><span class="line">&#125;</span><br><span class="line">bar()<span class="comment">// 2</span></span><br><span class="line">setTimeout(bar, <span class="number">100</span>)<span class="comment">// 2</span></span><br><span class="line">bar.call(<span class="built_in">window</span>)<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>3．由上下文对象调用？绑定到那个上下文对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a:<span class="number">42</span>,</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  obj2: obj2</span><br><span class="line">&#125;</span><br><span class="line">obj1.obj2.foo()</span><br></pre></td></tr></table></figure><p>4．默认：在严格模式下绑定到undefined，否则绑定到全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo();<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">2</span></span><br><span class="line">foo2() <span class="comment">// typeerror</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  foo3()<span class="comment">// 2</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>一定要注意，有些调用可能在无意中使用默认绑定规则。<br>ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的this绑定（无论this绑定到什么）。<br>这其实和ES6之前代码中的self = this机制一样。</p><p>今天先到这里，还有原型对象的部分，下一篇文章在写。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看《你不知道的javaScript》系列书籍，这里做一些记录。&lt;br&gt;上卷主要分两部分，分别是作用域和闭包，this 和 对象原型。&lt;br&gt;下面我就分别介绍这两部分的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="https://jambo0624.github.io/2018-11-04-longest-substring-without-repeating-characters.html"/>
    <id>https://jambo0624.github.io/2018-11-04-longest-substring-without-repeating-characters.html</id>
    <published>2018-11-04T06:39:04.000Z</published>
    <updated>2020-09-23T11:11:48.126Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录在 freeCodeCamp 遇到的一些问题和解法。</p><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>longest-substring-without-repeating-characters<br>题目：给定一个字符串，找出不含有重复字符的最长子串的长度。<br>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入： "abcabcbb"</span></span><br><span class="line"><span class="comment">// 输出： 3</span></span><br><span class="line"><span class="comment">// 原因： 无重复字符的最长子串是 "abc"，其长度为 3</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>一、暴力解法<br>逐个检查所有子字符串，判断是否含有重复的字符；<br>就通过逐个检查就能想到这个方法肯定有很多层循环，还是一个一个的判断很消耗时间，虽然最终也能拿到正确的值，但是其时间复杂度很大。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断给定的子串是否包含重复字符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUnique</span>(<span class="params">str, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> chars = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = str[i];</span><br><span class="line">    <span class="keyword">if</span>(chars.indexOf(char) !== <span class="number">-1</span>) &#123; <span class="comment">// 字符已存在，本字符串不符合条件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chars.push(char); <span class="comment">// 添加字符</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串最长子串长度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt;= s.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(isUnique(s, i, j)) &#123; <span class="comment">// 判断子串是否唯一</span></span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, j - i); <span class="comment">// j - i 为当前子串长度</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: O(n^3)<br>i循环，j循环，isUnquie中的循环，3次循还嵌套<br>时间复杂度很高，容易超时</p><p>二、滑动窗口解法<br>滑动窗口，通过字面意思猜出一个大概，应该是把一个空间类似为窗口的移动，一段一段的进行操作；<br>其具体的说法是：</p><blockquote><p>滑动窗口是数组/字符串问题中常用的抽象概念；<br>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）；<br>而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j) 向右滑动1个元素，则它将变为 [i+1, j+1)（左闭，右开）。</p></blockquote><p>回到问题：<br>通过找到定义字符到索引的映射，当我们找到重复的字符时，我们可以立即跳过该窗口。<br>也就是说，如果 s[j] 在 [i, j) 范围内有与 j有重复的字符，我们不需要逐渐增加 i 。 我们可以直接跳过 [i，j) 范围内的所有元素，并将 i 变为 j + 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childStrMaxLenNumEvent</span>(<span class="params">strData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strLen = strData.length,</span><br><span class="line">      childStrMaxLen = <span class="number">0</span>,</span><br><span class="line">      storeChildStrObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; strLen; j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> curStr = strData.charAt(j);</span><br><span class="line">    <span class="keyword">if</span> (storeChildStrObj.hasOwnProperty(curStr)) &#123;</span><br><span class="line">      i = <span class="built_in">Math</span>.max(storeChildStrObj[curStr], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    childStrMaxLen = <span class="built_in">Math</span>.max(childStrMaxLen, j - i + <span class="number">1</span>);</span><br><span class="line">    storeChildStrObj[curStr] = j + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> childStrMaxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度： O(n)，只有索引 j 迭代了一遍，比暴力法好多了</p><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>之前在其他地方，看到了这样的一道题目</p><p>题目描述：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><blockquote><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p></blockquote><p>示例 2：</p><blockquote><p>输入: “cbbd”<br>输出: “bb”</p></blockquote><p>回文是在回文中心两侧互为镜像，因此，可以从它的中心展开，并且2n-1个中心。使用中心扩展法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longestPalindrome</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">    <span class="keyword">const</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> len = <span class="built_in">Math</span>.max(len1, len2);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">      start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      end = i + len / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expandAroundCenter</span>(<span class="params">s, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> L = left, R = right;</span><br><span class="line">  <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">    L--;</span><br><span class="line">    R++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录在 freeCodeCamp 遇到的一些问题和解法。&lt;/p&gt;
&lt;h3 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h3&gt;&lt;p&gt;longest-substring-without-repeating-characters&lt;br&gt;题目：给定一个字符串，找出不含有重复字符的最长子串的长度。&lt;br&gt;示例&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输入： &quot;abcabcbb&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出： 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 原因： 无重复字符的最长子串是 &quot;abc&quot;，其长度为 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="arithmetic" scheme="https://jambo0624.github.io/tags/arithmetic/"/>
    
  </entry>
  
  <entry>
    <title>隐式转换implicit conversion</title>
    <link href="https://jambo0624.github.io/2018-11-03-implicit-conversion.html"/>
    <id>https://jambo0624.github.io/2018-11-03-implicit-conversion.html</id>
    <published>2018-11-03T03:19:27.000Z</published>
    <updated>2020-09-23T05:53:18.227Z</updated>
    
    <content type="html"><![CDATA[<p>在平时的积累过程中有没有遇见过类似这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]+[]  <span class="comment">// ''</span></span><br><span class="line">&#123;&#125;+&#123;&#125;  <span class="comment">// '[object Object][object Object]'</span></span><br><span class="line"><span class="number">1</span>+[]   <span class="comment">// '1'</span></span><br></pre></td></tr></table></figure><p>虽然代码中不提倡写这种晦涩难懂还说不定就出错的代码，但是其原理我们还是要懂得<br>那么下面可以开始记录一下 JavaScript 代码世界中的隐式转换。</p><a id="more"></a><h3 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h3><p>在 JavaScript 中加法运算很简单，它只做 <strong>数字</strong>和<strong>字符串</strong> 的加法操作，所以不是这两种类型的都会被转换成这两种原始类型数据再进行操作。<br>而在 JavaScript 中数据类型分为两种(原始数据类型和复杂数据类型):</p><p><strong>原始数据类型</strong> (primitives): undefined, null, number, string, boolean, symbol(es6新增)<br><strong>复杂数据类型</strong>: 对象(包括数组、函数)<br>那么对象是怎么转换成原始数据类型的呢？</p><h3 id="ToPrimitive-方法"><a href="#ToPrimitive-方法" class="headerlink" title="ToPrimitive 方法"></a>ToPrimitive 方法</h3><p>在 JavaScript 内部有一个 ToPrimitive() 方法，它用于将对象转换成原始数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToPrimitive(input, PreferredType?)</span><br></pre></td></tr></table></figure><p>这个函数接收两个参数：</p><blockquote><p>input: 输入值<br>PreferredType: 此参数可以是 Number 或者 String，它代表我们的对象会优先转换成哪种原始数据类型。<br>如果缺少第二个参数，对于 Date 的实例，默认为 String，其余的都为 Number； 转换步骤也会因为这个参数的不同而不同。</p></blockquote><p>下面看一下它的转换过程。<br><strong>PreferredType 为 Number</strong></p><ul><li><code>input</code> 为原始数据类型，直接返回 <code>input</code>；</li><li>如果 <code>input</code> 是一个<strong>对象</strong>，那么它会先去调对象的 <code>valueOf()</code> 方法，得到的结果若为<strong>原始数据类型</strong>则返回；</li><li>如果上一步得到的结果仍然是<strong>对象</strong>，那么此时会去调用对象的 <code>toString()</code> 方法，得到的结果为<strong>原始数据类型</strong>则返回；</li><li>如果上一步操作完之后得到的仍不是<strong>原始数据类型</strong>，那么此时就抛出<strong>错误</strong>。</li></ul><p><strong>PreferredType 为 String</strong></p><ul><li><code>input</code> 为原始数据类型，直接返回 <code>input</code>;</li><li>如果 <code>input</code> 是一个<strong>对象</strong>，那么它会先去调对象的 <code>toString()</code> 方法，得到的结果若为<strong>原始数据类型</strong>则返回；</li><li>如果上一步得到的结果仍然是<strong>对象</strong>，那么此时会去调用对象的 <code>valueOf()</code> 方法，得到的结果为<strong>原始数据类型</strong>则返回；</li><li>如果上一步操作完之后得到的仍不是<strong>原始数据类型</strong>，那么此时就抛出*<em>错误</em>。</li></ul><p>这里的 PreferredType 为 Number 和 String 两个不同值处理转换的步骤略有不同，主要区别就是根据数据类型判断先执行 valueOf() 方法还是 toString() 方法，交换上面执行步骤的2、3步。</p><p>那么 valueOf() 和 toString() 究竟返回的是什么？<br><strong>valueOf() 和 toString()</strong><br>valueOf() 和 toString() 都是 Object 的属性，那它们返回的都是什么？例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data1 = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(data1.valueOf());   <span class="comment">// &#123;a:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(data1.toString());  <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(data2.valueOf());   <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(data2.toString());  <span class="comment">// "1,2,3"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(data3.valueOf());  <span class="comment">// function() &#123;const a = 1; return a;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(data3.toString()); <span class="comment">// "function() &#123;const a = 1; return a;&#125;"</span></span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><p>对象: valueOf() 返回对象本身，toString() 返回字符串 [object Object];<br>数组: valueOf() 返回数组本身，toString() 返回数组值用逗号链接的字符串，和 join(‘,’) 得到的结果一样;<br>方法: valueOf() 返回方法本身，toString() 返回的是Function中改写的toString()处理完的字符串结果;</p></blockquote><h3 id="运算"><a href="#运算" class="headerlink" title="+ 运算"></a>+ 运算</h3><p>最后回归正题，加号(+)的运算，就是对当前进行加法运算的值进行转换后再做相应的操作，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value1 + value2</span><br></pre></td></tr></table></figure><p>在上面的加法运算表达式中，会是如下操作步骤：</p><p>1.将两个操作数转换成基本数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prim1 = ToPrimitive(value1);</span><br><span class="line">prim2 = ToPrimitive(value2);</span><br><span class="line"><span class="comment">// 这里省略了 PreferredType 参数，因此日期值为 String，其他的为 Number</span></span><br></pre></td></tr></table></figure><p>2.如果 prim1 和 prim2 是一个字符串，则将其转成字符串并返回相连接的结果<br>3.否则，将 prim1 和 prim2 都转为数字并返回结果的综合</p><p>那么最开始的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]+[] </span><br><span class="line">&#123;&#125;+&#123;&#125;</span><br><span class="line"><span class="number">1</span>+[]</span><br></pre></td></tr></table></figure><p>进行运算后得到的结果是什么呢？</p><p><code>[]+[]</code> </p><ul><li>首先将[]进行原始数据转换，也就是 ToPrimitive([])，因为是数组，所以 PreferredType 为 Number</li><li>经过转换步骤2（[].valueOf()）后仍是一个对象</li><li>那么再进行步骤3（[].toString()），得到的结果就是一个空字符串</li><li>两个空字符串相加还是一个空字符串（””）</li></ul><p><code>{}+{}</code> </p><ul><li>首先将{}进行原始数据转换，也就是 ToPrimitive({})，因为是对象，所以 PreferredType 为 Number</li><li>经过转换步骤2（[].toString()）后仍是一个字符串”[object Object]”，已经是原始数据类型，不需要在进行转换</li><li>那么得到的结果就是两个字符串相加的结果（”[object Object][object Object]”）</li></ul><p><code>1+[]</code> </p><ul><li>首先对1和[]进行原始数据转换，也就是 ToPrimitive(1) 和 ToPrimitive([])，因为1已经是原始数据类型，则直接返回值1</li><li>而[]是数组，则 PreferredType 为 Number，经过步骤2（[].valueOf()）后仍是一个对象，再进行步骤3（[].toString()），得到了一个空字符串</li><li>最后，就是 1+”” ，得到的结果是字符串 “1”</li></ul><p>而我在进行测试的时候发现了一个有意思的事情是：<br>{}+[] 和 {}+1 得到的结果并不是 “[object Object]” 和 “[object Object]1”<br>根据我们前面的操作，这里应该就是这个结果，那这是为什么呢？<br>最后发现这是不同的浏览器的解析不同，它会将前面的 {} 当成一个代码块，于是得到的结果就会变成 +0 和 +1，即为 0 和 1。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时的积累过程中有没有遇见过类似这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[]+[]  &lt;span class=&quot;comment&quot;&gt;// &#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;#125;+&amp;#123;&amp;#125;  &lt;span class=&quot;comment&quot;&gt;// &#39;[object Object][object Object]&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+[]   &lt;span class=&quot;comment&quot;&gt;// &#39;1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然代码中不提倡写这种晦涩难懂还说不定就出错的代码，但是其原理我们还是要懂得&lt;br&gt;那么下面可以开始记录一下 JavaScript 代码世界中的隐式转换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
  </entry>
  
  <entry>
    <title>css3 中选择器的总结</title>
    <link href="https://jambo0624.github.io/2018-10-28-c3-selector.html"/>
    <id>https://jambo0624.github.io/2018-10-28-c3-selector.html</id>
    <published>2018-10-28T08:20:20.000Z</published>
    <updated>2020-09-22T06:31:09.925Z</updated>
    
    <content type="html"><![CDATA[<p>css3 新增了许多特性。按照功能分为了6个部分，每个部分又分别包含了几个方面，总结如下：</p><a id="more"></a><table><thead><tr><th>新增特性名</th><th>对应的小分类</th></tr></thead><tbody><tr><td>选择器的拓展</td><td>属性选择器、结构伪类选择器、UI元素状态伪类选择器、目标伪类选择器、否定选择器、通用兄弟选择器</td></tr><tr><td>页面布局的加强</td><td>多列式布局、可变更的盒模型、可伸缩的布局</td></tr><tr><td>元素修饰的加强</td><td>RGBA和透明度、圆角支持、多背景图片支持、渐变效果支持、阴影和反射效果</td></tr><tr><td>开放字体的支持</td><td>CSS3提供@font-face特性为页面自定义字体的展示提供支持</td></tr><tr><td>多终端的适配</td><td>通过媒体查询（media queries）可以让你为不同的设备基于它们的能力定义不同的样式</td></tr><tr><td>动画支持</td><td>过渡(transition)、旋转缩放(transform)、执行动画(animation)</td></tr></tbody></table><p>但是今天我们只对 css 新增的选择器进行分析。因为在实际运用中还不能做到得心应手，甚至有一些还会混淆。所以现将选择器相关内容总结如下：</p><table><thead><tr><th>选择器</th><th>选择器含义</th><th>选择器类型</th><th>Level</th></tr></thead><tbody><tr><td>*    通配选择符，</td><td>可匹配任意元素</td><td>通用选择器</td><td>2</td></tr><tr><td>E</td><td>匹配类型为E的元素</td><td>类型选择器</td><td>1</td></tr><tr><td>E[foo]</td><td>匹配某元素，此元素含有”foo”属性</td><td>属性选择器</td><td>2</td></tr><tr><td>E[foo=”bar”]</td><td>匹配某元素，此元素的”foo” 属性等于bar</td><td>属性选择器</td><td>2</td></tr><tr><td>E[foo~=”bar”]</td><td>匹配某元素，此元素的”foo”属性值是由空格链接的多个值组成，其中有一个等于bar</td><td>属性选择器</td><td>2</td></tr><tr><td>E[foo^=”bar”]</td><td>匹配某元素，此元素的”foo” 属性值由bar开始</td><td>属性选择器</td><td>3</td></tr><tr><td>E[foo$=”bar”]</td><td>匹配某元素，此元素的”foo” 属性值由bar结束</td><td>属性选择器</td><td>3</td></tr><tr><td>E[foo*=”bar”]</td><td>匹配某元素，此元素的”foo” 属性值包含bar</td><td>属性选择器</td><td>3</td></tr><tr><td>E:root</td><td>匹配某元素所在文档的根元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:nth-child(n)</td><td>匹配元素类型为E且是其父元素的第N个子元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:nth-last-child(n)</td><td>匹配元素类型为E且是其父元素的倒数第N个子元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:nth-of-type(n)</td><td>匹配父元素的第N个类型为E的子元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:nth-last-of-type(n)</td><td>匹配父元素的倒数第N个类型为E的子元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:first-child</td><td>匹配元素类型为E且是父元素的第一个子元素</td><td>结构伪类选择器</td><td>2</td></tr><tr><td>E:last-child</td><td>匹配元素类型为E且是父元素的最后一个子元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:first-of-type</td><td>匹配父元素的第一个类型为E的子元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:last-of-type</td><td>匹配父元素的最后一个类型为E的子元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:only-child</td><td>匹配元素类型为E且是父元素中唯一的子元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:only-of-type</td><td>匹配父元素中唯一子元素是E的子元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:empty</td><td>匹配不包含子节点(包括文本) 的E元素</td><td>结构伪类选择器</td><td>3</td></tr><tr><td>E:link/E:visited</td><td>前者匹配已定义href属性的a元素(未访问)，后者匹配已访问过的a元素</td><td>链接伪类选择器</td><td>1</td></tr><tr><td>E:active/E:hover/E:focus</td><td>分别匹配被激活过、被鼠标经过、获得焦点的E元素。</td><td>用户操作伪类选择器</td><td>1、2</td></tr><tr><td>E:target</td><td>匹配URI中锚点指定的元素</td><td>目标伪类选择器</td><td>3</td></tr><tr><td>E:lang(fr)</td><td>匹配E元素，且该元素显示内容的语言类型是fr</td><td>语言伪类选择器</td><td>2</td></tr><tr><td>E:enabled/E:disabled</td><td>选择所有可用、不可用的E元素</td><td>UI元素状态伪类选择器</td><td>3</td></tr><tr><td>E:cheched</td><td>选择所有选中的E元素(主要用于checkbox和radio)</td><td>UI元素状态伪类选择器</td><td>3</td></tr><tr><td>E::first-line</td><td>E元素内的第一行文本</td><td>首行伪类选择器(伪选择器)</td><td>1</td></tr><tr><td>E::first-letter</td><td>匹配E元素内的第一个字符</td><td>首字符伪类选择器(伪选择器)</td><td>1</td></tr><tr><td>E::before</td><td>匹配E元素前的内容</td><td>伪元素选择器</td><td>2</td></tr><tr><td>E::after</td><td>匹配E元素后的内容</td><td>伪元素选择器</td><td>2</td></tr><tr><td>E.warning</td><td>匹配类名为warning的元素</td><td>类选择器</td><td>1</td></tr><tr><td>E#isId</td><td>匹配Id为isId的元素</td><td>ID选择器</td><td>1</td></tr><tr><td>E:not(s)</td><td>匹配类型为E，不匹配选择符为s的元素</td><td>否定选择器</td><td>3</td></tr><tr><td>E F</td><td>选择包含在E元素中的F元素</td><td>包含选择器</td><td>1</td></tr><tr><td>E &gt; F</td><td>匹配F元素，且该元素为所匹配E元素的子元素</td><td>子包含选择器</td><td>2</td></tr><tr><td>E + F</td><td>匹配与E元素相邻的第一个F元素，且F元素在E元素之后</td><td>通用兄弟元素选择器</td><td>2</td></tr><tr><td>E ~ F</td><td>匹配位于E元素后面所有的F元素</td><td>通用兄弟元素选择器</td><td>3</td></tr></tbody></table><p>下面我们就部分选择器，给出一些代码示例：</p><ul><li>使用的兼容性可以在<a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse</a>查看</li><li>代码可在<a href="https://jsbin.com/?html,output" target="_blank" rel="noopener">jsbin</a>配合对应的 HTML 查看效果</li></ul><p><strong>属性选择器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span><span class="selector-attr">[foo^=<span class="string">"bar"</span>]</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span><span class="selector-attr">[foo$=<span class="string">"bar"</span>]</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span><span class="selector-attr">[foo*=<span class="string">"bar"</span>]</span> &#123;</span></span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.bar-att</span><span class="selector-attr">[foo^=<span class="string">"bar"</span>]</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.att-bar</span><span class="selector-attr">[foo$=<span class="string">"bar"</span>]</span> &#123;</span></span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.attr-bar-con</span><span class="selector-attr">[foo*=<span class="string">"bar"</span>]</span> &#123;</span></span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>结构伪类选择器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">li</span><span class="selector-pseudo">:nth-of-type(1)</span> &#123;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line">    font-size: 20px;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">li</span><span class="selector-pseudo">:nth-last-child(1)</span> &#123;</span></span><br><span class="line">    font-size: 12px;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>UI元素状态伪类选择器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.attr-abled-radio</span> &#123;</span></span><br><span class="line">    width: 330px;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.attr-abled-radio</span><span class="selector-pseudo">:enabled</span> &#123;</span></span><br><span class="line">    font-size: 16px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.attr-abled-radio</span><span class="selector-pseudo">:disabled</span> &#123;</span></span><br><span class="line">    font-size: 20px;</span><br><span class="line">    border: 1px solid blue;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.attr-checked</span><span class="selector-pseudo">:checked</span> &#123;</span></span><br><span class="line">    font-size: 24px;</span><br><span class="line">    border: 1px solid green;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>否定伪类选择器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.attr-abled-radio</span> &#123;</span></span><br><span class="line">  width: 330px;</span><br><span class="line">  margin-bottom: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.attr-abled-radio</span><span class="selector-pseudo">:not(input)</span> &#123;</span></span><br><span class="line">  font-size: 16px;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>通用兄弟元素选择器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">  h3 &#123;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 20px;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  line-height: 20px;</span><br><span class="line">  color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  h3 ~ p &#123;</span><br><span class="line">  font-size: 22px;</span><br><span class="line">  line-height: 30px;</span><br><span class="line">  color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">  h4 &#123;</span><br><span class="line"><span class="css">  <span class="selector-tag">border-top</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">dashed</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  h4 + h5 &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">  color: green;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css3 新增了许多特性。按照功能分为了6个部分，每个部分又分别包含了几个方面，总结如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="css3" scheme="https://jambo0624.github.io/tags/css3/"/>
    
      <category term="selector" scheme="https://jambo0624.github.io/tags/selector/"/>
    
  </entry>
  
  <entry>
    <title>比较 jQuery 中的 attr 和 prop</title>
    <link href="https://jambo0624.github.io/2018-10-03-compare-attr-prop.html"/>
    <id>https://jambo0624.github.io/2018-10-03-compare-attr-prop.html</id>
    <published>2018-10-03T02:19:27.000Z</published>
    <updated>2020-09-22T06:50:00.260Z</updated>
    
    <content type="html"><![CDATA[<p>在高版本的 JQuery 引入 prop()方法后一直没有把它和 attr()做过多的区别，经常是用 attr()处理问题，少有时候用 prop()，由于前期的学习及结果的正确性而没有过多的去关心理解这两者的区别。<br>但是最近在这方面遇到了困惑, 由此自己思考什么时候该用 attr()？什么时候该用 prop()？</p><ul><li>.attr()，它从 jQuery1.0 就已经存在，官方文档说的是读写 dom 的 attribute 值；</li><li>.prop()，它在 jquery1.6 才引入，官方文档说的是读写 property 值；</li></ul><a id="more"></a><blockquote><p>其实 attr()和 prop()都是获取和设置指定的属性，均表示”属性”的意思；<br>但在 JQuery 中 attribute 和 property 是两个不同的概念<br>attribute 表示 HTML 文档节点的属性，property 表示 js 对象的属性。</p></blockquote><p>如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里的id、class、type、checked均是该元素文档节点的attribute --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"content-test"</span> <span class="attr">class</span>=<span class="string">"content-test"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 这里的name、color、address均是obj的property</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> testObj = &#123; name: <span class="string">"test"</span>, color: <span class="string">"red"</span>, address: <span class="string">"china"</span> &#125;;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在 jquery 底层实现中 attr()和 prop()都是通过什么实现的呢，其实它们都是通过 JS 原生的 element 对象实现的，其主要依赖的函数是 element 对象的 getAttribute()和 setAttribute()两个方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"content-test"</span> <span class="attr">class</span>=<span class="string">"content-test"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">"content-test"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> $content = $(content);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 相当于 content.setAttribute("checked", 'checked');</span></span></span><br><span class="line"><span class="actionscript">    $content.attr(<span class="string">"checked"</span>, <span class="string">"checked"</span>);       <span class="comment">// 设置checked="checked"</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 相当于 content.getAttribute("checked");</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> checkStage = $content.attr(<span class="string">"checked"</span>); <span class="comment">// "checked"</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">/** prop()依赖的是JS原生的 element[property] 和 element[property] = value; **/</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 相当于 content["checked"] = "checked值";</span></span></span><br><span class="line"><span class="actionscript">    $content.prop(<span class="string">"checked"</span>, <span class="string">"checked值"</span>);     <span class="comment">// 设置checked值到checked属性</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 相当于 content["pid"];</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> checkStage = $content.prop(<span class="string">"checked"</span>); <span class="comment">// checked值 —— true</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，我们在 jquery 中使用的这些方法被封装之后使我们操作起来更方便，并跨浏览器兼容。<br>上面了解到了两者的实现方式，它们最终的区别最终是什么呢？如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"content-test1"</span> <span class="attr">class</span>=<span class="string">"content-test1"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"content-test2"</span> <span class="attr">class</span>=<span class="string">"content-test2"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"content-test3"</span> <span class="attr">class</span>=<span class="string">"content-test3"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> $content1 = $(<span class="string">"#content-test1"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> $content2 = $(<span class="string">"#content-test2"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> $content3 = $(<span class="string">"#content-test3"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 获取第一个input的checked状态值</span></span></span><br><span class="line"><span class="actionscript">    $content1.attr(<span class="string">"checked"</span>); <span class="comment">// 得到结果是得字符串值checked</span></span></span><br><span class="line"><span class="actionscript">    $content1.prop(<span class="string">"checked"</span>); <span class="comment">// 得到结果是布尔值true</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 获取第二个input的checked状态值</span></span></span><br><span class="line"><span class="actionscript">    $content2.attr(<span class="string">"checked"</span>); <span class="comment">// 得到结果是字符串值checked</span></span></span><br><span class="line"><span class="actionscript">    $content2.prop(<span class="string">"checked"</span>); <span class="comment">// 得到结果是布尔值true</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 获取第三个input的checked状态值</span></span></span><br><span class="line"><span class="actionscript">    $content3.attr(<span class="string">"checked"</span>); <span class="comment">// 得到结果是undefined</span></span></span><br><span class="line"><span class="actionscript">    $content3.prop(<span class="string">"checked"</span>); <span class="comment">// 得到结果是布尔值false</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过结果比对发现，在使用 attr()和 prop()得到的结果在 input 上没有 checked 选中状态时才会有所不同。<br>结果表明 prop()会得到对应的布尔值，attr()在没有将属性值没有正确的写成字符串时会得到 undefined。<br>在 <code>checked = &#39;&#39;</code>的情况下 attr 和 prop 也都会得到正确的值，所以用的时候注意了。</p><p><strong>总结</strong><br>在 dom 结构中如果是其固有属性，即在 W3C 标准里就含有的属性，在处理时使用 prop() 例如：class,id,checked 等；<br>我们自定义的属性在处理时使用 attr() 例如：action=”test”；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在高版本的 JQuery 引入 prop()方法后一直没有把它和 attr()做过多的区别，经常是用 attr()处理问题，少有时候用 prop()，由于前期的学习及结果的正确性而没有过多的去关心理解这两者的区别。&lt;br&gt;但是最近在这方面遇到了困惑, 由此自己思考什么时候该用 attr()？什么时候该用 prop()？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.attr()，它从 jQuery1.0 就已经存在，官方文档说的是读写 dom 的 attribute 值；&lt;/li&gt;
&lt;li&gt;.prop()，它在 jquery1.6 才引入，官方文档说的是读写 property 值；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="jQuery" scheme="https://jambo0624.github.io/categories/jQuery/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="jQuery" scheme="https://jambo0624.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 学习笔记(五)</title>
    <link href="https://jambo0624.github.io/2018-09-16-vue-note-5.html"/>
    <id>https://jambo0624.github.io/2018-09-16-vue-note-5.html</id>
    <published>2018-09-16T10:40:33.000Z</published>
    <updated>2020-09-22T05:34:54.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SPA应用："><a href="#SPA应用：" class="headerlink" title="SPA应用："></a>SPA应用：</h3><p>SPA: Single Page Application 单页面应用<br>意思就是整个应用程序只有一个完整的HTML文件。所谓的”页面”，其实只是不同组件片段而已。在浏览器时，按需加载组件片段内容，替换HTML文件中指定位置。</p><a id="more"></a><h3 id="笔试题目：多页面应用-vs-单页面应用"><a href="#笔试题目：多页面应用-vs-单页面应用" class="headerlink" title="笔试题目：多页面应用 vs 单页面应用"></a>笔试题目：多页面应用 vs 单页面应用</h3><ol><li>请求次数:<br>多页面应用，会造成反复请求<br>单页面应用，只请求一次，就拿到所有内容</li><li>页面跳转的本质:<br>多页面应用，删除整棵DOM树重建<br>单页面应用，只替换DOM树中局部节点对象即可</li><li>共用资源:<br>多页面应用，多个页面共用的资源，也需要反复请求下载<br>单页面应用，只在首次加载HTML文件时，请求下载一次</li><li>页面切换动画:<br>多页面应用，不可能实现页面切换动画<br>单页面应用，很容易实现页面切换动画<br>问题: 首屏加载慢！<br>解决: 将来Vue项目中可设置“懒加载”——按需加载。</li></ol><h3 id="单页面应用实现的原理："><a href="#单页面应用实现的原理：" class="headerlink" title="单页面应用实现的原理："></a>单页面应用实现的原理：</h3><ol><li>定义多个template</li><li>定义一个唯一的完整的HTML文件。HTML中要有一个特殊的元素占位，表示将来要被不同template替换的位置。</li><li>定义路由字典:<br>路由: 一个请求地址和一个组件名的对应关系<br>路由字典：包含一组路由键值对儿的集合<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> routes=[</span><br><span class="line">  &#123;<span class="string">'#index'</span>, tplIndex&#125;,</span><br><span class="line">  &#123;<span class="string">'#products'</span>, tplProducts&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li>根据当前url中相对路径或请求参数的不同，用不同的template代替占位符的位置。<ol><li>获得相对路径或请求参数</li><li>遍历路由列表，找到对应的template，并读取其中内容</li><li>用template内容代替占位符的位置</li></ol></li></ol><h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架:"></a>脚手架:</h3><p>什么是: 具有核心功能的半成品代码。我们只要向其中添加个性化自定义内容即可。<br>为什么: 简化和标准化项目结构<br>何时: 今后只要开发Vue项目，都是用脚手架生成<br>如何:<br>创建项目: </p><ol><li>下载Vue-CLI脚手架命令行工具。Vue-CLI 专门用于通过命令生成脚手架代码<br>先安装命令行工具: <code>npm i -g @vue/cli</code></li><li>用命令行工具创建项目代码:<blockquote><p><code>vue create 项目名</code><br>选Manually select features 手动选择功能<br>选 Babel: 专门自动将ES6代码转化为ES5代码。比如: ES6 中 抛出模块: export default{ … }<br>Router: Vue-router组件<br>Vuex: 客户端状态管理<br>Use history mode for router 选Y 。采用不带#的路由地址<br>选 In package.json 将所有子工具的配置，都集中放在一个配置文件中(package.json)<br>Save this as a preset for future projects? 选N 是否将当前项目配置保存为默认项目配置<br>Use <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> for faster installation? 是否使用国内的淘宝镜像作为包管理工具，选n</p></blockquote></li><li>运行测试项目:<br><code>cd 项目文件夹</code><br>项目文件夹下&gt; <code>npm run serve</code><br>启动临时开发服务器，编译并宿主Vue生成后的文件。</li><li>安装必要组件:<br><code>npm i -save axios</code><br><code>npm i -save querystring</code></li></ol><h3 id="脚手架项目结构"><a href="#脚手架项目结构" class="headerlink" title="脚手架项目结构:"></a>脚手架项目结构:</h3><ol><li>public：专门保存不需要编译的静态资源的文件夹<br>  比如可复制学子商城项目的img文件夹到public下<br>  还保存着唯一的完整静态页面: index.html<br>  共用的css和共用的js</li><li>src: 包含项目所有要编译的源代码文件<blockquote><p>assets: 需要编译打包的静态资源<br>views: 所有直接出现在路由字典中的组件<br>components: 所有全局组件<br>app.vue: 整个项目中唯一根组件<br>main.js: 是根组件app.vue的主程序<br>router.js: 整个项目的路由器和路由字典</p></blockquote></li><li>每个组件的内容:<br> 每个组件都是一个.vue文件<br> 包含三部分内容: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    原template中的HTML片段</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    原组件对象中的属性: data, mounted(), methods...</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  &#x2F;*当前组件自用的CSS样式*&#x2F;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用Vue重构前端页面"><a href="#使用Vue重构前端页面" class="headerlink" title="使用Vue重构前端页面"></a>使用Vue重构前端页面</h3><p>回顾:<br>①vue中组件的创建、使用<br>SFC single file component 单文件组件系统 **.vue<br>组件：可被反复使用的，带有特定功能的模板内容</p><p>②vue中基本语法<br>指令、过滤器、属性、插件<br>vue官方提供了两个核心插件:vueRouter/vuex<br><strong>自定义插件的创建和使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin = &#123;</span><br><span class="line">  install:<span class="function"><span class="keyword">function</span>(<span class="params">vue</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//在此插件的内部，封装组件、过滤器、指令。。。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.use(MyPlugin)</span><br></pre></td></tr></table></figure><p>③vue中组件间内部通信</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// props down</span></span><br><span class="line">&lt;son myTitle=<span class="string">""</span>&gt;&lt;<span class="regexp">/son&gt;</span></span><br><span class="line"><span class="regexp">son:</span></span><br><span class="line"><span class="regexp">  &#123;</span></span><br><span class="line"><span class="regexp">    props:['myTitle']/</span><span class="regexp">/this.myTitle</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ events up</span></span><br><span class="line"><span class="regexp">parent:handleEvent(msg)&#123;&#125;</span></span><br><span class="line"><span class="regexp">&lt;son @myEvent="handleEvent"&gt;&lt;/</span>son&gt;</span><br><span class="line"><span class="keyword">this</span>.$emit(myEvent,<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bus:基于事件的机制</span></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">this</span>.$bus.$on(<span class="string">'myEvent'</span>,(msg)=&gt;&#123;&#125;)</span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(<span class="string">'myEvent'</span>,<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>④vue中网络通信 axios</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Axios.get().then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//response.data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>⑤vue-router(路由系统)<br>基本配置<br>创建组件<br>创建容器 <code>&lt;router-view&gt;&lt;/router-view&gt;</code><br>配置路由词典</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">''</span>,<span class="attr">component</span>:**&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>配置路由器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Router(&#123; <span class="attr">routes</span>:[] &#125;)</span><br></pre></td></tr></table></figure><p>调用路由器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">router</span>:** &#125;)</span><br></pre></td></tr></table></figure><p><strong>跳转</strong> <code>this.$router.push()/go()/back()</code></p><p><strong>传参</strong><br>配置接收方的路由地址  <code>/detail --&gt; /detail/:id</code><br>传参 <code>this.$router.push(&#39;/detail/10&#39;)</code><br>接收参数 <code>this.$route.params.id</code></p><p><strong>守卫：</strong><br>全局守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    next()<span class="comment">//放行</span></span><br><span class="line">    next(<span class="literal">false</span>)<span class="comment">//禁止访问</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路由独享守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:<span class="string">''</span>,</span><br><span class="line">    component:**,</span><br><span class="line">    beforeEnter:<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑥vuex<br>中大型Vue项目 组件间通讯会变得非常复杂，简化通讯任务，使用vuex<br>Vuex借助于状态来集中式管理数据，读写操作都要经过vuex<br>准备工作:</p><blockquote><p>npm i vuex<br>import Vuex from ‘vuex’<br>Vue.use(Vuex)//this.$store</p></blockquote><p>核心概念：<br><strong>state:</strong> state是负责来初始化数据的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">state:&#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    list:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>getters:</strong> getters是负责在state原始数据基础之上，派生新的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">    getOddList(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>mutations:</strong> mutations是负责来定义修改数据的方法，认为类似事件绑定 this.$store.commit(‘getList’,12)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">    modifyList(state)&#123;</span><br><span class="line">        <span class="keyword">var</span> num  = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">100</span>)</span><br><span class="line">        state.list.push(num)</span><br><span class="line">    &#125;,</span><br><span class="line">    getList(state,list)&#123;</span><br><span class="line">        state.list = list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>actions:</strong> 需要异步的来修改数据，异步操作写在action，数据操作还要靠触发mutation来实现 this.$store.dispatch(“myInit”)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">    myInit(context)&#123;</span><br><span class="line">        <span class="comment">//异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> myList = [<span class="string">"商品1"</span>,<span class="string">"商品2"</span>,<span class="string">"商品3"</span>]</span><br><span class="line">            <span class="comment">//保存在state:应该通过触发mutation来实现</span></span><br><span class="line">            context.commit(<span class="string">"getList"</span>,myList)</span><br><span class="line">        &#125;,<span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>modules:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    state: &#123; ... &#125;,</span><br><span class="line">    mutations: &#123; ... &#125;,</span><br><span class="line">    actions: &#123; ... &#125;,</span><br><span class="line">    getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">    state: &#123; ... &#125;,</span><br><span class="line">    mutations: &#123; ... &#125;,</span><br><span class="line">    actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        a: moduleA,</span><br><span class="line">        b: moduleB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SPA应用：&quot;&gt;&lt;a href=&quot;#SPA应用：&quot; class=&quot;headerlink&quot; title=&quot;SPA应用：&quot;&gt;&lt;/a&gt;SPA应用：&lt;/h3&gt;&lt;p&gt;SPA: Single Page Application 单页面应用&lt;br&gt;意思就是整个应用程序只有一个完整的HTML文件。所谓的”页面”，其实只是不同组件片段而已。在浏览器时，按需加载组件片段内容，替换HTML文件中指定位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/tags/Vue/"/>
    
      <category term="note" scheme="https://jambo0624.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 学习笔记(四)</title>
    <link href="https://jambo0624.github.io/2018-09-15-vue-note-4.html"/>
    <id>https://jambo0624.github.io/2018-09-15-vue-note-4.html</id>
    <published>2018-09-15T05:10:33.000Z</published>
    <updated>2020-09-22T05:34:54.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="axios"><a href="#axios" class="headerlink" title="axios:"></a>axios:</h3><p>什么是: 一个基于Promise的支持HTTP请求响应的函数库<br>为什么: 浏览器中向服务端发送 ajax 请求<br>4种发送 ajax 请求方法: </p><ul><li>使用原生的xhr对象 —— 繁琐</li><li>使用jQuery中的$.ajax() —— 大材小用</li><li>旧版Vue中，Vue官方自带了Vue-resource组件，专门发送xhr请求。 —— 新版本中已经不推荐使用</li><li>axios，官方推荐的代替Vue-resource的，专门发送ajax请求的函数库<a id="more"></a>何时：只要在Vue中发送ajax请求，都用 axios<br>如何: axios是一个单独的js文件，与平台无关。即可用在浏览器中，也可运行在node.js中<br>在浏览器中： <ol><li>下载并引入axios.min.js文件，辅助下载并引入qs.min.js。</li><li>调用axios函数，发起异步请求</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get: </span></span><br><span class="line"><span class="keyword">var</span> res= axios.get(<span class="string">"url"</span>,&#123;</span><br><span class="line">   params:&#123;</span><br><span class="line">     请求参数<span class="number">1</span>:值,</span><br><span class="line">         ... : ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//res不是直接的响应结果</span></span><br><span class="line">  <span class="comment">//res.data才是！</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// await和then选其一即可。</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// post:</span></span><br><span class="line"><span class="comment">// 先引入qs.min.js</span></span><br><span class="line"><span class="keyword">var</span> res = <span class="keyword">await</span> axios.post(<span class="string">"url"</span>,Qs.stringify(&#123;</span><br><span class="line">  <span class="string">'请求参数1'</span>:<span class="string">'值'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// await和then选其一</span></span><br></pre></td></tr></table></figure><h3 id="axios的使用"><a href="#axios的使用" class="headerlink" title="axios的使用:"></a>axios的使用:</h3><p>1.在<code>main.js</code>中引入<code>axios</code>模块，并将<code>axios</code>添加到Vue类型的原型对象中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6引入    </span></span><br><span class="line"><span class="comment">// import axios from 'axios' </span></span><br><span class="line"><span class="comment">// 相当于const axios=require("axios")</span></span><br><span class="line">  Vue.prototype.axios=axios;</span><br></pre></td></tr></table></figure><p>2.坑: <code>axios</code>请求默认不带cookie！导致无法使用服务器端 session。<br>   解决: 配置<code>axios</code>，让其携带 cookie :<br>   <code>axios.defaults.withCredentials=true</code><br>3.坑: 如果服务端采用 CORS 跨域，默认无法接受验证信息的<br>  服务端: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装cors模块：npm i -save cors</span></span><br><span class="line"><span class="comment">// express主模块app.js中，配置cors中间件，允许接受身份认证信息：</span></span><br><span class="line">   app.use(cors(&#123;</span><br><span class="line">     origin:<span class="string">'http://localhost:8080'</span>,</span><br><span class="line">     credentials:<span class="literal">true</span></span><br><span class="line">   &#125;))</span><br></pre></td></tr></table></figure><p>4.调用axios发送请求:<br>在任意.vue中: <code>this.axios.get/post( ... )</code></p><h3 id="路由组件-Vue-router"><a href="#路由组件-Vue-router" class="headerlink" title="路由组件: Vue-router"></a>路由组件: Vue-router</h3><p>Vue-router: 是vue中专门实现单页面应用的组件<br>何时: 只要用vue实现单页面应用时，都用vue-router<br>如何: Vue核心功能中不包含Vue-router，需要下载后才能使用<br>1.下载并引入vue-router.js<br>    <code>&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</code><br>    <code>&lt;script src=&quot;js/vue-router.js&quot;&gt;&lt;/script&gt;</code><br>2.将页面区域都定义在template中<br>3.<code>&lt;div id=&quot;#app&quot;&gt;</code>中添加占位元素<code>&lt;router-view&gt;&lt;/router-view&gt;</code><br>    <code>&lt;router-view&gt;&lt;/router-view&gt;</code>表示将来要被替换的区域<br>4.所有template，都要创建对应的组件对象<br>    共用的template，创建全局组件<br>    替换router-view的组件，创建局部子组件<br>5.建立路由字典: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> routes=[</span><br><span class="line">  &#123;<span class="attr">path</span>:<span class="string">"/"</span>,<span class="attr">component</span>: 默认组件&#125;,</span><br><span class="line">  &#123;<span class="attr">path</span>:<span class="string">"/路径名"</span>, <span class="attr">component</span>: 组件对象&#125;,</span><br><span class="line">  &#123;<span class="attr">path</span>:<span class="string">"/*"</span>,<span class="attr">component</span>: NotFound&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>仅是保存对应关系的数组，即不会解析地址，也不会替换router-view<br>6.创建路由器对象，加载路由字典:<br>    <code>var router=new VueRouter({ routes })</code><br>7.创建vue示例，并载入路由器对象<br>    <code>new Vue({ ... router ...})</code></p><p>8.如何路由跳转: </p><ul><li>在HTML中写死:<br>  <code>&lt;router-link to=&quot;/相对路径&quot;&gt;文本</code><br>  原理: router-link用法和a几乎安全一样，因为router-link运行时会被自动翻译为a</li><li>在Vue中用程序:<br>  <code>this.$router.push(&quot;/相对路径&quot;)</code></li></ul><p>9.如何路由传参: </p><ul><li>在接收参数的组件中: <code>props:[ &quot;参数变量&quot; ]</code></li><li>配置路由地址： <code>{path:&quot;/相对路径/:变量名&quot;,component: 组件对象,props:true}</code></li><li>跳转时: 地址: /相对路径/参数值  <strong>强调: 不加:</strong></li><li>获得当前路由地址对象: this.$route</li></ul><p><strong><code>this.$router</code> vs <code>this.$route</code></strong></p><ul><li>$router代表路由器，专门执行跳转任务</li><li>$route 封装当前路径信息的对象</li><li>this.$route.path 当前所在路径</li></ul><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由:"></a>嵌套路由:</h3><p>如果一个router-view内的部分内容，也需要根据二级路径的不同，动态替换时，就用嵌套路由:<br>如何: </p><ol><li>定义子组件模板，封装子组件对象</li><li>在父组件中添加<code>&lt;router-view&gt;</code></li><li>在路由字典中: <pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>   path<span class="token punctuation">:</span> 上级路径<span class="token punctuation">,</span>  component<span class="token punctuation">:</span> 父组件对象<span class="token punctuation">,</span>  children<span class="token punctuation">:</span><span class="token punctuation">[</span>     <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> 上级路径<span class="token operator">+</span>二级路径<span class="token punctuation">,</span>      component<span class="token punctuation">:</span>子组件对象     <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>跳转: <code>/上级路径/二级路径</code><br>其中: <code>/上级路径</code>决定根组件中<code>router-view</code>的内容 <code>/二级路径</code>决定父组件中<code>router-view</code>的内容</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;axios&quot;&gt;&lt;a href=&quot;#axios&quot; class=&quot;headerlink&quot; title=&quot;axios:&quot;&gt;&lt;/a&gt;axios:&lt;/h3&gt;&lt;p&gt;什么是: 一个基于Promise的支持HTTP请求响应的函数库&lt;br&gt;为什么: 浏览器中向服务端发送 ajax 请求&lt;br&gt;4种发送 ajax 请求方法: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用原生的xhr对象 —— 繁琐&lt;/li&gt;
&lt;li&gt;使用jQuery中的$.ajax() —— 大材小用&lt;/li&gt;
&lt;li&gt;旧版Vue中，Vue官方自带了Vue-resource组件，专门发送xhr请求。 —— 新版本中已经不推荐使用&lt;/li&gt;
&lt;li&gt;axios，官方推荐的代替Vue-resource的，专门发送ajax请求的函数库
    
    </summary>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/tags/Vue/"/>
    
      <category term="note" scheme="https://jambo0624.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 学习笔记(三)</title>
    <link href="https://jambo0624.github.io/2018-09-01-vue-note-3.html"/>
    <id>https://jambo0624.github.io/2018-09-01-vue-note-3.html</id>
    <published>2018-09-01T11:40:27.000Z</published>
    <updated>2020-09-22T04:12:52.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发:"></a>组件化开发:</h3><p>组件化开发，就是将大的网页划分为若干组件区域，每个组件区域都有专门的HTML，CSS和数据。<br>自定义组件，分为3种: </p><ol><li>根组件: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">"父元素选择器"</span>,</span><br><span class="line">  data:&#123; 模型变量 &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a></li><li>全局组件：可用在页面任何位置的组件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"组件名"</span>, &#123;</span><br><span class="line">  template:<span class="string">"template元素的选择器"</span>,</span><br><span class="line">  data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; 模型变量 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>子组件: 只能用于特定的父组件内<br>何时: 只要规定一个组件只能出现在指定的父组件内<br>如何: </li></ol><ul><li>将全局组件降级:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 子组件对象=&#123;</span><br><span class="line">template:<span class="string">"template元素的选择器"</span>,</span><br><span class="line">  data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; 模型变量 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在父组件中，添加components属性，包含子组件对象，并为子组件起名！<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 父组件=&#123;</span><br><span class="line"> components:&#123;</span><br><span class="line">   <span class="string">"子组件名"</span>:子组件对象</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信:"></a>组件间通信:</h3><p><strong>父-&gt;子: 属性下行:</strong><br>子组件: 定义props属性，其中包含接收父组件数据的模型变量<br>props属性：可被外部访问，并赋值的特殊模型数据</p><ul><li>在组件内的用法和data中的模型变量完全一样！</li><li>可被其他组件发现并赋值。<br>父组件的template中: </li><li><code>&lt;子组件 :子组件props属性变量=&quot;父组件模型变量&quot;&gt;</code></li><li>结果: 父组件将自己的模型变量赋值给子组件内的props属性变量。</li></ul><p><strong>子-&gt;父: 事件上行</strong></p><ol><li>父组件中:<br><code>&lt;子组件  @自定义事件名=&quot;处理函数&quot; &gt;</code> </li></ol><p><strong>强调: @自定义事件名=”处理函数”，在定义处理函数时不要加(参数)。因为参数会被认为是绑定模型变量，会报错。</strong><br>2. 子组件任意位置，都可触发父组件中绑定的自定义事件<br>   this.$emit(“自定义事件名”,参数值)<br>   会触发父组件template中，提前绑定的@自定义事件，并将参数传递给父组件中的处理函数</p><p><strong>兄弟间: 采用先给父，再由父绑定到另一个子</strong><br>    强烈建议，今后，只要多个子组件共用一个数据时，都应将数据定义在父组件上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;组件化开发&quot;&gt;&lt;a href=&quot;#组件化开发&quot; class=&quot;headerlink&quot; title=&quot;组件化开发:&quot;&gt;&lt;/a&gt;组件化开发:&lt;/h3&gt;&lt;p&gt;组件化开发，就是将大的网页划分为若干组件区域，每个组件区域都有专门的HTML，CSS和数据。&lt;br&gt;自定义组件，分为3种: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根组件: &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vue(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  el:&lt;span class=&quot;string&quot;&gt;&quot;父元素选择器&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  data:&amp;#123; 模型变量 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/tags/Vue/"/>
    
      <category term="note" scheme="https://jambo0624.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 学习笔记(二)</title>
    <link href="https://jambo0624.github.io/2018-08-19-vue-note-2.html"/>
    <id>https://jambo0624.github.io/2018-08-19-vue-note-2.html</id>
    <published>2018-08-19T05:40:27.000Z</published>
    <updated>2020-09-24T09:10:07.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤器-filter"><a href="#过滤器-filter" class="headerlink" title="过滤器(filter)"></a>过滤器(filter)</h3><ul><li><p>什么是: 接收原始数据后，执行再加工，才显示</p></li><li><p>何时: 原始数据不能直接使用时，都要用过滤器</p></li><li><p>比如: </p><ul><li>性别(1,0-&gt;男，女)  </li><li>钱(345.5-&gt; ¥345.50)</li><li>时间(ms-&gt;字符串格式)</li><li>状态(10,20,30,40-&gt;未付款，已付款，已发货，已签收)    <a id="more"></a></li></ul></li><li><p>如何: Vue官方没有提供任何预定义的过滤器，都要自己定义</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">"过滤器名"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value,形参<span class="number">1</span>,形参<span class="number">2</span>,...</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//value接收的是原始值</span></span><br><span class="line">  <span class="keyword">return</span> 加工后的新值！</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  只要绑定数据，都可用过滤器：</p><pre class="line-numbers language-html"><span class="tag">&lt;<span class="name">ANY</span> 模型变量|过滤器名|<span class="attr"><code class="language-html"><span class="tag">&lt;<span class="name">ANY</span> 模型变量|过滤器名|<span class="attr">......</span>></span><span class="tag"><<span class="name">ANY</span> 模型变量|过滤器名(值<span class="attr">1</span>,值<span class="attr">2</span>)|<span class="attr">......</span>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>强调: </p><ul><li><strong>1.后一个过滤器获得的原始值，是前一个过滤器加工后的</strong></li><li><strong>2.v-text不能使用过滤器</strong> </li></ul></li></ul><h3 id="Vue实例-组件的生命周期："><a href="#Vue实例-组件的生命周期：" class="headerlink" title="Vue实例/组件的生命周期："></a>Vue实例/组件的生命周期：</h3><p><strong>笔试题目: Vue实例/组件的声明周期共几个阶段，每个阶段做什么:</strong> </p><ul><li><p>4个阶段: </p><ul><li>1.创建（create）阶段：创建组件对象，和模型数据对象</li><li>2.挂载（mount）阶段：扫描真实 DOM 树，创建虚拟 DOM 树，并绑定模型中的数据到视图中</li><li>3.更新（update）阶段：只要模型数据发生变化，就更新组件的内容和 DOM 树</li><li>4.销毁（destroy）阶段：主动调用了<code>$destory()</code>函数，销毁组件时</li></ul></li><li><p>声明周期钩子函数：</p><ul><li>什么是在组件的每个阶段都会自动执行的函数</li><li>何时: 如果希望在组件的不同阶段执行一项任务时</li></ul></li></ul><p>包括: </p><blockquote><p>beforeCreate()   <code>$el:undefined   data:undefined</code><br>created()        <code>$el: undefined   data: { ... }</code><br>beforeMount()    <code>$el: 空DOM对象 data: { ... }</code><br>mounted()        <code>$el: 完整DOM树  data: { ... }</code><br>beforeUpdate()<br>updated()<br>beforeDestroy()<br>destroyed()</p></blockquote><p><strong>请求数据<code>axios.get()</code>可放在created或mounted中均可</strong><br><strong>但是，如果有DOM操作，就必须放在mounted中</strong></p><h3 id="组件Component"><a href="#组件Component" class="headerlink" title="组件Component:"></a>组件Component:</h3><ul><li>什么是: 拥有专属的HTML，CSS和数据的，可重用的页面独立区域</li><li>为什么: 重用！分工协作！松藕合！</li><li>何时: 只要发现独立的区域，都要封装为组件。</li><li>如何: </li></ul><p>1.创建组件:</p><pre class="line-numbers language-js"><span class="comment"><code class="language-js"><span class="comment">//</span>Vue.component(<span class="string">"组件名"</span>,{   <span class="comment">// 代替了new Vue中的el:  </span>  template: <span class="string">"选择器"</span>,   <span class="comment">// 代替new Vue中的data:{ 模型变量 } </span>  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{         <span class="comment">// 每次都要调用函数，为本次组件创建专属的数据模型</span>    <span class="keyword">return</span> {      <span class="comment">// 创建新对象的意思</span>      <span class="string">'模型变量'</span>: <span class="string">'值'</span>,         <span class="string">'...'</span> : <span class="string">'...'</span>    }  },  <span class="comment">// 其余都一样！</span>})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>组件专属的HTML放在 <code>&lt;template&gt;HTML片段&lt;/template&gt;</code></strong><br>template是专门保存一段隐藏HTML片段的元素</p><ul><li>何时: 专门用于为组件保存HTML片段</li><li>规定: template中只能且必须有唯一的一个父元素包裹组件的片段。</li><li>如何:<br>  1.定义<code>&lt;template&gt;</code>元素包裹组件的 HTML 片段，还需要添加一个唯一的父元素<br>  2.<code>Vue.component(&quot;....&quot;,{template:&quot;选择器&quot;})</code>，通过选择器找到对应的template元素</li></ul><ol start="2"><li>在视图中使用组件:<br> 一个组件其实就是一个可重用的自定义HTML标签<br> <code>&lt;组件名&gt;&lt;/组件名&gt;</code><br> 执行时，会用组件的template代替<code>&lt;组件名&gt;&lt;/组件名&gt;</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;过滤器-filter&quot;&gt;&lt;a href=&quot;#过滤器-filter&quot; class=&quot;headerlink&quot; title=&quot;过滤器(filter)&quot;&gt;&lt;/a&gt;过滤器(filter)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是: 接收原始数据后，执行再加工，才显示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;何时: 原始数据不能直接使用时，都要用过滤器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比如: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性别(1,0-&amp;gt;男，女)  &lt;/li&gt;
&lt;li&gt;钱(345.5-&amp;gt; ¥345.50)&lt;/li&gt;
&lt;li&gt;时间(ms-&amp;gt;字符串格式)&lt;/li&gt;
&lt;li&gt;状态(10,20,30,40-&amp;gt;未付款，已付款，已发货，已签收)
    
    </summary>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/tags/Vue/"/>
    
      <category term="note" scheme="https://jambo0624.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 学习笔记(一)</title>
    <link href="https://jambo0624.github.io/2018-08-12-vue-note-1.html"/>
    <id>https://jambo0624.github.io/2018-08-12-vue-note-1.html</id>
    <published>2018-08-12T02:19:27.000Z</published>
    <updated>2020-09-22T02:23:55.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原生API-vs-函数库-vs-框架"><a href="#原生API-vs-函数库-vs-框架" class="headerlink" title="原生API vs 函数库 vs 框架"></a>原生API vs 函数库 vs 框架</h3><p>  DOM jQuery Vue</p><ul><li>原生API：浏览器/平台已经实现的，咱们可直接使用的API 。比如: DOM   BOM<ul><li>优点: 万能; 缺点: 繁琐</li></ul></li><li>函数库(library)：基于原生API，进一步封装的，更简化的一组函数的集合。比如: jQuery<ul><li>优点: 每个API都极简化; 缺点: 没有改变做事的方式。比如: 依然需要增删改查和事件绑定</li></ul></li><li>框架(framework)：前人将多次成功的项目经验总结起来，形成的半成品项目。比如: Vue<ul><li>优点：无需重复劳动，后人只要继续开发新功能即可; 缺点：彻底改变了做事的方法！需要适应<a id="more"></a> </li></ul></li></ul><h3 id="Vue概述"><a href="#Vue概述" class="headerlink" title="Vue概述:"></a>Vue概述:</h3><ul><li>什么是Vue.js: <ul><li>一个渐进式的，基于MVVM设计模式的JavaScript框架。    </li><li>渐进式(progressive)：虽然提供了很多功能，但不强迫全部使用。可逐渐使用，逐渐扩大使用范围。</li></ul></li><li>何时: 适用于以数据操作为主的项目</li><li>如何: 官网: <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></li></ul><p>  <strong>特点：不支持IE8及以下版本</strong></p><h3 id="MVVM设计模式"><a href="#MVVM设计模式" class="headerlink" title="MVVM设计模式:"></a>MVVM设计模式:</h3><ul><li>传统网页组成: 3部分： <ul><li>HTML：定义网页的内容</li><li>CSS：定义网页样式</li><li>JS：添加交互行为</li><li>问题: JS肩负的任务太多太杂了，就产生了大量重复的劳动</li></ul></li><li>重新划分3部分: <ul><li>View视图: 包含网页内容(HTML)和样式(CSS)</li><li>Model 模型数据: 指程序中创建的或从服务器端获取的数据</li><li>ViewModel 视图模型/控制器: 代替之前的DOM/JQUERY操作，自动把模型中的数据，绑定到View中的指定位置。</li><li>其实就是new Vue()</li></ul></li></ul><p>引入Vue.js时，等于在全局引入了一种新类型<strong>Vue</strong><br>包含: </p><ul><li>1.构造函数: 创建该类型的子对象</li><li>2.原型对象：包含该类型子对象共用的成员</li></ul><p><code>new Vue()</code> 创建Vue类型的一个实例，其实是创建一个用于同步Model和View的ViewModel对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"选择器"</span>, <span class="comment">//告诉Vue监听哪个父元素的内容</span></span><br><span class="line">    data:&#123; <span class="comment">//作为Model，保存页面需要的所有数据</span></span><br><span class="line">      模型数据:值, 模型数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="new-Vue-：2件事-2大子系统"><a href="#new-Vue-：2件事-2大子系统" class="headerlink" title="new Vue()：2件事(2大子系统)"></a>new Vue()：2件事(2大子系统)</h3><p><strong>1. 响应系统：</strong><br>    new Vue()将 data 中的每个模型数据提升为整个 Vue 对象的访问器属性。<br>    在访问器属性的 set 方法中，只要修改模型数据的值，就触发通知。通知 Vue 框架修改页面。<br>    <strong>一句话就是</strong>，通过<strong>数据劫持 + 发布订阅模式</strong>。使用 <code>Object.defineProperty()</code> 方法来实现数据劫持<br><strong>2. 虚拟DOM树：</strong></p><ul><li><p>什么是: 用js程序模拟的一棵简化版的 DOM 子树</p></li><li><p>为什么：真实 DOM 树包含的内容太多！极其不便于比较和遍历。</p></li><li><p>如何生成虚拟DOM树: <code>new Vue({el:&quot;选择器&quot;})</code>会查找指定父元素，并遍历其中所有子内容。仅将可能发生变化的元素和属性用js对象结构集中存储在内存中。</p></li><li><p>何时使用虚拟DOM树:</p><ul><li>当修改模型数据，触发响应系统时，响应系统通知 Vue 要修改DOM树。</li><li>Vue 框架就遍历虚拟 DOM 树，找到发生变化的节点，利用底层的 DOM API 仅修改发生变化的 DOM 元素</li></ul></li><li><p>虚拟DOM树的优点: </p><ul><li>1.节点个数和属性个数都比真实 DOM 树少的多，极其便于遍历和比较</li><li>2.仅修改受影响的 DOM 元素，不变的元素不用修改。</li></ul></li></ul><h3 id="数据绑定语法"><a href="#数据绑定语法" class="headerlink" title="数据绑定语法:"></a>数据绑定语法:</h3><pre><code>{{}}：双括号语法，外号大胡子语法(Mustache)</code></pre><ul><li><p>什么是数据绑定: 选择特定的Model变量，绑定到View试图中指定位置。使视图中指定位置的值，随Model变量同步变化。</p></li><li><p>何时: 只要希望用Model中的一个变量，填补View中的一个动态显示位置时。</p></li><li><p>如何: <code>{{模型变量名}}</code></p></li><li><p>执行时，会用模型变量的当前值，代替{{}}位置</p></li><li>{{}}中可包含以下几种情况的内容: <ul><li>1.{{ 模型变量名 }}  比如: <code>{{ uname }}</code></li><li>2.{{ 运算 }} : 算术/比较/逻辑/三目运算  <code>{{ price * count}}</code></li><li>3.{{  方法调用}} 比如: <code>{{ uname.toUpperCase() }}</code></li><li>4.{{ 对象.属性 }}  比如: <code>{{ address.city }}</code></li><li>5.{{ 数组[i] }} </li><li><strong>注意！不能写if  else   for  等程序解构</strong></li></ul></li><li><p>问题: {{}} 只能绑定innerHTML，不能绑定属性和事件</p></li><li><p>解决: 指令</p></li></ul><h3 id="指令-directive"><a href="#指令-directive" class="headerlink" title="指令(directive)"></a>指令(directive)</h3><ul><li><p>什么是:Vue.js提供的，专门用于增强HTML功能的特殊属性</p></li><li><p>为什么: HTML本身是静态的，写死的，无法根据数据动态变化属性值。</p></li><li><p>何时: 只要希望动态绑定HTML属性时,都用指令</p><p>包括: 13个: </p></li></ul><p>   <strong>1. v-bind: 专门绑定属性值。</strong></p><ul><li>如何: <code>&lt;ANY v-bind:属性=&quot;模型变量&quot;&gt;</code></li><li>强调: 不用加{{}}</li><li>简写: v-bind可省略，只写”:属性=”</li></ul><p>   <strong>2. v-for: 根据数组或集合内容，反复生成多个相同的HTML元素</strong></p><ul><li><p>何时: 只要根据数组数据反复生成多个相同的HTML元素</p></li><li><p>如何:<code>&lt;ANY v-for=&quot;(元素值,下标) in 数组|对象|字符串&quot;&gt;</code></p></li><li><p>结果: </p><ul><li>根据in后的数组/集合中元素的个数，反复生成当前HTML元素。</li><li>每次in都会取出数组/集合中当前元素值和位置下标</li><li>如果 ANY下还有子元素，则子元素可用for获得元素值和下标继续绑定内容。</li></ul></li><li><p>强调: v-for必须放在要反复生成的HTML元素上，不能放在父元素上！</p></li><li><p>简写: </p><ul><li>1.如果不关心下标，只关心内容: v-for=”变量 in 数组”</li><li>2.in可换为of，</li></ul></li></ul><p>   <strong>3. v-if: 根据一个 Boolean 类型的模型变量值作为条件，控制是否生成该元素到 DOM 树(控制一个元素的显示和隐藏)</strong></p><ul><li>何时: 根据条件，控制一个元素的显示和隐藏</li><li>如何: <code>&lt;ANY v-if=&quot;true&quot; &gt;</code> </li><li>依次判断每个条件，只要条件为true，就生成该元素，其余元素不生成(隐藏)</li><li><strong>强调: v-if，v-else-if，v-else之间必须紧邻，不能插入其它元素。</strong></li></ul><p>   <strong>4. v-show: 用法和v-if几乎完全一样！也可以控制一个元素的显示隐藏。</strong></p><ul><li>如何: <code>&lt;ANY v-show=&quot;bool类型的模型变量&quot;&gt;</code></li></ul><p><strong>笔试题目: v-show vs v-if的区别:</strong>  </p><ul><li>v-show，不改变DOM树，通过display:none/block控制显示隐藏<ul><li>优: 效率高！</li><li>缺: 只适合控制一个元素的显示隐藏。如果控制多个元素的显示隐藏时，代码会很繁琐</li></ul></li><li>v-if，通过添加/删除DOM树上元素节点的方式控制显示隐藏<ul><li>缺: 效率低！</li><li>优: 专门控制多个元素选其一显示，代码精简。</li></ul></li><li>如果一个元素频繁显示隐藏切换，首选v-show</li><li>如果多个元素控制选其一显示，首选v-if, v-else-if, v-else</li></ul><p>   <strong>5. v-on:专门为元素绑定事件处理函数</strong></p><ul><li><p>1.在new Vue()实例对象内添加事件处理函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el:<span class="string">"选择器"</span></span><br><span class="line">   data: &#123; 模型变量:值, ... ... &#125;</span><br><span class="line">   methods:&#123;</span><br><span class="line">     处理函数(参数列表)&#123;</span><br><span class="line">       <span class="comment">//访问当前Vue内自己的模型变量: this.变量名</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>2.在HTML元素上绑定事件处理函数: <code>&lt;ANY v-on:事件名=&quot;处理函数()&quot;&gt;</code><br>获得事件对象e: <code>&lt;ANY v-on:事件名=&quot;处理函数($event)&quot;&gt;</code> <strong>$event是Vue内置的事件对象，不能随便改名</strong><br>简写:  v-on: 被@替代: <code>&lt;ANY @事件名=&quot;处理函数()&quot;&gt;</code></p></li><li><p>事件修饰符: 对常用事件操作的简写！<br>  1.取消冒泡: e.stopPropagation()  <code>&lt;ANY @事件名.stop=&quot;处理函数()&quot;&gt;</code><br>  2.阻止默认行为: e.preventDefault(); <code>&lt;ANY @事件名.prevent=&quot;处理函数()&quot;&gt;</code><br>  3.键盘事件: <code>&lt;ANY @事件名.按键号=&quot;处理函数()&quot;&gt;</code></p></li></ul><p>   <strong>6. v-html和v-text</strong><br>   v-html 使用模型变量替换当前元素的innerHTML<br>       何时: 如果绑定一段HTML代码片段<br>   v-text  使用模型变量替换当前元素的textContent<br>       何时: 如果绑定纯文本内容<br>   <strong>笔试题目：{{}}  vs  v-text   vs  v-html</strong></p><ul><li>是否编译内容:<br>v-html，专门用于绑定HTML片段，绑定的内容会被浏览器解析为正文。{{}}和v-text，专门用于绑定不需要解析的纯文本内容，保持内容的原样不变。</li><li>屏蔽{{}}<br>问题: 当请求响应慢时，用户可能短暂看到{{}}语法。<br>解决: 用v-text和v-html代替{{}}。但是v-text和v-html在请求响应慢时，暂时显示为空白</li></ul><p>   <strong>7. v-cloak:</strong> </p><ul><li>什么是: 在vue实例加载完之前，暂时隐藏需要绑定的元素。</li><li>为什么: 避免在vue实例加载完之前，用户短暂看到{{}}</li><li>何时: 只要希望在vue实例加载前，不然该用户看到{{}}</li><li>如何: <ul><li>1.自定义v-cloak属性选择器，定义display:none</li><li>2.在要绑定的元素上，添加v-cloak</li><li>原理: new Vue()实例加载完成后，会自动找到v-cloak属性，并移除。</li></ul></li></ul><p>   <strong>8. v-pre: 保护内容中的{{}}不被编译，保持原样</strong><br>   何时: 正文中刚好也有{{}}时，不想被Vue识别</p><p>   <strong>9. v-once: 让当前元素只在首次加载时，绑定一次。之后，即使模型数据发生变化，页面也不改变。</strong><br>   原理: 标有v-once的元素在首次加载后，就从监视队列中移除了。不再受监视。</p><p>   <strong>10. 双向绑定：</strong><br>   单向绑定: 仅能将内存中模型数据的修改更新到视图中(M-&gt;V)<br>   双向绑定：即能将内存中模型数据的修改更新到视图中(M-&gt;V)，又能将视图中的更改，反向更新回内存中的模型数据（V-&gt;M）<br>   何时: 只要页面上内容修改，也想反向更新回内存中的模型数据时——专门用于绑定表单元素<br>   如何: <code>&lt;表单元素  v-model:value=&quot;模型数据&quot;&gt;</code><br>   简写: 可省略:value，<code>&lt;表单元素 v-model=&quot;模型数据&quot;&gt;</code></p><p>   自定义监听函数: 监听函数就是当模型数据发生变化时自动执行的函数<br>   何时: 只要希望模型数据一发生变化就立刻执行一项任务——搜索帮助/表单验证<br>   如何: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">''</span>,</span><br><span class="line">  data:<span class="string">''</span>,</span><br><span class="line">  methods:<span class="string">''</span>,</span><br><span class="line">  watch:&#123;</span><br><span class="line">    模型变量名()&#123; ... &#125; <span class="comment">//只要同名模型变量发生变化就立刻执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>   各种表单元素的绑定方式: </p><ol><li>文本框/文本域: <code>v-model=&quot;模型变量&quot;</code></li><li>单选按钮:<br><code>&lt;input type=&quot;radio&quot; name=&quot;组名&quot; value=&quot;值1&quot; v-model=&quot;变量&quot;&gt;</code><br><code>&lt;input type=&quot;radio&quot; name=&quot;组名&quot; value=&quot;值2&quot; v-model=&quot;变量&quot;&gt;</code><br>其实v-model绑定的是checked属性 <code>checked= (变量==value)</code><br>复选框: v-model绑定的也是checked属性<br>选择框: v-model 绑定selected= (变量==option的value)</li></ol><h3 id="绑定class和style属性"><a href="#绑定class和style属性" class="headerlink" title="绑定class和style属性"></a>绑定class和style属性</h3><p><strong>class 2种方式:</strong></p><ul><li>1.用字符串方式绑定class和style</li><li>2.用对象方式绑定：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ANY</span> <span class="attr">class</span>=<span class="string">"固定不变的class"</span> <span class="attr">:class</span>=<span class="string">" xxxClassObj "</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    xxxClassObj:&#123;</span><br><span class="line">      fade: <span class="string">'true/false'</span>,</span><br><span class="line">      <span class="keyword">in</span>: <span class="string">'true/false'</span>, </span><br><span class="line">      active: <span class="string">'true/false'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>结果: </p><ul><li>动态class中的类会和class中的类合并</li><li>动态class中只有值为true的类名才能出现在class中<br>总结: </li><li>1.在多个元素之间切换一个class，首选用字符串方式</li><li>2.控制一个元素的class，有与没有切换，首选用对象方式</li></ul><p><strong>style 2种方式:</strong> </p><ul><li>1.作为字符串属性绑定: </li><li>2.用对象方式:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ANY</span> <span class="attr">:style</span>=<span class="string">"styleObj"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> data:&#123;</span><br><span class="line">   styleObj:&#123;</span><br><span class="line">     <span class="string">'css属性'</span>: <span class="string">'属性值'</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>建议: 今后所有style都采用对象语法绑定。</p><h3 id="计算属性："><a href="#计算属性：" class="headerlink" title="计算属性："></a>计算属性：</h3><p>   什么是: 不实际存储属性值，而是根据其他属性的值动态计算获得。<br>   为什么: 不是所有值都可直接获得。<br>   何时: 只要一个值不能直接获得，需要根据其它值计算获得时<br>   如何:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">''</span>,</span><br><span class="line">   data:<span class="string">''</span>,</span><br><span class="line">   methods:&#123;&#125;,</span><br><span class="line">   watch: &#123;&#125;,</span><br><span class="line">   computed:&#123;</span><br><span class="line">     属性名()&#123; <span class="keyword">return</span> 计算后的值 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>   绑定：和普通属性的绑定完全一样！{{属性名}} <strong>强调: 不要加()</strong>    </p><p>   <strong>计算属性 vs 函数</strong><br>   计算属性的值可被Vue<strong>缓存</strong>并重复使用，只要计算属性依赖的其它属性不改变，就不用重复计算！<br>   函数只要调用，就重新计算！</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>   如何自定义: </p><ol><li>创建自定义指令: <pre class="line-numbers language-js">Vue.directive(<span class="string">"指令名"</span>,{  <span class="comment"><code class="language-js">Vue.directive(<span class="string">"指令名"</span>,{  <span class="comment">//创建一个自定义指令</span>inserted(elem){ <span class="comment">//当当前元素被挂载到DOM树后自动执行</span> <span class="comment">//elem 当前所在元素的DOM对象</span> <span class="comment">//elem可调用一切DOM的API</span>}})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>   <strong>强调: 定义指令时，指令名不要加v-前缀！</strong><br>   2. 使用自定义指令: &lt;any v-指令名&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原生API-vs-函数库-vs-框架&quot;&gt;&lt;a href=&quot;#原生API-vs-函数库-vs-框架&quot; class=&quot;headerlink&quot; title=&quot;原生API vs 函数库 vs 框架&quot;&gt;&lt;/a&gt;原生API vs 函数库 vs 框架&lt;/h3&gt;&lt;p&gt;  DOM jQuery Vue&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原生API：浏览器/平台已经实现的，咱们可直接使用的API 。比如: DOM   BOM&lt;ul&gt;
&lt;li&gt;优点: 万能; 缺点: 繁琐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数库(library)：基于原生API，进一步封装的，更简化的一组函数的集合。比如: jQuery&lt;ul&gt;
&lt;li&gt;优点: 每个API都极简化; 缺点: 没有改变做事的方式。比如: 依然需要增删改查和事件绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;框架(framework)：前人将多次成功的项目经验总结起来，形成的半成品项目。比如: Vue&lt;ul&gt;
&lt;li&gt;优点：无需重复劳动，后人只要继续开发新功能即可; 缺点：彻底改变了做事的方法！需要适应
    
    </summary>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/tags/Vue/"/>
    
      <category term="note" scheme="https://jambo0624.github.io/tags/note/"/>
    
  </entry>
  
</feed>
