<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You should know</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jambo0624.github.io/"/>
  <updated>2020-07-26T12:45:06.759Z</updated>
  <id>https://jambo0624.github.io/</id>
  
  <author>
    <name>Jambo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>how-program-works</title>
    <link href="https://jambo0624.github.io/2020-07-26-how-program-works.html"/>
    <id>https://jambo0624.github.io/2020-07-26-how-program-works.html</id>
    <published>2020-07-26T07:47:59.000Z</published>
    <updated>2020-07-26T12:45:06.759Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是《程序是怎么跑起来的》读书笔记。<br>在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。<br>下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: </p><a id="more"></a><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>程序是由指令和数据构成的。<br>CPU所负责的就是解释和运行最终转换成机器语言的程序内容。<br>从功能方面来看， CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。<br><strong>寄存器</strong> 可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。<br><strong>控制器</strong> 负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。<br><strong>运算器</strong> 负责运算从内存读入寄存器的数据。<br><strong>时钟</strong> 负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。</p><p>汇编语言 (assembly) 采用助记符 (memonic) 来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符，助记符通常为指令功能的英语单词的简写。<br>通常我们将汇编语言编写的程序转化成机器语言的过程称为 <strong>汇编</strong> ；反之，机器语言程序转化成汇编语言程序的过程则称为 <strong>反汇编</strong> 。  </p><p>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器 (基址，变址，通用) 一般有多个。<br>CPU每执行一个指令，程序计数器的值就会自动加1。也就是说，<strong>程序计数器</strong> 决定着程序的流程。<br><strong>标志寄存器</strong> 实现了对程序的流程控制。<br>函数调用处理是通过把程序计数器的值设定成函数的<strong>存储地址</strong>来实现的。<br>函数调用使用的是call指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call指令会把 <strong>调用函数后要执行的指令地址</strong> 存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行<code>return</code>命令。<code>return</code>命令的功能是把保存在栈中的地址设定到程序计数器中。  </p><p>第一张结束了，通过第一章。我们要知道几个基本的知识:</p><ol><li>程序就是数据和指令</li><li><code>高级编程语言</code>-&gt;<code>汇编语言</code>-&gt;<code>机器语言</code></li></ol><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>因为 IC 的所有引脚，只有直流电压 0V 或 5V 两个状态。所以，决定了计算机的信息数据只能用二进制数来处理。<br>计算机处理信息的最小单位——位，就相当于二进制中的一位。位的英文 <code>bit</code> 是二进制数位<code>(binary digit)</code>的缩写。<br>8位二进制数被称为一个 <strong>字节</strong> 。字节是最基本的信息计量单位。位是最小单位，字节是基本单位。   </p><p>二进制数的值转换成十进制数的值，只需将二进制数的各数位的值和 <strong>位权</strong> 相乘，然后将相乘的结果相加即可。<br><strong>移位运算</strong> 指的是将二进制数值的各数位进行左右移位 (shift=移位) 的运算。移位有左移 &lt;&lt; (向高位方向) 和右移 &gt;&gt; (向低位方向) 两种。      </p><p>为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加1。<strong>将二进制数的值取反后加1的结果，和原来的值相加，结果为 0</strong><br>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为<strong>逻辑右移</strong>。<br>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值 (0或1) 。这就称为<strong>算术右移</strong>。如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2、1/4、1/8等的数值运算。如果是正数，只需在最高位补0即可。<br>只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式 (逻辑左移) 还是相乘运算 (算术左移) ，都只需在空出来的低位补 0 即可。   </p><p><strong>符号扩充</strong>就是指在保持值不变的前提下将其转换成16位和32位的二进制数。也就是说，不管是正数还是用补数表示的负数，都只需用符号位的值 (0或者1) 填充高位即可。     </p><p>计算机能处理的运算，大体可分为<strong>算术运算</strong>和<strong>逻辑运算</strong>。算术运算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算，包括逻辑非（NOT运算）、逻辑与（AND运算）、逻辑或（OR运算）和逻辑异或（XOR运算）四种。  </p><h3 id="计算机中进行小数计算时出错的原因"><a href="#计算机中进行小数计算时出错的原因" class="headerlink" title="计算机中进行小数计算时出错的原因"></a>计算机中进行小数计算时出错的原因</h3><p>经典面试题目: 0.1 + 0.2 = ?<br>是因为 <strong>“有一些十进制数的小数无法转换成二进制数”</strong>    </p><p><strong>双精度浮点数</strong> 类型用64位、<strong>单精度浮点数</strong> 类型用32位来表示全体小数<br><strong>浮点数</strong> 是指用符号、尾数、基数和指数这四部分来表示的小数<br>64: 1位符号，11位指数，52位尾数<br>32: 1位符号，8位指数，23位尾数</p><p>如何避免计算机计算出错  </p><blockquote><p>首先是回避策略，即无视这些错误。根据程序目的的不同，有时一些微小的偏差并不会造成什么问题。<br>把小数转换成整数来计算。计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题。</p></blockquote><p>在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD方法，以确保最终得到准确的数值。BCD (Binary Coded Decimal) 是一种使用二进制表示十进制的方法。  </p><p>在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。因此，在实际程序中，也经常会用十六进制数来代替二进制数。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><strong>内存</strong> 实际上是一种名为内存IC的电子元件。内存IC中有<code>电源</code>、<code>地址信号</code>、<code>数据信号</code>、<code>控制信号</code>等用于输入输出的大量引脚（IC的引脚），通过为其指定地址（address），来进行数据的读写。  </p><p>编程语言中的<strong>数据类型</strong>表示存储的是何种类型的数据。<br>从内存来看，就是占用的内存大小的意思。<br>即使是物理上以1个字节为单位来逐一读写数据的内存，在程序中，通过指定其类型（变量的数据类型等），也能实现以特定字节数为单位来进行读写。      </p><p><strong>指针</strong>也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写。   </p><p>数组是高效实用内存的基础。<br><strong>数组</strong>是指多个同样数据类型的数据在内存中连续排列的形式。<br>作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引<code>(index)</code>。<br>指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由<strong>编译器</strong>自动实现的。<br>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。  </p><p><strong>栈</strong>用的是<code>LIFO</code>（Last Input First Out，后入先出）方式，而队列用的则是<code>FIFO</code>（First Input First Out，先入先出）方式。<br><strong>队列</strong>一般是以<code>环状缓冲区</code>（ring buffer）的方式来实现的  </p><p>在数组的各个元素中，除了数据的值之外，通过为其附带上下一个元素的索引，即可实现<strong>链表</strong>。使用<strong>链表</strong>来追加或删除数据则毫不费事。   </p><h3 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h3><blockquote><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。即使CPU可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低。总之，存储在磁盘中的程序需要读入到内存后才能运行。</p></blockquote><p>磁盘缓存 (disk cache) 指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。使用磁盘缓存可以大大改善磁盘数据的访问速度<br>虚拟内存 (virtual memory) 是指把磁盘的一部分作为假想的内存来使用。<br>虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的。也就是说，为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。    </p><p>节约内存的编程方法<br>(1) 通过DLL文件实现函数共有<br>DLL（Dynamic Link Library）文件，顾名思义，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。此外，还有一个需要大家注意的地方，那就是多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。<br>Windows的操作系统本身也是多个DLL文件的集合体。有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。<br>(2) 通过调用_stdcall来减小程序文件的大小<br><strong>栈清理处理</strong>是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。<br>该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。<br>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。这时所使用的就是_stdcall。<br>在函数前加上_stdcall，就可以把栈清理处理变为在被调用函数一方进行。</p><p>磁盘的物理结构<br>扇区是对磁盘进行物理读写的最小单位。<br>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用1簇的空间。这样一来，所有的文件都会占用1簇的整数倍的磁盘空间。<br>以簇为单位进行读写时，1簇中没有填满的区域会保持不被使用的状态。虽然这看起来是有点浪费，不过该机制就是如此规定的，所以我们也没有什么好办法。另外，如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。由于在磁盘表面上，表示扇区区分的领域是必要的，因此，如果簇的容量过小，磁盘的整体容量也会减少。扇区和簇的大小，是由处理速度和存储容量的平衡来决定的。   </p><h3 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h3><p>RLE算法: 把文件内容用<code>数据×重复次数</code>的形式来表示的压缩方法称为RLE (Run Length Encoding，行程长度编码) 算法。<br>在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE算法可以发挥不错的效果，但它并不适合文本文件的压缩。   </p><p><strong>莫尔斯编码</strong>是根据日常文本中各字符的出现频率来决定表示各字符的编码的数据长度的。<br>使用<strong>哈夫曼树</strong>后，出现频率越高的数据所占用的数据位数就越少，而且数据的区分也可以很清晰地实现。   </p><h3 id="程序是在何种环境中运行的"><a href="#程序是在何种环境中运行的" class="headerlink" title="程序是在何种环境中运行的"></a>程序是在何种环境中运行的</h3><p>应用的运行环境，是指<code>操作系统</code>和<code>计算机本身(硬件)</code>的种类   </p><p>机器语言的程序称为<strong>本地代码</strong> (native code)<br>程序员用C语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为<strong>源代码</strong>。    </p><p>应用程序向操作系统传递指令的途径称为API (ApplicationProgramming Interface)<br>BIOS (BasicInput/Output System)。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。<br><strong>引导程序</strong>是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。   </p><h3 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h3><p>源代码完成后，就可以编译生成可执行文件了。负责实现该功能的是编译器。<br><code>Dump</code> 是指把文件的内容，每个字节用2位十六进制数来表示的方式。</p><p>能够把C语言等高级编程语言编写的源代码转换成本地代码的程序称为<strong>编译器</strong>。<br>但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p><p>编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理。<br>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行连接的程序就称为<strong>链接器</strong>（linkage editor或连结器）  </p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ilink32 -Tpe -c -x -aa c0w32.obj Sample1.obj, Sample1.exe, ,</span><br><span class="line">import32.lib cw32.lib</span><br></pre></td></tr></table></figure><p>c0w32.obj这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的<strong>启动</strong>。<br>因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来。     </p><p>像import32.lib及cw32.lib这样的文件称为库文件。<br><strong>库文件</strong>指的是把多个目标文件集成保存到一个文件中的形式。<br><strong>链接器</strong>指定<strong>库文件</strong>后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件。    </p><p><code>sprintf()</code>等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为<code>标准函数</code>。<br>之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这一过程。   </p><p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL（Dynamic Link Library）文件的特殊库文件中。<br>就如Dynamic这一名称所表示的那样，DLL文件是程序运行时动态结合的文件。  </p><p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为<strong>静态链接库</strong>。<br>静态（static=静态的）同动态（dynamic=动态的）是相反的意思。存储着<code>sprintf()</code>的目标文件的cw32lib就是静态链接库。<br><code>sprintf()</code>提供了通过指定格式把数值转换成字符串的功能。   </p><p>那就是EXE文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在EXE文件的开头，追加转换内存地址所需的必要信息。这个信息称为<strong>再配置信息</strong>。<br>EXE文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离。   </p><p>EXE文件的内容分为再配置信息、变量组和函数组<br>当程序加载到内存后，除此之外还会额外生成两个组，那就是栈和堆。<br><strong>栈</strong>是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域。<br><strong>堆</strong>是用来存储程序运行时的任意数据及对象的内存领域<br>EXE文件中并不存在栈及堆的组。栈和堆需要的内存空间是在EXE文件加载到内存后开始运行时得到分配的。<br>因而，内存中的程序，就是由<code>用于变量的内存空间</code>、<code>用于函数的内存空间</code>、<code>用于栈的内存空间</code>、<code>用于堆的内存空间</code>这4部分构成的。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。不过，在内存的使用方法上，二者存在些许不同。栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。与此相对，堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。<br><strong>栈</strong>中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。<br>与此相对，<strong>堆</strong>的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。<br>如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为<strong>内存泄露</strong>（memory leak）   </p><blockquote><p>Q：编译器和解释器有什么不同？<br>A：<strong>编译器</strong>是在运行前对所有源代码进行解释处理的。而<strong>解释器</strong>则是在运行时对源代码的内容一行一行地进行解释处理的。<br>Q：“分割编译”指的是什么？<br>A：将整个程序分为多个源代码来编写，然后分别进行编译，最后链接成一个EXE文件。这样每个源代码都相对变短，便于程序管理。<br>Q：“Build”指的是什么？<br>A：根据开发工具种类的不同，有的编译器可以通过选择“Build”菜单来生成EXE文件。这种情况下，<strong><code>Build</code>指的是连续执行编译和链接</strong>。<br>Q：使用DLL文件的好处是什么？<br>A: DLL文件中的函数可以被多个程序共用。因此，借助该功能可以节约内存和磁盘。此外，在对函数的内容进行修正时，还不需要重新链接（静态链接）使用这个函数的程序。<br>Q：不链接导入库的话就无法调用DLL文件中的函数吗？<br>A：通过使用LoadLibrary()及GetProcAddress()这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。不过使用导入库更简单一些。<br>Q：“叠加链接”这个术语指的是什么？<br>A：将不会同时执行的函数，交替加载到同一个地址中运行。通过使用“叠加链接器”这一特殊的链接器即可实现。在计算机中配置的内存容量不多的MS-DOS时代，经常使用叠加链接。</p></blockquote><p>IDE: Integrated Development Environment，即继承了变成所需的各种工具的开发软件。<br>CPU: Central Processing Unit (中央处理器)<br>IC: Integrated Circuit (集成电路)<br>DLL: Dynamic Link Library</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是《程序是怎么跑起来的》读书笔记。&lt;br&gt;在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。&lt;br&gt;下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: &lt;/p&gt;
    
    </summary>
    
    
      <category term="program" scheme="https://jambo0624.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://jambo0624.github.io/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>CodeStandard</title>
    <link href="https://jambo0624.github.io/2020-07-19-code-standard.html"/>
    <id>https://jambo0624.github.io/2020-07-19-code-standard.html</id>
    <published>2020-07-19T03:16:16.000Z</published>
    <updated>2020-07-21T15:44:38.506Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：</p><ul><li>谨记代码是给人看的，它们只是恰巧能跑而已<a id="more"></a></li></ul><h4 id="能愿动词说明"><a href="#能愿动词说明" class="headerlink" title="能愿动词说明"></a>能愿动词说明</h4><p> 本文统一采用以下几个能愿动词作为规范的约束强度。</p><ul><li><code>必须（Must）</code>：只能这样做，请无条件遵守</li><li><code>绝不（Must Not）</code>：严令禁止，在任何情况下都不能这么做</li><li><code>应该（Should）</code>：强烈建议这样做，但是并不强求</li><li><code>不应该（Should Not）</code>：强烈建议不这样做，但是并不强求</li><li><code>可以（May）</code>：你可以按照自己的喜好去做</li></ul><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><p>下面几个词组指代四种命名风格。</p><ul><li><code>camelCase</code>：小驼峰</li><li><code>PascalCase</code>：大驼峰</li><li><code>kebab-case</code>：小写 + 中划线</li><li><code>kebab_ase</code>：小写 + 下划线</li></ul><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h3 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h3><h4 id="lang属性"><a href="#lang属性" class="headerlink" title="lang属性"></a>lang属性</h4><p>html 标签 <strong>必须</strong> 设置 lang 属性，此属性值 <strong>应该</strong> 与目标用户的第一语言保持一致。<br>当使用i18n等工具进行页面语言的切换时，此属性值也 <strong>应该</strong> 一并切换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh_CN"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="img-标签的-alt-属性"><a href="#img-标签的-alt-属性" class="headerlink" title="img 标签的 alt 属性"></a>img 标签的 alt 属性</h4><p>每一个 img 标签都 <strong>应该</strong> 有一个 alt 属性， 且它的内容 <strong>应该</strong> 尽可能详尽地描述这张图片的作用。<br>它除了能提供信息以及更好的 seo 之外，还能帮助视障人士。</p><h4 id="中文和西文之间的空格"><a href="#中文和西文之间的空格" class="headerlink" title="中文和西文之间的空格"></a>中文和西文之间的空格</h4><p>页面上的中文和西文（数字）之间 <strong>必须</strong> 有一个空格。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia是混成词，分别取自于网站核心技术Wiki以及英文中百科全书之意的encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia 是混成词，分别取自于网站核心技术 Wiki 以及英文中百科全书之意的 encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>皇后乐队是英国摇滚乐乐队，成立于 1970 年。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><h4 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h4><p><strong>必须</strong> 在所有样式文件前引入 <a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a> 用于消除各个浏览器之间的差异。<br>对于不同的项目，<strong>应该</strong> 根据需求设立 reset 样式集，并在 Normalize.css 之后引入。 Reset 样式集应该秉承最小化原则。</p><h4 id="简化版的CSS-BEM"><a href="#简化版的CSS-BEM" class="headerlink" title="简化版的CSS BEM"></a>简化版的CSS BEM</h4><p><a href="http://getbem.com/introduction/" target="_blank" rel="noopener">CSS BEM</a>是一种可以有效降低样式冲突概率的 css 选择器方法，但这种风格的代码对绝大部分项目来说是 too heavy 的。<br>这里提出一种简化的方案，只有”层级”和”断字”的概念。使用中划线 <code>-</code> 表示层级，使用下划线 <code>_</code> 表示断字。项目 <strong>必须</strong> 严格遵守该规范。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-img"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-login"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-sign_up"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>如果项目要使用 Css 预处理器， <strong>应该</strong>优先使用 Sass，且 <strong>必须</strong> 使用 Scss 语法。使用 Scss 语法对上方的 html 代码进行选择会变得非常简单易行。<br>每一个 Scss 选择器后面 <strong>必须</strong> 有一个空行。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  &amp;-logo &#123;</span><br><span class="line">    &amp;-<span class="selector-tag">img</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    &amp;-text &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &amp;-navbar &#123;</span><br><span class="line">    &amp;-item &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &amp;-login &#123;&#125;</span><br><span class="line">    &amp;-sign_up &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择器命名"><a href="#选择器命名" class="headerlink" title="选择器命名"></a>选择器命名</h4><p>选择器命名的第一要务是见名知意。</p><ul><li>对于一些常见的、约定俗成的单词简写，<strong>可以</strong> 使用简写形式。如：<code>description</code>-&gt;<code>desc</code></li><li><strong>绝不</strong> 使用简写后有多种释义，或是简写后无法辨别含义的单词简写。如：<code>description</code>-&gt;<code>des</code>,<code>fc</code></li><li>嵌套层级 <strong>不应该</strong> 过深，当出现三到四层嵌套后，可以使用全新的选择器名称。如：<code>.page-header-logo{ .title ...}</code></li></ul><h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>所有项目都 <strong>应该</strong> 使用 Babel 进行转义，而源码都 <strong>应该</strong> 拥抱已经发布的 ECMAScript 特性。</p><h4 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h4><p>所有项目都 <strong>应该</strong> 使用 ESLint 进行代码格式检查。</p><h4 id="const-let-和-var"><a href="#const-let-和-var" class="headerlink" title="const, let 和 var"></a>const, let 和 var</h4><p><code>const</code> <strong>必须</strong> 是第一公民，次之是 <code>let</code>。被 Babel (或其他转义工具)转义的项目中 <strong>绝不</strong> 出现 <code>var</code>。</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>变量命名的第一要务是见名知意。</p><ul><li>布尔型的变量 <strong>应该</strong> 以 <code>is</code> 或 <code>flag</code> 开头。如：<code>isVisible</code></li><li>数值类型的变量 <strong>必须</strong> 采用复数形式的名词。如：<code>users</code>,<code>categories</code></li><li>对于单复同行的数值型变量，<strong>应该</strong> 添加其他的单词进行辅助释义。如：<code>newsList</code></li><li>对象类型的变量 <strong>必须</strong> 采用单数形式的名词。如:<code>user</code></li><li>函数 (方法) 命名 <strong>必须</strong> 是以动词开头的 camelCase 风格。如: <code>createUser</code>, <code>validateForm</code></li><li>对于项目中约定的常量 (如配置项等)，<strong>应该</strong> 使用 PASCAL_CASE 风格。如: <code>HEADER_MENU</code>, <code>PRIMARY_COLOR</code></li><li>类( Class )的名称 <strong>必须</strong> 采用 PascalCase 形式，且 <strong>应该</strong> 拟人化。如: <code>Permission</code>, <code>FormValidator</code></li><li>任何变量的命名都 <strong>不应该</strong> 过于生僻和抽象</li></ul><h4 id="一些推荐使用的函数首部动词"><a href="#一些推荐使用的函数首部动词" class="headerlink" title="一些推荐使用的函数首部动词"></a>一些推荐使用的函数首部动词</h4><ul><li><code>do</code>/<code>deal</code>：做某些事情</li><li><code>go</code>：跳转、前往</li><li><code>get</code>/<code>fetch</code>：获取某些事物</li><li><code>set</code>：设置某些事物</li><li><code>make</code>/<code>create</code>：创建</li><li><code>edit</code>/<code>update</code>：编辑</li><li><code>delete</code>/<code>destory</code>：删除</li><li><code>handle</code>：被其他操作触发了</li></ul><h4 id="Restful-Actions"><a href="#Restful-Actions" class="headerlink" title="Restful Actions"></a>Restful Actions</h4><p>对于项目中的接口，<strong>应该</strong> 将 ajax 请求拆分为请求函数以实现复用以及提高项目的可维护性。<br>如果接口使用 Restful API，那么前端对应的方法名 <strong>可以</strong> 按照下面的规范来进行命名。</p><ul><li><code>get</code> <code>/books</code>=&gt;<code>reqFetchBooks</code></li><li><code>get</code> <code>/books/:id</code>=&gt;<code>reqShowBooks</code></li><li><code>post</code> <code>/books</code>=&gt;<code>reqCreateBooks</code></li><li><code>post,put,patch</code> <code>/books/:id</code>=&gt;<code>reqUpdateBooks</code></li><li><code>delete</code> <code>/books/:id</code>=&gt;<code>reqDestoryBooks</code></li></ul><h4 id="数组的循环"><a href="#数组的循环" class="headerlink" title="数组的循环"></a>数组的循环</h4><p>在使用循环时， <strong>不应该</strong> 使用<code>item</code>作为数组的元素名，而 <strong>应该</strong> 使用数组的单数形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">books.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; &#125;);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">books.map(<span class="function"><span class="params">book</span> =&gt;</span> &#123; &#125;);</span><br><span class="line">newsList.map(<span class="function"><span class="params">news</span> =&gt;</span> &#123; &#125;)</span><br></pre></td></tr></table></figure><h4 id="if的处理"><a href="#if的处理" class="headerlink" title="if的处理"></a>if的处理</h4><p>每一个<code>if</code>都 <strong>必须</strong> 囊括所有情况，也就是说每一种逻辑都可以被 if 处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125; <span class="keyword">else</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>部分<code>if else</code>逻辑 <strong>可以</strong> 通过及时 <code>return</code> 减少嵌套层数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// correct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (a !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br></pre></td></tr></table></figure><p>过多的<code>!a || b</code> <strong>应该</strong> 被转换为<code>!(a &amp;&amp; b)</code>，这种逻辑更符合直觉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not bad</span></span><br><span class="line"><span class="keyword">if</span> (!a || !b) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (!(a &amp;&amp; b)) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>注释本身 <strong>不应该</strong> 对变量或方法本身是做什么的进行解释。这要求变量命名尽可能得见名知意。</li></ul><h3 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h3><p><strong>NOTICE HERE</strong>： Vue 的相关规范全部基于官方的<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">风格指南</a>， 并在此基础上进行了一些修改和约束。</p><h4 id="组件文件命名"><a href="#组件文件命名" class="headerlink" title="组件文件命名"></a>组件文件命名</h4><ul><li>页面、路由相关的组件 <strong>应该</strong> 使用一个单词命名</li><li>非页面、路由相关的组件 <strong>应该</strong> 使用<code>PascalCase</code>风格命名</li><li>组件 <strong>应该</strong> 拟人化。如：<code>UserCreator</code>,<code>Selector</code></li></ul><h4 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h4><p>如果文件夹内拥有<code>index.vue</code>，那么引入时 <strong>应该</strong> 省略 index 字样， 并在末尾添加 <code>/</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/'</span></span><br></pre></td></tr></table></figure><p>引入组件时，模块名 <strong>必须</strong> 为 <code>PascalCase</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="根标签书写规范"><a href="#根标签书写规范" class="headerlink" title="根标签书写规范"></a>根标签书写规范</h4><p>vue 文件中的标签书写顺序 <strong>必须</strong> 为：</p><ol><li><code>&lt;template&gt;&lt;/template&gt;</code></li><li><code>&lt;script&gt;&lt;/script&gt;</code></li><li><code>&lt;style&gt;&lt;/style&gt;</code></li></ol><h3 id="lt-template-gt-lt-template-gt-根标签"><a href="#lt-template-gt-lt-template-gt-根标签" class="headerlink" title="&lt;template&gt;&lt;/template&gt;根标签"></a><code>&lt;template&gt;&lt;/template&gt;</code>根标签</h3><p>每一个根标签下的顶级元素都 <strong>必须</strong> 有一个与当前文件名对应的 css 选择器。在本规范中， <strong>应该</strong> 使用<code>文件名</code>的<code>kebab_case</code>结构作为该 css 选择器。如：<code>SelectorGender</code>-&gt;<code>selector_gender</code><br>如果为了进一步降低组件间的样式冲突的可能性， <strong>可以</strong> 使用 <code>文件夹层级</code> + <code>文件名</code> 共同组装成根组件的根选择器。假定有以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- common &lt;dir&gt;</span><br><span class="line">|  |-- selectors &lt;dir&gt;</span><br><span class="line">|  |  |-- SelectorGender &lt;file&gt;</span><br></pre></td></tr></table></figure><p>那么其对应的唯一 css 选择器名应该为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;common-selectors-selector_gender&quot;&gt;</span><br><span class="line">     &lt;!--    --&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-script-gt-lt-script-gt-根标签"><a href="#lt-script-gt-lt-script-gt-根标签" class="headerlink" title="&lt;script&gt;&lt;/script&gt;根标签"></a><code>&lt;script&gt;&lt;/script&gt;</code>根标签</h3><p>实例选项顺序<br>组件实例中的选项顺序 <strong>必须</strong> 按照 vue 风格指南的要求进行排版</p><ol><li><code>el</code></li><li><code>name</code></li><li><code>parent</code></li><li><code>functional</code></li><li><code>delemiters</code></li><li><code>comments</code></li><li><code>components</code></li><li><code>directives</code></li><li><code>filters</code></li><li><code>extends</code></li><li><code>mixins</code></li><li><code>inheritAttrs</code></li><li><code>model</code></li><li><code>props/prosData</code></li><li><code>data</code></li><li><code>computed</code></li><li><code>watch</code></li><li><code>beforeCreated</code></li><li><code>created</code></li><li><code>beforeMounted</code></li><li><code>mounted</code></li><li><code>beforeUpdate</code></li><li><code>updated</code></li><li><code>activated</code></li><li><code>deactivated</code></li><li><code>beforeDestory</code></li><li><code>destoryed</code></li><li><code>methods</code></li><li><code>template/render</code></li><li><code>renderError</code></li></ol><h4 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h4><p>各个选项间 <strong>必须</strong> 间隔一个空行，而内部的值或方法不空行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Demo'</span>,</span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tableData: <span class="string">''</span>,</span><br><span class="line">      userInfo: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    getTableData () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getUserInfo () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：name"><a href="#实例选项：name" class="headerlink" title="实例选项：name"></a>实例选项：<code>name</code></h4><p>每一个组件 <strong>必须</strong> 有一个 <code>name</code> 实例选项，其值 <strong>必须</strong> 为被其他组件引入时的模块名。如果你的组件命名完全符合本规范，那么一般情况下，此属性的值应与组件的文件名保持一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file name: MyComponent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// worst</span></span><br><span class="line">  <span class="comment">// no name</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'my-component'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'myComponent'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  name: <span class="string">'MyComponent'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * use this component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'../common/MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="实例选项：props"><a href="#实例选项：props" class="headerlink" title="实例选项：props"></a>实例选项：<code>props</code></h4><p>组件需要的参数，都 <strong>应该</strong> 拥有完善的验证规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    demo:&#123;</span><br><span class="line">      type: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="params">val</span> =&gt;</span> [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'first'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="string">'second'</span>].includes(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：data"><a href="#实例选项：data" class="headerlink" title="实例选项：data"></a>实例选项：<code>data</code></h4><ul><li><strong>不应该</strong> 使用 <code>Vue.set()</code> 方式为组件扩展响应式的 data</li><li><strong>应该</strong> 将一些同属于某一块页面元素的 data 合并为对象的形式，避免 data 的扁平化</li><li>每一个 data 都 <strong>必须</strong> 是被使用到的</li></ul><h4 id="实例选项-生命周期函数"><a href="#实例选项-生命周期函数" class="headerlink" title="实例选项: 生命周期函数"></a>实例选项: 生命周期函数</h4><p>生命周期函数内 <strong>不应该</strong> 直接书写过多的业务逻辑。如果逻辑过多，<strong>应该</strong> 在 methods 中定义独立的函数并在生命周期函数中进行调用。</p><h3 id="lt-style-gt-lt-style-gt-根标签"><a href="#lt-style-gt-lt-style-gt-根标签" class="headerlink" title="&lt;style&gt;&lt;/style&gt;根标签"></a><code>&lt;style&gt;&lt;/style&gt;</code>根标签</h3><ul><li><strong>必须</strong> 添加 scoped 属性</li><li><strong>必须</strong> 使用 sass 预处理器，并且使用 scss 语法</li><li>所有的组件内样式 <strong>必须</strong> 被该组件的唯一 css 选择器包裹<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"selector_gender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.selector_gender</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* ... */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="关于命名的（最佳）实践"><a href="#关于命名的（最佳）实践" class="headerlink" title="关于命名的（最佳）实践"></a>关于命名的（最佳）实践</h3><ul><li>在 Dom 上绑定的事件回调方法 <strong>应该</strong> 使用<code>on</code>+<code>动词</code>+<code>名词</code>形式。如：<code>@click=&quot;onCreateUser&quot;</code></li><li>子组件 emit 的事件名称 <strong>应该</strong> 使用 <code>动词的一般现在时</code>。如：<code>@click</code>,<code>@submit</code></li><li>子组件 emit 的事件回调方法 <strong>应该</strong> 使用<code>handle</code>+<code>名词</code>+<code>动词过去式</code>形式。如：<code>@submit=&quot;handleUserCreated&quot;</code></li><li><strong>应该</strong> 正确使用<code>or</code>和<code>and</code>。详见下方示例<br>一个完整的例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"users"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onCreateUser"</span>&gt;</span>Create User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onEditUser(scope.row)"</span>&gt;</span>Edit User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">:loading</span>=<span class="string">"isDeletingUser"</span> @<span class="attr">click</span>=<span class="string">"onDeleteUser(scope.row)"</span>&gt;</span>Delete User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">user-creator-and-editor</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ref</span>=<span class="string">"userCreatorAndEditor"</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">submit</span>=<span class="string">"handleUserCreatedOrEdited"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user-creator-and-editor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> UserCreatorAndEditor <span class="keyword">from</span> <span class="string">'./UserCreatorAndEditor'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; reqDestoryUser &#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'Users'</span>,</span></span><br><span class="line"></span><br><span class="line">    components: &#123; UserCreatorAndEditor &#125;,</span><br><span class="line"></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        isDeletingUser: <span class="literal">false</span>,</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">      onCreateUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'create'</span> &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      onEditUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'edit'</span>, userId: id &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      handleUserCreatedOrEdited(result) &#123;</span><br><span class="line">        if(result) &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line">        &#125;     </span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="keyword">async</span> onDeleteUser(&#123; id &#125;) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">await</span> reqDestoryUser(id);</span></span><br><span class="line"><span class="actionscript">           <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">finally</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">false</span></span></span><br><span class="line">        &#125;   </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>每个方法和变量都见名知意，并且永不重复！</li></ul><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><p><strong>不应该</strong> 使用路由大量传递参数,请尽可能地保证<code>clean and beautiful</code>。</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p><strong>应该</strong> 使用<code>module</code>组织 vuex，而非全部注册在顶级。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>绝不</strong> 给 Vue 挂载大体量的插件或扩展， <strong>应该</strong> 在需要用到的页面进行按需引入</li><li><strong>不应该</strong> 直接选取某个 dom 元素进行直接的 dom 操作( Echarts 等插件除外)</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>项目的技术文档 <strong>必须</strong> 使用 Markdown 格式编写。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><ul><li>英文文档 <strong>必须</strong> 使用半角标点符号</li><li>中文文档中以下标点符号 <strong>必须</strong> 使用半角，并在其后添加一个空格<ul><li>引号: <code>&quot;&quot;</code></li><li>冒号: <code>:</code></li><li>感叹号: <code>!</code></li><li>问号: <code>?</code></li><li>所有的括号: <code>() [] {}</code></li></ul></li><li>中文文档中以下标点符号 <strong>必须</strong> 使用全角，其后不需要添加空格<ul><li>逗号: <code>，</code></li><li>句号: <code>。</code></li><li>省略号: <code>……</code></li></ul></li></ul><h3 id="Markdown-语法约束"><a href="#Markdown-语法约束" class="headerlink" title="Markdown 语法约束"></a>Markdown 语法约束</h3><ul><li><strong>必须</strong> 有且仅有一个一级标题</li><li>标题的层级最多 <strong>不应该</strong> 超过三级</li><li>句子的末尾 <strong>必须</strong> 有句号</li><li>无序列表和有序列表的末尾 <strong>不应该</strong> 添加句号</li><li><strong>应该</strong> 优先选用无需列表而非有序列表</li><li>用于表明格式的关键字符 <strong>必须</strong> 前后各留一个空格</li><li>标题与段落之间 <strong>必须</strong> 前后各留一个空行</li></ul><h3 id="的，得，地"><a href="#的，得，地" class="headerlink" title="的，得，地"></a>的，得，地</h3><p><strong>必须</strong> 正确使用<code>的</code>，<code>得</code>，<code>地</code>。</p><h3 id="项目版本"><a href="#项目版本" class="headerlink" title="项目版本"></a>项目版本</h3><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>项目开发过程中的版本迭代 <strong>应该</strong> 遵循类似 npm 的版本定义方法。即:</p><ul><li><code>1.1.1</code> -&gt; <code>1.1.2</code>: 向下兼容的问题修复</li><li><code>1.1.1</code> -&gt; <code>1.2.1</code>: 向下兼容的功能迭代</li><li><code>1.1.1</code> -&gt; <code>2.1.1</code>: 发生了非向下兼容的功能迭代</li></ul><h4 id="版本迭代及分支管理"><a href="#版本迭代及分支管理" class="headerlink" title="版本迭代及分支管理"></a>版本迭代及分支管理</h4><ul><li><code>master</code>分支 <strong>必须</strong> 对应线上代码</li><li>对于开发告一段落，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><ul><li>安装依赖时 <strong>必须</strong> 按照功能严格区分生产环境依赖和开发环境依赖</li><li><strong>绝不</strong> 遗留未被使用的依赖。如果不使用某个依赖时， <strong>必须</strong> 第一时间进行卸载</li><li><strong>绝不</strong> 在未获得其他开发人员同意的情况下升级依赖版本</li><li><strong>应该</strong> 优先使用使用量大、受众面广的依赖</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="使用If"><a href="#使用If" class="headerlink" title="使用If"></a>使用If</h4><p>Windows 下的 Git 默认使用<code>crlf</code>作为换行符，甚至会将<code>lf</code>转换为<code>crlf</code>。本规范要求所有的换行都 <strong>必须</strong> 使用<code>lf</code>风格。</p><p>Q: 安装 Git 时，忘记去勾了 crlf 自动替换的选项，怎么办？<br>A: 执行以下命令:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.eol lf</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><ul><li>开发分支 <strong>必须</strong> 是<code>develop</code></li><li>功能分支 <strong>必须</strong> 以<code>feature/</code>开头。如: <code>feature/user_system</code></li><li>开发完毕，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h4 id="Merge-Request-Pull-Request"><a href="#Merge-Request-Pull-Request" class="headerlink" title="Merge Request(Pull Request)"></a>Merge Request(Pull Request)</h4><p>每一次分支合并都 <strong>必须</strong> 发起一个<code>Merge Request</code>，并且交由他人评审。</p><h3 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h3><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><ul><li><code>src</code><ul><li><code>api</code>: 存放 API 资源</li><li><code>assets</code>: 存放需要被 Webpack 处理的静态资源</li><li><code>components</code>: 存放于项目无关的公共组件。理论上这些组件可以被任何项目直接使用</li><li><code>config</code>: 存放一些项目配置文件</li><li><code>models</code>: 存放前端的数据模型。如果项目使用了 Typescript， 理论上不需要设置改目录</li><li><code>router</code>: Vue 路由</li><li><code>store</code>: Vuex。 <strong>应该</strong> 只包含<code>modules</code>和<code>index.js</code>，保证 vuex 所有功能都尽可能按照模块划分<ul><li><code>modules</code>: Vuex 的模块</li><li><code>index.js</code></li></ul></li><li><code>styles</code>: 存放全局样式。样式文件 <strong>必须</strong> 使用 Scss 进行组织; 作为子文件的样式文件 <strong>必须</strong> 使用 <code>_</code>开头<ul><li><code>_common.scss</code>: 公共样式文件</li><li><code>_hack.scss</code>: 对各种组件库或其他样式进行加强修改。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>_mixins.scss</code>: 提供全局的 Scss Mixins</li><li><code>_reset.scss</code>: 对页面样式进行重置。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>main.scss</code>: 按照一定的顺序注册全部样式文件。被<code>main.js</code>引入</li><li><code>resource.scss</code>: 被<code>scss-loader</code>处理，注册全局可用的 Scss 资源</li></ul></li><li><code>utils</code>: 各种工具<ul><li><code>http.js</code>: 请求层。<strong>必须</strong> 优先使用<code>axios</code></li></ul></li><li><code>views</code>: 视图层</li><li><code>App.vue</code></li><li><code>main.js</code>: 文件内容 <strong>必须</strong> 尽可能短小且清晰</li></ul></li><li><code>.editorconfig</code></li><li><code>.prettierignore</code></li><li><code>.prettierrc.js</code></li><li><code>.prettierrc.js</code></li><li><code>CHANGELOG.md</code>: 项目更新日志。在每一次上线前都 <strong>必须</strong> 进行补全</li><li><code>README.md</code>: 用来说明项目，以及帮助其他人快速上手项目</li></ul><h4 id="main-scss-组织"><a href="#main-scss-组织" class="headerlink" title="main.scss 组织"></a>main.scss 组织</h4><p>由于样式存在后者覆盖前者的问题，因此 main.scss <strong>必须</strong> 按照一定的顺序进行组织。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络资源 (network resources)</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">"https://fonts.googleapis.com/css?family=Nunito"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地资源 (local resources)。如: 变量，mixin，图标</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"iconfont"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式重置 (reset)。推荐优先使用 normalize.css，自己书写的 reset 文件的内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~normalize.css/normalize.css"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"reset"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方库 (libraries)</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~element-ui/packages/theme-chalk/src/index"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~swiper/css/swiper"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共样式 (common)。如果有需要的话，给公共样式加入一个前缀以作区分，如 ` g-container `</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"common"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图 (views)。对于一个 vue 项目，可能不需要引入视图内的样式</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/layout/home"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/widgets/header"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强行重置某些样式 (hack)。内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"hack"</span>;</span><br></pre></td></tr></table></figure><h4 id="Scss全局资源"><a href="#Scss全局资源" class="headerlink" title="Scss全局资源"></a>Scss全局资源</h4><blockquote><p>参考官方文档: <a href="https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项</a></p></blockquote><p>在<code>src/styles/</code>目录下创建<code>resources.scss</code>文件，用于存放全局可以使用的样式资源，如变量，mixin 等。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br></pre></td></tr></table></figure><p>在<code>vue.config.js</code>中进行了配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: <span class="string">`@import "@/styles/resources.scss";`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Editorconfig"><a href="#Editorconfig" class="headerlink" title="Editorconfig"></a>Editorconfig</h3><p>每一个项目都 <strong>必须</strong> 添加<code>Editorconfig</code>文件，并且每一个开发人员的编辑器都 <strong>必须</strong> 安装该插件。<br>下面是一份推荐使用的 editorconfig 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset = utf<span class="number">-8</span></span><br><span class="line">end_of_line = lf</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = <span class="number">2</span></span><br><span class="line">tab_width = <span class="number">2</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p>所有项目都 <strong>必须</strong> 使用<code>Prettier</code>进行代码的格式化。<br>下面是一份推荐使用的 prettier 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line">modules.export = &#123;</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: <span class="string">"*.&#123;js,ts,jsx,tsx,vue&#125;"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        singleQuote: <span class="literal">true</span>,</span><br><span class="line">        printWidth: <span class="number">100</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谨记代码是给人看的，它们只是恰巧能跑而已
    
    </summary>
    
    
      <category term="standard" scheme="https://jambo0624.github.io/categories/standard/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="standard" scheme="https://jambo0624.github.io/tags/standard/"/>
    
  </entry>
  
</feed>
