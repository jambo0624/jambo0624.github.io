<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You should know more</title>
  
  
  <link href="blog/atom.xml" rel="self"/>
  
  <link href="https://jambo0624.github.io/"/>
  <updated>2020-10-20T12:19:51.440Z</updated>
  <id>https://jambo0624.github.io/</id>
  
  <author>
    <name>Jambo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue3 笔记</title>
    <link href="https://jambo0624.github.io/2020-10-10-vue3-note.html"/>
    <id>https://jambo0624.github.io/2020-10-10-vue3-note.html</id>
    <published>2020-10-10T02:21:38.000Z</published>
    <updated>2020-10-20T12:19:51.440Z</updated>
    
    <content type="html"><![CDATA[<p>之前用了 vue3 rc版本做了一个 UI 库。<br>但是正式版 vue3 One Piece 已于9月18日晚已发布。<br><a href="https://v3.cn.vuejs.org/" target="_blank" rel="noopener">v3 中文文档</a>和<a href="https://github.com/vuejs/docs-next-zh-cn" target="_blank" rel="noopener">仓库</a>也逐渐完善。<br>那么下面我们就看看 vue 3 到底做了哪些工作。</p><a id="more"></a><h2 id="Vue2与Vue3的全局配置API变化区别"><a href="#Vue2与Vue3的全局配置API变化区别" class="headerlink" title="Vue2与Vue3的全局配置API变化区别"></a>Vue2与Vue3的全局配置API变化区别</h2><h3 id="createApp"><a href="#createApp" class="headerlink" title="createApp"></a>createApp</h3><p>Vue2.x创建实例并且挂载DOM上</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure><p>Vue3新增api===&gt;createApp 创建实例</p><blockquote><p>createApp 会产生一个 app 实例，该实例拥有全局的可配置上下文</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line">createApp(App).mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p><strong>createApp做了什么</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function">(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> app = ensureRender(<span class="params"></span>).createApp(<span class="params">...args</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">if</span>(<span class="params">__DEV__</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    injectNativeTagCheck(<span class="params">app</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> &#123; mount &#125; = app</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  app.mount = (<span class="params"></span>):<span class="built_in">any</span> =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> container = normalizeContainer(<span class="params">containerOrSelector</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span>(<span class="params">!container</span>) <span class="keyword">return</span> </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> component = app._component</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span>(<span class="params">!isFunction(<span class="params">component</span>) &amp;&amp; !component.render &amp;&amp; !component.template</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      component.template = container.innerHTML</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// clear content before mounting</span></span></span></span><br><span class="line"><span class="function"><span class="params">    container.innerHTML = ''</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> proxy = mount(<span class="params">container</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    container.removeAttribute(<span class="params">'v-cloak'</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    container.setAttribute(<span class="params">'data-v-app', ''</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> proxy  </span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> app</span></span></span><br><span class="line"><span class="function"><span class="params">  </span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) <span class="params">as</span> <span class="params">CreateAppFunction</span>&lt;<span class="params">Element</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>ensureRenderer方法追溯过去底添加<a href="https://github.com/vuejs/vue-next/blob/4951d4352605eb9f4bcbea40ecc68fc6cbc3dce2/packages/runtime-dom/src/patchProp.ts" target="_blank" rel="noopener">patchclass+patchStyle等跟操作DOM相关的方法</a></p></li><li><p>ensureRenderer(创建虚拟DOM)一直追溯到<a href="https://github.com/vuejs/vue-next/blob/de62cc040c22e3bd93222a9cc84b6564a4b08b51/packages/runtime-core/src/renderer.ts" target="_blank" rel="noopener">createRenderer以及baseCreateRenderer，baseCreateRenderer</a>方法涉及了虚拟DOM的创建更新DIFF算法</p></li><li><p>之后就是检查时候又mount是否挂载在DOM上</p></li><li><p>app对象上的方法：config、use、mixin、component、directive、mount、unmount、provide/inject</p></li></ul><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><p>Vue2.x【注册或获取全局组件。注册还会自动使用给定的 id 设置组件的名称】</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册组件，传入一个选项对象 (自动调用 Vue.extend) </span></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123; <span class="comment">/* ... */</span> &#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取注册的组件 (始终返回构造器) </span></span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.component(<span class="string">'my-component'</span>)</span><br></pre></td></tr></table></figure><p>Vue3【注册或获取全局组件. 注册还会自动使用给定的 name组件 设置组件的名称】<br><a href="https://codepen.io/team/Vue/pen/rNVqYvM" target="_blank" rel="noopener">全局组件</a></p><p><strong>基本vue2写法一致</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册组件，传入一个选项对象</span></span><br><span class="line">app.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取注册的组件 (始终返回构造器) </span></span><br><span class="line"><span class="keyword">const</span> MyComponent = app.component(<span class="string">'my-component'</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="config【app-createApp-App-】"><a href="#config【app-createApp-App-】" class="headerlink" title="config【app=createApp(App)】"></a>config【app=createApp(App)】</h3><h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3><blockquote><p>配置是否允许 vue-devtools 检查代码。<br>开发版本默认为 true，生产版本默认为 false。<br>生产版本设为 true 可以启用检查。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Vue.config.devtools &#x3D; true</span><br><span class="line">+ app.config.devtools &#x3D; true</span><br></pre></td></tr></table></figure><h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- Vue.config.errorHandler &#x3D; function (err, vm, info) &#123;</span><br><span class="line">  &#x2F;&#x2F; handle error</span><br><span class="line">  &#x2F;&#x2F; &#96;info&#96; 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span><br><span class="line">  &#x2F;&#x2F; 只在 2.2.0+ 可用</span><br><span class="line">&#125;</span><br><span class="line">+ app.config.errorHandler &#x3D; (err, vm, info) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; handle error</span><br><span class="line">  &#x2F;&#x2F; &#96;info&#96; 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span><br><span class="line">  &#x2F;&#x2F; 这里能发现错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>指定组件的渲染和观察期间未捕获错误的处理函数。<br>这个处理函数被调用时，可获取错误信息和 Vue 实例。</p></blockquote><h3 id="warnHandler"><a href="#warnHandler" class="headerlink" title="warnHandler"></a>warnHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Vue.config.warnHandler &#x3D; function (msg, vm, trace) &#123;</span><br><span class="line">  &#x2F;&#x2F; &#96;trace&#96; 是组件的继承关系追踪</span><br><span class="line">&#125;</span><br><span class="line">+ app.config.warnHandler &#x3D; function(msg, vm, trace) &#123;</span><br><span class="line">  &#x2F;&#x2F; &#96;trace&#96; 是组件的继承关系追踪</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为 Vue 的运行时警告赋予一个自定义处理函数。<br>注意这只会在开发者环境下生效，在生产环境下它会被忽略。</p></blockquote><h3 id="globalProperties-【新增属性】"><a href="#globalProperties-【新增属性】" class="headerlink" title="globalProperties 【新增属性】"></a>globalProperties 【新增属性】</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.config.globalProperties.foo = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">app.component(<span class="string">'child-component'</span>, &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) <span class="comment">// 'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>添加可在程序内的任何组件实例中访问的全局属性。<br>当存在键冲突时，组件属性将优先替代掉Vue2.x的 Vue.prototype属性放到原型上的写法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Vue2.x</span><br><span class="line">Vue.prototype.$http &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Vue3</span><br><span class="line">const app &#x3D; Vue.createApp(&#123;&#125;)</span><br><span class="line">app.config.globalProperties.$http &#x3D; () &#x3D;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="isCustomElement-【新增属性】"><a href="#isCustomElement-【新增属性】" class="headerlink" title="isCustomElement 【新增属性】"></a>isCustomElement 【新增属性】</h3><ul><li>替代掉Vue2.x的ignoredElements<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Vue.config.ignoredElements &#x3D; [</span><br><span class="line">  &#x2F;&#x2F; 用一个 &#96;RegExp&#96; 忽略所有“ion-”开头的元素</span><br><span class="line">  &#x2F;&#x2F; 仅在 2.5+ 支持</span><br><span class="line">  &#x2F;^ion-&#x2F;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一些组件以&#39;ion-&#39;开头将会被解析为自定义组件</span><br><span class="line">+ app.config.isCustomElement &#x3D; tag &#x3D;&gt; tag.startsWith(&#39;ion-&#39;)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>指定一个方法来识别在Vue之外定义的自定义组件(例如，使用<a href="http://www.ruanyifeng.com/blog/2019/08/web_components.html" target="_blank" rel="noopener">Web Component API</a>)。<br>如果组件符合这个条件，它就不需要本地或全局注册，Vue也不会抛出关于Unknown custom element的警告</p></blockquote><blockquote><p>注意，这个函数中不需要匹配所有原生HTML和SVG标记—Vue解析器会自动执行此检查</p></blockquote><h3 id="optionMergeStrategies"><a href="#optionMergeStrategies" class="headerlink" title="optionMergeStrategies"></a>optionMergeStrategies</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.hello)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.config.optionMergeStrategies.hello = <span class="function">(<span class="params">parent, child, vm</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;child&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.mixin(&#123;</span><br><span class="line">  hello: <span class="string">'Vue'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'Hello, Vue</span></span><br></pre></td></tr></table></figure><blockquote><p>定义自定义选项的合并策略。<br>合并策略接收在<strong>父实例</strong>options和<strong>子实例</strong>options，分别作为第一个和第二个参数。<br>上下文Vue实例作为第三个参数传递</p></blockquote><h3 id="【自定义选项合并策略】mixin"><a href="#【自定义选项合并策略】mixin" class="headerlink" title="【自定义选项合并策略】mixin"></a>【自定义选项合并策略】mixin</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  custom: <span class="string">'hello!'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.config.optionMergeStrategies.custom = <span class="function">(<span class="params">toVal, fromVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fromVal, toVal)</span><br><span class="line">  <span class="comment">// =&gt; "goodbye!", undefined</span></span><br><span class="line">  <span class="comment">// =&gt; "hello!", "goodbye!"</span></span><br><span class="line">  <span class="keyword">return</span> fromVal || toVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.mixin(&#123;</span><br><span class="line">  custom: <span class="string">'goodbye!'</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.custom) <span class="comment">// =&gt; "hello!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>optionMergeStrategies先获取到子实例的<code>$options</code>的<code>mixin</code><br>而没有父实例【custom第一次改变从<code>undefined</code>到<code>goodbye</code>—&gt;打印<code>&quot;goodbye!&quot;, undefined</code>】</p></blockquote><blockquote><p>父实例的options替换掉子实例的options替换掉子实例的options替换掉子实例的options<br>【custom第二次从goodbye到hello!—&gt;打印了”hello”, “goodbye!”】</p></blockquote><blockquote><p>最后在打印app.config.optionMergeStrategies.custom返回的父实例的<code>$options</code></p></blockquote><blockquote><p>无论如何this.options.custom最后会返回合并策略的return的值<br>【使用场景利用父子组件的options,然后返回计算等操作得到所需要的值】<br>optionMergeStrategies合并$options变化</p></blockquote><h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Vue.config.performance&#x3D;true;</span><br><span class="line">+ app.config.performance&#x3D;true;</span><br></pre></td></tr></table></figure><blockquote><p>设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。<br>只适用于开发模式和支持 performance.mark API 的浏览器上。</p></blockquote><h3 id="directive"><a href="#directive" class="headerlink" title="directive"></a>directive</h3><blockquote><p>注册或获取全局指令。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">app.directive(<span class="string">'my-directive'</span>, &#123;</span><br><span class="line">  <span class="comment">// 指令的生命周期</span></span><br><span class="line">  <span class="comment">// 在绑定元素的父组件被挂载之前调用</span></span><br><span class="line">  beforeMount(el, binding, vnode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在挂载绑定元素的父组件时调用</span></span><br><span class="line">  mounted(el, binding, vnode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在更新包含组件的VNode之前调用</span></span><br><span class="line">  beforeUpdate(el, binding, vnode, prevNode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 组件的VNode及其子组件的VNode更新之后调用</span></span><br><span class="line">  updated(el, binding, vnode, prevNode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在卸载绑定元素的父组件之前调用</span></span><br><span class="line">  beforeUnmount(el, binding, vnode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在卸载绑定元素的父组件时调用</span></span><br><span class="line">  unmounted(el, binding, vnode) &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 (指令函数)</span></span><br><span class="line">app.directive(<span class="string">'my-directive'</span>, <span class="function">(<span class="params">el, binding, vnode, prevNode</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里将会被 `mounted` 和 `updated` 调用</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter，返回已注册的指令</span></span><br><span class="line"><span class="keyword">const</span> myDirective = app.directive(<span class="string">'my-directive'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/BSjs9e" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSjs9e.png" alt="BSjs9e.png"></a><br><a href="https://imgchr.com/i/BSjDhD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSjDhD.png" alt="BSjDhD.png"></a></p><ul><li><p>el: 指令绑定到的元素。这可以用来直接操作DOM。</p></li><li><p>binding【包含下列属性的对象】</p></li></ul><p><strong>instance</strong>：使用指令的组件的实例</p><p><strong>value</strong>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code>中，绑定值为 <code>2</code></p><p><strong>oldValue</strong>：指令绑定的前一个值，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用。无论值是否改变都可用</p><p><strong>arg</strong>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code></p><p><strong>modifiers</strong>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code></p><p><strong>dir</strong>：一个对象，在注册指令时作为参数传递;  举个例子，看下面指令</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  mounted(el) &#123;</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>dir就是下面的对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mounted(el) &#123;</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vnode</strong><br>编译生成的虚拟节点</p><p><strong>prevNode</strong><br>前一个虚拟节点，仅在beforeUpdate和updated钩子中可用</p><blockquote><p>tips:除了 el 之外，其它参数都应该是只读的，切勿进行修改。<br>如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行</p></blockquote><h3 id="mixin【基本Vue2-x一致】"><a href="#mixin【基本Vue2-x一致】" class="headerlink" title="mixin【基本Vue2.x一致】"></a>mixin【基本Vue2.x一致】</h3><ul><li>optionMergeStrategies 影响，可看上面</li></ul><blockquote><p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。<br>插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。</p></blockquote><h3 id="mount【类似Vue2-x】"><a href="#mount【类似Vue2-x】" class="headerlink" title="mount【类似Vue2.x】"></a>mount【类似Vue2.x】</h3><ul><li>在所提供的DOM元素上挂载应用程序实例的根组件<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br><span class="line"><span class="comment">// 做一些准备</span></span><br><span class="line">app.mount(<span class="string">'#my-app'</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="provide-inject【Vue2-x一致】"><a href="#provide-inject【Vue2-x一致】" class="headerlink" title="provide/inject【Vue2.x一致】"></a>provide/inject【Vue2.x一致】</h3><blockquote><p>该选项与<code>inject</code>一起使用，允许一个祖先组件作为其所有后代的依赖注入器，无论组件层次结构有多深，只要它们位于同一父链中就可以</p></blockquote><blockquote><p><code>provide</code> 选项应该是一个对象或返回一个对象的函数。<br>该对象包含可注入其子孙的 <code>property</code>。<br>在该对象中你可以使用 <code>ES2015 Symbols</code> 作为 <code>key</code>，但是只在原生支持 <code>Symbol</code> 和 <code>Reflect.ownKeys</code> 的环境下可工作。</p></blockquote><blockquote><p>如果在组件中两者都只能在当前活动组件实例的 setup() 中调用，详细请看依赖注入部分</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    user: <span class="string">'John Doe'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">'user-card'</span>, &#123;</span><br><span class="line">  inject: [<span class="string">'user'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; user &#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="unmount【新增属性】"><a href="#unmount【新增属性】" class="headerlink" title="unmount【新增属性】"></a>unmount【新增属性】</h3><p>在所提供的DOM元素上卸载应用程序实例的根组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br><span class="line"><span class="comment">// 做一些必要的准备</span></span><br><span class="line">app.mount(<span class="string">'#my-app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序将在挂载后5秒被卸载</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> app.unmount(<span class="string">'#my-app'</span>), <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h3 id="use【Vue2-x一致】"><a href="#use【Vue2-x一致】" class="headerlink" title="use【Vue2.x一致】"></a>use【Vue2.x一致】</h3><blockquote><p>安装 Vue.js 插件。<br>如果插件是一个对象，必须提供 install 方法。<br>如果插件是一个函数，它会被作为 install 方法。<br>install 方法调用时，会将 Vue 作为参数传入。</p></blockquote><blockquote><p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p></blockquote><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p><code>setup</code> 函数是一个新的组件选项。作为在组件内使用 <code>Composition API</code> 的入口点</p><blockquote><p>注意 <code>setup</code> 返回的 ref 在模板中会自动解开，不需要写 .value【setup 内部需要.value】</p></blockquote><p><strong>调用时机</strong></p><blockquote><p>创建组件实例，然后初始化 <code>props</code> ，紧接着就调用<code>setup</code> 函数。<br>从生命周期钩子的视角来看，它会在 <code>beforeCreate</code> 钩子之前被调用</p></blockquote><blockquote><p>如果 <code>setup</code> 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文</p></blockquote><p><strong>参数</strong></p><p><code>props</code> 作为其第一个参数</p><blockquote><p>注意 <code>props</code> 对象是响应式的，<code>watchEffect</code> 或 <code>watch</code> 会观察和响应 <code>props</code> 的更新不要解构 <code>props</code> 对象，那样会使其失去响应性</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props.name)</span><br><span class="line">     watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`name is: `</span> + props.name)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数提供了一个上下文对象【从原来 2.x 中 <code>this</code> 选择性地暴露了一些 <code>property（attrs/emit/slots）</code>】</p><blockquote><p>attrs 和 slots 都是内部组件实例上对应项的代理，可以确保在更新后仍然是最新值。<br>所以可以解构，无需担心后面访问到过期的值</p></blockquote><p><strong>为什么props作为第一个参数？</strong></p><blockquote><p>组件使用 props 的场景更多，有时候甚至只使用 props<br>将 props 独立出来作为第一个参数，可以让 TypeScript 对 props 单独做类型推导，不会和上下文中的其他属性相混淆。<br>这也使得 setup 、 render 和其他使用了 TSX 的函数式组件的签名保持一致</p></blockquote><blockquote><p><code>this</code> 在 <code>setup()</code>中不可用。<br>由于 setup() 在解析 2.x 选项前被调用，setup() 中的 this 将与 2.x 选项中的 this 完全不同。<br>同时在 setup() 和 2.x 选项中使用 this 时将造成混乱</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setup(props, &#123; attrs &#125;) &#123;</span><br><span class="line">    <span class="comment">// 一个可能之后回调用的签名</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(attrs.foo) <span class="comment">// 一定是最新的引用，没有丢失响应性</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/BSzSX9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSzSX9.png" alt="BSzSX9.png"></a><br><a href="https://imgchr.com/i/BSxz6J" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSxz6J.png" alt="BSxz6J.png"></a></p><h3 id="响应式系统-API"><a href="#响应式系统-API" class="headerlink" title="响应式系统 API"></a>响应式系统 API</h3><ul><li><strong>reactive</strong></li></ul><p>desc: 接收一个普通对象然后返回该普通对象的响应式代理【等同于 2.x 的 <code>Vue.observable()</code>】</p><blockquote><p>tips:Proxy对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。<br>因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作</p></blockquote><blockquote><p>响应式转换是“深层的”：会影响对象内部所有嵌套的属性。基于 ES2015 的 Proxy 实现，返回的代理对象不等于原始对象。建议仅使用代理对象而避免依赖原始对象</p></blockquote><blockquote><p>reactive 类的 api 主要提供了将复杂类型的数据处理成响应式数据的能力，其实这个复杂类型是要在object array map set weakmap weakset 这五种之中【如下源码，他会判断是否是五类以及是否被冻结】</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> collectionTypes = <span class="keyword">new</span> Set&lt;<span class="built_in">Function</span>&gt;([Set, Map, WeakMap, WeakSet])</span><br><span class="line"><span class="keyword">const</span> isObservableType = <span class="comment">/*#__PURE__*/</span> makeMap(</span><br><span class="line">  <span class="string">'Object, Array, Map, Set, WeakMap, WeakSet'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> canObserve = (value: Target): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    !value[ReactiveFlags.SKIP] &amp;&amp;</span><br><span class="line">    isObservableType(toRawType(value)) &amp;&amp;</span><br><span class="line">    !<span class="built_in">Object</span>.isFrozen(value)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为是组合函数【对象】，所以必须始终保持对这个所返回对象的引用以保持响应性【不能解构该对象或者展开】<br>例如 <code>const { x, y } = useMousePosition()</code> 或者 <code>return { ...useMousePosition() }</code></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMousePosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pos = reactive(&#123;</span><br><span class="line">        x: <span class="number">0</span>,</span><br><span class="line">        y: <span class="number">0</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">return</span> pos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>toRefs API 用来提供解决此约束的办法——它将响应式对象的每个 property 都转成了相应的 ref【把对象转成了ref】。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">useMousePosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pos = reactive(&#123;</span><br><span class="line">        x: <span class="number">0</span>,</span><br><span class="line">        y: <span class="number">0</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">return</span> toRefs(pos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x &amp; y 现在是 ref 形式了!</span></span><br><span class="line"><span class="keyword">const</span> &#123; x, y &#125; = useMousePosition()</span><br></pre></td></tr></table></figure><ul><li><strong>ref</strong></li></ul><p>接受一个参数值并返回一个响应式且可改变的 ref 对象。<br>ref 对象拥有一个指向内部值的单一属性 .value</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> convert = &lt;T <span class="keyword">extends</span> unknown&gt;(val: T): <span class="function"><span class="params">T</span> =&gt;</span> isObject(val) ? reactive(val) :val</span><br></pre></td></tr></table></figure><p><strong>陷阱</strong><br>setup 中return返回会自动解套【在模板中不需要.value】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script &gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: ref(0)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>ref 作为 reactive 对象的 property 被访问或修改时，也将自动解套 .value</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="comment">/*当做reactive的对象属性----解套*/</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  count,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* 不需要.value*/</span></span><br><span class="line"><span class="built_in">console</span>.log(state.count) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改reactive的值*/</span></span><br><span class="line">state.count = <span class="number">1</span></span><br><span class="line"><span class="comment">/*修改了ref的值*/</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>注意如果将一个新的 ref 分配给现有的 ref， 将替换旧的 ref</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建一个新的ref*/</span></span><br><span class="line"><span class="keyword">const</span> otherCount = ref(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*赋值给reactive的旧的ref，旧的会被替换掉*/</span></span><br><span class="line">state.count = otherCount</span><br><span class="line"><span class="comment">/*修改reactive会修改otherCount*/</span></span><br><span class="line"><span class="built_in">console</span>.log(state.count) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">/*修改reactive会count没有被修改 */</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>嵌套在 reactive Object 中时，ref 才会解套。<br>从 Array 或者 Map 等原生集合类中访问 ref 时，不会自动解套【自由数据类型是Object才会解套，array  map  set   weakmap  weakset集合类 访问 ref 时，不会自动解套】</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = reactive([ref(<span class="number">0</span>)])</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>].value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = reactive(<span class="keyword">new</span> Map([[<span class="string">'foo'</span>, ref(<span class="number">0</span>)]]))</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'foo'</span>).value)</span><br></pre></td></tr></table></figure><p><strong>心智负担上 ref   vs  reactive</strong></p><p>在普通 JavaScript 中区别声明基础类型变量与对象变量时一样区别使用 ref 和 reactive<br>所有的地方都用 reactive，然后记得在组合函数返回响应式对象时使用 toRefs。<br>这降低了一些关于 ref 的心智负担</p><ul><li><strong>readonly</strong><br>传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。<br>一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的【返回一个永远不会变的只读代理】【场景可以参数比对等】<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = reactive(&#123; count: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = readonly(original)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 依赖追踪</span></span><br><span class="line">  <span class="built_in">console</span>.log(copy.count)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// original 上的修改会触发 copy 上的侦听</span></span><br><span class="line">original.count++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法修改 copy 并会被警告</span></span><br><span class="line">copy.count++ <span class="comment">// warning!</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="reactive响应式系统工具集"><a href="#reactive响应式系统工具集" class="headerlink" title="reactive响应式系统工具集"></a>reactive响应式系统工具集</h3><ul><li><p><strong>isProxy</strong></p><blockquote><p>检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</p></blockquote></li><li><p><strong>isReactive</strong><br>检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, isReactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      name: <span class="string">'John'</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(state)) <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><p>如果这个代理是由 <code>readonly</code> 创建的，但是又被 <code>reactive</code> 创建的另一个代理包裹了一层，那么同样也会返回 <code>true</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, isReactive, readonly &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      name: <span class="string">'John'</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// 用readonly创建一个只读响应式对象plain</span></span><br><span class="line"><span class="keyword">const</span> plain = readonly(&#123;</span><br><span class="line">    name: <span class="string">'Mary'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//readonly创建的，所以isReactive为false</span></span><br><span class="line"><span class="built_in">console</span>.log(isReactive(plain)) <span class="comment">// -&gt; false  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive创建的响应式代理对象包裹一层readonly,isReactive也是true,isReadonly也是true</span></span><br><span class="line"><span class="keyword">const</span> stateCopy = readonly(state)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(stateCopy)) <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>isReadonly</strong><br>检查一个对象是否是由 <code>readonly</code> 创建的只读代理</p></li></ul><h3 id="reactive高级响应式系统API"><a href="#reactive高级响应式系统API" class="headerlink" title="reactive高级响应式系统API"></a>reactive高级响应式系统API</h3><ul><li><strong>toRaw</strong></li></ul><blockquote><p>返回由 <code>reactive</code> 或 <code>readonly</code> 方法转换成响应式代理的普通对象。<br>这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发更改。<br>不建议一直持有原始对象的引用【<strong>不建议赋值给任何变量</strong>】。请谨慎使用</p></blockquote><p>被<code>toRaw</code>之后的对象是没有被代理/跟踪的的普通对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> reactiveFoo = reactive(foo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(toRaw(reactiveFoo) === foo) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(toRaw(reactiveFoo) !== reactiveFoo) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>markRaw</strong><br>显式标记一个对象为“永远不会转为响应式代理”，函数返回这个对象本身。</li></ul><p>【<code>markRaw</code>传入对象，返回的值是永远不会被转为响应式代理的】</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = markRaw(&#123;</span><br><span class="line">    name: <span class="string">'Mary'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(reactive(foo))) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>被 <code>markRaw</code> 标记了，即使在响应式对象中作属性，也依然不是响应式的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = reactive(&#123; foo &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(bar.foo)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong><code>markRaw</code>注意点</strong></p><p><code>markRaw</code>和<code>shallowXXX</code> 一族的 API允许选择性的覆盖reactive或者readonly 默认创建的 “深层的” 特性【响应式】/或者使用无代理的普通对象</p><p>设计这种「浅层读取」有很多原因</p><blockquote><p>一些值的实际上的用法非常简单，并没有必要转为响应式【例如三方库的实例/省市区json/Vue组件对象】<br>当渲染一个元素数量庞大，但是数据是不可变的，跳过 Proxy 的转换可以带来性能提升</p></blockquote><blockquote><p>这些 API 被认为是高级的，是因为这种特性仅停留在根级别，所以如果你将一个嵌套的，没有 markRaw 的对象设置为 reactive 对象的属性，在重新访问时，你又会得到一个 Proxy 的版本<br>在使用中最终会导致标识混淆的严重问题：执行某个操作同时依赖于某个对象的原始版本和代理版本（标识混淆在一般使用当中应该是非常罕见的<br>但是要想完全避免这样的问题，必须要对整个响应式系统的工作原理有一个相当清晰的认知）</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = markRaw(&#123;</span><br><span class="line">  nested: &#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = reactive(&#123;</span><br><span class="line">  <span class="comment">// 尽管 `foo` 己经被标记为 raw 了, 但 foo.nested 并没有</span></span><br><span class="line">  nested: foo.nested,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.nested === bar.nested) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>foo.nested没有被标记为(永远不会转为响应式代理)，导致最后的值一个reactive</p><p><a href="https://imgchr.com/i/BplWNV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BplWNV.png" alt="BplWNV.png"></a></p><ul><li><strong>shallowReactive</strong><br>只为某个对象的私有（第一层）属性创建浅层的响应式代理，不会对“属性的属性”做深层次、递归地响应式代理，而只是保留原样【第一层是响应式代理，深层次只保留原样(不具备响应式代理)】<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowReactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  nested: &#123;</span><br><span class="line">    bar: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变更 state 的自有属性是响应式的【第一层次响应式】</span></span><br><span class="line">state.foo++</span><br><span class="line"><span class="comment">// ...但不会深层代理【深层次不是响应式】(渲染性能)</span></span><br><span class="line">isReactive(state.nested) <span class="comment">// false</span></span><br><span class="line">state.nested.bar++ <span class="comment">// 非响应式</span></span><br></pre></td></tr></table></figure></li></ul><p>shallowReadonly<br>类似于shallowReactive，区别是：</p><p>第一层将会是响应式代理【第一层修改属性会失败】，属性为响应式<br>深层次的对象属性可以修改，属性不是响应式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowReadonly(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  nested: &#123;</span><br><span class="line">    bar: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变更 state 的自有属性会失败</span></span><br><span class="line">state.foo++</span><br><span class="line"><span class="comment">// ...但是嵌套的对象是可以变更的</span></span><br><span class="line">isReadonly(state.nested) <span class="comment">// false</span></span><br><span class="line">state.nested.bar++ <span class="comment">// 嵌套属性依然可修改</span></span><br></pre></td></tr></table></figure><h3 id="ref-响应式系统工具集"><a href="#ref-响应式系统工具集" class="headerlink" title="ref 响应式系统工具集"></a><code>ref</code> 响应式系统工具集</h3><ul><li><p><strong>unref</strong><br><code>unref</code>是<code>val = isRef(val) ? val.value : val</code> 的语法糖</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unref(ref(<span class="number">0</span>))===unref(<span class="number">0</span>)===<span class="number">0</span>   返回<span class="built_in">number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFoo</span>(<span class="params">x: <span class="built_in">number</span> | Ref&lt;<span class="built_in">number</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unwrapped = unref(x) <span class="comment">// unwrapped 一定是 number 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>toRef</strong></p></li></ul><p><code>toRef</code> 可以用来为一个 <code>reactive</code> 对象的属性【某个属性区别toRefs每一个属性】创建一个 ref。<br>这个 ref 可以被传递并且能够保持响应性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//reactive获取单个属性转为ref【fooRef只是一个代理】</span></span><br><span class="line"><span class="keyword">const</span> fooRef = toRef(state, <span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line">fooRef.value++</span><br><span class="line"><span class="built_in">console</span>.log(state.foo) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">state.foo++</span><br><span class="line"><span class="built_in">console</span>.log(fooRef.value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li><strong>toRefs</strong><br>把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stateAsRefs = toRefs(state)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">stateAsRefs 的类型如下:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  foo: Ref&lt;number&gt;,</span></span><br><span class="line"><span class="comment">  bar: Ref&lt;number&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ref 对象 与 原属性的引用是 "链接" 上的</span></span><br><span class="line">state.foo++</span><br><span class="line"><span class="built_in">console</span>.log(stateAsRefs.foo) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">stateAsRefs.foo.value++</span><br><span class="line"><span class="built_in">console</span>.log(state.foo) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><p>可以通过<code>toRefs</code>返回可解构的reactive，因为<code>toRefs</code>包裹之后返回一一对应的ref属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFeatureX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 state 的逻辑操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回时将属性都转为 ref</span></span><br><span class="line">  <span class="keyword">return</span> toRefs(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// 可以解构，不会丢失响应性</span></span><br><span class="line">    <span class="keyword">const</span> &#123; foo, bar &#125; = useFeatureX()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo,</span><br><span class="line">      bar,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>isRef</strong><br>检查一个值是否为一个 ref 对象</li></ul><h3 id="ref-高级响应式系统API"><a href="#ref-高级响应式系统API" class="headerlink" title="ref 高级响应式系统API"></a>ref 高级响应式系统API</h3><ul><li><strong>customRef</strong><br>用于自定义一个 ref，可以显式地控制依赖追踪和触发响应，接受一个工厂函数，两个参数分别是用于追踪的 track 与用于触发响应的 trigger，并返回一个一个带有 get 和 set 属性的对象【实际上就是手动 track追踪 和 trigger触发响应】</li></ul><p>以下代码可以使得v-model防抖</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebouncedRef</span>(<span class="params">value, delay = 200</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> customRef(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="comment">/*初始化手动追踪依赖讲究什么时候去触发依赖收集*/</span></span><br><span class="line">        track()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">          <span class="comment">/*修改数据的时候会把上一次的定时器清除【防抖】*/</span></span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">/*把新设置的数据给到ref数据源*/</span></span><br><span class="line">          value = newValue</span><br><span class="line">            <span class="comment">/*再有依赖追踪的前提下触发响应式*/</span></span><br><span class="line">          trigger()</span><br><span class="line">        &#125;, delay)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setup() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">/*暴露返回的数据加防抖*/</span></span><br><span class="line">      text: useDebouncedRef(<span class="string">'hello'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>shallowRef</strong><br>创建一个 ref ，将会追踪它的 .value 更改操作，但是并不会对变更后的 .value 做响应式代理转换（即变更不会调用 reactive）</li></ul><p>前面我们说过如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换,通过shallowRef创建的ref,将不会调用reactive【对象不会是响应式的】</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refOne = shallowRef(&#123;&#125;);</span><br><span class="line">refOne.value = &#123; id: <span class="number">1</span> &#125;;</span><br><span class="line">refOne.id == <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(refOne.value),refOne.value);<span class="comment">//false  &#123; id: 1 &#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>triggerRef 【与shallowRef配合】</strong><br>手动执行与shallowRef相关的任何效果<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallow = shallowRef(&#123;</span><br><span class="line">  greet: <span class="string">'Hello, world'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次运行打印 "Hello, world" </span></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(shallow.value.greet)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这不会触发效果，因为ref是shallow</span></span><br><span class="line">shallow.value.greet = <span class="string">'Hello, universe'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 "Hello, universe"</span></span><br><span class="line">triggerRef(shallow)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Computed-and-watch【监控变化】"><a href="#Computed-and-watch【监控变化】" class="headerlink" title="Computed and watch【监控变化】"></a>Computed and watch【监控变化】</h3><ul><li><strong>computed</strong><br>传入一个 getter 函数，返回一个<strong>默认不可手动修改的 ref 对象</strong>【默认传入的是get函数的对象】</li></ul><p>传入一个拥有 <code>get</code> 和 <code>set</code> 函数的对象，创建一个可手动修改的计算状态</p><p><a href="https://imgchr.com/i/Bp8RAI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/Bp8RAI.png" alt="Bp8RAI.png"></a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="comment">/*不支持修改【只读的】 */</span></span><br><span class="line"><span class="keyword">const</span> plusOne = computed(<span class="function"><span class="params">()</span> =&gt;</span> count.value + <span class="number">1</span>)</span><br><span class="line">plusOne.value++ <span class="comment">// 错误！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*【可更改的】 */</span></span><br><span class="line"><span class="keyword">const</span> plusOne = computed(&#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> count.value + <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">set</span>: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    count.value = val - <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plusOne.value = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li><strong>watchEffect</strong><br>立即执行传入的一个函数，并响应式追踪其依赖，并在<strong>其依赖变更时重新运行该函数</strong></li></ul><p>computed与watchEffect区别：</p><blockquote><p>computed计算属性可通过setup return，再模板中使用，watchEffect不能；<br>computed可以使用多个，并且对多个属性进行不同的响应计算，watchEffect会存在副作用</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"><span class="comment">// -&gt; 打印出 0</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="comment">// -&gt; 打印出 1</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><strong>停止观察</strong></p><p>当在组件的setup()函数或生命周期钩子期间调用watchEffect时，监视程序会链接到组件的生命周期，并在卸载组件时自动停止</p><p>一般情况下watchEffect返回可以stop 操作，停止监听程序</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止监听程序</span></span><br><span class="line">stop()</span><br></pre></td></tr></table></figure><p><strong>副作用(函数式编程)</strong><br>一个带有副作用的函数不仅只是简单的返回一个值，还干了一些其他的事情，比如:</p><blockquote><p>修改一个变量<br>直接修改数据结构<br>设置一个对象的成员<br>抛出一个异常或以一个错误终止<br>打印到终端或读取用户的输入<br>读取或写入一个文件<br>在屏幕上绘画</p></blockquote><p>buyCoffee的例子(p3)：<br>函数只不过是需要返回一杯咖啡，可是却对费用进行了持久化操作（产生副作用），我们可以在buyCoffee方法返回咖啡时也把费用作为值一并返回，将费用这条记录交给其他程序来做持久化，以此来去除副作用<br>通过把这些副作用推到程序的外层，来转换任何带有副作用的函数（纯的内核和一层很薄的外围来处理副作用）</p><p>如果一个函数内外有依赖于外部变量或者环境时，常常我们称之为其有副作用<br>如果我们仅通过函数签名不打开内部代码检查并不能知道该函数在干什么，作为一个独立函数我们期望有明确的输入和输出，副作用是bug的发源地<br>作为程序员开发者应尽量少的开发有副作用的函数或方法，副作用也使得方法通用性下降不适合扩展和可重用性</p><p><strong>清除副作用</strong><br><code>[^]: watchEffect</code>函数都是副作用<br>在一些时候监听函数将执行异步副作用【一个响应式依赖被修改了，会做其他事情】，这些响应需要在其失效时清除(例如在效果完成前状态改变)。<br>effect函数接收一个onInvalidate 函数作入参， 用来注册清理失效时的回调。<br>这个 invalidation函数 在什么时候会被调用：</p><blockquote><p>监听函数重新被执行的时候【响应式依赖的数据被修改】</p></blockquote><blockquote><p>监听停止的时候（如果watchEffect在setup()或者生命周期函数中被使用的时候组件会被卸载）【停止观察】</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*这是个异步操作*/</span></span><br><span class="line">  <span class="keyword">const</span> token = performAsyncOperation(id.value)<span class="comment">//id依赖</span></span><br><span class="line">  onInvalidate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// id被修改了或者监听停止了会触发token.cancel()事件【这块区域的代码】.</span></span><br><span class="line">    <span class="comment">// 这里是异步事件的话，前面的peding的异步操作无效【这里的异步事件只执行一次】</span></span><br><span class="line">     token.cancel()<span class="comment">/*异步操作*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'onInvalidate'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从上面看：我们之所以是通过传入一个函数去注册失效回调，而不是从回调返回它，是因为返回值对于异步错误处理很重要</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = ref(<span class="literal">null</span>)</span><br><span class="line">watchEffect(<span class="keyword">async</span> onInvalidate =&gt; &#123;</span><br><span class="line">  onInvalidate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;) <span class="comment">// 我们在Promise的resolves之前注册清理函数(cleanup function)</span></span><br><span class="line">  data.value = <span class="keyword">await</span> fetchData(props.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们知道异步函数都会隐式地返回一个 Promise，但是<strong>清理副作用的函数</strong>必须要在 Promise 被 resolve <strong>之前被注册</strong>。<br>另外，Vue 依赖这个返回的 Promise 来自动处理 Promise 链上的潜在错误</p><p><strong>副作用刷新时机</strong><br>Vue 的响应式系统会<strong>缓存副作用函数</strong>，并异步地刷新它们，这样可以避免同一个 tick 中多个状态改变导致的不必要的重复调用。<br>在核心的具体实现中, 组件的更新函数也是一个被侦听的副作用。<br>当一个用户定义的副作用函数进入队列时, 会在<strong>所有的组件更新后执行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      const count &#x3D; ref(0)</span><br><span class="line"></span><br><span class="line">      watchEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(count.value)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return &#123;</span><br><span class="line">        count,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>count</code> 会在初始运行时同步打印出来</p><p>更改 <code>count</code> 时，将在组件更新后执行副作用</p><p>初始化运行是在组件 mounted 之前执行的【你希望在编写副作用函数时访问 DOM（或模板 ref），请在 onMounted 钩子中进行】</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里可以访问到 DOM 或者 template refs</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果副作用需要同步或在组件更新之前重新运行，我们可以传递一个拥有 flush 属性的对象作为选项（默认为 ‘post’）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步运行</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">'sync'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件更新前执行</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">'pre'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>侦听器调试【响应式调试用的】</strong></p><p><code>onTrack</code> 和 <code>onTrigger</code> 选项可用于调试一个侦听器的行为。</p><p>当一个 reactive 对象属性或一个 ref 作为依赖被追踪时，将调用 <code>onTrack</code>【调用次数为被追踪的数量】<br>依赖项变更会导致重新追踪依赖，从而<code>onTrack</code>被调用【调用次数为被追踪的数量】<br>依赖项变更导致副作用被触发时，将调用 <code>onTrigger</code></p><p>这两个回调都将接收到一个包含有关所依赖项信息的调试器事件。<br>建议在以下回调中编写 debugger 语句来检查依赖关系:【<code>onTrack</code> 和 <code>onTrigger</code> 仅在开发模式下生效】</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">/* 副作用的内容 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    onTrigger(e) &#123;</span><br><span class="line">      <span class="comment">/*副作用依赖修改*/</span></span><br><span class="line">      debugger</span><br><span class="line">    &#125;,</span><br><span class="line">    onTrack(e) &#123;</span><br><span class="line">      <span class="comment">/*副作用依赖修改*/</span></span><br><span class="line">      debugger</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/BpUGjK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BpUGjK.png" alt="BpUGjK.png"></a></p><ul><li><strong>watch</strong><br>watch API 完全等效于 2.x watch 中相应的选项。<br>watch 需要侦听特定的数据源，并在回调函数中执行副作用【默认情况是懒执行的，也就是说仅在侦听的源变更时才执行回调】</li></ul><p>watch允许我们:</p><blockquote><p>懒执行副作用<br>更明确哪些状态的改变会触发侦听器重新运行副作用<br>访问侦听状态变化前后的值</p></blockquote><p><strong>侦听单个数据源</strong><br>侦听器的数据源可以是一个拥有返回值的 getter 函数，也可以是 ref:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 侦听一个 getter</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; count: <span class="number">0</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接侦听一个 ref</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>侦听多个数据源</strong></p><p>watcher 也可以使用数组来同时侦听多个源</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>与 <code>watchEffect</code> 共享的行为</strong><br>watch 和 watchEffect 在停止侦听, 清除副作用 (相应地 onInvalidate 会作为回调的第三个参数传入)，副作用刷新时机 和 侦听器调试 等方面行为一致</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">watch([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar],onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  onInvalidate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    onTrigger(e) &#123;</span><br><span class="line">      <span class="comment">/*副作用依赖修改*/</span></span><br><span class="line">      debugger</span><br><span class="line">    &#125;,</span><br><span class="line">    onTrack(e) &#123;</span><br><span class="line">      <span class="comment">/*副作用依赖修改*/</span></span><br><span class="line">      debugger</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><ul><li><strong>与 2.x 版本生命周期相对应的组合式 API</strong></li></ul><blockquote><p><del>beforeCreate</del> -&gt; 使用 setup()<br><del>created</del> -&gt; 使用 setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>errorCaptured -&gt; onErrorCaptured</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUpdated, onUnmounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">setup() &#123;</span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'mounted!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    onUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'updated!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'unmounted!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这些生命周期钩子注册函数只能在 <code>setup()</code> 期间同步使用， 因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 <code>setup()</code> 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。</p><p>组件实例上下文也是在生命周期钩子同步执行期间设置的，因此，在卸载组件时，在生命周期钩子内部同步创建的侦听器和计算状态也将自动删除。</p><ul><li><strong>新增的钩子函数</strong><br>除了和 2.x 生命周期等效项之外，组合式 API 还提供了以下调试钩子函数：</li></ul><blockquote><p><strong>onRenderTracked</strong><br><strong>onRenderTriggered</strong></p></blockquote><p>两个钩子函数都接收一个 <code>DebuggerEvent</code>，与 <code>watchEffect</code> 参数选项中的 <code>onTrack</code> 和 <code>onTrigger</code> 类似:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  onRenderTracked(e)&#123;</span><br><span class="line">      debugger</span><br><span class="line">    <span class="comment">// 检查有响应和追踪的依赖性</span></span><br><span class="line"> &#125;,</span><br><span class="line">  onRenderTriggered(e) &#123;</span><br><span class="line">    debugger</span><br><span class="line">    <span class="comment">// 检查哪个依赖性导致组件重新渲染</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue提供的内置组件"><a href="#Vue提供的内置组件" class="headerlink" title="Vue提供的内置组件"></a>Vue提供的内置组件</h3><ul><li><strong>component 与Vue2.x一致</strong><br>渲染一个“元组件”为动态组件。依 <code>is</code> 的值，来决定哪个组件被渲染。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态组件由 vm 实例的 `componentId` property 控制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"componentId"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"$options.components.child"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>transition 与 Vue2.x 【基本】 一致有差异</strong></li></ul><p><strong>Props新增：</strong><br><code>persisted - boolean</code> 如果为<code>true</code>，则表示这是一个转换，实际上不会插入/删除元素，而是切换显示/隐藏状态。<br><code>transition</code> 过渡挂钩被注入，但会被渲染器跳过。<br>相反，自定义指令可以通过调用注入的钩子（例如v-show）来控制过渡</p><blockquote><p><del>enter-class</del>—–&gt;enter-from-class<br><del>leave-class</del>—–&gt;leave-from-class</p></blockquote><p><strong>事件</strong></p><blockquote><p><del>before-appear</del></p></blockquote><ul><li><p><strong>transition-group 与 Vue2.x 一致</strong></p></li><li><p><strong>slot 与 Vue2.x 一致</strong></p></li><li><p><strong>teleport 【新增组件】</strong></p></li></ul><p><strong>Props</strong></p><p><code>to - string</code> 必填属性，必须是一个有效的query选择器，或者是元素(如果在浏览器环境中使用）中的内容将会被放置到指定的目标元素中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"#some-id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">".some-class"</span> /&gt;</span></span><br><span class="line"> /*元素*/</span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"[data-teleport]"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"h1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"some-string"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>disabled  - boolean</code> 这是一个可选项 ，做一个是可以用来禁用的功能，这意味着它的插槽内容不会移动到任何地方，而是按没有teleport组件一般来呈现【默认为false】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"#popup"</span> <span class="attr">:disabled</span>=<span class="string">"displayVideoInline"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>999999<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>，这将移动实际的DOM节点，而不是销毁和重新创建，并且还将保持任何组件实例是活动的。<br>所有有状态HTML元素(比如一个正在播放的视频)将保持它们的状态。<br>【控制displayVideoInline并不是销毁重建，它保持实例是存在的，不会被注销】</p><p><strong>关于Teleport 其他内容</strong></p><p>Vue鼓励我们通过将UI和相关行为封装到组件中来构建UI。<br>我们可以将它们彼此嵌套在一起，以构建构成应用程序UI的树</p><p>但是，有时组件模板的一部分逻辑上属于这个组件，而从技术角度来看，最好将这一部分模板移到DOM中的其他地方，放到Vue应用程序之外</p><p>一个常见的场景是创建一个包含全屏模态的组件。<br>在大多数情况下，您希望模态的逻辑驻留在组件中，但是模态框的定位问题很快就很难通过CSS解决，或者需要更改组件的组成</p><p>考虑下面的HTML结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Tooltips with Vue 3 Teleport<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">modal-button</span>&gt;</span><span class="tag">&lt;/<span class="name">modal-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>让我们看看 <code>mode -button</code></p><p>该组件将有一个<code>button</code>元素来触发模态的打开，还有一个div元素，其类为.modal，它将包含模态的内容和一个自关闭按钮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const app &#x3D; Vue.createApp(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">app.component(&#39;modal-button&#39;, &#123;</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;button @click&#x3D;&quot;modalOpen &#x3D; true&quot;&gt;</span><br><span class="line">        Open full screen modal!</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div v-if&#x3D;&quot;modalOpen&quot; class&#x3D;&quot;modal&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        I&#39;m a modal! </span><br><span class="line">        &lt;button @click&#x3D;&quot;modalOpen &#x3D; false&quot;&gt;</span><br><span class="line">          Close</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123; </span><br><span class="line">      modalOpen: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当在初始HTML结构中使用这个组件时，我们可以看到一个问题——模态被呈现在深嵌套的div中，模态的绝对位置以父div相对位置作为参考。</p><p><a href="https://imgchr.com/i/BpdckQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BpdckQ.png" alt="BpdckQ.png"></a><br><a href="https://imgchr.com/i/BpdyTg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BpdyTg.png" alt="BpdyTg.png"></a></p><p>Teleport提供了一种干净的方式，允许我们控制DOM中希望在哪个父节点下呈现HTML片段，而不必诉诸全局状态或将其拆分为两个组件。</p><p>让我们修改我们的modal-button来使用并告诉Vue “teleport this HTML to the “body”标签”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.component(&#39;modal-button&#39;, &#123;</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;button @click&#x3D;&quot;modalOpen &#x3D; true&quot;&gt;</span><br><span class="line">        Open full screen modal! (With teleport!)</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;teleport to&#x3D;&quot;body&quot;&gt;</span><br><span class="line">      &lt;div v-if&#x3D;&quot;modalOpen&quot; class&#x3D;&quot;modal&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          I&#39;m a teleported modal! </span><br><span class="line">          (My parent is &quot;body&quot;)</span><br><span class="line">          &lt;button @click&#x3D;&quot;modalOpen &#x3D; false&quot;&gt;</span><br><span class="line">            Close</span><br><span class="line">          &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;teleport&gt;</span><br><span class="line">  &#96;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123; </span><br><span class="line">      modalOpen: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/BpdImT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BpdImT.png" alt="BpdImT.png"></a><br><a href="https://imgchr.com/i/Bpd4XV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/Bpd4XV.png" alt="Bpd4XV.png"></a></p><p><strong>与Vue组件一起使用</strong></p><p>如果包含一个Vue组件，它将仍然是的父组件的逻辑子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const app &#x3D; Vue.createApp(&#123;</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;h1&gt;Root instance&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;parent-component &#x2F;&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.component(&#39;parent-component&#39;, &#123;</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;h2&gt;This is a parent component&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;teleport to&#x3D;&quot;#endofbody&quot;&gt;</span><br><span class="line">      &lt;child-component name&#x3D;&quot;John&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;teleport&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.component(&#39;child-component&#39;, &#123;</span><br><span class="line">  props: [&#39;name&#39;],</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div&gt;Hello, &#123;&#123; name &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这种情况下，即使在不同的地方呈现child-component，它仍将是parent-componen的子组件【而不是爷爷组件】，并将从其父组件接收一个name 的props</p><p>这也意味着来自父组件的注入如预期的那样工作，并且子组件将嵌套在Vue Devtools的父组件之下，而不是放在实际内容移动到的地方</p><p><strong>对同一目标使用多次teleports</strong><br>一个常见的用例场景是一个可重用的组件，该组件可能同时有多个活动实例。<br>对于这种场景，多个组件可以将它们的内容挂载到相同的目标元素。<br>这个顺序将是一个简单的附加—稍后的挂载将位于目标元素中较早的挂载之后。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"#modals"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"#modals"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- result--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"modals"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖注入Provide-Inject"><a href="#依赖注入Provide-Inject" class="headerlink" title="依赖注入Provide / Inject"></a>依赖注入Provide / Inject</h3><p>provide 和 inject 提供依赖注入，功能类似 2.x 的 provide/inject。<br>两者都只能在当前活动组件实例的 setup() 中调用</p><p>例如，如果我们想在根组件上提供一个book name，并将其inject到子组件上</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide, inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RootComponent = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    provide(<span class="string">'book'</span>, <span class="string">'Vue 3 guide'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyBook = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> book = inject(</span><br><span class="line">      <span class="string">'book'</span>,</span><br><span class="line">      <span class="string">'Eloquent Javascript'</span> <span class="comment">/* 选项的默认值，假如父组件不提供值就返回默认 */</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      book</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inject 接受一个可选的的默认值作为第二个参数。<br>如果未提供默认值，并且在 provide 上下文中未找到该属性，则 inject 返回 undefined。</p><p>如果我们需要提供或注入多个值，我们可以通过随后分别调用provide或inject来实现【多次调用】</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide, inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RootComponent = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    provide(<span class="string">'book'</span>, <span class="string">'Vue 3 guide'</span>)</span><br><span class="line">    provide(<span class="string">'year'</span>, <span class="string">'2020'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyBook = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> book = inject(</span><br><span class="line">      <span class="string">'book'</span>,</span><br><span class="line">      <span class="string">'Eloquent Javascript'</span> <span class="comment">/* 选项的默认值，假如父组件不提供值就返回默认 */</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> year = inject(<span class="string">'year'</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      book,</span><br><span class="line">      year</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注入的响应性</strong><br>可以使用 ref 或 reactive 来保证 provided 和 injected 之间值的响应<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供者</span></span><br><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> book = reactive(&#123;</span><br><span class="line">    title: <span class="string">'Vue 3 Guide'</span>,</span><br><span class="line">    author: <span class="string">'Vue Team'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> year = ref(<span class="string">'2020'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*提供reactive响应式*/</span></span><br><span class="line">  provide(<span class="string">'book'</span>, book)</span><br><span class="line"> <span class="comment">/*提供ref响应式*/</span></span><br><span class="line">  provide(<span class="string">'year'</span>, year)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> book = inject(<span class="string">'book'</span>)</span><br><span class="line">  <span class="keyword">const</span> year = inject(<span class="string">'year'</span>)</span><br><span class="line"> <span class="comment">/*响应式*/</span></span><br><span class="line">  <span class="keyword">return</span> &#123; book, year &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>现在，当提供者组件上的book或year发生变化时，我们可以观察到它们在注入的组件上的变化。</li></ul><blockquote><p><strong>警告</strong>:我们不建议改变一个被注入的反应性属性【子组件去修改数据流】，因为它会破坏Vue的单向数据流。<br>相反，尝试在提供值【父组件去修改】的地方改变值，或者提供一个方法来改变值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in provider</span></span><br><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> book = reactive(&#123;</span><br><span class="line">    title: <span class="string">'Vue 3 Guide'</span>,</span><br><span class="line">    author: <span class="string">'Vue Team'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBookName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    book.title = <span class="string">'Vue 3 Advanced Guide'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provide(<span class="string">'book'</span>, book)</span><br><span class="line">  provide(<span class="string">'changeBookName'</span>, changeBookName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in consumer</span></span><br><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> book = inject(<span class="string">'book'</span>)</span><br><span class="line">  <span class="keyword">const</span> changeBookName = inject(<span class="string">'changeBookName'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; book, changeBookName &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>v-text 【Vue2.x一致】</li><li>v-html【Vue2.x一致】</li><li>v-show【Vue2.x一致】</li><li>v-if【Vue2.x一致】</li><li>v-else【Vue2.x一致】</li><li>v-else-if【Vue2.x一致】</li><li>v-for【Vue2.x一致】</li><li>v-on【Vue2.x一致】</li><li>v-model【Vue2.x一致】</li><li>v-slot【Vue2.x一致】</li><li>v-cloak【Vue2.x一致】</li><li>v-once 【Vue2.x一致】</li><li>v-pre【Vue2.x一致】</li><li><strong>v-bind 【Vue2.x 修饰符差异】</strong></li></ul><p><strong>修饰符</strong></p><blockquote><p><del>.prop</del> 去除<br><del>.sync</del> 去除<br>.camel 将 kebab-case attribute 名转换为 camelCase</p></blockquote><ul><li><strong>v-is【新增】</strong></li></ul><p><strong>注意</strong>:本节只影响在页面的HTML中直接编写Vue模板的情况<br>限制：原生html元素<br>使用：<br>使用in-DOM模板时，该模板应遵守本机HTML解析规则。 某些HTML元素对可以在其中显示哪些元素有限制，而某些元素（例如，和）只能 出现在某些其他元素内。 解决方法是，我们可以在这些元素上使用v-is指令【作用就是转成组件的名字】</p><blockquote><p><strong>警告</strong>：<code>v-is</code> 功能 像一个动态2.x <code>:is</code> 绑定 所以要根据注册的名称渲染组件，它的值应该是一个JavaScript字符串</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不正确的, 不会出现任何渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-is</span>=<span class="string">"blog-post-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-is</span>=<span class="string">"'blog-post-row'"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/Bpwovt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/Bpwovt.png" alt="Bpwovt.png"></a></p><h3 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h3><ul><li><strong>createApp</strong></li></ul><p>返回一个应用程序实例,提供了一个应用程序上下文。应用程序实例挂载的整个组件树共享相同的上下文</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br></pre></td></tr></table></figure><p><strong>参数</strong><br>该函数接收一个根组件选项对象作为第一个参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;...&#125;,</span><br><span class="line">  computed: &#123;...&#125;</span><br><span class="line">  setup()&#123;...&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用第二个参数，我们可以将根组件props 传递给应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;!-- 这里将会显示 &#39;Evan&#39; --&gt;</span><br><span class="line">  &#123;&#123; username &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">const app &#x3D; Vue.createApp(</span><br><span class="line">  &#123;</span><br><span class="line">    props: [&#39;username&#39;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; username: &#39;Evan&#39; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Data &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: unknown</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> CreateAppFunction&lt;HostElement&gt; = (</span><br><span class="line">  rootComponent: PublicAPIComponent,</span><br><span class="line">  rootProps?:Data | <span class="literal">null</span></span><br><span class="line">) =&gt; App&lt;HostElement&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>h</strong></li></ul><p>返回“虚拟节点”，通常缩写为<code>VNode</code>:一个简单的对象，它包含描述Vue应该在页面上渲染何种类型的节点的信息，包括对任何子节点的描述。你可以手动阅读render functions</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> Vue.h(<span class="string">'h1'</span>, &#123;&#125;, <span class="string">'Some title'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数</strong><br>接受三个参数tag, props and children</p><p><code>tag</code>: </p><blockquote><p>类型：String | Object | Function | null<br>详情:一个HTML标签名，一个组件，一个异步组件或null。使用null将渲染成注释。此参数是必需的</p></blockquote><p><code>props</code></p><blockquote><p>类型:Object<br>详情:模板中使用的attributes、props 和events 对应的对象。可选</p></blockquote><p><code>children</code></p><blockquote><p>类型: String | Array | Object</p></blockquote><blockquote><p>详情：Children VNodes，使用h()构建，或使用字符串来获取“text VNodes”或带有槽的对象。可选</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aaa = &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    someProp: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props, <span class="string">"dsadasdasddasds"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> h(</span><br><span class="line">      <span class="string">"h2"</span>,</span><br><span class="line">        <span class="comment">// &#123;Object&#125;props</span></span><br><span class="line">        <span class="comment">//与props，attributes和events相对应的对象</span></span><br><span class="line">        <span class="comment">//我们将在template中使用。</span></span><br><span class="line">        <span class="comment">// 可选的。</span></span><br><span class="line">        &#123;style: &#123;<span class="string">"font-size"</span>: <span class="string">"20px"</span>,</span><br><span class="line">          color: <span class="string">"#136"</span>&#125;&#125;,</span><br><span class="line">          [<span class="keyword">this</span>.someProp,<span class="keyword">this</span>.$slots.default()]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">app.component(<span class="string">"anchored-heading"</span>, &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> h(</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // &#123;String | Object | Function | null&#125;标签</span></span><br><span class="line"><span class="comment">        // HTML标记名称，组件，异步组件或null。</span></span><br><span class="line"><span class="comment">        //使用null将渲染注释。</span></span><br><span class="line"><span class="comment">        //必填</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="string">"h"</span> + <span class="keyword">this</span>.level, <span class="comment">// tag name</span></span><br><span class="line">        <span class="comment">// &#123;Object&#125;props</span></span><br><span class="line">        <span class="comment">//与props，attributes和events相对应的对象</span></span><br><span class="line">        <span class="comment">//我们将在template中使用。</span></span><br><span class="line">        <span class="comment">// 可选的。</span></span><br><span class="line">      &#123;&#125;, </span><br><span class="line">        <span class="comment">// &#123;String | Array | Object&#125; children</span></span><br><span class="line">        <span class="comment">//使用`h（）`构建的子级VNode，</span></span><br><span class="line">        <span class="comment">//或使用字符串获取“文本VNodes”或</span></span><br><span class="line">        <span class="comment">//具有插槽的对象。</span></span><br><span class="line">        <span class="comment">// 可选的。</span></span><br><span class="line">      [</span><br><span class="line">        <span class="string">"Some text comes first."</span>,</span><br><span class="line">        h(<span class="string">"h1"</span>, <span class="string">"A headline"</span>),</span><br><span class="line">        h(aaa, &#123;</span><br><span class="line">          someProp: <span class="string">"foobar"</span></span><br><span class="line">        &#125;)</span><br><span class="line">      ]  );&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/Bp0vdO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/Bp0vdO.png" alt="Bp0vdO.png"></a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.h(</span><br><span class="line">   <span class="string">'a'</span>,</span><br><span class="line">   &#123;</span><br><span class="line">     name: headingId,</span><br><span class="line">     href: <span class="string">'#'</span> + headingId</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="keyword">this</span>.$slots.default()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>限制：VNodes 必须独一无二</strong></p><p>组件树中的所有vnode必须是唯一的。这意味着下面的渲染函数是无效的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">const</span> myParagraphVNode = Vue.h(<span class="string">'p'</span>, <span class="string">'hi'</span>)</span><br><span class="line">     <span class="keyword">return</span> Vue.h(<span class="string">'div'</span>, [</span><br><span class="line">       <span class="comment">// 表示惊讶 - 副本复制 VNodes!</span></span><br><span class="line">       myParagraphVNode, myParagraphVNode</span><br><span class="line">     ])</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果您确实想多次复制相同的元素/组件，则可以使用工厂函数进行复制。 例如，以下呈现函数是呈现20个相同段落的完美有效方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> Vue.h(<span class="string">'div'</span>,</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123; length: <span class="number">20</span> &#125;).map(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Vue.h(<span class="string">'p'</span>, <span class="string">'hi'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用普通的JavaScript替换模板特性"><a href="#用普通的JavaScript替换模板特性" class="headerlink" title="用普通的JavaScript替换模板特性"></a>用普通的JavaScript替换模板特性</h3><ul><li><strong>v-if and v-for</strong><br>在任何地方都可以用普通JavaScript轻松完成，Vue渲染functions 都不提供专有的替代方案。例如，在使用v-if和v-for的模板中<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"items.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'items'</span>],</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.items.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> Vue.h(<span class="string">'ul'</span>, <span class="keyword">this</span>.items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Vue.h(<span class="string">'li'</span>, item.name)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Vue.h(<span class="string">'p'</span>, <span class="string">'No items found.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>v-model</strong><br>v-model指令被扩展到<code>modelValue</code>和<code>onUpdate:modelValue</code>道具在模板编译期间，我们将不得不自己提供这些props<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> props: [<span class="string">'modelValue'</span>],</span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">return</span> Vue.h(SomeComponent, &#123;</span><br><span class="line">     modelValue: <span class="keyword">this</span>.modelValue,</span><br><span class="line">     <span class="string">'onUpdate:modelValue'</span>: <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">this</span>.$emit(<span class="string">'update:modelValue'</span>, value)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+ **v-on**</span></span><br><span class="line"><span class="string">我们必须为事件处理程序提供一个适当的prop名称，例如，为了处理click事件，prop名称应该是onClick</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>ts</span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">return</span> Vue.h(<span class="string">'div'</span>, &#123;</span><br><span class="line">     onClick: $event =&gt; <span class="built_in">console</span>.log(<span class="string">'clicked'</span>, $event.target)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><strong>事件修饰符</strong><br>对于.passive、.capture和.once事件修饰符，Vue提供了处理程序的对象语法<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> Vue.h(<span class="string">'input'</span>, &#123;</span><br><span class="line">    onClick: &#123;</span><br><span class="line">      handler: <span class="keyword">this</span>.doThisInCapturingMode,</span><br><span class="line">      capture: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onKeyUp: &#123;</span><br><span class="line">      handler: <span class="keyword">this</span>.doThisOnce,</span><br><span class="line">      once: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onMouseOver: &#123;</span><br><span class="line">      handler: <span class="keyword">this</span>.doThisOnceInCapturingMode,  <span class="comment">//事件</span></span><br><span class="line">      once: <span class="literal">true</span>, <span class="comment">//是否触发一次</span></span><br><span class="line">      capture: <span class="literal">true</span> </span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对于所有其他事件和键修饰符，不需要特殊的API，因为我们可以在处理程序中使用事件方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> Vue.h(<span class="string">'input'</span>, &#123;</span><br><span class="line">    onKeyUp: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果发出事件的元素不存在，则中止事件绑定到的元素</span></span><br><span class="line">      <span class="keyword">if</span> (event.target !== event.currentTarget) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 同时如果按下的键不是enter键key (13)以及shift键没有按下</span></span><br><span class="line">      <span class="keyword">if</span> (!event.shiftKey || event.keyCode !== <span class="number">13</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 停止事件传播</span></span><br><span class="line">      event.stopPropagation()</span><br><span class="line">      <span class="comment">// 阻止此元素的默认keyup处理程序</span></span><br><span class="line">      event.preventDefault()</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Slots</strong></li></ul><p>你可以访问插槽内容this.$slots在VNodes数组的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> Vue.h(<span class="string">'div'</span>, &#123;&#125;, <span class="keyword">this</span>.$slots.default())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'message'</span>],</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;slot :text="message"&gt;&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> Vue.h(<span class="string">'div'</span>, &#123;&#125;, <span class="keyword">this</span>.$slots.default(&#123;</span><br><span class="line">    text: <span class="keyword">this</span>.message</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用render函数将槽传递给子组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;child v-slot="props"&gt;&lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;&lt;/child&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> Vue.h(<span class="string">'div'</span>, [</span><br><span class="line">    Vue.h(<span class="string">'child'</span>, &#123;&#125;, &#123;</span><br><span class="line">      <span class="comment">// 通过`slots'作为子对象</span></span><br><span class="line">      <span class="comment">// in the form of &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function">(<span class="params">props</span>) =&gt;</span> Vue.h(<span class="string">'span'</span>, props.text)</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>JSX</strong><br>如果我们要编写大量的渲染函数，编写这样的东西可能会让人感到痛苦<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.h(</span><br><span class="line">  <span class="string">'anchored-heading'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    level: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [Vue.h(<span class="string">'span'</span>, <span class="string">'Hello'</span>), <span class="string">' world!'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>特别是当模板版本相比之下如此简洁的时候<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">anchored-heading</span> <span class="attr">:level</span>=<span class="string">"1"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span> world! <span class="tag">&lt;/<span class="name">anchored-heading</span>&gt;</span></span><br></pre></td></tr></table></figure>这就是为什么有一个Babel插件可以在Vue中使用JSX，让我们回到更接近模板的语法<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AnchoredHeading <span class="keyword">from</span> <span class="string">'./AnchoredHeading.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AnchoredHeading level=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello&lt;<span class="regexp">/span&gt; world!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>AnchoredHeading&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="defineComponent【组件】"><a href="#defineComponent【组件】" class="headerlink" title="defineComponent【组件】"></a>defineComponent【组件】</h3><p>在实现方面，defineComponent只会执行返回传递给它的对象的操作。<br>但是，就类型而言，返回的值具有人工渲染功能，TSX和IDE工具支持的构造函数的综合类型</p><p><strong>参数</strong><br>具有组件选项的对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = defineComponent(&#123;</span><br><span class="line"> data() &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123; count: <span class="number">1</span> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line">   increment() &#123;</span><br><span class="line">     <span class="keyword">this</span>.count++</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="defineAsyncComponent-【异步组件】"><a href="#defineAsyncComponent-【异步组件】" class="headerlink" title="defineAsyncComponent 【异步组件】"></a>defineAsyncComponent 【异步组件】</h3><p>创建只在必要时加载的异步组件<br><strong>参数</strong><br>对于基本用法，defineAsyncComponent可以接受返回Promise的工厂函数。<br>当您从serve检索到组件定义时，应该调用Promise的解析回调。<br>您还可以调用reject(reason)来指示加载失败。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AsyncComp = defineAsyncComponent(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="comment">/*或者*/</span></span><br><span class="line"> <span class="keyword">import</span>(<span class="string">'./components/AsyncComponent.vue'</span>)</span><br><span class="line">  <span class="comment">/*或者*/</span></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">/*可以reject*/</span></span><br><span class="line">     resolve(&#123;</span><br><span class="line">       template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">'async-component'</span>, AsyncComp)</span><br></pre></td></tr></table></figure><p>在使用本地注册时，还可以直接提供返回Promise的函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">createApp(&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> components: &#123;</span><br><span class="line">   AsyncComponent: defineAsyncComponent(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">     <span class="keyword">import</span>(<span class="string">'./components/AsyncComponent.vue'</span>)</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于高级用法，defineAsyncComponent可以接受一个对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> AsyncComp = defineAsyncComponent(&#123;</span><br><span class="line">     <span class="comment">// 工厂函数</span></span><br><span class="line">     loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>)</span><br><span class="line">     <span class="comment">// 加载异步组件时使用的组件</span></span><br><span class="line">     loadingComponent: LoadingComponent,</span><br><span class="line">     <span class="comment">//加载失败的时候使用的组件</span></span><br><span class="line">     errorComponent: ErrorComponent,</span><br><span class="line">     <span class="comment">// 在显示加载组件之前延迟。默认值:200 ms。</span></span><br><span class="line">     delay: <span class="number">200</span>,</span><br><span class="line">     <span class="comment">// 如果超时，将显示错误组件</span></span><br><span class="line">     <span class="comment">// 存在timeout并且超过这个时间. 默认值:无穷</span></span><br><span class="line">     timeout: <span class="number">3000</span>,</span><br><span class="line">     <span class="comment">// 返回布尔值的函数，指示当加载器promise rejects时异步组件是否应该重试</span></span><br><span class="line">     retryWhen: <span class="function"><span class="params">error</span> =&gt;</span> error.code !== <span class="number">404</span>,</span><br><span class="line">     <span class="comment">// 允许的最大重试次数</span></span><br><span class="line">     maxRetries: <span class="number">3</span>,</span><br><span class="line">     <span class="comment">// 定义组件是否可挂载</span></span><br><span class="line">     suspensible: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="resolveComponent"><a href="#resolveComponent" class="headerlink" title="resolveComponent"></a>resolveComponent</h3><p><strong>警告</strong>resolveComponent只能在render或setup函数中使用。</p><p>允许通过名称解析组件，如果它在当前应用程序实例中可用。<br>如果找不到组件，返回组件或未定义组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">'MyComponent'</span>, &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> MyComponent = resolveComponent(<span class="string">'MyComponent'</span>)</span><br></pre></td></tr></table></figure><h3 id="resolveDynamicComponent【解析活动的组件active】"><a href="#resolveDynamicComponent【解析活动的组件active】" class="headerlink" title="resolveDynamicComponent【解析活动的组件active】"></a>resolveDynamicComponent【解析活动的组件active】</h3><p>resolveDynamicComponent只能在<code>render</code>或<code>setup</code>函数中使用。<br>允许使用与<code>&lt;component:is=&quot;&quot;&gt;</code>相同的机制来解析组件。<br>返回解析的组件或一个新创建的VNode以组件名称作为节点标记的。<br>如果没有找到组件，会发出警告</p><h3 id="resolveDirective"><a href="#resolveDirective" class="headerlink" title="resolveDirective"></a>resolveDirective</h3><p><strong>警告</strong> resolveDirective只能在<code>render</code>或<code>setup</code>函数中使用。<br>允许通过名称解析指令，如果它在当前应用程序实例中可用。<br>返回一个Directive或 当没有找到的时候，返回undefined。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.directive(<span class="string">'highlight'</span>, &#123;&#125;)</span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">const</span> highlightDirective = resolveDirective(<span class="string">'highlight'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="withDirectives"><a href="#withDirectives" class="headerlink" title="withDirectives"></a>withDirectives</h3><p><strong>警告</strong> withDirectives只能在render或setup函数中使用。<br>允许应用指令到VNode。返回一个带有应用指令的VNode。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = resolveDirective(<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> withDirectives(h(<span class="string">'div'</span>), [</span><br><span class="line">  [bar, <span class="keyword">this</span>.y]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>将回调延迟到下一个DOM更新周期之后执行。在更改了一些数据以等待DOM更新之后立即使用它</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> message = ref(<span class="string">'Hello!'</span>)</span><br><span class="line">  <span class="keyword">const</span> changeMessage = <span class="keyword">async</span> newMessage =&gt; &#123;</span><br><span class="line">    message.value = newMessage</span><br><span class="line">    <span class="comment">/*等待DOM更新*/</span></span><br><span class="line">    <span class="keyword">await</span> nextTick()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Now DOM is updated'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例方法methods"><a href="#实例方法methods" class="headerlink" title="实例方法methods"></a>实例方法methods</h3><ul><li><strong>$watch</strong></li></ul><p><strong>参数</strong></p><blockquote><p>{string | Function} source<br>{Function | Object} callback<br>{Object} [options]<br>{boolean} deep<br>{boolean} immediate </p></blockquote><p><strong>用法</strong><br>观察组件实例上的响应式属性或computed函数的更改。<br>使用回调获取到给定属性的新值和旧值。<br>我们只能通过顶级data、prop或computed的属性名作为字符串的形式传递。<br>对于更复杂的表达式或嵌套属性，使用函数代替。<br><strong>例子</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      a: <span class="number">1</span>,</span><br><span class="line">      b: <span class="number">2</span>,</span><br><span class="line">      c: &#123;</span><br><span class="line">        d: <span class="number">3</span>,</span><br><span class="line">        e: <span class="number">4</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// 顶级属性名a</span></span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'a'</span>, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 做一些事</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察监视单个嵌套属性</span></span><br><span class="line">    <span class="keyword">this</span>.$watch(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.c.d,</span><br><span class="line">      (newVal, oldVal) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 做一些事</span></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控复杂表达式</span></span><br><span class="line">    <span class="keyword">this</span>.$watch(</span><br><span class="line">      <span class="comment">// 每当表达式`this.a + this.b`产生不同的结果时</span></span><br><span class="line">      <span class="comment">// 处理程序将被调用。这就好像我们在看computed属性</span></span><br><span class="line">      <span class="comment">// 而不定义计算属性本身</span></span><br><span class="line">      () =&gt; <span class="keyword">this</span>.a + <span class="keyword">this</span>.b,</span><br><span class="line">      (newVal, oldVal) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 做一些事</span></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当监视的值是对象或数组时，对其属性或元素的任何更改都不会触发监视程序，因为它们引用相同的对象/数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      article: &#123;</span><br><span class="line">        text: <span class="string">'Vue is awesome!'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      comments: [<span class="string">'Indeed!'</span>, <span class="string">'I agree'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'article'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Article changed!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'comments'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Comments changed!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 这些方法不会触发观察者，因为我们仅更改了对象/数组的属性,</span></span><br><span class="line">    <span class="comment">// 并不是 Object/Array 本身</span></span><br><span class="line">    changeArticleText() &#123;</span><br><span class="line">      <span class="keyword">this</span>.article.text = <span class="string">'Vue 3 is awesome'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    addComment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.comments.push(<span class="string">'New comment'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些方法会触发观察者，因为我们完整替换了对象/数组</span></span><br><span class="line">    changeWholeArticle() &#123;</span><br><span class="line">      <span class="keyword">this</span>.article = &#123; text: <span class="string">'Vue 3 is awesome'</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    clearComments() &#123;</span><br><span class="line">      <span class="keyword">this</span>.comments = []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>$watch返回一个取消监视的函数，该函数停止触发回调</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = vm.$watch(<span class="string">'a'</span>, cb)</span><br><span class="line"><span class="comment">// later, teardown the watcher</span></span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure><p><strong>Option: deep</strong><br>检测对象内部嵌套的值更改，需要在options参数中传入deep: true。<br>注意，侦听数组突变并不需要这样做。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'someObject'</span>, callback, &#123;</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">vm.someObject.nestedValue = <span class="number">123</span></span><br><span class="line"><span class="comment">// 触发回调</span></span><br></pre></td></tr></table></figure><p><strong>Option: immediate</strong><br>在选项中传入immediate: true将立即用表达式的当前值触发回调</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'a'</span>, callback, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// “callback”被立即触发，当前值为“a”</span></span><br></pre></td></tr></table></figure><p>请注意，使用immediate选项，您将无法在第一个回调调用中取消监视给定的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个例子是错误的</span></span><br><span class="line"><span class="keyword">const</span> unwatch = vm.$watch(</span><br><span class="line">  <span class="string">'value'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomething()</span><br><span class="line">    unwatch()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; immediate: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果你仍然想在回调中调用一个unwatch函数，你应该首先检查它的可用性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = vm.$watch(</span><br><span class="line">  <span class="string">'value'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomething()</span><br><span class="line">    <span class="keyword">if</span> (unwatch) &#123;</span><br><span class="line">      unwatch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; immediate: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p><strong>$emit 【一致】</strong></p></li><li><p><strong>$forceUpdate【一致】</strong></p></li><li><p><strong>$nextTick【一致】</strong></p></li></ul><h3 id="实例-property"><a href="#实例-property" class="headerlink" title="实例 property"></a>实例 property</h3><blockquote><p>vm.$data 【一致】<br>vm.$props 【一致】<br>vm.$el 【一致】<br>vm.$options 【一致】<br>vm.$parent 【一致】<br>vm.$root【一致】<br>vm.$slots 【一致】<br>vm.$refs 【一致】<br>vm.$attrs 【一致】</p></blockquote><p>废弃:<br><del>vm.$children</del><br><del>vm.$slots</del><br><del>vm.$scopedSlots</del><br><del>vm.$isServer</del><br><del>vm.$listeners</del></p><h3 id="选项-组合"><a href="#选项-组合" class="headerlink" title="选项 / 组合"></a>选项 / 组合</h3><p>mixins 【一致】<br>extends【一致】<br>provide / inject【一致】<br>parent【废弃】<br><strong>setup</strong>【新增】</p><h3 id="选项-资源"><a href="#选项-资源" class="headerlink" title="选项 / 资源"></a>选项 / 资源</h3><p>directives【一致】<br>components【一致】<br><del>filters</del>【废弃】</p><h3 id="选项-数据"><a href="#选项-数据" class="headerlink" title="选项 / 数据"></a>选项 / 数据</h3><p>data【一致】<br>props【一致】<br>computed【一致】<br>methods【一致】<br>watch【一致】<br><strong>emits</strong>【新增】</p><p><strong>详情</strong><br>可以从组件发出的自定义事件的list/hash。<br>它具有基于数组的简单语法和允许配置事件验证的替代的基于对象的语法。</p><p>在基于对象的语法中，每个属性的值可以为null或验证函数。<br>验证函数将接收传递给emit调用的其他参数。<br>例如，如果调用this.emit(‘foo’,1)，则foo的相应验证器将接收参数1。<br>验证器函数应返回一个布尔值，以指示事件参数是否有效。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组语法</span></span><br><span class="line">app.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  emits: [<span class="string">'check'</span>],</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'check'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象语法</span></span><br><span class="line">app.component(<span class="string">'reply-form'</span>, &#123;</span><br><span class="line">  emits: &#123;</span><br><span class="line">    <span class="comment">// 无效</span></span><br><span class="line">    click: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 有效</span></span><br><span class="line">    submit: <span class="function"><span class="params">payload</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (payload.email &amp;&amp; payload.password) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">`Invalid submit event payload!`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>提示</strong>: 在emit选项中列出的事件将不会被组件的根元素继承</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前用了 vue3 rc版本做了一个 UI 库。&lt;br&gt;但是正式版 vue3 One Piece 已于9月18日晚已发布。&lt;br&gt;&lt;a href=&quot;https://v3.cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v3 中文文档&lt;/a&gt;和&lt;a href=&quot;https://github.com/vuejs/docs-next-zh-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;也逐渐完善。&lt;br&gt;那么下面我们就看看 vue 3 到底做了哪些工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://jambo0624.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="note" scheme="https://jambo0624.github.io/tags/note/"/>
    
      <category term="vue3" scheme="https://jambo0624.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>ts 笔记</title>
    <link href="https://jambo0624.github.io/2020-09-18-ts-note.html"/>
    <id>https://jambo0624.github.io/2020-09-18-ts-note.html</id>
    <published>2020-09-18T03:43:25.000Z</published>
    <updated>2020-10-20T05:56:34.501Z</updated>
    
    <content type="html"><![CDATA[<p>最近尝试用 ts 和 vue3 rc版本做一个 UI 库，这里记录一下 ts 的学习心得。<br>下面我们开始吧。</p><a id="more"></a><p>首先进行一个<strong>小插曲</strong>，记录软件各个版本的差异。</p><ul><li>Alpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。</li><li>Beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</li><li>RC：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。</li><li>GA:General Availability,正式发布的版本，在国外都是用GA来说明release版本的。</li><li>RTM：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。</li><li>OEM：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。</li><li>RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。</li><li>EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。 </li><li>RTL：Retail(零售版)是真正的正式版，正式上架零售版。<br>在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。<br>比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。<br>其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。</li></ul><p>α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。</p><p>下面进入<strong>正文</strong></p><h3 id="TypeScript-是什么"><a href="#TypeScript-是什么" class="headerlink" title="TypeScript 是什么"></a>TypeScript 是什么</h3><p>TypeScript 是一种由微软开发的自由和开源的编程语言。<br>它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。<br>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。<br>下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系：<br><a href="https://imgchr.com/i/0zr9vq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/19/0zr9vq.png" alt="0zr9vq.png"></a></p><p><strong>TypeScript 与 JavaScript 的区别</strong></p><table><thead><tr><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>JavaScript 的超集用于解决大型项目的代码复杂性</td><td>一种脚本语言，用于创建动态网页</td></tr><tr><td>可以在编译期间发现并纠正错误</td><td>作为一种解释型语言，只能在运行时发现错误</td></tr><tr><td>强类型，支持静态和动态类型</td><td>弱类型，没有静态类型选项</td></tr><tr><td>最终被编译成 JavaScript 代码，使浏览器可以理解</td><td>可以直接在浏览器中使用</td></tr><tr><td>支持模块、泛型和接口</td><td>不支持模块，泛型或接口</td></tr><tr><td>社区的支持仍在增长，而且还不是很大</td><td>大量的社区支持以及大量文档和解决问题的支持</td></tr></tbody></table><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>TS 中继承了所有 JS 中的基本数据类型，并做了一些拓展。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es 中的基本数据类型</span></span><br><span class="line">boolean</span><br><span class="line">number</span><br><span class="line">string</span><br><span class="line">array</span><br><span class="line"><span class="built_in">Function</span></span><br><span class="line">object</span><br><span class="line">symbol</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TS 扩展的类型</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">any</span><br><span class="line">never</span><br><span class="line">元组</span><br><span class="line">枚举</span><br><span class="line">高级类型</span><br></pre></td></tr></table></figure><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2: <span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">1</span>, <span class="string">'ts'</span>];</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。<br>比如，你可以定义一对值分别为 string和number类型的元组。<br>元组只允许按照定义时的类型和长度添加元素。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tuple: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">'ts'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组的越界问题</span></span><br><span class="line">tuple.push(<span class="number">3</span>);  <span class="comment">// success</span></span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">2</span>]);  <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>元组可是使用原生的方法增加元素产生越界。但是无法访问越界元素。</p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>在ts中函数不仅可以约定参数类型还可以定义返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><p>以上是一个常见函数。而且此时函数会默认知道自己返回的是 number 类型。这叫类型推断<br>此时如此赋值就会报错</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text: <span class="built_in">string</span> = add(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: object = &#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">obj.x = <span class="number">3</span> <span class="comment">// error ????</span></span><br><span class="line"><span class="keyword">let</span> obj2: &#123;x: <span class="built_in">number</span>, y <span class="built_in">number</span>&#125; = &#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">obj.x = <span class="number">3</span> <span class="comment">// success</span></span><br></pre></td></tr></table></figure><h3 id="undefined-amp-null"><a href="#undefined-amp-null" class="headerlink" title="undefined &amp; null"></a>undefined &amp; null</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> un: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">un = <span class="number">1</span> <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">num = <span class="literal">undefined</span>; <span class="comment">// success</span></span><br></pre></td></tr></table></figure><p>以上代码可以看出 undefined 和 null 是所有类型的子类型。<br><strong>如果出现其他类型复制 undefined 失败的情况。可以将 tsconfig 中的 strictNullChecks 设置为 false。</strong></p><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>void 表示：一个表达式的返回值是 undefined</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun(x: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>此时 testFun 的返回值为 undefined。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">3</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>任意类型</p><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>never 代表永远不会有返回值的类型。<br>注意和 void 的区分。</p><ul><li>void：有返回值，返回 undefined</li><li>never：没有返回值<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在 ts 中枚举类型细分下来有三种</p><blockquote><p>数字枚举<br>字符串枚举<br>异构枚举</p></blockquote><ul><li><p><strong>数字枚举</strong><br>以下代码声明了一个数字类型的枚举。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BanGong &#123;</span><br><span class="line">    cup,</span><br><span class="line">    pen,</span><br><span class="line">    computer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BanGong[<span class="number">0</span>]  <span class="comment">// cup</span></span><br><span class="line">BanGong.pen <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你对索引进行一些干预则会有不同的效果</span></span><br><span class="line"><span class="keyword">enum</span> BanGongAgain &#123;</span><br><span class="line">    cup = <span class="number">1</span>,</span><br><span class="line">    pen,</span><br><span class="line">    computer = <span class="number">5</span>,</span><br><span class="line">    banana,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BanGongAgain.pen   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">BanGongAgain[<span class="number">0</span>]    <span class="comment">// ?</span></span><br><span class="line">BanGongAgain.banana <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>ts 是如何实现数字枚举的？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BanGong;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">BanGong</span>) </span>&#123;</span><br><span class="line">    BanGong[BanGong[<span class="string">"cup"</span>] = <span class="number">0</span>] = <span class="string">"cup"</span>;</span><br><span class="line">    BanGong[BanGong[<span class="string">"pen"</span>] = <span class="number">1</span>] = <span class="string">"pen"</span>;</span><br><span class="line">    BanGong[BanGong[<span class="string">"computer"</span>] = <span class="number">2</span>] = <span class="string">"computer"</span>;</span><br><span class="line">&#125;)(BanGong || (BanGong = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>这种方法学名叫做<strong>反向映射</strong>。</p></li><li><p><strong>字符串枚举</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Message &#123;</span><br><span class="line">    success = <span class="string">'成功'</span>,</span><br><span class="line">    fail = <span class="string">'失败'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message.success <span class="comment">// 成功</span></span><br><span class="line">Message[<span class="string">'成功'</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><p>以上代码可以看出，字符串枚举类型是不支持反向映射的。</p><ul><li><p><strong>异构枚举</strong><br>异构枚举：数字枚举和字符串枚举的混合装。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Answer &#123;</span><br><span class="line">    N,</span><br><span class="line">    Y = <span class="string">'Yes'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>枚举的其他特性</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TestEnum &#123;</span><br><span class="line">    <span class="comment">// 常量型枚举：在编译时就已经得出结果</span></span><br><span class="line">    a,</span><br><span class="line">    b = <span class="number">1</span> + <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 计算型枚举：在运行时才有结果。定义在此后的枚举值一定要有初始值</span></span><br><span class="line">    d = <span class="string">'abc'</span>.length(),</span><br><span class="line">    e, <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量型枚举在编译时候会被移除。</p></li></ul><p>但我们不需要对象。仅仅需要对象值的时候就可以使用常量枚举以减少代码编译后的体积。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口分为以下类型</p><blockquote><p>对象类型接口<br>函数类型接口</p></blockquote><ul><li><strong>对象类型接口和鸭式辨形法</strong><br>来看一个最基本的接口用法。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> List = &#123;</span><br><span class="line">    id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleList</span>(<span class="params">res: List[]</span>) </span>&#123;</span><br><span class="line">    res.forEach(<span class="function"><span class="params">listItem</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(listItem.name)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上代码中 res 可能是后端返回的一段数据，也可能是你自己写的一段 JSON。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = [</span><br><span class="line">    &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'res1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        name: <span class="string">'res2'</span>,</span><br><span class="line">        age: <span class="number">26</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">handleList(res); <span class="comment">// success</span></span><br></pre></td></tr></table></figure><p>以上代码中，数据多了 age 属性。<br>但是 ts 依然没有报错。这个就叫做鸭式辨形法。<br>只要 res 的元素中包含了 List 的必要属性，那么 ts 就认为他是一段正确的数据。</p><p>如果变成这样那么就会有问题了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handleList(</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            id: <span class="number">3</span>,</span><br><span class="line">            age: <span class="number">26</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>因为以上代码中，没有 name 这个必要的属性所以报错了。</p><ul><li><strong>函数类型接口</strong></li></ul><p><strong>声明函数接口的方式</strong><br>变量法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><p>接口法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Add &#123;</span><br><span class="line">    (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型别名：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Add = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：以上三种方式只是对函数进行了定义，而没有实现。</strong></p><p>实现函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add: Add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure><p><strong>混合类型接口</strong><br>混合类型接口意思是：一个接口既可以定义一个函数，也可以像对象一样拥有属性和方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MixinType &#123;</span><br><span class="line">    (): <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">    success(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">let</span> mixinType: MixinType = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">mixinType.type = <span class="string">'1'</span>;</span><br><span class="line">mixinType.success = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>其实以上代码定义完成后，编译器依然会报错。所以你可能需要一个类型断言。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mixinType: MixinType = <span class="function">(<span class="params">(<span class="params"></span>) =&gt; &#123;&#125;</span>) <span class="params">as</span> <span class="params">MixinType</span>;</span></span><br></pre></td></tr></table></figure><ul><li><strong>接口的继承</strong><br>类的继承，可以抽离公共的方法也可以将多个接口合并成一个方法。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Human &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Man EXTENDS Human &#123;</span><br><span class="line">    beard: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Tom extedns Man &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Tom &#123;</span><br><span class="line">    name: <span class="string">''</span>,</span><br><span class="line">    beard: <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><strong>函数泛型</strong><br>我们可以利用函数重载来实现一个类型灵活的函数。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>或者也可使用联合类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span>[]</span>): <span class="title">string</span> | <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是以上的方法依然不够灵活。现在我们可以使用泛型。<br>泛型允许你在调用的时候才传入真正的类型，从而实现最大的灵活性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log&lt;<span class="built_in">number</span>[]&gt;([<span class="number">0</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>泛型同时也支持多个参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">one: T, Two: U</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(one, two);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型也可以用来约束接口成员</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Log&lt;T&gt; &#123;</span><br><span class="line">    (value: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意 一旦使用了泛型接口，类型推断就不再有作用，必须传入具体的类型。</span></span><br><span class="line"><span class="keyword">let</span> myLog: Log&lt;<span class="built_in">number</span>&gt; = <span class="function">(<span class="params">value</span>) =&gt;</span> value</span><br></pre></td></tr></table></figure><ul><li><strong>泛型类</strong><br>先来看一个最简单的泛型类的实现。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Log&lt;T&gt; &#123;</span><br><span class="line">    run(value: T) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log1 = <span class="keyword">new</span> Log&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">log1.run(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> log2 = <span class="keyword">new</span> Log();</span><br><span class="line">log2.run(<span class="string">'ttt'</span>);</span><br><span class="line">log2.run(&#123; test: <span class="string">'test'</span> &#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：泛型类不能用于静态成员，以下代码是会报错的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Log&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> run(value: T) &#123;</span><br><span class="line">        XXXX</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型约束</strong><br>先来看一段代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器会报错：T 上不存在 length 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(value, value.length);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们就要用到类型约束了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Length &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span> <span class="title">ectends</span> <span class="title">Length</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, value.length);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制代码此时编译器就不会报错了。<br>但是同时 T 也不可以再传任意类型的参数进来。<br>参数必须是有 length 属性的参数。此时我们就说 T 受到了类型约束。</p><h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><p>高阶类型大致可以分为以下几种</p><blockquote><p>交叉类型<br>联合类型<br>索引类型<br>映射类型<br>条件类型 </p></blockquote><ul><li><strong>交叉类型</strong><br>将多个类型合并为一个类型。新的类型将具有所有类型的特性。</li></ul><p>所以交叉类型特别适合对象混入的场景。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> DogType &#123;</span><br><span class="line">    run(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> CatType &#123;</span><br><span class="line">    jump(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet: DogType &amp; CatType = &#123;</span><br><span class="line">    run() &#123;&#125;,</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的 pet宠物 就是 狗 和 猫的交叉类型。</p><p><strong>注意</strong>：交叉类型并不是取所有类型的交集，而是取所有类型的并集。</p><p>如果我们在交叉类型中定义了同样的方法会发生什么呢？看看以下代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> DogType &#123;</span><br><span class="line">    run(): <span class="built_in">void</span></span><br><span class="line">    eat(x: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> CatType &#123;</span><br><span class="line">    jump(): <span class="built_in">void</span></span><br><span class="line">    eat(y: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet: DogType &amp; CatType = &#123;</span><br><span class="line">    run() &#123;&#125;,</span><br><span class="line">    jump() &#123;&#125;,</span><br><span class="line">    <span class="comment">// 此时的 eat 应该怎么实现？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口属性分为两种，如果是基本类型比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    a: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    a: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo: A &amp; B = &#123;</span><br><span class="line">    a:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 foo 的属性 a 应该是 never 即 number &amp; string 的类型。<br>但是 ts 没有任何值可以赋值给 never 类型，所以无论怎么赋值都会失败。</p><p>如果属性是函数那么情况就有所不同。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    f(a: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    f(a: <span class="built_in">string</span>, b: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo: A &amp; B = &#123;</span><br><span class="line">    f(a: never) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> foo: A &amp; B = &#123;</span><br><span class="line">    f(a: <span class="built_in">any</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> aa &#123;</span><br><span class="line">  f(a: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> bb &#123;</span><br><span class="line">  f(a: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo2: aa &amp; bb = &#123;</span><br><span class="line">  f(a: never) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo3: aa &amp; bb = &#123;</span><br><span class="line">  f(a: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在代码中没有报错。<br>在交叉类型中，函数 f 实际发生了函数重载。<br>为了同时兼容 A 和 B 中的定义，参数要选择最少的。参数的返回值要取 number &amp; string 即 never 或者 any。</p><p>但是实际上我们应该避免以上这种写法。</p><ul><li><strong>联合类型</strong><br>当声明的类型并不确定，可能是多个类型中的中的一个，叫做联合类型。<br>联合类型也可以分为不同的种类。</li></ul><p><strong>基本类型的联合类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有时候我们不仅需要规定类型。还要求将取值确定在一定范围内</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>对象的联合类型</strong><br>此处我们要用到交叉类型中的两个接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog <span class="keyword">implements</span> DogType &#123;</span><br><span class="line">    run() &#123;&#125;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">implements</span> CatType &#123;</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emun Master &#123; Boy, Girl &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPet</span>(<span class="params">master: Master</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pet = master === Master.Boy ? <span class="keyword">new</span> Dog() : <span class="keyword">new</span> Cat();</span><br><span class="line">    <span class="comment">// 此时 pet 就是一个联合类型</span></span><br><span class="line">    <span class="keyword">return</span> pet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下在代码中的实际表现<br><a href="https://imgchr.com/i/BSNcUs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSNcUs.png" alt="BSNcUs.png"></a></p><p>可以看到当我们输入 pet. 的时候编译器只显示了 eat，而如果我们访问其他的属性则会报错。<br><a href="https://imgchr.com/i/BSNW80" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSNW80.png" alt="BSNW80.png"></a></p><p>所以我们可以得知。联合类型听起来是 Dog 和 Cat 的并集，实际上是其交集。正常情况下只能访问到两个类型的共有属性。</p><p><strong>可区分的联合类型</strong></p><p>利用联合类型的共有属性。我们就可以建立一系列的分支区块。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: <span class="string">"square"</span>;</span><br><span class="line">    size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">    kind: <span class="string">"rectangle"</span>;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>:</span><br><span class="line">            <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>:</span><br><span class="line">            <span class="keyword">return</span> s.width * s.height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中 area 是一个计算形状面积的函数。<br>表面上看起来没有什么问题，但是如果我们此时扩展一个类型就会发现有点问题。</p><p><a href="https://imgchr.com/i/BSw3RI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSw3RI.png" alt="BSw3RI.png"></a></p><p>我们增加了一个圆形。<br>调用了 area 函数进行计算并打印结果。<br>此时打印出了 undefined。<br>很明显此时的 switch 语句没有覆盖到所有的情况，但是是我们的 TS 并没有报错。怎么办？</p><p>1.我们可以强制规定一个类型返回<br><a href="https://imgchr.com/i/BS0COf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BS0COf.png" alt="BS0COf.png"></a></p><p>此时 TS 就会检查 switch 是否覆盖到了所有的情况。<br>2.利用 never 类型</p><p><a href="https://imgchr.com/i/BS096P" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BS096P.png" alt="BS096P.png"></a></p><p>default 函数的作用就是检查 s 是不是 never 类型。<br>如果 s 是 never 类型说明 case 分支已经覆盖了所有的情况 default 函数永远都不会被执行。<br>如果 s 不是 never 类型就说明 case 分支有遗漏就会报错。<br><a href="https://imgchr.com/i/BS0plt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BS0plt.png" alt="BS0plt.png"></a></p><p><strong>索引类型</strong></p><p>先来看一个场景：我们需要在一个对象中抽取一些属性值生成一个数组，以下是代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">obj: <span class="built_in">any</span>, keys: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码会看到以下的结果。<br><a href="https://imgchr.com/i/BSDsSA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSDsSA.png" alt="BSDsSA.png"></a></p><p>我们访问了两个 myObj 中不存在的属性，但是 TS 没有报错。如果才能让 TS 帮助我们对类型进行一些检查呢？此时就需要用到索引类型。</p><p>请先了解如下概念</p><p>1.索引类型的查询操作符</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keyof T：表示类型 T 的所有公共属性的字面量的联合类型</span></span><br><span class="line"><span class="keyword">interface</span> Obj &#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">    b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> key: keyof Obj</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/BSDBJH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSDBJH.png" alt="BSDBJH.png"></a></p><p>2.索引访问操作符</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Obj &#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">    b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T[k] 表示 T 的 属性 K 所代表的的类型</span></span><br><span class="line"><span class="keyword">let</span> value: Obj[<span class="string">'a'</span>]  <span class="comment">// 此时 value 的类型就是 number</span></span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/BSr178" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSr178.png" alt="BSr178.png"></a></p><p>3.泛型约束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T extends U 表示泛型变量可以继承某个类型，从而得到一些属性</span></span><br></pre></td></tr></table></figure><p>有了以上三个概念我们就可以改造 getValues 函数了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, keys: K[]</span>): <span class="title">T</span>[<span class="title">k</span>][] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看效果<br><a href="https://imgchr.com/i/BSDDWd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSDDWd.png" alt="BSDDWd.png"></a></p><p>由此可以看到，索引类型可以实现对【对象属性】的查询和访问。<br>然后配合泛型约束我们就可以建立【对象】【对象属性】【属性值】之间的约束关系。</p><ul><li><strong>映射类型</strong><br>通过映射类型，我们可以通过一些旧的类型生成新的类型。来看看代码<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Obj &#123;</span><br><span class="line">    a: <span class="built_in">string</span>;</span><br><span class="line">    b: <span class="built_in">number</span>;</span><br><span class="line">    c: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadOnly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadOnlyObj = ReadOnly&lt;Ojb&gt;</span><br></pre></td></tr></table></figure>我们来看看有什么效果</li></ul><p><a href="https://imgchr.com/i/BSrb3d" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSrb3d.png" alt="BSrb3d.png"></a></p><p>此时 ReadOnlyObj 和 Obj 中的属性相同但是全都变成了只读属性。<br>我们来看看 type ReadOnly 做了什么。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readonly 是一个可索引的泛型接口</span></span><br><span class="line"><span class="keyword">type</span> ReadOnly&lt;T&gt; = &#123;</span><br><span class="line">    <span class="comment">// keyof T: T 中所有属性字面量的联合类型</span></span><br><span class="line">    <span class="comment">// P in：相当于执行了一次 for in 操作</span></span><br><span class="line">    <span class="comment">// T[P]：表示 T 中的属性 P 所指的类型</span></span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 TS 已经内置了很多的映射类型，包括以上的 ReadOnly。<br>可以查看 <code>node_modules/typescript/lib/lib.es5.d.ts</code> 中的内容获得更多的信息。<br>以下列举了几个可能常用的映射类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只读：将 Obj 的所有属性变为只读</span></span><br><span class="line"><span class="keyword">type</span> ReadOnlyObj = Readonly&lt;Obj&gt;</span><br><span class="line"><span class="comment">// 可选：将 Obj 的所有属性变为可选属性</span></span><br><span class="line"><span class="keyword">type</span> PartiaObj = Partial&lt;Obj&gt;</span><br><span class="line"><span class="comment">// 抽取：抽取了 Obj 中的 a b 属性</span></span><br><span class="line"><span class="keyword">type</span> PickObj = Pick&lt;Obj, <span class="string">'a'</span> | <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure><p>以上三种类型官方统一称为<strong>同态</strong>，也就是不会引入新的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordObj = Record&lt;<span class="string">'x'</span> | <span class="string">'y'</span>, Obj&gt;</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/BSrqgA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSrqgA.png" alt="BSrqgA.png"></a></p><p>Record 就是一个<strong>非同态</strong>类型</p><h3 id="ts-的其他特性"><a href="#ts-的其他特性" class="headerlink" title="ts 的其他特性"></a>ts 的其他特性</h3><ul><li><strong>ts的命名空间</strong><br>在 js 中命名空间可以避免全局污染，但是在 es6 引入模块化概念后命名空间就比较少被用到了。<br>在 ts 中依然实现了这个特性，虽然在模块系统中我们不用考虑全局污染的问题，但是如果使用了全局类库，命名空间依然是比较好的解决方案。</li></ul><p><strong>命名空间的基本使用</strong></p><p>命名空间使用 namespace 关键字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Shape 命名空间内可以定义任意多的变量，但是只能在 Shape 内可见，如果想让外部使用就需要 export 导出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> Shape &#123;</span><br><span class="line">    <span class="keyword">const</span> mp = <span class="built_in">Math</span>.PI;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circle</span>(<span class="params">r: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pi * r ** <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Shape.circle(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>命名空间的拆分</strong><br>命名空间的拆分是可以跨文件的。<br>如果上一段代码是 circle.ts 那么我们在另一个文件 square.ts 中声明一个同名的命名空间，只需要用三斜线指令指定引用就可以正常使用 circle.ts 中的方法了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;reference path="circle.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Shape &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Shape.circle(<span class="number">3</span>);</span><br><span class="line">Shape.square(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>命名空间是如何实现的</strong><br>我们直接来看看代码的编译结果就可以了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Shape;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pi = <span class="built_in">Math</span>.PI;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">circle</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pi * <span class="built_in">Math</span>.pow(r, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Shape.circle = circle</span><br><span class="line">&#125;)(Shape || (Shape = &#123;&#125;))</span><br></pre></td></tr></table></figure><p>Shape 被编译成了一个立即执行的函数，函数形成了一个闭包，pi 是一个私有成员，而 export 出的 circle 则被挂载到了一个全局变量上。</p><p><strong>命名空间的别名</strong><br>我们可以给命名空间中的方法起一个别名方便我们引用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> circle = Shape.circle;</span><br><span class="line">circle(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>注意此处的 import 和模块化引用没有任何关系。</p><ul><li><strong>ts的声明合并</strong><br>声明合并是 ts 中的独特概念。<br>概念是：<strong>编译器会把程序多个地方具有相同命名的声明合并为一个声明。</strong><br>好处就是当你声明了多个同名接口，在实现的时候你将会同时对多个接口有感知能力，可以避免对接口成员的遗漏。</li></ul><p><strong>接口的声明合并</strong></p><p>先来看以下代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    x: numnber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: A &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，接口 A 并没有出现覆盖的情况而是被合并到了一起。如果该代码是一个全局性的文件，两个 interface A 甚至可以不在同一个文件中也可以实现声明合并。</p><p><strong>注意，接口的声明合并中如果重复声明非函数的方法，要求类型相同</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    y: <span class="built_in">number</span>; <span class="comment">//error 程序报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于重复声明的函数方法，每个方法都会变成函数重载</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    fun: (arg: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    fun (arg: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">    fun (arg: <span class="built_in">number</span>[]): numnber[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: A &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">2</span>,</span><br><span class="line">    fun(arg: <span class="built_in">any</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中对于 fun 就是实现了函数的重载。<br>在 ts 中函数的重载是由解析顺序的。<br>在正常情况下会按照从最早的声明开始寻找。<br>但是在接口合并中规则稍有变化。<br>同一接口中从早声明到晚声明，不同接口中从晚声明到早声明，如果函数的参数是一个字符串字面量的话该声明会被提升到最顶端。<br>按照以上的规则在刚在的示例代码中，函数重载的查找规则是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    fun (arg: <span class="built_in">number</span>): <span class="built_in">number</span>;  <span class="comment">// 5</span></span><br><span class="line">    fun (arg: <span class="string">'text1'</span>): <span class="built_in">number</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    fun: (arg: <span class="built_in">string</span>): <span class="built_in">string</span>;  <span class="comment">// 3</span></span><br><span class="line">    fun: (arg: <span class="built_in">number</span>[]): numnber[];  <span class="comment">// 4</span></span><br><span class="line">    fun (arg: <span class="string">'text2'</span>): <span class="built_in">number</span>; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工程篇"><a href="#工程篇" class="headerlink" title="工程篇"></a>工程篇</h3><ul><li><strong>tsconfig 配置</strong><br>本节列举了一些ts常见的配置</li></ul><p><strong>文件选项</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 继承其他的 config 文件</span></span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"./tsconfigBase"</span>,</span><br><span class="line">    <span class="comment">// 编译器需要编译的单个文件的列表</span></span><br><span class="line">    <span class="string">"files"</span>: [</span><br><span class="line">        <span class="string">"src/test.ts"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 编译器需要编译的文件或者目录</span></span><br><span class="line">    <span class="comment">// include 和 files 是会合并的</span></span><br><span class="line">    <span class="string">"include"</span>: [</span><br><span class="line">        <span class="string">"src"</span>, <span class="comment">// src 下的所有文件type RecordObj = Record&lt;'x' | 'y', Obj&gt;</span></span><br><span class="line">        <span class="string">"src/*/*"</span> <span class="comment">// src 二级目录下的文件</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 编译器需要排除的文件或者目录，默认排除 node_modules 和 所有声明文件</span></span><br><span class="line">    <span class="string">"exclude"</span>: [</span><br><span class="line">        <span class="string">"src/lib"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 不太好用啊！保存文件的时候让编译器自动编译 vs code 目前不支持</span></span><br><span class="line">    <span class="string">"compileOnSave"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译相关</strong></p><p>编译相关的选项有100多个。一下列举常用的选项。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 增量编译</span></span><br><span class="line">    <span class="string">"incremental"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 增量编译文件的储存位置</span></span><br><span class="line">    <span class="string">"tsBuildInfoFile"</span>: <span class="string">"./buildFile"</span>,</span><br><span class="line">    <span class="comment">// 打印诊断信息</span></span><br><span class="line">    <span class="string">"diagnostics"</span>: <span class="literal">true</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标语言版本</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="comment">// 生成代码的模块标准</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="comment">// 将多个相互依赖的文件生成一个文件，通常用于生成 AMD 模块</span></span><br><span class="line">    <span class="string">"outFile"</span>: <span class="string">"./app.js"</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TS 要引用的库的声明文件</span></span><br><span class="line">    <span class="comment">// 如果不声明 lib ts 也会默认导入一些 lib 声明，例如 target 为 es5 的时候默认导入以下声明</span></span><br><span class="line">    <span class="comment">// lib: ['dom', 'es5', 'scripthost']</span></span><br><span class="line">    <span class="comment">// 如果我们想使用更新的方法例如 [1, 2, 3, [4, [5]]].flat() 则要引入新的类库</span></span><br><span class="line">    <span class="comment">// lib: ['dom', 'es5', 'scripthost', 'es2019.Array']</span></span><br><span class="line">    <span class="string">"lib"</span>: [],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许编译 JS JSX 文件</span></span><br><span class="line">    <span class="comment">// 注意该属性通常要和 exclude 同时使用，否则可能会编译很多无用的文件</span></span><br><span class="line">    <span class="string">"allowJs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 允许在 JS 文件中报错</span></span><br><span class="line">    <span class="string">"checkJs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./"</span>,</span><br><span class="line">    <span class="comment">// 指定输入文件目录</span></span><br><span class="line">    <span class="string">"rootDif"</span>: <span class="string">"./"</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动为编译的文件生成声明文件</span></span><br><span class="line">    <span class="string">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 声明文件的路径</span></span><br><span class="line">    <span class="string">"declarationDir"</span>: <span class="string">"./d"</span>,</span><br><span class="line">    <span class="comment">// 只生成声明文件</span></span><br><span class="line">    <span class="string">"emitDeclarationOnly"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 生成目标文件的 sourceMap</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 生成 inline 的 sourceMap</span></span><br><span class="line">    <span class="string">"inlineSourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 为声明文件生成 sourceMap</span></span><br><span class="line">    <span class="string">"declarationMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 声明文件目录 默认 node_modules/@types</span></span><br><span class="line">    <span class="string">"typeRoots"</span>: [],</span><br><span class="line">    <span class="comment">// 声明文件包</span></span><br><span class="line">    <span class="string">"types"</span>: [],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除注释</span></span><br><span class="line">    <span class="string">"removeComments"</span>: <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不输出任何文件</span></span><br><span class="line">    <span class="string">"noEmit"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 发生错误时候不输出文件</span></span><br><span class="line">    <span class="string">"noEmitOnError"</span>: <span class="literal">true</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不生成 helper 函数。需要额外安装 ts-helpers</span></span><br><span class="line">    <span class="string">"noEmitHelpers"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 通过 tslib 引入 helper 函数，文件必须是模块</span></span><br><span class="line">    <span class="comment">// 这两个选项共同使用可以缩小编译后代码的体积</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 降级遍历的实现，针对 es3 | 5</span></span><br><span class="line">    <span class="string">"downlevelIteration"</span>: <span class="literal">true</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启所有严格的类型检查</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 在代码中注入 'use Strict'</span></span><br><span class="line">    <span class="string">"alwaysStrict"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 不允许隐式的 any 类型</span></span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 不允许将 null 和 undefined 赋值给其他变量</span></span><br><span class="line">    <span class="string">"stricNullChecks"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 不循序函数参数双向协变</span></span><br><span class="line">    <span class="string">"strictFunctionTypes"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 类的实例属性必须初始化</span></span><br><span class="line">    <span class="string">"strictPopertyInitialization"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 严格的 bind call apply 检查</span></span><br><span class="line">    <span class="string">"strictBindCallApply"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 不允许 this 具有 any 类型</span></span><br><span class="line">    <span class="string">"noImplicitThis"</span>: <span class="literal">false</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁止声明但未使用的变量</span></span><br><span class="line">    <span class="string">"noUnusedLocals"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 禁止声明但未使用的参数</span></span><br><span class="line">    <span class="string">"noUnusedParameters"</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分内容参考自<a href="https://juejin.im/post/6872111128135073806" target="_blank" rel="noopener">ts学习指南</a><br>另外风格，更详细的demo，可参考<a href="https://juejin.im/post/6844903574002991118" target="_blank" rel="noopener">该篇文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近尝试用 ts 和 vue3 rc版本做一个 UI 库，这里记录一下 ts 的学习心得。&lt;br&gt;下面我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ts" scheme="https://jambo0624.github.io/categories/ts/"/>
    
    
      <category term="note" scheme="https://jambo0624.github.io/tags/note/"/>
    
      <category term="ts" scheme="https://jambo0624.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』 js questions</title>
    <link href="https://jambo0624.github.io/2020-08-29-js-question.html"/>
    <id>https://jambo0624.github.io/2020-08-29-js-question.html</id>
    <published>2020-08-29T01:33:45.000Z</published>
    <updated>2020-10-19T15:15:41.061Z</updated>
    
    <content type="html"><![CDATA[<p>『question 系列』终于迎来了 js 的部分。<br>js 之所以放在最后，是因为 js 部分的内容最多，细枝末节的东西也有很多难理解的部分。<br>But，没有什么能阻挡我们进阶的步伐。下面我们开始吧。</p><a id="more"></a><ul><li><p><strong>介绍 js 的基本数据类型。</strong><br>js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String、Object。<br>还有在 ES6 中新增的 Symbol 类型，代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。</p></li><li><p><strong>JavaScript 有几种类型的值？你能画一下他们的内存图吗？</strong><br>涉及知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈：原始数据类型（Undefined、Null、Boolean、Number、String）</span></span><br><span class="line"><span class="comment">// 堆：引用数据类型（对象、数组和函数）</span></span><br><span class="line"><span class="comment">// 两种类型的区别是：存储位置不同。</span></span><br><span class="line"><span class="comment">// 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span></span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><blockquote><p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。</p><p>基本数据类型Undefined、Null、Boolean、Number、String</p><p>复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。</p><p>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</p></blockquote><ul><li><strong>什么是堆？什么是栈？它们之间有什么区别和联系？</strong><blockquote><p>堆和栈的概念存在于数据结构中和操作系统内存中。</p></blockquote></li></ul><blockquote><p>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。</p></blockquote><blockquote><p>在操作系统中，内存被分为栈区和堆区。</p></blockquote><blockquote><p>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p></blockquote><blockquote><p>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p></blockquote><ul><li><p><strong>内部属性 [[Class]] 是什么？</strong><br>所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] );</span><br><span class="line"><span class="comment">// "[object Array]"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="regexp">/regex-literal/i</span> );</span><br><span class="line"><span class="comment">// "[object RegExp]"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>介绍 js 有哪些内置对象？</strong><br>涉及知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">全局的对象（ global objects ）或称标准内置对象，不要和 <span class="string">"全局对象（global object）"</span> 混淆。这里说的全局的对象是说在全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class="line"></span><br><span class="line">标准内置对象的分类</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 <span class="literal">Infinity</span>、<span class="literal">NaN</span>、<span class="literal">undefined</span>、<span class="literal">null</span> 字面量</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 <span class="built_in">eval</span>()、<span class="built_in">parseFloat</span>()、<span class="built_in">parseInt</span>() 等</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 <span class="built_in">Object</span>、<span class="built_in">Function</span>、<span class="built_in">Boolean</span>、<span class="built_in">Symbol</span>、<span class="built_in">Error</span> 等</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 <span class="built_in">Number</span>、<span class="built_in">Math</span>、<span class="built_in">Date</span></span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）字符串，用来表示和操作字符串的对象。例如 <span class="built_in">String</span>、<span class="built_in">RegExp</span></span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 <span class="built_in">Array</span></span><br><span class="line"></span><br><span class="line">（<span class="number">7</span>）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例如 <span class="built_in">Map</span>、<span class="built_in">Set</span>、<span class="built_in">WeakMap</span>、<span class="built_in">WeakSet</span></span><br><span class="line"></span><br><span class="line">（<span class="number">8</span>）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等</span><br><span class="line"></span><br><span class="line">（<span class="number">9</span>）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 <span class="built_in">JSON</span> 编码的数据。例如 <span class="built_in">JSON</span> 等</span><br><span class="line"></span><br><span class="line">（<span class="number">10</span>）控制抽象对象。例如 <span class="built_in">Promise</span>、Generator 等</span><br><span class="line"></span><br><span class="line">（<span class="number">11</span>）反射。例如 <span class="built_in">Reflect</span>、<span class="built_in">Proxy</span></span><br><span class="line"></span><br><span class="line">（<span class="number">12</span>）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 <span class="built_in">Intl</span>、<span class="built_in">Intl</span>.Collator 等</span><br><span class="line"></span><br><span class="line">（<span class="number">13</span>）WebAssembly</span><br><span class="line"></span><br><span class="line">（<span class="number">14</span>）其他。例如 <span class="built_in">arguments</span></span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><blockquote><p>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p></blockquote><ul><li><strong>undefined 与 undeclared 的区别？</strong><blockquote><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。</p></blockquote></li></ul><blockquote><p>对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。</p></blockquote><ul><li><strong>null 和 undefined 的区别？</strong><blockquote><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p></blockquote></li></ul><blockquote><p>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p></blockquote><blockquote><p>undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p></blockquote><blockquote><p>当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p></blockquote><ul><li><p><strong>如何获取安全的 undefined 值？</strong></p><blockquote><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。</p><p>表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。</p><p>按惯例我们用 void 0 来获得 undefined。</p></blockquote></li><li><p><strong>说几条写 JavaScript 的基本规范？</strong><br>在平常项目开发中，我们遵守一些这样的基本规范，比如说：</p></li></ul><blockquote><p>（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</p><p>（2）代码中出现地址、时间等字符串时需要使用常量代替。</p><p>（3）在进行比较的时候吧，尽量使用’===’, ‘!==’代替’==’, ‘!=’。</p><p>（4）不要在内置对象的原型上添加方法，如 Array, Date。</p><p>（5）switch 语句必须带有 default 分支。</p><p>（6）for 循环必须使用大括号。</p><p>（7）if 语句必须使用大括号。</p></blockquote><ul><li><strong>JavaScript 原型，原型链？ 有什么特点？</strong><blockquote><p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 <code>prototype</code> 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</p></blockquote></li></ul><blockquote><p>当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 <code>prototype</code> 属性对应的值，在 ES5 中这个指针被称为对象的原型。</p></blockquote><blockquote><p>一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 <code>__proto__</code> 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。</p></blockquote><blockquote><p>ES5 中新增了一个 <code>Object.getPrototypeOf()</code> 方法，我们可以通过这个方法来获取对象的原型。</p></blockquote><blockquote><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。</p></blockquote><blockquote><p>原型链的尽头一般来说都是 <code>Object.prototype</code> 所以这就是我们新建的对象为什么能够使用 <code>toString()</code> 等方法的原因。</p></blockquote><p>特点：</p><p>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><ul><li><p><strong>js 获取原型的方法？</strong></p><blockquote><p><code>p.__proto__</code><br><code>p.constructor.prototype</code><br><code>Object.getPrototypeOf(p)</code></p></blockquote></li><li><p><strong>在 js 中不同进制数字的表示方式</strong><br>以 0X、0x 开头的表示为十六进制。</p></li></ul><p>以 0、0O、0o 开头的表示为八进制。</p><p>以 0B、0b 开头的表示为二进制格式。</p><ul><li><strong>js 中整数的安全范围是多少？</strong><br>安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失。<br>能够被“安全”呈现的最大整数是 <strong>2^53 - 1</strong>，即9007199254740991，在 ES6 中被定义为 <code>Number.MAX_SAFE_INTEGER</code>。<br>最小整数是-9007199254740991，在 ES6 中被定义为 <code>Number.MIN_SAFE_INTEGER</code>。</li></ul><p>如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。<br>如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。</p><ul><li><strong>typeof NaN 的结果是什么？</strong><br>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// "number"</span></span><br></pre></td></tr></table></figure></li></ul><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。</p><ul><li><strong>isNaN 和 Number.isNaN 函数的区别？</strong><br>函数 isNaN 接收参数后，会<strong>尝试将这个参数转换为数值</strong>，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li></ul><p>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。</p><ul><li><strong>Array 构造函数只有一个参数值时的表现？</strong><br>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。</li></ul><p>构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。</p><ul><li><strong>其他值到字符串的转换规则？</strong><br>规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。</li></ul><blockquote><p>（1）Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</p></blockquote><blockquote><p>（2）Boolean 类型，true 转换为 “true”，false 转换为 “false”。</p></blockquote><blockquote><p>（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</p></blockquote><blockquote><p>（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</p></blockquote><blockquote><p>（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</p></blockquote><ul><li><strong>其他值到数字值的转换规则？</strong><br>有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。</li></ul><blockquote><p>（1）Undefined 类型的值转换为 NaN。</p></blockquote><blockquote><p>（2）Null 类型的值转换为 0。</p></blockquote><blockquote><p>（3）Boolean 类型的值，true 转换为 1，false 转换为 0。</p></blockquote><blockquote><p>（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</p></blockquote><blockquote><p>（5）Symbol 类型的值不能转换为数字，会报错。</p></blockquote><blockquote><p>（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</p></blockquote><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><ul><li><strong>其他值到布尔类型的值的转换规则？</strong><br>ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。</li></ul><p>以下这些是假值：</p><blockquote><p>• undefined<br>• null<br>• false<br>• +0、-0 和 NaN<br>• “”</p></blockquote><p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p><ul><li><strong>{} 和 [] 的 valueOf 和 toString 的结果是什么？</strong><blockquote><p>{} 的 valueOf 结果为 {} ，toString 的结果为 “[object Object]”</p></blockquote></li></ul><blockquote><p>[] 的 valueOf 结果为 [] ，toString 的结果为 “”</p></blockquote><ul><li><p><strong>什么是假值对象？</strong></p><blockquote><p>浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。<br>假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false<br>最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。</p></blockquote></li><li><p><strong>~ 操作符的作用？</strong></p><blockquote><p>~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</p><p>~x 大致等同于 -(x+1)。 </p></blockquote></li><li><p><strong>解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</strong></p><blockquote><p>解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN。</p></blockquote></li><li><p><strong><code>+</code> 操作符什么时候用于字符串的拼接？</strong></p><blockquote><p>根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p></blockquote></li><li><p><strong>什么情况下会发生布尔值的隐式强制类型转换？</strong></p><blockquote><p>（1） if (..) 语句中的条件判断表达式。<br>（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。<br>（3） while (..) 和 do..while(..) 循环中的条件判断表达式。<br>（4） ? : 中的条件判断表达式。<br>（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</p></blockquote></li><li><p><strong>|| 和 &amp;&amp; 操作符的返回值？</strong></p><blockquote><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。</p><p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</p><p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</p><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p></blockquote></li><li><p><strong>Symbol 值的强制类型转换？</strong></p><blockquote><p>ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</p><p>Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true ）。</p></blockquote></li><li><p><strong>== 操作符的强制类型转换规则？</strong></p><blockquote><p>（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</p><p>（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</p><p>（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</p><p>（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。</p><p>（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。</p><p>（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</p></blockquote></li><li><p><strong>如何将字符串转化为数字，例如 ‘12.3b’?</strong></p><blockquote><p>（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。</p><p>（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p><p>（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。</p><p>（4）使用 + 操作符的隐式转换。</p></blockquote></li><li><p><strong>如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number &amp;&amp; number.replace(<span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">","</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>常用正则表达式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>如何实现数组的随机排序？</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）随机从原数组抽取一个元素，加入到新数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length);</span><br><span class="line">    result.push(arr[randomIndex]);</span><br><span class="line">    arr.splice(randomIndex, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）随机交换数组内的元素（洗牌算法类似）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp,</span><br><span class="line">    len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">    randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len - index)) + index;</span><br><span class="line"></span><br><span class="line">    temp = arr[index];</span><br><span class="line">    arr[index] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (length - index)) + index;</span><br><span class="line"></span><br><span class="line">    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>javascript 创建对象的几种方式？</strong><br>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式，我了解到的方式有这么几种：</li></ul><blockquote><p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p></blockquote><blockquote><p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p></blockquote><blockquote><p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p></blockquote><blockquote><p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p></blockquote><blockquote><p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p></blockquote><blockquote><p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p></blockquote><ul><li><strong>JavaScript 继承的几种实现方式？</strong><br>我了解的 js 中实现继承的几种方式有：</li></ul><blockquote><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p></blockquote><blockquote><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p></blockquote><blockquote><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p></blockquote><blockquote><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p></blockquote><blockquote><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p></blockquote><blockquote><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p></blockquote><ul><li><p><strong>寄生式组合继承的实现？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My grade is "</span> + <span class="keyword">this</span>.grade + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>Javascript 的作用域链？</strong></p><blockquote><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</p></blockquote></li></ul><blockquote><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p></blockquote><blockquote><p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p></blockquote><blockquote><p>作用域链的创建过程跟执行上下文的建立有关….</p></blockquote><ul><li><strong>谈谈 This 对象的理解。</strong><br>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</li></ul><p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p><p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p><p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p><p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。</p><p>其中 <code>apply</code> 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。<br><code>call</code> 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。<br><code>bind</code> 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p><p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p><ul><li><strong>eval 是做什么的？</strong><br>它的功能是把对应的字符串解析成 JS 代码并运行。</li></ul><p>应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</p><ul><li><strong>什么是 DOM 和 BOM？</strong><br>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</li></ul><p>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</p><p>BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。</p><p>window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</p><ul><li><strong>写一个通用的事件侦听器函数。</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtils = &#123;</span><br><span class="line">  <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  addEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  removeEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件目标</span></span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span></span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event || <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span></span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件的默认行为</span></span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></li></ul><p>1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p><p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p><p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p><ul><li><strong>三种事件模型是什么？</strong><br>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</li></ul><p>第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</p><p>第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</p><p>第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</p><ul><li><strong>事件委托是什么？</strong><br>事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</li></ul><p>使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。</p><p>并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p><ul><li><strong>[“1”, “2”, “3”].map(parseInt) 答案是多少？</strong><br>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。</li></ul><p>此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 “1-0”, “2-1”, “3-2”</p><p>因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。</p><ul><li><strong>什么是闭包，为什么要用它？</strong><br>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</li></ul><p>闭包有两个常用的用途。</p><p>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p><p>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</p><p>其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</p><ul><li><strong>javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</strong></li></ul><p>use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。</p><p>设立”严格模式”的目的，主要有以下几个：</p><blockquote><p>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;<br>消除代码运行的一些不安全之处，保证代码运行的安全；<br>提高编译器效率，增加运行速度；<br>为未来新版本的 Javascript 做好铺垫。</p></blockquote><p>区别：</p><blockquote><p>1.禁止使用 with 语句。<br>2.禁止 this 关键字指向全局对象。<br>3.对象不能有重名的属性。</p></blockquote><p>总结：</p><p>use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。<br>比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。<br>设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。<br>同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。<br>我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。</p><ul><li><strong>如何判断一个对象是否属于某个类？</strong><br>第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li></ul><p>第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p><p>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</p><ul><li><strong>instanceof 的作用？</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span></span><br><span class="line"><span class="comment">// 实现：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">    prototype = right.prototype; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>new 操作符具体干了什么呢？如何实现？</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）首先创建了一个新的空对象</span></span><br><span class="line"><span class="comment">// （2）设置原型，将对象的原型设置为函数的 prototype 对象。</span></span><br><span class="line"><span class="comment">// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span></span><br><span class="line"><span class="comment">// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">constructor</span> = Array.prototype.shift.call(arguments),</span><br><span class="line">    result = null;</span><br><span class="line"></span><br><span class="line">  // 参数判断</span><br><span class="line">  if (typeof <span class="keyword">constructor</span> !== "function") &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"type error"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line"></span><br><span class="line">  // 将 this 指向新建对象，并执行函数</span><br><span class="line">  result = <span class="keyword">constructor</span>.apply(newObject, arguments);</span><br><span class="line"></span><br><span class="line">  // 判断返回对象</span><br><span class="line">  let flag =</span><br><span class="line">    result &amp;&amp; (typeof result === "object" || typeof result === "function");</span><br><span class="line"></span><br><span class="line">  // 判断返回结果</span><br><span class="line">  return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用方法</span><br><span class="line">// objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</strong><br><code>hasOwnProperty</code></li></ul><p>所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</p><ul><li><strong>对于 JSON 的了解？</strong><br>相关知识点：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与值的映射）。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。</span></span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。</p><p>另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</p><ul><li><strong>[].forEach.call($$(“”),function(a){a.style.outline=”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</strong><br>（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</li></ul><p>（2）循环遍历 DOM 元素</p><p>（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。</p><p>（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</p><ul><li><strong>js 延迟加载的方式有哪些？</strong></li></ul><p>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p>js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</p><p>我了解到的几种方式是：</p><blockquote><p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p></blockquote><blockquote><p>第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p></blockquote><blockquote><p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p></blockquote><blockquote><p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p></blockquote><ul><li><strong>Ajax 是什么? 如何创建一个 Ajax？</strong><br>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</li></ul><p>具体来说，AJAX 包括以下几个步骤。</p><p>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象<br>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息<br>3.设置响应 HTTP 请求状态变化的函数<br>4.发送 HTTP 请求<br>5.获取异步调用返回的数据<br>6.使用 JavaScript 和 DOM 实现局部刷新<br>一般实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">"/server"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.open(<span class="string">"GET"</span>, SERVER_URL, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">    handle(<span class="keyword">this</span>.response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.responseType = <span class="string">"json"</span>;</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.responseType = <span class="string">"json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>谈一谈浏览器的缓存机制？</strong><br>浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。</li></ul><p>web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是<strong>强缓存策略</strong>和<strong>协商缓存策略</strong>。</p><p>使用<strong>强缓存</strong>策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。<br>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p><p>服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。<br>在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。<br>这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p><p>Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。<br>它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires来说，这种方式更加有效一些。<br>常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 no-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。</p><p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用，Cache-Control 的优先级要高于 Expires 。</p><p>使用<strong>协商缓存</strong>策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。<br>如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。</p><p>服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。<br>当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。<br>如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。<br>如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</p><p>因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。<br>在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。<br>服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。<br>通过这种方式，比 Last-Modified 的方式更加精确。</p><p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p><p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。<br>浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。<br>如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p><ul><li><strong>Ajax 解决浏览器缓存问题？</strong></li></ul><p>1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</p><p>2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p><p>3.在 URL 后面加上一个随机数： “fresh=” + Math.random();。</p><p>4.在 URL 后面加上时间戳：”nowtime=” + new Date().getTime();。</p><p>5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p><ul><li><strong>同步和异步的区别？</strong></li></ul><p>同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</p><p>异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</p><ul><li><strong>什么是浏览器的同源政策？</strong><br>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。<br>这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。</li></ul><p>同源政策主要限制了三个方面</p><p>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p><p>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</p><p>第三个是当前域下 ajax 无法发送跨域请求。</p><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p><ul><li><strong>如何解决跨域问题？</strong></li></ul><blockquote><p>通过 jsonp 跨域<br>document.domain + iframe 跨域<br>location.hash + iframe<br>window.name + iframe 跨域<br>postMessage 跨域<br>跨域资源共享（CORS)<br>nginx 代理跨域<br>nodejs 中间件代理跨域<br>WebSocket 协议跨域 </p></blockquote><p>总结：</p><p>解决跨域的方法我们可以根据我们想要实现的目的来划分。</p><p>首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。</p><blockquote><p>（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。</p></blockquote><blockquote><p>（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</p></blockquote><blockquote><p>（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</p></blockquote><blockquote><p>（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</p></blockquote><blockquote><p>（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。</p></blockquote><blockquote><p>（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是”跨域资源共享”。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</p></blockquote><blockquote><p>（7）使用 websocket 协议，这个协议没有同源限制。</p></blockquote><blockquote><p>（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『question 系列』终于迎来了 js 的部分。&lt;br&gt;js 之所以放在最后，是因为 js 部分的内容最多，细枝末节的东西也有很多难理解的部分。&lt;br&gt;But，没有什么能阻挡我们进阶的步伐。下面我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』writeDown</title>
    <link href="https://jambo0624.github.io/2020-08-07-writedown-question.html"/>
    <id>https://jambo0624.github.io/2020-08-07-writedown-question.html</id>
    <published>2020-08-07T15:01:04.000Z</published>
    <updated>2020-10-19T12:44:34.839Z</updated>
    
    <content type="html"><![CDATA[<p>『question 系列』的 js 部分，有一个很关键的部分就是<strong>手写</strong>的实现。<br>今天我们就把上出现的手写题目，进行梳理。下面我们开始吧。        </p><a id="more"></a><h2 id="面试手写部分"><a href="#面试手写部分" class="headerlink" title="面试手写部分"></a>面试手写部分</h2><ul><li><strong>AJAX手写</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = xhr.responseText</span><br><span class="line">    resolve(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(method,url,isAsyn)</span><br><span class="line">xhr.send()  <span class="comment">// xhr.send(body)</span></span><br></pre></td></tr></table></figure></li></ul><p>对于这种状态在ajax中分为5中状态：      </p><blockquote><p>0: (未初始化)还没有调用send()方法。<br>1: (载入)已经调用send()方法，正在派发请求。<br>2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。<br>3: (交互)正在解析响应内容。<br>4: (完成)响应内容已经解析完成，用户可以调用。</p></blockquote><p>AJAX状态码说明      </p><blockquote><p>1** ：请求收到，继续处理<br>2** ：操作成功收到，分析、接受<br>3** ：完成此请求必须进一步处理<br>4** ：请求包含一个错误语法或不能完成<br>5** ：服务器执行一个完全有效请求失败      </p></blockquote><ul><li><strong>Promise用法</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(data)   <span class="comment">//成功时调用</span></span><br><span class="line">    reject(err)  <span class="comment">//失败时调用</span></span><br><span class="line">  &#125;)  </span><br><span class="line">&#125;</span><br><span class="line">fn.then(success,fail).then(success2,fail2)</span><br></pre></td></tr></table></figure></li></ul><p>Promise.all 用法–promise1和promise2都成功才会调用success<br><code>Promise.all([promise1,promise2]).then(success,fail)</code><br>Promise.race 用法–promise1和promise2只要有一个成功就会调用success<br><code>Promise.race([promise1,promise2]).then(success,fail)</code>      </p><ul><li><strong>JavaScript常见的六种继承方式</strong></li></ul><blockquote><p>方式一、原型链继承  </p></blockquote><p><code>Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象</code><br>核心： 将父类的实例作为子类的原型<br>缺点：<br>  来自原型对象的所有属性被所有实例共享<br>  创建子类实例时，无法向父类构造函数传参<br>  要想为子类新增属性和方法，必须要在Student.prototype = new Person() 之后执行，不能放到构造器中     </p><blockquote><p>方式二:    </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 相当于: this.Person(name, age)</span></span><br><span class="line">  <span class="comment">/*this.name = name</span></span><br><span class="line"><span class="comment">  this.age = age*/</span></span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类<br>缺点：<br>  实例并不是父类的实例，只是子类的实例<br>  只能继承父类的实例属性和方法，<strong>不能继承原型属性和方法</strong><br>  无法实现函数复用，每个子类都有父类实例函数的副本，影响性能      </p><blockquote><p>方式三: 原型链+借用构造函数的组合继承</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 相当于: this.Person(name, age)</span></span><br><span class="line">  <span class="comment">/*this.name = name</span></span><br><span class="line"><span class="comment">  this.age = age*/</span></span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//组合继承也是需要修复构造函数指向的</span></span><br></pre></td></tr></table></figure><p>缺点：<br>  调用了两次父类构造函数，生成了两份实例      </p><blockquote><p>方式四: 组合继承优化1</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = Person.prototype</span><br></pre></td></tr></table></figure><p>缺点：<br>  没办法辨别是实例是子类还是父类创造的，子类和父类的构造函数指向是同一个   </p><blockquote><p>方式五: 组合继承优化2</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype)<span class="comment">//核心代码</span></span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//核心代码</span></span><br></pre></td></tr></table></figure><blockquote><p>方式六：ES6中class 的继承</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, salary) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age)<span class="comment">//通过super调用父类的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.salary = salary</span><br><span class="line">  &#125;</span><br><span class="line">  showName() &#123;<span class="comment">//在子类自身定义方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调用子类的方法"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>五和六分别是ES5和ES6的标准方法</p></blockquote><ul><li><strong>数组去重</strong>        </li></ul><blockquote><p>1.哈希表思想</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = []</span><br><span class="line">  <span class="keyword">var</span> hash = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hash[item]) &#123;</span><br><span class="line">      result.push(item)</span><br><span class="line">      hash[item] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.遍历数组，用indexOf() / includes()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//indexOf()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(arr[i])===<span class="number">-1</span>) &#123;</span><br><span class="line">      result.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//includes()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    !result.includes(item) &amp;&amp; result.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.数组下标判断法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.indexOf(arr[i])===i) &#123;</span><br><span class="line">      result.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序查找的ES6写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>4.排序，去除相邻的重复值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.sort()</span><br><span class="line">  <span class="keyword">var</span> result = [arr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    arr[i] !== arr[i<span class="number">-1</span>] &amp;&amp; result.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>5.双层循环遍历</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>,len=arr.length;i&lt;len;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;len;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i]===arr[j]) &#123;</span><br><span class="line">        arr.splice(j,<span class="number">1</span>)</span><br><span class="line">        len--</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>6.ES6的Set结构（高性能）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line">  <span class="keyword">return</span> [...result]</span><br><span class="line">  <span class="comment">//👆两行合并 return Array.from(new Set(arr))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数节流（throttle）</strong><br>核心的事情是能不能，开始是能。调用完，马上不能。一段时间之后才可以                   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canUse = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canUse) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">      canUse = <span class="literal">false</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>canUse = <span class="literal">true</span>, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>函数防抖（debounce）</strong><br><a href="https://juejin.im/post/5b8de829f265da43623c4261" target="_blank" rel="noopener">防抖和节流的区别</a><br>核心的事情是重新定时，所以开始定义timer为null。返回的函数也是先清timer。进去timer之后，先执行fn。之后赶紧清timer  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存在问题版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timerId = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span>(timerId)&#123;<span class="built_in">window</span>.clearTimeout(timerId)&#125;</span><br><span class="line">    <span class="comment">// 问题主要是箭头函数导致this指向，和arguments传递的问题</span></span><br><span class="line">    timerId = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      fn.apply(context, <span class="built_in">arguments</span>)</span><br><span class="line">      timerId = <span class="literal">null</span></span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面有助于理解arguments的传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFun = debounce(doSomething,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">newFun(<span class="number">1234</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>手动写一个node服务器</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url == <span class="string">'/'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> indexFile = fs.createReadStream(<span class="string">'./index.html'</span>)</span><br><span class="line">    req.writeHead(<span class="number">200</span>,&#123;<span class="string">'context-Type'</span>:<span class="string">'text/html;charset = utf8'</span>&#125;)</span><br><span class="line">    indexFile.pipe(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>如何用正则实现 trim()</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> string.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong><a href="https://juejin.im/post/5e16eb2df265da3e0640b290" target="_blank" rel="noopener">手写Promise</a></strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  _this.state = PENDING</span><br><span class="line">  _this.value = <span class="literal">undefined</span></span><br><span class="line">  _this.onFulfilledFunc=[]</span><br><span class="line">  _this.onRejectedFunc=[]</span><br><span class="line">  executor(resolve,rejected)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_this.state===PENDING)&#123;</span><br><span class="line">      _this.value = value</span><br><span class="line">      _this.state = RESOLVED</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_this.state===PENDING)&#123;</span><br><span class="line">      _this.value = value</span><br><span class="line">      _this.state = REJECTED</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.state === RESOLVED)&#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.value)</span><br><span class="line">          resolvePromise(promise,x,resolve,reject)</span><br><span class="line">        &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.state === REJECTED)&#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.value)</span><br><span class="line">          resolvePromise(promise,x,resolve,reject)</span><br><span class="line">        &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.state === PENDING)&#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      self.onFulfilledFunc.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(self.value)</span><br><span class="line">            resolvePromise(promise,x,resolve,reject)</span><br><span class="line">          &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      self.onRejectedFunc.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.value)</span><br><span class="line">            resolvePromise(promise,x,resolve,reject)</span><br><span class="line">          &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise,x,solve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(promise === x &amp;&amp; x !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'发生了循环引用'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'function'</span> || <span class="keyword">typeof</span> x === <span class="string">'object'</span>))&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> then ===<span class="string">'function'</span>)&#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          resolvePromise(promise,y,solve,reject)</span><br><span class="line">        &#125;, e =&gt; &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>用js如何去除url中的#号</strong><br>• 情景一: 单纯将hash路由改变成history路由即可去除hash的#号,此时需要服务器做路由重定向,比如nginx, node重定向<br>• 情景二: 单纯去除#       <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dropHash</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = url.indexOf(<span class="string">'#'</span>)</span><br><span class="line">  <span class="keyword">return</span> i &gt; <span class="number">-1</span> ? url.replace(<span class="regexp">/#/g</span>, <span class="string">''</span>) : url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>手动实现 Array.prototype.map 方法</strong><br>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">arr, mapCallback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || !arr.length || <span class="keyword">typeof</span> mapCallback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 每次调用此函数时，我们都会创建一个 result 数组</span></span><br><span class="line">    <span class="comment">// 因为我们不想改变原始数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      result.push(mapCallback(arr[i], i, arr));</span><br><span class="line">      <span class="comment">// 将 mapCallback 返回的结果 push 到 result 数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>手动实现Array.prototype.filter方法</strong><br>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">arr, filterCallback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || !arr.length || <span class="keyword">typeof</span> filterCallback !== <span class="string">'function'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 每次调用此函数时，我们都会创建一个 result 数组</span></span><br><span class="line">    <span class="comment">// 因为我们不想改变原始数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 检查 filterCallback 的返回值是否是真值</span></span><br><span class="line">      <span class="keyword">if</span> (filterCallback(arr[i], i, arr)) &#123;</span><br><span class="line">      <span class="comment">// 如果条件为真，则将数组元素 push 到 result 中</span></span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// return the result array</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>手动实现Array.prototype.reduce方法</strong><br>reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">arr, reduceCallback, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || !arr.length || <span class="keyword">typeof</span> reduceCallback !== <span class="string">'function'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span></span><br><span class="line">    <span class="keyword">let</span> hasInitialValue = initialValue !== <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">let</span> value = hasInitialValue ? initialValue : arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = hasInitialValue ? <span class="number">0</span> : <span class="number">1</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      value = reduceCallback(value, arr[i], i, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>编写一个可以执行如下操作的函数。</strong>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addSix = createBase(<span class="number">6</span>);</span><br><span class="line">addSix(<span class="number">10</span>); <span class="comment">// 返回 16</span></span><br><span class="line">addSix(<span class="number">21</span>); <span class="comment">// 返回 27</span></span><br></pre></td></tr></table></figure>可以创建一个闭包来存放传递给函数 createBase 的值。被返回的内部函数是在外部函数中创建的，内部函数就成了一个闭包，它可以访问外部函数中的变量，在本例中是变量 baseNumber。     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBase</span>(<span class="params">baseNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">N</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我们在这里访问 baseNumber，即使它是在这个函数之外声明的。</span></span><br><span class="line">    <span class="comment">// JavaScript 中的闭包允许我们这么做。</span></span><br><span class="line">    <span class="keyword">return</span> baseNumber + N;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addSix = createBase(<span class="number">6</span>);</span><br><span class="line">addSix(<span class="number">10</span>);</span><br><span class="line">addSix(<span class="number">21</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>请写出下面代码的运行结果：</strong>        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'settimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>答案<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// settimeout</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组</strong>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>判断一个给定的字符串是否是同构的。</strong><br>paper 和 title 将返回 true。<br>egg 和 sad 将返回 false。<br>dgg 和 add 将返回 true。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIsomorphic</span>(<span class="params">firstString, secondString</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查长度是否相等，如果不相等, 它们不可能是同构的</span></span><br><span class="line">  <span class="keyword">if</span> (firstString.length !== secondString.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> letterMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; firstString.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> letterA = firstString[i],</span><br><span class="line">        letterB = secondString[i];</span><br><span class="line">    <span class="comment">// 如果 letterA 不存在, 创建一个 map，并将 letterB 赋值给它</span></span><br><span class="line">    <span class="keyword">if</span> (letterMap[letterA] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      letterMap[letterA] = letterB;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (letterMap[letterA] !== letterB) &#123;</span><br><span class="line">      <span class="comment">// 如果 letterA 在 map 中已存在, 但不是与 letterB 对应，</span></span><br><span class="line">      <span class="comment">// 那么这意味着 letterA 与多个字符相对应。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 迭代完毕，如果满足条件，那么返回 true。</span></span><br><span class="line">  <span class="comment">// 它们是同构的。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『question 系列』的 js 部分，有一个很关键的部分就是&lt;strong&gt;手写&lt;/strong&gt;的实现。&lt;br&gt;今天我们就把上出现的手写题目，进行梳理。下面我们开始吧。        &lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
      <category term="write-down" scheme="https://jambo0624.github.io/tags/write-down/"/>
    
  </entry>
  
  <entry>
    <title>读《程序是怎么跑起来的》</title>
    <link href="https://jambo0624.github.io/2020-07-26-how-program-works.html"/>
    <id>https://jambo0624.github.io/2020-07-26-how-program-works.html</id>
    <published>2020-07-26T07:47:59.000Z</published>
    <updated>2020-09-26T02:38:56.990Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是《程序是怎么跑起来的》读书笔记。<br>在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。<br>下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: </p><a id="more"></a><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>程序是由指令和数据构成的。<br>CPU所负责的就是解释和运行最终转换成机器语言的程序内容。<br>从功能方面来看， CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。<br><strong>寄存器</strong> 可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。<br><strong>控制器</strong> 负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。<br><strong>运算器</strong> 负责运算从内存读入寄存器的数据。<br><strong>时钟</strong> 负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。</p><p>汇编语言 (assembly) 采用助记符 (memonic) 来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符，助记符通常为指令功能的英语单词的简写。<br>通常我们将汇编语言编写的程序转化成机器语言的过程称为 <strong>汇编</strong> ；反之，机器语言程序转化成汇编语言程序的过程则称为 <strong>反汇编</strong> 。  </p><p>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器 (基址，变址，通用) 一般有多个。<br>CPU每执行一个指令，程序计数器的值就会自动加1。也就是说，<strong>程序计数器</strong> 决定着程序的流程。<br><strong>标志寄存器</strong> 实现了对程序的流程控制。<br>函数调用处理是通过把程序计数器的值设定成函数的<strong>存储地址</strong>来实现的。<br>函数调用使用的是call指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call指令会把 <strong>调用函数后要执行的指令地址</strong> 存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行<code>return</code>命令。<code>return</code>命令的功能是把保存在栈中的地址设定到程序计数器中。  </p><p>第一张结束了，通过第一章。我们要知道几个基本的知识:</p><ol><li>程序就是数据和指令</li><li><code>高级编程语言</code>-&gt;<code>汇编语言</code>-&gt;<code>机器语言</code></li></ol><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>因为 IC 的所有引脚，只有直流电压 0V 或 5V 两个状态。所以，决定了计算机的信息数据只能用二进制数来处理。<br>计算机处理信息的最小单位——位，就相当于二进制中的一位。位的英文 <code>bit</code> 是二进制数位<code>(binary digit)</code>的缩写。<br>8位二进制数被称为一个 <strong>字节</strong> 。字节是最基本的信息计量单位。位是最小单位，字节是基本单位。   </p><p>二进制数的值转换成十进制数的值，只需将二进制数的各数位的值和 <strong>位权</strong> 相乘，然后将相乘的结果相加即可。<br><strong>移位运算</strong> 指的是将二进制数值的各数位进行左右移位 (shift=移位) 的运算。移位有左移 &lt;&lt; (向高位方向) 和右移 &gt;&gt; (向低位方向) 两种。      </p><p>为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加1。<strong>将二进制数的值取反后加1的结果，和原来的值相加，结果为 0</strong><br>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为<strong>逻辑右移</strong>。<br>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值 (0或1) 。这就称为<strong>算术右移</strong>。如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2、1/4、1/8等的数值运算。如果是正数，只需在最高位补0即可。<br>只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式 (逻辑左移) 还是相乘运算 (算术左移) ，都只需在空出来的低位补 0 即可。   </p><p><strong>符号扩充</strong>就是指在保持值不变的前提下将其转换成16位和32位的二进制数。也就是说，不管是正数还是用补数表示的负数，都只需用符号位的值 (0或者1) 填充高位即可。     </p><p>计算机能处理的运算，大体可分为<strong>算术运算</strong>和<strong>逻辑运算</strong>。算术运算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算，包括逻辑非（NOT运算）、逻辑与（AND运算）、逻辑或（OR运算）和逻辑异或（XOR运算）四种。  </p><h3 id="计算机中进行小数计算时出错的原因"><a href="#计算机中进行小数计算时出错的原因" class="headerlink" title="计算机中进行小数计算时出错的原因"></a>计算机中进行小数计算时出错的原因</h3><p>经典面试题目: 0.1 + 0.2 = ?<br>是因为 <strong>“有一些十进制数的小数无法转换成二进制数”</strong>    </p><p><strong>双精度浮点数</strong> 类型用64位、<strong>单精度浮点数</strong> 类型用32位来表示全体小数<br><strong>浮点数</strong> 是指用符号、尾数、基数和指数这四部分来表示的小数<br>64: 1位符号，11位指数，52位尾数<br>32: 1位符号，8位指数，23位尾数</p><p>如何避免计算机计算出错  </p><blockquote><p>首先是回避策略，即无视这些错误。根据程序目的的不同，有时一些微小的偏差并不会造成什么问题。<br>把小数转换成整数来计算。计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题。</p></blockquote><p>在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD方法，以确保最终得到准确的数值。BCD (Binary Coded Decimal) 是一种使用二进制表示十进制的方法。  </p><p>在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。因此，在实际程序中，也经常会用十六进制数来代替二进制数。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><strong>内存</strong> 实际上是一种名为内存IC的电子元件。内存IC中有<code>电源</code>、<code>地址信号</code>、<code>数据信号</code>、<code>控制信号</code>等用于输入输出的大量引脚（IC的引脚），通过为其指定地址（address），来进行数据的读写。  </p><p>编程语言中的<strong>数据类型</strong>表示存储的是何种类型的数据。<br>从内存来看，就是占用的内存大小的意思。<br>即使是物理上以1个字节为单位来逐一读写数据的内存，在程序中，通过指定其类型（变量的数据类型等），也能实现以特定字节数为单位来进行读写。      </p><p><strong>指针</strong>也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写。   </p><p>数组是高效实用内存的基础。<br><strong>数组</strong>是指多个同样数据类型的数据在内存中连续排列的形式。<br>作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引<code>(index)</code>。<br>指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由<strong>编译器</strong>自动实现的。<br>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。  </p><p><strong>栈</strong>用的是<code>LIFO</code>（Last Input First Out，后入先出）方式，而队列用的则是<code>FIFO</code>（First Input First Out，先入先出）方式。<br><strong>队列</strong>一般是以<code>环状缓冲区</code>（ring buffer）的方式来实现的  </p><p>在数组的各个元素中，除了数据的值之外，通过为其附带上下一个元素的索引，即可实现<strong>链表</strong>。使用<strong>链表</strong>来追加或删除数据则毫不费事。   </p><h3 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h3><blockquote><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。即使CPU可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低。总之，存储在磁盘中的程序需要读入到内存后才能运行。</p></blockquote><p>磁盘缓存 (disk cache) 指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。使用磁盘缓存可以大大改善磁盘数据的访问速度<br>虚拟内存 (virtual memory) 是指把磁盘的一部分作为假想的内存来使用。<br>虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的。也就是说，为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。    </p><p>节约内存的编程方法<br>(1) 通过DLL文件实现函数共有<br>DLL（Dynamic Link Library）文件，顾名思义，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。此外，还有一个需要大家注意的地方，那就是多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。<br>Windows的操作系统本身也是多个DLL文件的集合体。有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。<br>(2) 通过调用_stdcall来减小程序文件的大小<br><strong>栈清理处理</strong>是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。<br>该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。<br>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。这时所使用的就是_stdcall。<br>在函数前加上_stdcall，就可以把栈清理处理变为在被调用函数一方进行。</p><p>磁盘的物理结构<br>扇区是对磁盘进行物理读写的最小单位。<br>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用1簇的空间。这样一来，所有的文件都会占用1簇的整数倍的磁盘空间。<br>以簇为单位进行读写时，1簇中没有填满的区域会保持不被使用的状态。虽然这看起来是有点浪费，不过该机制就是如此规定的，所以我们也没有什么好办法。另外，如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。由于在磁盘表面上，表示扇区区分的领域是必要的，因此，如果簇的容量过小，磁盘的整体容量也会减少。扇区和簇的大小，是由处理速度和存储容量的平衡来决定的。   </p><h3 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h3><p>RLE算法: 把文件内容用<code>数据×重复次数</code>的形式来表示的压缩方法称为RLE (Run Length Encoding，行程长度编码) 算法。<br>在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE算法可以发挥不错的效果，但它并不适合文本文件的压缩。   </p><p><strong>莫尔斯编码</strong>是根据日常文本中各字符的出现频率来决定表示各字符的编码的数据长度的。<br>使用<strong>哈夫曼树</strong>后，出现频率越高的数据所占用的数据位数就越少，而且数据的区分也可以很清晰地实现。   </p><h3 id="程序是在何种环境中运行的"><a href="#程序是在何种环境中运行的" class="headerlink" title="程序是在何种环境中运行的"></a>程序是在何种环境中运行的</h3><p>应用的运行环境，是指<code>操作系统</code>和<code>计算机本身(硬件)</code>的种类   </p><p>机器语言的程序称为<strong>本地代码</strong> (native code)<br>程序员用C语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为<strong>源代码</strong>。    </p><p>应用程序向操作系统传递指令的途径称为API (ApplicationProgramming Interface)<br>BIOS (BasicInput/Output System)。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。<br><strong>引导程序</strong>是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。   </p><h3 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h3><p>源代码完成后，就可以编译生成可执行文件了。负责实现该功能的是编译器。<br><code>Dump</code> 是指把文件的内容，每个字节用2位十六进制数来表示的方式。</p><p>能够把C语言等高级编程语言编写的源代码转换成本地代码的程序称为<strong>编译器</strong>。<br>但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p><p>编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理。<br>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行连接的程序就称为<strong>链接器</strong>（linkage editor或连结器）  </p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ilink32 -Tpe -c -x -aa c0w32.obj Sample1.obj, Sample1.exe, ,</span><br><span class="line">import32.lib cw32.lib</span><br></pre></td></tr></table></figure><p>c0w32.obj这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的<strong>启动</strong>。<br>因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来。     </p><p>像import32.lib及cw32.lib这样的文件称为库文件。<br><strong>库文件</strong>指的是把多个目标文件集成保存到一个文件中的形式。<br><strong>链接器</strong>指定<strong>库文件</strong>后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件。    </p><p><code>sprintf()</code>等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为<code>标准函数</code>。<br>之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这一过程。   </p><p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL（Dynamic Link Library）文件的特殊库文件中。<br>就如Dynamic这一名称所表示的那样，DLL文件是程序运行时动态结合的文件。  </p><p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为<strong>静态链接库</strong>。<br>静态（static=静态的）同动态（dynamic=动态的）是相反的意思。存储着<code>sprintf()</code>的目标文件的cw32lib就是静态链接库。<br><code>sprintf()</code>提供了通过指定格式把数值转换成字符串的功能。   </p><p>那就是EXE文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在EXE文件的开头，追加转换内存地址所需的必要信息。这个信息称为<strong>再配置信息</strong>。<br>EXE文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离。   </p><p>EXE文件的内容分为再配置信息、变量组和函数组<br>当程序加载到内存后，除此之外还会额外生成两个组，那就是栈和堆。<br><strong>栈</strong>是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域。<br><strong>堆</strong>是用来存储程序运行时的任意数据及对象的内存领域<br>EXE文件中并不存在栈及堆的组。栈和堆需要的内存空间是在EXE文件加载到内存后开始运行时得到分配的。<br>因而，内存中的程序，就是由<code>用于变量的内存空间</code>、<code>用于函数的内存空间</code>、<code>用于栈的内存空间</code>、<code>用于堆的内存空间</code>这4部分构成的。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。不过，在内存的使用方法上，二者存在些许不同。栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。与此相对，堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。<br><strong>栈</strong>中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。<br>与此相对，<strong>堆</strong>的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。<br>如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为<strong>内存泄露</strong>（memory leak）   </p><blockquote><p>Q：编译器和解释器有什么不同？<br>A：<strong>编译器</strong>是在运行前对所有源代码进行解释处理的。而<strong>解释器</strong>则是在运行时对源代码的内容一行一行地进行解释处理的。<br>Q：“分割编译”指的是什么？<br>A：将整个程序分为多个源代码来编写，然后分别进行编译，最后链接成一个EXE文件。这样每个源代码都相对变短，便于程序管理。<br>Q：“Build”指的是什么？<br>A：根据开发工具种类的不同，有的编译器可以通过选择“Build”菜单来生成EXE文件。这种情况下，<strong><code>Build</code>指的是连续执行编译和链接</strong>。<br>Q：使用DLL文件的好处是什么？<br>A: DLL文件中的函数可以被多个程序共用。因此，借助该功能可以节约内存和磁盘。此外，在对函数的内容进行修正时，还不需要重新链接（静态链接）使用这个函数的程序。<br>Q：不链接导入库的话就无法调用DLL文件中的函数吗？<br>A：通过使用LoadLibrary()及GetProcAddress()这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。不过使用导入库更简单一些。<br>Q：“叠加链接”这个术语指的是什么？<br>A：将不会同时执行的函数，交替加载到同一个地址中运行。通过使用“叠加链接器”这一特殊的链接器即可实现。在计算机中配置的内存容量不多的MS-DOS时代，经常使用叠加链接。</p></blockquote><p>IDE: Integrated Development Environment，即继承了变成所需的各种工具的开发软件。<br>CPU: Central Processing Unit (中央处理器)<br>IC: Integrated Circuit (集成电路)<br>DLL: Dynamic Link Library</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是《程序是怎么跑起来的》读书笔记。&lt;br&gt;在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。&lt;br&gt;下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: &lt;/p&gt;
    
    </summary>
    
    
      <category term="program" scheme="https://jambo0624.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://jambo0624.github.io/tags/program/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>CodeStandard</title>
    <link href="https://jambo0624.github.io/2020-07-19-code-standard.html"/>
    <id>https://jambo0624.github.io/2020-07-19-code-standard.html</id>
    <published>2020-07-19T03:16:16.000Z</published>
    <updated>2020-08-12T14:31:54.468Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：</p><ul><li>谨记代码是给人看的，它们只是恰巧能跑而已<a id="more"></a></li></ul><h4 id="能愿动词说明"><a href="#能愿动词说明" class="headerlink" title="能愿动词说明"></a>能愿动词说明</h4><p> 本文统一采用以下几个能愿动词作为规范的约束强度。</p><ul><li><code>必须（Must）</code>：只能这样做，请无条件遵守</li><li><code>绝不（Must Not）</code>：严令禁止，在任何情况下都不能这么做</li><li><code>应该（Should）</code>：强烈建议这样做，但是并不强求</li><li><code>不应该（Should Not）</code>：强烈建议不这样做，但是并不强求</li><li><code>可以（May）</code>：你可以按照自己的喜好去做</li></ul><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><p>下面几个词组指代四种命名风格。</p><ul><li><code>camelCase</code>：小驼峰</li><li><code>PascalCase</code>：大驼峰</li><li><code>kebab-case</code>：小写 + 中划线</li><li><code>kebab_ase</code>：小写 + 下划线</li></ul><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h3 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h3><h4 id="lang属性"><a href="#lang属性" class="headerlink" title="lang属性"></a>lang属性</h4><p>html 标签 <strong>必须</strong> 设置 lang 属性，此属性值 <strong>应该</strong> 与目标用户的第一语言保持一致。<br>当使用i18n等工具进行页面语言的切换时，此属性值也 <strong>应该</strong> 一并切换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh_CN"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="img-标签的-alt-属性"><a href="#img-标签的-alt-属性" class="headerlink" title="img 标签的 alt 属性"></a>img 标签的 alt 属性</h4><p>每一个 img 标签都 <strong>应该</strong> 有一个 alt 属性， 且它的内容 <strong>应该</strong> 尽可能详尽地描述这张图片的作用。<br>它除了能提供信息以及更好的 seo 之外，还能帮助视障人士。</p><h4 id="中文和西文之间的空格"><a href="#中文和西文之间的空格" class="headerlink" title="中文和西文之间的空格"></a>中文和西文之间的空格</h4><p>页面上的中文和西文（数字）之间 <strong>必须</strong> 有一个空格。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia是混成词，分别取自于网站核心技术Wiki以及英文中百科全书之意的encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia 是混成词，分别取自于网站核心技术 Wiki 以及英文中百科全书之意的 encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>皇后乐队是英国摇滚乐乐队，成立于 1970 年。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><h4 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h4><p><strong>必须</strong> 在所有样式文件前引入 <a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a> 用于消除各个浏览器之间的差异。<br>对于不同的项目，<strong>应该</strong> 根据需求设立 reset 样式集，并在 Normalize.css 之后引入。 Reset 样式集应该秉承最小化原则。</p><h4 id="简化版的CSS-BEM"><a href="#简化版的CSS-BEM" class="headerlink" title="简化版的CSS BEM"></a>简化版的CSS BEM</h4><p><a href="http://getbem.com/introduction/" target="_blank" rel="noopener">CSS BEM</a>是一种可以有效降低样式冲突概率的 css 选择器方法，但这种风格的代码对绝大部分项目来说是 too heavy 的。<br>这里提出一种简化的方案，只有”层级”和”断字”的概念。使用中划线 <code>-</code> 表示层级，使用下划线 <code>_</code> 表示断字。项目 <strong>必须</strong> 严格遵守该规范。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-img"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-login"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-sign_up"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>如果项目要使用 Css 预处理器， <strong>应该</strong>优先使用 Sass，且 <strong>必须</strong> 使用 Scss 语法。使用 Scss 语法对上方的 html 代码进行选择会变得非常简单易行。<br>每一个 Scss 选择器后面 <strong>必须</strong> 有一个空行。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  &amp;-logo &#123;</span><br><span class="line">    &amp;-<span class="selector-tag">img</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    &amp;-text &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &amp;-navbar &#123;</span><br><span class="line">    &amp;-item &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &amp;-login &#123;&#125;</span><br><span class="line">    &amp;-sign_up &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择器命名"><a href="#选择器命名" class="headerlink" title="选择器命名"></a>选择器命名</h4><p>选择器命名的第一要务是见名知意。</p><ul><li>对于一些常见的、约定俗成的单词简写，<strong>可以</strong> 使用简写形式。如：<code>description</code>-&gt;<code>desc</code></li><li><strong>绝不</strong> 使用简写后有多种释义，或是简写后无法辨别含义的单词简写。如：<code>description</code>-&gt;<code>des</code>,<code>fc</code></li><li>嵌套层级 <strong>不应该</strong> 过深，当出现三到四层嵌套后，可以使用全新的选择器名称。如：<code>.page-header-logo{ .title ...}</code></li></ul><h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>所有项目都 <strong>应该</strong> 使用 Babel 进行转义，而源码都 <strong>应该</strong> 拥抱已经发布的 ECMAScript 特性。</p><h4 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h4><p>所有项目都 <strong>应该</strong> 使用 ESLint 进行代码格式检查。</p><h4 id="const-let-和-var"><a href="#const-let-和-var" class="headerlink" title="const, let 和 var"></a>const, let 和 var</h4><p><code>const</code> <strong>必须</strong> 是第一公民，次之是 <code>let</code>。被 Babel (或其他转义工具)转义的项目中 <strong>绝不</strong> 出现 <code>var</code>。</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>变量命名的第一要务是见名知意。</p><ul><li>布尔型的变量 <strong>应该</strong> 以 <code>is</code> 或 <code>flag</code> 开头。如：<code>isVisible</code></li><li>数值类型的变量 <strong>必须</strong> 采用复数形式的名词。如：<code>users</code>,<code>categories</code></li><li>对于单复同行的数值型变量，<strong>应该</strong> 添加其他的单词进行辅助释义。如：<code>newsList</code></li><li>对象类型的变量 <strong>必须</strong> 采用单数形式的名词。如:<code>user</code></li><li>函数 (方法) 命名 <strong>必须</strong> 是以动词开头的 camelCase 风格。如: <code>createUser</code>, <code>validateForm</code></li><li>对于项目中约定的常量 (如配置项等)，<strong>应该</strong> 使用 PASCAL_CASE 风格。如: <code>HEADER_MENU</code>, <code>PRIMARY_COLOR</code></li><li>类( Class )的名称 <strong>必须</strong> 采用 PascalCase 形式，且 <strong>应该</strong> 拟人化。如: <code>Permission</code>, <code>FormValidator</code></li><li>任何变量的命名都 <strong>不应该</strong> 过于生僻和抽象</li></ul><h4 id="一些推荐使用的函数首部动词"><a href="#一些推荐使用的函数首部动词" class="headerlink" title="一些推荐使用的函数首部动词"></a>一些推荐使用的函数首部动词</h4><ul><li><code>do</code>/<code>deal</code>：做某些事情</li><li><code>go</code>：跳转、前往</li><li><code>get</code>/<code>fetch</code>：获取某些事物</li><li><code>set</code>：设置某些事物</li><li><code>make</code>/<code>create</code>：创建</li><li><code>edit</code>/<code>update</code>：编辑</li><li><code>delete</code>/<code>destory</code>：删除</li><li><code>handle</code>：被其他操作触发了</li></ul><h4 id="Restful-Actions"><a href="#Restful-Actions" class="headerlink" title="Restful Actions"></a>Restful Actions</h4><p>对于项目中的接口，<strong>应该</strong> 将 ajax 请求拆分为请求函数以实现复用以及提高项目的可维护性。<br>如果接口使用 Restful API，那么前端对应的方法名 <strong>可以</strong> 按照下面的规范来进行命名。</p><ul><li><code>get</code> <code>/books</code>=&gt;<code>reqFetchBooks</code></li><li><code>get</code> <code>/books/:id</code>=&gt;<code>reqShowBooks</code></li><li><code>post</code> <code>/books</code>=&gt;<code>reqCreateBooks</code></li><li><code>post,put,patch</code> <code>/books/:id</code>=&gt;<code>reqUpdateBooks</code></li><li><code>delete</code> <code>/books/:id</code>=&gt;<code>reqDestoryBooks</code></li></ul><h4 id="数组的循环"><a href="#数组的循环" class="headerlink" title="数组的循环"></a>数组的循环</h4><p>在使用循环时， <strong>不应该</strong> 使用<code>item</code>作为数组的元素名，而 <strong>应该</strong> 使用数组的单数形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">books.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; &#125;);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">books.map(<span class="function"><span class="params">book</span> =&gt;</span> &#123; &#125;);</span><br><span class="line">newsList.map(<span class="function"><span class="params">news</span> =&gt;</span> &#123; &#125;)</span><br></pre></td></tr></table></figure><h4 id="if的处理"><a href="#if的处理" class="headerlink" title="if的处理"></a>if的处理</h4><p>每一个<code>if</code>都 <strong>必须</strong> 囊括所有情况，也就是说每一种逻辑都可以被 if 处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125; <span class="keyword">else</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>部分<code>if else</code>逻辑 <strong>可以</strong> 通过及时 <code>return</code> 减少嵌套层数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// correct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (a !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br></pre></td></tr></table></figure><p>过多的<code>!a || b</code> <strong>应该</strong> 被转换为<code>!(a &amp;&amp; b)</code>，这种逻辑更符合直觉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not bad</span></span><br><span class="line"><span class="keyword">if</span> (!a || !b) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (!(a &amp;&amp; b)) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>注释本身 <strong>不应该</strong> 对变量或方法本身是做什么的进行解释。这要求变量命名尽可能得见名知意。</li></ul><h3 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h3><p><strong>NOTICE HERE</strong>： Vue 的相关规范全部基于官方的<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">风格指南</a>， 并在此基础上进行了一些修改和约束。</p><h4 id="组件文件命名"><a href="#组件文件命名" class="headerlink" title="组件文件命名"></a>组件文件命名</h4><ul><li>页面、路由相关的组件 <strong>应该</strong> 使用一个单词命名</li><li>非页面、路由相关的组件 <strong>应该</strong> 使用<code>PascalCase</code>风格命名</li><li>组件 <strong>应该</strong> 拟人化。如：<code>UserCreator</code>,<code>Selector</code></li></ul><h4 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h4><p>如果文件夹内拥有<code>index.vue</code>，那么引入时 <strong>应该</strong> 省略 index 字样， 并在末尾添加 <code>/</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/'</span></span><br></pre></td></tr></table></figure><p>引入组件时，模块名 <strong>必须</strong> 为 <code>PascalCase</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="根标签书写规范"><a href="#根标签书写规范" class="headerlink" title="根标签书写规范"></a>根标签书写规范</h4><p>vue 文件中的标签书写顺序 <strong>必须</strong> 为：</p><ol><li><code>&lt;template&gt;&lt;/template&gt;</code></li><li><code>&lt;script&gt;&lt;/script&gt;</code></li><li><code>&lt;style&gt;&lt;/style&gt;</code></li></ol><h3 id="lt-template-gt-lt-template-gt-根标签"><a href="#lt-template-gt-lt-template-gt-根标签" class="headerlink" title="&lt;template&gt;&lt;/template&gt;根标签"></a><code>&lt;template&gt;&lt;/template&gt;</code>根标签</h3><p>每一个根标签下的顶级元素都 <strong>必须</strong> 有一个与当前文件名对应的 css 选择器。在本规范中， <strong>应该</strong> 使用<code>文件名</code>的<code>kebab_case</code>结构作为该 css 选择器。如：<code>SelectorGender</code>-&gt;<code>selector_gender</code><br>如果为了进一步降低组件间的样式冲突的可能性， <strong>可以</strong> 使用 <code>文件夹层级</code> + <code>文件名</code> 共同组装成根组件的根选择器。假定有以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- common &lt;dir&gt;</span><br><span class="line">|  |-- selectors &lt;dir&gt;</span><br><span class="line">|  |  |-- SelectorGender &lt;file&gt;</span><br></pre></td></tr></table></figure><p>那么其对应的唯一 css 选择器名应该为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;common-selectors-selector_gender&quot;&gt;</span><br><span class="line">     &lt;!--    --&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-script-gt-lt-script-gt-根标签"><a href="#lt-script-gt-lt-script-gt-根标签" class="headerlink" title="&lt;script&gt;&lt;/script&gt;根标签"></a><code>&lt;script&gt;&lt;/script&gt;</code>根标签</h3><p>实例选项顺序<br>组件实例中的选项顺序 <strong>必须</strong> 按照 vue 风格指南的要求进行排版</p><ol><li><code>el</code></li><li><code>name</code></li><li><code>parent</code></li><li><code>functional</code></li><li><code>delemiters</code></li><li><code>comments</code></li><li><code>components</code></li><li><code>directives</code></li><li><code>filters</code></li><li><code>extends</code></li><li><code>mixins</code></li><li><code>inheritAttrs</code></li><li><code>model</code></li><li><code>props/prosData</code></li><li><code>data</code></li><li><code>computed</code></li><li><code>watch</code></li><li><code>beforeCreated</code></li><li><code>created</code></li><li><code>beforeMounted</code></li><li><code>mounted</code></li><li><code>beforeUpdate</code></li><li><code>updated</code></li><li><code>activated</code></li><li><code>deactivated</code></li><li><code>beforeDestory</code></li><li><code>destoryed</code></li><li><code>methods</code></li><li><code>template/render</code></li><li><code>renderError</code></li></ol><h4 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h4><p>各个选项间 <strong>必须</strong> 间隔一个空行，而内部的值或方法不空行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Demo'</span>,</span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tableData: <span class="string">''</span>,</span><br><span class="line">      userInfo: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    getTableData () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getUserInfo () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：name"><a href="#实例选项：name" class="headerlink" title="实例选项：name"></a>实例选项：<code>name</code></h4><p>每一个组件 <strong>必须</strong> 有一个 <code>name</code> 实例选项，其值 <strong>必须</strong> 为被其他组件引入时的模块名。如果你的组件命名完全符合本规范，那么一般情况下，此属性的值应与组件的文件名保持一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file name: MyComponent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// worst</span></span><br><span class="line">  <span class="comment">// no name</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'my-component'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'myComponent'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  name: <span class="string">'MyComponent'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * use this component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'../common/MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="实例选项：props"><a href="#实例选项：props" class="headerlink" title="实例选项：props"></a>实例选项：<code>props</code></h4><p>组件需要的参数，都 <strong>应该</strong> 拥有完善的验证规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    demo:&#123;</span><br><span class="line">      type: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="params">val</span> =&gt;</span> [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'first'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="string">'second'</span>].includes(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：data"><a href="#实例选项：data" class="headerlink" title="实例选项：data"></a>实例选项：<code>data</code></h4><ul><li><strong>不应该</strong> 使用 <code>Vue.set()</code> 方式为组件扩展响应式的 data</li><li><strong>应该</strong> 将一些同属于某一块页面元素的 data 合并为对象的形式，避免 data 的扁平化</li><li>每一个 data 都 <strong>必须</strong> 是被使用到的</li></ul><h4 id="实例选项-生命周期函数"><a href="#实例选项-生命周期函数" class="headerlink" title="实例选项: 生命周期函数"></a>实例选项: 生命周期函数</h4><p>生命周期函数内 <strong>不应该</strong> 直接书写过多的业务逻辑。如果逻辑过多，<strong>应该</strong> 在 methods 中定义独立的函数并在生命周期函数中进行调用。</p><h3 id="lt-style-gt-lt-style-gt-根标签"><a href="#lt-style-gt-lt-style-gt-根标签" class="headerlink" title="&lt;style&gt;&lt;/style&gt;根标签"></a><code>&lt;style&gt;&lt;/style&gt;</code>根标签</h3><ul><li><strong>必须</strong> 添加 scoped 属性</li><li><strong>必须</strong> 使用 sass 预处理器，并且使用 scss 语法</li><li>所有的组件内样式 <strong>必须</strong> 被该组件的唯一 css 选择器包裹<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"selector_gender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.selector_gender</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* ... */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="关于命名的（最佳）实践"><a href="#关于命名的（最佳）实践" class="headerlink" title="关于命名的（最佳）实践"></a>关于命名的（最佳）实践</h3><ul><li>在 Dom 上绑定的事件回调方法 <strong>应该</strong> 使用<code>on</code>+<code>动词</code>+<code>名词</code>形式。如：<code>@click=&quot;onCreateUser&quot;</code></li><li>子组件 emit 的事件名称 <strong>应该</strong> 使用 <code>动词的一般现在时</code>。如：<code>@click</code>,<code>@submit</code></li><li>子组件 emit 的事件回调方法 <strong>应该</strong> 使用<code>handle</code>+<code>名词</code>+<code>动词过去式</code>形式。如：<code>@submit=&quot;handleUserCreated&quot;</code></li><li><strong>应该</strong> 正确使用<code>or</code>和<code>and</code>。详见下方示例<br>一个完整的例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"users"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onCreateUser"</span>&gt;</span>Create User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onEditUser(scope.row)"</span>&gt;</span>Edit User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">:loading</span>=<span class="string">"isDeletingUser"</span> @<span class="attr">click</span>=<span class="string">"onDeleteUser(scope.row)"</span>&gt;</span>Delete User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">user-creator-and-editor</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ref</span>=<span class="string">"userCreatorAndEditor"</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">submit</span>=<span class="string">"handleUserCreatedOrEdited"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user-creator-and-editor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> UserCreatorAndEditor <span class="keyword">from</span> <span class="string">'./UserCreatorAndEditor'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; reqDestoryUser &#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'Users'</span>,</span></span><br><span class="line"></span><br><span class="line">    components: &#123; UserCreatorAndEditor &#125;,</span><br><span class="line"></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        isDeletingUser: <span class="literal">false</span>,</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">      onCreateUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'create'</span> &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      onEditUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'edit'</span>, userId: id &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      handleUserCreatedOrEdited(result) &#123;</span><br><span class="line">        if(result) &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line">        &#125;     </span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="keyword">async</span> onDeleteUser(&#123; id &#125;) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">await</span> reqDestoryUser(id);</span></span><br><span class="line"><span class="actionscript">           <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">finally</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">false</span></span></span><br><span class="line">        &#125;   </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>每个方法和变量都见名知意，并且永不重复！</li></ul><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><p><strong>不应该</strong> 使用路由大量传递参数,请尽可能地保证<code>clean and beautiful</code>。</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p><strong>应该</strong> 使用<code>module</code>组织 vuex，而非全部注册在顶级。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>绝不</strong> 给 Vue 挂载大体量的插件或扩展， <strong>应该</strong> 在需要用到的页面进行按需引入</li><li><strong>不应该</strong> 直接选取某个 dom 元素进行直接的 dom 操作( Echarts 等插件除外)</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>项目的技术文档 <strong>必须</strong> 使用 Markdown 格式编写。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><ul><li>英文文档 <strong>必须</strong> 使用半角标点符号</li><li>中文文档中以下标点符号 <strong>必须</strong> 使用半角，并在其后添加一个空格<ul><li>引号: <code>&quot;&quot;</code></li><li>冒号: <code>:</code></li><li>感叹号: <code>!</code></li><li>问号: <code>?</code></li><li>所有的括号: <code>() [] {}</code></li></ul></li><li>中文文档中以下标点符号 <strong>必须</strong> 使用全角，其后不需要添加空格<ul><li>逗号: <code>，</code></li><li>句号: <code>。</code></li><li>省略号: <code>……</code></li></ul></li></ul><h3 id="Markdown-语法约束"><a href="#Markdown-语法约束" class="headerlink" title="Markdown 语法约束"></a>Markdown 语法约束</h3><ul><li><strong>必须</strong> 有且仅有一个一级标题</li><li>标题的层级最多 <strong>不应该</strong> 超过三级</li><li>句子的末尾 <strong>必须</strong> 有句号</li><li>无序列表和有序列表的末尾 <strong>不应该</strong> 添加句号</li><li><strong>应该</strong> 优先选用无需列表而非有序列表</li><li>用于表明格式的关键字符 <strong>必须</strong> 前后各留一个空格</li><li>标题与段落之间 <strong>必须</strong> 前后各留一个空行</li></ul><h3 id="的，得，地"><a href="#的，得，地" class="headerlink" title="的，得，地"></a>的，得，地</h3><p><strong>必须</strong> 正确使用<code>的</code>，<code>得</code>，<code>地</code>。</p><h3 id="项目版本"><a href="#项目版本" class="headerlink" title="项目版本"></a>项目版本</h3><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>项目开发过程中的版本迭代 <strong>应该</strong> 遵循类似 npm 的版本定义方法。即:</p><ul><li><code>1.1.1</code> -&gt; <code>1.1.2</code>: 向下兼容的问题修复</li><li><code>1.1.1</code> -&gt; <code>1.2.1</code>: 向下兼容的功能迭代</li><li><code>1.1.1</code> -&gt; <code>2.1.1</code>: 发生了非向下兼容的功能迭代</li></ul><h4 id="版本迭代及分支管理"><a href="#版本迭代及分支管理" class="headerlink" title="版本迭代及分支管理"></a>版本迭代及分支管理</h4><ul><li><code>master</code>分支 <strong>必须</strong> 对应线上代码</li><li>对于开发告一段落，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><ul><li>安装依赖时 <strong>必须</strong> 按照功能严格区分生产环境依赖和开发环境依赖</li><li><strong>绝不</strong> 遗留未被使用的依赖。如果不使用某个依赖时， <strong>必须</strong> 第一时间进行卸载</li><li><strong>绝不</strong> 在未获得其他开发人员同意的情况下升级依赖版本</li><li><strong>应该</strong> 优先使用使用量大、受众面广的依赖</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="使用If"><a href="#使用If" class="headerlink" title="使用If"></a>使用If</h4><p>Windows 下的 Git 默认使用<code>crlf</code>作为换行符，甚至会将<code>lf</code>转换为<code>crlf</code>。本规范要求所有的换行都 <strong>必须</strong> 使用<code>lf</code>风格。</p><p>Q: 安装 Git 时，忘记去勾了 crlf 自动替换的选项，怎么办？<br>A: 执行以下命令:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.eol lf</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><ul><li>开发分支 <strong>必须</strong> 是<code>develop</code></li><li>功能分支 <strong>必须</strong> 以<code>feature/</code>开头。如: <code>feature/user_system</code></li><li>开发完毕，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h4 id="Merge-Request-Pull-Request"><a href="#Merge-Request-Pull-Request" class="headerlink" title="Merge Request(Pull Request)"></a>Merge Request(Pull Request)</h4><p>每一次分支合并都 <strong>必须</strong> 发起一个<code>Merge Request</code>，并且交由他人评审。</p><h3 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h3><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><ul><li><code>src</code><ul><li><code>api</code>: 存放 API 资源</li><li><code>assets</code>: 存放需要被 Webpack 处理的静态资源</li><li><code>components</code>: 存放于项目无关的公共组件。理论上这些组件可以被任何项目直接使用</li><li><code>config</code>: 存放一些项目配置文件</li><li><code>models</code>: 存放前端的数据模型。如果项目使用了 Typescript， 理论上不需要设置改目录</li><li><code>router</code>: Vue 路由</li><li><code>store</code>: Vuex。 <strong>应该</strong> 只包含<code>modules</code>和<code>index.js</code>，保证 vuex 所有功能都尽可能按照模块划分<ul><li><code>modules</code>: Vuex 的模块</li><li><code>index.js</code></li></ul></li><li><code>styles</code>: 存放全局样式。样式文件 <strong>必须</strong> 使用 Scss 进行组织; 作为子文件的样式文件 <strong>必须</strong> 使用 <code>_</code>开头<ul><li><code>_common.scss</code>: 公共样式文件</li><li><code>_hack.scss</code>: 对各种组件库或其他样式进行加强修改。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>_mixins.scss</code>: 提供全局的 Scss Mixins</li><li><code>_reset.scss</code>: 对页面样式进行重置。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>main.scss</code>: 按照一定的顺序注册全部样式文件。被<code>main.js</code>引入</li><li><code>resource.scss</code>: 被<code>scss-loader</code>处理，注册全局可用的 Scss 资源</li></ul></li><li><code>utils</code>: 各种工具<ul><li><code>http.js</code>: 请求层。<strong>必须</strong> 优先使用<code>axios</code></li></ul></li><li><code>views</code>: 视图层</li><li><code>App.vue</code></li><li><code>main.js</code>: 文件内容 <strong>必须</strong> 尽可能短小且清晰</li></ul></li><li><code>.editorconfig</code></li><li><code>.prettierignore</code></li><li><code>.prettierrc.js</code></li><li><code>.prettierrc.js</code></li><li><code>CHANGELOG.md</code>: 项目更新日志。在每一次上线前都 <strong>必须</strong> 进行补全</li><li><code>README.md</code>: 用来说明项目，以及帮助其他人快速上手项目</li></ul><h4 id="main-scss-组织"><a href="#main-scss-组织" class="headerlink" title="main.scss 组织"></a>main.scss 组织</h4><p>由于样式存在后者覆盖前者的问题，因此 main.scss <strong>必须</strong> 按照一定的顺序进行组织。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络资源 (network resources)</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">"https://fonts.googleapis.com/css?family=Nunito"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地资源 (local resources)。如: 变量，mixin，图标</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"iconfont"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式重置 (reset)。推荐优先使用 normalize.css，自己书写的 reset 文件的内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~normalize.css/normalize.css"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"reset"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方库 (libraries)</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~element-ui/packages/theme-chalk/src/index"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~swiper/css/swiper"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共样式 (common)。如果有需要的话，给公共样式加入一个前缀以作区分，如 ` g-container `</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"common"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图 (views)。对于一个 vue 项目，可能不需要引入视图内的样式</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/layout/home"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/widgets/header"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强行重置某些样式 (hack)。内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"hack"</span>;</span><br></pre></td></tr></table></figure><h4 id="Scss全局资源"><a href="#Scss全局资源" class="headerlink" title="Scss全局资源"></a>Scss全局资源</h4><blockquote><p>参考官方文档: <a href="https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项</a></p></blockquote><p>在<code>src/styles/</code>目录下创建<code>resources.scss</code>文件，用于存放全局可以使用的样式资源，如变量，mixin 等。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br></pre></td></tr></table></figure><p>在<code>vue.config.js</code>中进行了配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: <span class="string">`@import "@/styles/resources.scss";`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Editorconfig"><a href="#Editorconfig" class="headerlink" title="Editorconfig"></a>Editorconfig</h3><p>每一个项目都 <strong>必须</strong> 添加<code>Editorconfig</code>文件，并且每一个开发人员的编辑器都 <strong>必须</strong> 安装该插件。<br>下面是一份推荐使用的 editorconfig 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset = utf<span class="number">-8</span></span><br><span class="line">end_of_line = lf</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = <span class="number">2</span></span><br><span class="line">tab_width = <span class="number">2</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p>所有项目都 <strong>必须</strong> 使用<code>Prettier</code>进行代码的格式化。<br>下面是一份推荐使用的 prettier 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line">modules.export = &#123;</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: <span class="string">"*.&#123;js,ts,jsx,tsx,vue&#125;"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        singleQuote: <span class="literal">true</span>,</span><br><span class="line">        printWidth: <span class="number">100</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谨记代码是给人看的，它们只是恰巧能跑而已
    
    </summary>
    
    
      <category term="standard" scheme="https://jambo0624.github.io/categories/standard/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="standard" scheme="https://jambo0624.github.io/tags/standard/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』network&amp;performance questions</title>
    <link href="https://jambo0624.github.io/2020-06-14-network-question.html"/>
    <id>https://jambo0624.github.io/2020-06-14-network-question.html</id>
    <published>2020-06-14T05:20:34.000Z</published>
    <updated>2020-10-19T09:00:26.245Z</updated>
    
    <content type="html"><![CDATA[<p>今天是『question 系列』的 http 和 performance 部分， js 部分我们放在最后。<br>下面我们开始吧。        </p><a id="more"></a><h2 id="network部分"><a href="#network部分" class="headerlink" title="network部分"></a>network部分</h2><ul><li>304的缓存原理（添加Etag标签.last-modified）<br>304 网页上次请求没有更新，节省带宽和开销            </li></ul><ol><li>服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）        </li><li>304是    HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件                 </li><li>流程：客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。    </li></ol><p>=&gt; 有了Last-Modified，为什么还要用ETag？          </p><ol><li>因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）       </li><li>某些服务器不能精确的得到文件的最后修改时间                                     </li><li>一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get    </li></ol><p>=&gt; 有了ETag，为什么还要用Last-Modified？    </p><ol><li>两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改      </li><li>如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）      </li><li>ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。      </li></ol><ul><li>TCP的三次握手和四次挥手<br>三次握手<br>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；<br>第二次握手：服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接<br>第三次握手：客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；<br>四次挥手<br>第一次挥手：客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；<br>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成<br>第三次挥手：服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕<br>第四次挥手：客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；       </li></ul><ul><li>为什么建立连接是三次握手，而断开连接是四次挥手呢?<br>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。       </li></ul><ul><li>http协议的理解    </li></ul><ol><li><p>超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议    </p></li><li><p>基于TCP/IP通信协议来传递数据（HTML，图片资源）    </p></li><li><p>基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统    </p></li><li><p>http请求信息request：<br>请求行（request line）、请求头部（header）,空行和请求数据四部分构成    </p><blockquote><p>请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.<br>请求头部，用来说明服务器要使用的附加信息<br>空行，请求头部后面的空行是必须的<br>请求数据也叫主体，可以添加任意的其他数据。    </p></blockquote></li></ol><p>5.http相应信息Response<br>状态行、消息报头、空行和响应正文    </p><blockquote><p>状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成<br>消息报头，用来说明客户端要使用的一些附加信息<br>空行，消息报头后面的空行是必须的<br>响应正文，服务器返回给客户端的文本信息。     </p></blockquote><ul><li>http和https<br>https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密<br>http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少    </li></ul><ul><li>web缓存    </li></ul><ol><li>web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本    </li><li>缓存的好处<br>（1）减少不必要的请求<br>（2）降低服务器的压力，减少服务器的消耗<br>（3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）    </li></ol><ul><li>CDN（内容分发网络）    </li></ul><ol><li>尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。       </li><li>关键技术：内容存储和分发技术中       </li><li>基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术<br>将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）      </li></ol><ul><li>从输入url到获取页面的完整过程     </li></ul><ol><li>查询浏览器缓存，系统缓存，路由器缓存    </li><li>查询NDS(域名解析)，获取域名对应的IP地址     </li><li>浏览器与服务器建立tcp链接（三次握手）    </li><li>浏览器向服务器发送http请求(请求和传输数据）    </li><li>服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器    </li><li>浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤    </li><li>浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来    </li></ol><ul><li>浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print<br>流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树<br>概念：    </li></ul><p>1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树<br>2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）<br>3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置<br>4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点    </p><p>重绘：<br>当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上<br>触发重绘的条件：改变元素外观属性。如：color，background-color等<br>重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观<br><strong>注意</strong>：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局    </p><p>重排（重构/回流/reflow）<br>当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。<br>每个页面都需要一次回流，就是页面第一次渲染的时候<br>重排一定会影响重绘，但是重绘不一定会影响重排    </p><ul><li>为什么css放在顶部而js写在后面    </li></ul><ol><li>浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了    </li><li>其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。    </li><li>js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验<br>但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理    </li></ol><ul><li>存储方式与传输方式    </li></ul><ol><li>indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m    </li><li>Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响    </li><li>Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）    </li><li>localStroage: h5的本地存储，数据永久保存在客服端    </li></ol><ul><li>token、cookie、session三者的理解？？？！！！    </li></ul><ol><li>token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的用户身份的验证方式)      </li><li>cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名。服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）    </li><li>session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）。cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。    </li></ol><ul><li>基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前时间戳 + sign签名）    </li></ul><ol><li>用户通过用户名和密码发送请求    </li><li>服务器端验证    </li><li>服务器端返回一个带签名的token，给客户端    </li><li>客户端储存token，并且每次用于发送请求    </li><li>服务器验证token并且返回数据<br>每一次请求都需要token    </li></ol><ul><li>cookie与session区别    </li></ul><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。    </li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。    </li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。    </li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。    </li></ol><ul><li>session与token区别    </li></ul><ol><li>session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App    </li><li>token是Auth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，token不能转移到其他的App，也不能转到其他用户上。（适用于App）    </li><li>session的状态是存在服务器端的，客户端只存在session id，Token状态是存储在客户端的    </li></ol><ul><li>HTTP 缓存有哪几种？<br>ETag 是通过对比浏览器和服务器资源的特征值（如MD5）来决定是否要发送文件内容，如果一样就只发送 304（not modified）<br>Expires 是设置过期时间（绝对时间），但是如果用户的本地时间错乱了，可能会有问题<br>CacheControl: max-age=3600 是设置过期时长（相对时间），跟本地时间无关。    </li></ul><ul><li>RESTful常用的方法和介绍<br>rest请求方法有4种，包括get,post,put,delete.分别对应获取资源，添加资源，更新资源及删除资源    </li></ul><ul><li>csrf跨站攻击怎么解决<br>CSRF, 跨站请求伪造,它可以在用户毫不知情的情况下以用户名义伪造请求发送给受攻击站点，从而对用户或者网站造成攻击. 预防措施如下:<br>=&gt; 服务器端验证HTTP Referer字段, Referer记录了该HTTP请求的来源地址<br>=&gt; 在请求地址中添加token并验证<br>=&gt; 在HTTP头中自定义属性并验证    </li></ul><ul><li>对web安全的理解<br>=&gt; CSRF 攻击和防范<br>跨站请求伪造,可以理解为攻击者盗用了用户的身份，以用户的名义发送恶意请求，造成用户隐私及财产损失<br>过程:     </li></ul><ol><li>登录受信任网站并在本地生成cookie;     </li><li>在不登出 网站 的情况下访问危险网站     </li></ol><p><strong>防范:</strong> 关键操作只接受POST请求, 使用验证码, 检测Referer, 使用token(或者JWT)    </p><p>=&gt; XSS 攻击和防范<br>全称Cross-site script，跨站脚本攻击，是Web程序中常见的漏洞。<br>原理是攻击者向有XSS漏洞的网站中输入恶意的脚本，当其它用户浏览该网站时候，该脚本会自动执行，从而达到攻击的目的(盗取Cookie，破坏页面结构，重定向到钓鱼网站等)。<br>区分: 分为持久型XSS和非持久性XSS. 持久型XSS是将攻击的脚本植入到服务器，从而导致每个访问的用户都会遭到此XSS脚本的攻击。非持久型XSS是将恶意脚本包装在页面的URL参数中，通过URL链接骗取用户访问，从而进行攻击.<br><strong>防范:</strong> 对用户输入进行HTML转义, 对敏感信息进行过滤    </p><p>=&gt; SQL 注入与防范<br>通过把SQL命令插入到表单中并提交或页面请求的参数中，最终使得服务器执行恶意的SQL命令.<br><strong>防范:</strong> 对用户的输入进行校验或限制长度；对特殊字符进行转换, 不要使用动态拼装SQL，为每个应用使用单独的权限有限的数据库连接。对隐私信息进行加密    </p><p>=&gt; DDOS 攻击<br>分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。    </p><ul><li>base64为什么能提升性能以及它的缺点是什么<br>优点:<br>• 无额外请求<br>• 适用于很小或者很简单的图片<br>• 可像单独图片一样使用，比如背景图片等<br>• 没有跨域问题，不需要考虑缓存、文件头或者cookies问题<br>缺点:<br>• CSS 文件体积的增大, 造成CRP(关键渲染路径)阻塞<br>• 页面解析CSS生成的CSSOM时间增加    </li></ul><ul><li>介绍webp图片文件格式<br>WebP是一种支持有损压缩和无损压缩的图片文件格式，根据Google的测试，无损压缩后的WebP比PNG 文件少了45％的文件大小，即使这些PNG文件经过其他压缩工具压缩之后，WebP 还是可以减少28％的文件大小。<br>•优点<br>更小的文件尺寸<br>更高的质量——与其他相同大小不同格式的压缩图像比较<br>•缺点<br>编码和解码速度比较慢,存在一定兼容性    </li></ul><ul><li>说说H5手机端的适配的几种方案 </li></ul><ol><li><p>js实现一</p><pre class="line-numbers language-js">(<span class="function"><span class="keyword">function</span> (<span class="params"><code class="language-js">(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>{  <span class="keyword">var</span> docEl = doc.documentElement,    resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,    recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{      <span class="keyword">var</span> clientWidth = docEl.clientWidth;      <span class="keyword">var</span> fontSize = <span class="number">20</span>;      docEl.style.fontSize = fontSize + <span class="string">'px'</span>;      <span class="keyword">var</span> docStyles = getComputedStyle(docEl);      <span class="keyword">var</span> realFontSize = <span class="built_in">parseFloat</span>(docStyles.fontSize);      <span class="keyword">var</span> scale = realFontSize / fontSize;      <span class="built_in">console</span>.log(<span class="string">"realFontSize: "</span> + realFontSize + <span class="string">", scale: "</span> + scale);      fontSize = clientWidth / <span class="number">750</span> * <span class="number">20</span>;      <span class="keyword">if</span>(isIphoneX()) fontSize = <span class="number">19</span>;      fontSize = fontSize / scale;      docEl.style.fontSize = fontSize + <span class="string">'px'</span>;    };  <span class="comment">// Abort if browser does not support addEventListener</span>  <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;  win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);  doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);  <span class="comment">// iphoneX判断</span>  <span class="function"><span class="keyword">function</span> <span class="title">isIphoneX</span>(<span class="params"></span>)</span>{    <span class="keyword">return</span> <span class="regexp">/iphone/gi</span>.test(navigator.userAgent) && (screen.height == <span class="number">812</span> && screen.width == <span class="number">375</span>)  }})(<span class="built_in">document</span>, <span class="built_in">window</span>);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>js实现二</p><pre class="line-numbers language-js">(<span class="function"><span class="keyword">function</span>(<span class="params"><code class="language-js">(<span class="function"><span class="keyword">function</span>(<span class="params">base</span>) </span>{  <span class="keyword">var</span> _base = base|| <span class="number">75</span>;  <span class="keyword">var</span> ua = navigator.userAgent;  <span class="keyword">var</span> matches = ua.match(<span class="regexp">/Android[\S\s]+AppleWebkit\/(\d{3})/i</span>);  <span class="keyword">var</span> isIos = navigator.appVersion.match(<span class="regexp">/(iphone|ipad|ipod)/gi</span>);  <span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>;  <span class="keyword">if</span>(!isIos && !(matches && matches[<span class="number">1</span>] > <span class="number">534</span>)) {  <span class="comment">// 如果非iOS, 非Android4.3以上, dpr设为1;</span>    dpr = <span class="number">1</span>;  }  <span class="keyword">var</span> scale = <span class="number">1</span>/ dpr;  <span class="keyword">var</span> metaEl = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>);  <span class="keyword">if</span>(!metaEl) {    metaEl = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>);    metaEl.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>);    <span class="built_in">window</span>.document.head.appendChild(metaEl);  }  metaEl.setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width,user-scalable=no,initial-scale='</span>+ scale + <span class="string">',maximum-scale='</span>+ scale + <span class="string">',minimum-scale='</span>+ scale);  <span class="built_in">document</span>.documentElement.style.fontSize = <span class="built_in">document</span>.documentElement.clientWidth / (<span class="number">750</span>/ _base) + <span class="string">'px'</span>;})(<span class="number">75</span>);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>3.css @media媒介查询(苏宁易购实现方式)</p><p>4.手淘的lib-flexible实现方式</p><h2 id="性能优化部分"><a href="#性能优化部分" class="headerlink" title="性能优化部分"></a>性能优化部分</h2><h3 id="关于webpack的面试题总结"><a href="#关于webpack的面试题总结" class="headerlink" title="关于webpack的面试题总结"></a><a href="https://zhuanlan.zhihu.com/p/44438844" target="_blank" rel="noopener">关于webpack的面试题总结</a></h3><ul><li>webpack打包文件体积过大？（最终打包为一个js文件）    </li></ul><ol><li>异步加载模块    </li><li>提取第三库    </li><li>代码压缩    </li><li>去除不必要的插件    </li></ol><ul><li>如何优化webpack构建的性能<br>一、减少代码体积     </li></ul><ol><li>使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积    </li><li>把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理    </li><li>对一些组件库采用按需加载，避免无用的代码<br>二、减少目录检索范围<br>在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度<br>三、减少检索路经<br>resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路径，可以对其配置alias    </li></ol><ul><li>移动端的性能优化    </li></ul><ol><li>首屏加载和按需加载，懒加载    </li><li>资源预加载    </li><li>图片压缩处理，使用base64内嵌图片    </li><li>合理缓存dom对象    </li><li>使用touchstart代替click（click 300毫秒的延迟）    </li><li>利用transform:translateZ(0)，开启硬件GUP加速    </li><li>不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明    </li><li>使用viewport固定屏幕渲染，加速页面渲染内容    </li><li>尽量使用事件代理，避免直接事件绑定    </li></ol><ul><li>Vue的SPA 如何优化加载速度    </li></ul><ol><li>减少入口文件体积    </li><li>静态资源本地缓存    </li><li>开启Gzip压缩    </li><li>使用SSR,nuxt.js    </li></ol><ul><li>有哪些常见 loader 和 plugin，你用过哪些<br>loader:让webpack能够处理非js文件(自身职能理解js)，然后你就可以利用 webpack 的打包能力，对它们进行处理。<br>例如：css-loader、style-loader、postcss-loader、sass-loader<br>plugins:从打包优化和压缩，一直到重新定义环境中的变量.<br>例如：uglify-webpack-plugin、clean-webpack-plugin、babel-polyfill                                     </li></ul><ul><li>如何优化网站的SEO    </li></ul><ol><li>网站结构布局优化：尽量简单, 提倡扁平化结构. 一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。     </li><li>img标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。    </li><li>把重要内容HTML代码放在最前搜索引擎抓取HTML内容是从上到下，利用这一特点，可以让主要代码优先读取，广告等不重要代码放在下边。    </li><li>控制页面的大小，减少http请求，提高网站的加载速度。    </li><li>合理的设计title、description和keywords<br>• title标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的title标题中不要设置相同的内容。<br>• meta keywords页面/网站的关键字。<br>• meta description网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。    </li><li>语义化书写HTML代码，符合W3C标准尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事。让阅读源码者和“蜘蛛”都一目了然。    </li><li>a标签：页面链接，要加 “title” 属性说明，链接到其他网站则需要加上 el=”nofollow” 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。    </li><li>图标使用IconFont替换    </li><li>使用CDN网络缓存，加快用户访问速度，减轻服务器压力    </li><li>启用GZIP压缩，浏览速度变快，搜索引擎的蜘蛛抓取信息量也会增大    </li><li>SSR技术    </li><li>预渲染技术    </li></ol><ul><li>如何优化用户体验<br>• 页面渲染前使用骨架屏或者加载动画,避免大块白屏<br>• 使用预渲染或者ssr技术提高首屏加载时间<br>• 动画使用css3硬件加速,避免用户操作动画卡顿<br>• 计算密集型业务使用web worker或者js分片处理,避免js线程阻塞<br>• 页面状态监控,给用户提供反馈机制<br>• 静态资源走CDN缓存或者oss服务,提高用户访问速度<br>• 避免用户操作报错,提供404页面或则错误提示页面    </li></ul><ul><li>webpack和gulp的优缺点  </li></ul><table><thead><tr><th></th><th>gulp</th><th>webpack</th></tr></thead><tbody><tr><td>定位</td><td>基于任务流的自动化打包工具</td><td>模块化打包工具</td></tr><tr><td>优点</td><td>易于学习和理解, 适合多页面应用开发</td><td>可以模块化的打包任何资源,适配任何模块系统,适合SPA单页应用的开发</td></tr><tr><td>缺点</td><td>不太适合单页或者自定义模块的开发</td><td>学习成本低,配置复杂,通过babel编译后的js代码打包后体积过大</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是『question 系列』的 http 和 performance 部分， js 部分我们放在最后。&lt;br&gt;下面我们开始吧。        &lt;/p&gt;
    
    </summary>
    
    
      <category term="network" scheme="https://jambo0624.github.io/categories/network/"/>
    
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
      <category term="performance" scheme="https://jambo0624.github.io/tags/performance/"/>
    
      <category term="network" scheme="https://jambo0624.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』 css questions (part 3)</title>
    <link href="https://jambo0624.github.io/2020-05-31-css-question3.html"/>
    <id>https://jambo0624.github.io/2020-05-31-css-question3.html</id>
    <published>2020-05-31T06:18:24.000Z</published>
    <updated>2020-10-19T15:15:41.040Z</updated>
    
    <content type="html"><![CDATA[<p>现在把整理的 css 在面试中可能会被问到的问题剩下部分记录一下。<br>我们开始吧。</p><a id="more"></a><ul><li><strong>position:fixed;在 android 下无效怎么处理？</strong><blockquote><p>因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。</p></blockquote></li></ul><blockquote><p>如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：</p></blockquote><p><code>&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt;</code></p><ul><li><p><strong>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</strong></p><blockquote><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms</p></blockquote></li><li><p><strong>如何让去除 inline-block 元素间间距？</strong></p><blockquote><p>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p></blockquote></li><li><p><strong>overflow:scroll 时不能平滑滚动的问题怎么处理？</strong><br>以下代码可解决这种卡顿的问题：<code>-webkit-overflow-scrolling:touch</code>;是因为这行代码启用了硬件加速特性，所以滑动很流畅。</p></li><li><p><strong>有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</strong></p><blockquote><p>（1）外层div使用<code>position：relative</code>；高度要求自适应的div使用<code>position:absolute;top:100px;bottom:0;left:0;right:0</code>;</p><p>（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。</p></blockquote></li><li><p><strong>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</strong></p></li></ul><p>我了解到的一共有七种常见的图片的格式。</p><blockquote><p>（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。</p></blockquote><blockquote><p>（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。</p></blockquote><blockquote><p>（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。</p></blockquote><blockquote><p>（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。</p></blockquote><blockquote><p>（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。</p></blockquote><blockquote><p>（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合于用来制作一些网站logo或者图标之类的图片。</p></blockquote><blockquote><p>（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。</p></blockquote><ul><li><p><strong>浏览器如何判断是否支持 webp 格式图片</strong></p><blockquote><p>（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。</p><p>（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。</p></blockquote></li><li><p><strong>什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</strong></p><blockquote><p>网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。</p><p>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开，静态资源放CDN。</p><p>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</p><p>同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的http请求的解析速度。</p></blockquote></li><li><p><strong>style 标签写在 body 后与 body 前有什么区别？</strong></p><blockquote><p>页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）</p></blockquote></li><li><p><strong>什么是 CSS 预处理器/后处理器？</strong></p><blockquote><p>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。</p></blockquote></li></ul><blockquote><p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p></blockquote><blockquote><p>CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。</p></blockquote><blockquote><p>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p></blockquote><ul><li><strong>阐述一下 CSSSprites</strong><br>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites能减少图片的字节。</li></ul><p>优点：</p><blockquote><p>减少HTTP请求数，极大地提高页面加载速度<br>增加图片信息重复度，提高压缩比，减少图片大小<br>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</p></blockquote><p>缺点：</p><blockquote><p>图片合并麻烦<br>维护麻烦，修改一个图片可能需要重新布局整个图片，样式</p></blockquote><ul><li><strong>使用 rem 布局的优缺点？</strong><br>优点：<blockquote><p>在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。<br>而且现在浏览器基本都已经支持rem了，兼容性也非常的好。</p></blockquote></li></ul><p>缺点：</p><blockquote><p>（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。<br>（2）使用iframe引用也会出现问题。<br>（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。</p></blockquote><ul><li><p>画一条 0.5px 的线</p><blockquote><p>采用meta viewport的方式</p><p>采用border-image的方式</p><p>采用transform:scale()的方式</p></blockquote></li><li><p><strong>transition 和 animation 的区别</strong></p><blockquote><p>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。</p><p>animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</p></blockquote></li><li><p><strong>什么是首选最小宽度？</strong><br>“首选最小宽度”，指的是元素最适合的最小宽度。</p></li></ul><blockquote><p>东亚文字（如中文）最小宽度为每个汉字的宽度。</p><p>西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。</p><p>如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</p></blockquote><ul><li><p><strong>为什么 height:100%会无效？</strong></p><blockquote><p>对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</p><p>原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，<br>所以无法参与计算。</p><p>使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。 </p></blockquote></li><li><p><strong>min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</strong></p><blockquote><p>（1）max-width会覆盖width，即使width是行类样式或者设置了!important。</p><p>（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。</p></blockquote></li><li><p><strong>内联盒模型基本概念</strong></p><blockquote><p>（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。</p><p>（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。</p><p>（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</p><p>（4）包含块（containing box），由一行一行的“行框盒子”组成。</p></blockquote></li><li><p><strong>什么是幽灵空白节点？</strong></p><blockquote><p>“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</p></blockquote></li><li><p><strong>什么是替换元素？</strong><br>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，<code>&lt;img&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;iframe&gt;</code>或者表单元素<code>&lt;textarea&gt;</code>和<code>&lt;input&gt;</code>和<code>&lt;select&gt;</code>都是典型的替换元素。</p></li></ul><p>替换元素除了内容可替换这一特性以外，还有以下一些特性。</p><blockquote><p>（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口，</p><p>（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如<code>&lt;video&gt;</code>、<code>&lt;iframe&gt;</code>或者<code>&lt;canvas&gt;</code>等，也有少部分替换元素为0像素，如<code>&lt;img&gt;</code>图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。</p><p>（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是<code>vertical-align</code>属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</p><p>（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</p></blockquote><ul><li><strong>替换元素的计算规则？</strong><br>替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</li></ul><blockquote><p>（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</p><p>（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括<code>&lt;img&gt;</code>的width和height属性、<code>&lt;input&gt;</code>的size属性、<code>&lt;textarea&gt;</code>的cols和rows属性等。</p><p>（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</p></blockquote><p>这3层结构的计算规则具体如下</p><blockquote><p>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</p><p>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</p><p>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。</p><p>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</p><p>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</p><p>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p></blockquote><ul><li><strong>content 与替换元素的关系？</strong><br>content属性生成的对象称为“匿名替换元素”。</li></ul><blockquote><p>（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。</p><p>（2）content生成的内容不能左右:empty伪类。</p><p>（3）content动态生成值无法获取。 </p></blockquote><ul><li><strong>margin:auto 的填充规则？</strong><br>margin的’auto’可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。</li></ul><blockquote><p>（1）如果一侧定值，一侧auto，则auto为剩余空间大小。<br>（2）如果两侧均是auto，则平分剩余空间。</p></blockquote><ul><li><p><strong>margin 无效的情形</strong></p><blockquote><p>（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有margin合并的问题。</p><p>（2）表格中的<tr>和<td>元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。</p><p>（3）绝对定位元素非定位方位的margin值“无效”。</p><p>（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。</p></blockquote></li><li><p><strong>border 的特殊性？</strong></p><blockquote><p>（1）border-width却不支持百分比。</p><p>（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-color没有边框显示的原因。</p><p>（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。</p><p>（4）border-color默认颜色就是color色值。</p><p>（5）默认background背景图片是相对于padding box定位的。</p></blockquote></li><li><p><strong>什么是基线和 x-height？</strong></p><blockquote><p>字母x的下边缘（线）就是我们的基线。</p><p>x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。</p><p>ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</p></blockquote></li><li><p><strong>line-height 的特殊性？</strong></p><blockquote><p>（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</p><p>（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</p><p>（3）行距=line-height-font-size。</p><p>（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。</p><p>（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</p><p>（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。</p><p>（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</p><p>（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。</p><p>（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</p><p>（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</p></blockquote></li><li><p><strong>vertical-align 的特殊性？</strong></p><blockquote><p>（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。</p><p>（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display计算值是table-cell的元素，我们不妨脑补成<td>元素，则和<tr>元素上边缘对齐。</p><p>（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。</p><p>（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。</p><p>（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。</p><p>（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。</p><p>（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。</p></blockquote></li><li><p><strong>overflow 的特殊性？</strong></p><blockquote><p>（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。</p><p>（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素<code>&lt;html&gt;</code>，另一个是文本域<code>&lt;textarea&gt;</code>。</p><p>（3）滚动条会占用容器的可用宽度或高度。</p><p>（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</p></blockquote></li><li><p><strong>无依赖绝对定位是什么？</strong></p><blockquote><p>没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。</p><p>无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。</p></blockquote></li><li><p><strong>absolute 与 overflow 的关系？</strong></p><blockquote><p>（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素进行剪裁。</p><p>（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也都不会出现滚动条。</p><p>（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。</p></blockquote></li><li><p><strong>clip 裁剪是什么？</strong></p><blockquote><p>所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。</p><p>clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</p></blockquote></li><li><p><strong>relative 的特殊性？</strong></p><blockquote><p>（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</p><p>（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。</p><p>（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。</p></blockquote></li><li><p><strong>什么是层叠上下文？</strong><br>层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p></li></ul><p>层叠上下文元素有如下特性：</p><blockquote><p>（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。<br>（2）层叠上下文可以阻断元素的混合模式。<br>（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。<br>（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。<br>（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</p></blockquote><p>层叠上下文的创建：</p><blockquote><p>（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是<html>元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。</p><p>（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。</p><p>（3）其他一些CSS3属性，比如元素的opacity值不是1。</p></blockquote><ul><li><p><strong>什么是层叠水平？</strong></p><blockquote><p>层叠水平，英文称作stacking level，决定了同一个层叠上下文中元素在z轴上的显示顺序。</p><p>显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。</p></blockquote></li><li><p><strong>元素的层叠顺序？</strong><br>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。</p></li><li><p><strong>层叠准则？</strong></p><blockquote><p>（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</p><p>（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</p></blockquote></li><li><p><strong>font-weight 的特殊性？</strong></p><blockquote><p>如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。</p></blockquote></li><li><p><strong>text-indent 的特殊性？</strong></p><blockquote><p>（1）text-indent仅对第一行内联盒子内容有效。</p><p>（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inline-table则会生效。</p><p>（3）<code>&lt;input&gt;</code>标签按钮text-indent值无效。</p><p>（4）<code>&lt;button&gt;</code>标签按钮text-indent值有效。</p><p>（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</p></blockquote></li><li><p><strong>letter-spacing 与字符间距？</strong><br>letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。</p></li></ul><p>letter-spacing具有以下一些特性。</p><blockquote><p>（1）继承性。<br>（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。<br>（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。<br>（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。<br>（5）支持小数值，即使0.1px也是支持的。<br>（6）暂不支持百分比值。</p></blockquote><ul><li><strong>word-spacing 与单词间距？</strong><blockquote><p>letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。</p></blockquote></li><li><strong>white-space 与换行和空格的控制？</strong><br>white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否生效）等。</li></ul><p>其属性值包括下面这些。</p><blockquote><p>•normal：合并空白字符和换行符。<br>•pre：空白字符不合并，并且内容只在有换行符的地方换行。<br>•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。<br>•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。<br>•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。</p></blockquote><ul><li><strong>隐藏元素的 background-image 到底加不加载？</strong></li></ul><blockquote><p>（1）元素的背景图片</p></blockquote><p>-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求 -:hover 样式下，触发时请求</p><blockquote><p>（2）img 标签图片任何情况下都会请求图片</p></blockquote><ul><li><p><strong>如何实现单行／多行文本溢出的省略（…）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="comment">/*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'...'</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>常见的元素隐藏方式？</strong></p><blockquote><p>（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</p><p>（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</p><p>（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</p><p>（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</p><p>（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</p><p>（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p><p>（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p></blockquote></li></ul><ul><li><strong>css 实现上下固定中间自适应布局</strong><br>利用绝对定位实现<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>利用flex布局实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>css 两栏布局的实现</strong><br>相关资料：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*/</span></span><br><span class="line"><span class="comment">/*以左边宽度固定为200px为例*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: auto;</span><br><span class="line">  <span class="comment">/*11auto*/</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为</span></span><br><span class="line"><span class="comment">200px。将右边元素的margin-left的值设置为200px。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。</p><p>以左边宽度固定为 200px 为例</p><blockquote><p>（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。</p><p>（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。</p><p>（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。</p><p>（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。</p></blockquote><ul><li><strong>css 三栏布局的实现</strong><br>相关资料：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里以左边宽度固定为100px，右边宽度固定为200px为例。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">00100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">00200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元</span></span><br><span class="line"><span class="comment">素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</p><p>这里以左边宽度固定为100px，右边宽度固定为200px为例。</p><blockquote><p>（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</p><p>（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。</p><p>（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。</p><p>（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。双飞翼布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。</p><p>（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</p></blockquote><ul><li><strong>实现一个宽高自适应的正方形</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.第一种方式是利用vw来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.第三种方式是利用子元素的margin-top的值来实现的*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>实现一个三角形</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*三角形的实现原理是利用了元素边框连接处的等分原理。*/</span></span><br><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: tomato transparent transparent transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>一个自适应矩形，水平垂直居中，且宽高比为 2:1</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现原理参考自适应正方形和水平居中方式*/</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在把整理的 css 在面试中可能会被问到的问题剩下部分记录一下。&lt;br&gt;我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』 css questions (part 2)</title>
    <link href="https://jambo0624.github.io/2020-05-05-css-question2.html"/>
    <id>https://jambo0624.github.io/2020-05-05-css-question2.html</id>
    <published>2020-05-05T11:28:04.000Z</published>
    <updated>2020-10-19T08:58:01.176Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jambo0624.github.io/2020-05-03-css-question.html">前一篇文章</a>整理了 css 在面试中可能会被问到的问题，现在把整理的第二部分记录下来。<br>我们开始吧。</p><a id="more"></a><ul><li><strong>::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。</strong></li></ul><blockquote><p>在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。<br>但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。<br>伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。</p></blockquote><ul><li><p><strong>伪类与伪元素的区别</strong></p><blockquote><p>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p><p>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。</p><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p></blockquote></li><li><p><strong>CSS 中哪些属性可以继承？</strong><br>有继承性的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）字体系列属性 font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）文本系列属性 text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）表格布局属性 caption-side border-collapse empty-cells</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）列表属性 list-style-type、list-style-image、list-style-position、list-style</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）光标属性 cursor</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）元素可见性 visibility</span><br><span class="line"></span><br><span class="line">（<span class="number">7</span>）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性</span><br><span class="line"></span><br><span class="line">注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>CSS 优先级算法如何计算？</strong><br>相关知识点：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CSS的优先级是根据样式声明的特殊性值来判断的。</span><br><span class="line"></span><br><span class="line">选择器的特殊性值分为四个等级，如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）标签内选择符x,0,0,0</span></span><br><span class="line"><span class="comment">//（2）ID选择符0,x,0,0</span></span><br><span class="line"><span class="comment">//（3）class选择符/属性选择符/伪类选择符0,0,x,0</span></span><br><span class="line"><span class="comment">//（4）元素和伪元素选择符0,0,0,x</span></span><br><span class="line"></span><br><span class="line">计算方法：</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）每个等级的初始值为0</span></span><br><span class="line"><span class="comment">//（2）每个等级的叠加为选择器出现的次数相加</span></span><br><span class="line"><span class="comment">//（3）不可进位，比如0,99,99,99</span></span><br><span class="line"><span class="comment">//（4）依次表示为：0,0,0,0</span></span><br><span class="line"><span class="comment">//（5）每个等级计数之间没关联</span></span><br><span class="line"><span class="comment">//（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值</span></span><br><span class="line"><span class="comment">//（7）如果两个优先级相同，则最后出现的优先级高，!important也适用</span></span><br><span class="line"><span class="comment">//（8）通配符选择器的特殊性值为：0,0,0,0</span></span><br><span class="line"><span class="comment">//（9）继承样式优先级最低，通配符样式优先级高于继承样式</span></span><br><span class="line"><span class="comment">//（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>关于伪类 LVHA 的解释?</strong><br>a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</li></ul><p>当链接未访问过时：</p><blockquote><p>（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；<br>（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。</p></blockquote><p>当链接访问过时，情况基本同上，只不过需要将:link换成:visited。</p><p>这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。</p><ul><li><p><strong>display 有哪些值？说明他们的作用。</strong></p><blockquote><p>block    块类型。默认宽度为父元素宽度，可设置宽高，换行显示。<br>none    元素不显示，并从文档流中移除。<br>inline    行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。<br>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。<br>list-item    像块类型元素一样显示，并添加样式列表标记。<br>table    此元素会作为块级表格来显示。<br>inherit    规定应该从父元素继承display属性的值。</p></blockquote></li><li><p><strong>CSS3 有哪些新特性？</strong></p><blockquote><p>新增各种CSS选择器    （:not(.input)：所有class不是“input”的节点）<br>圆角        （border-radius:8px）<br>多列布局    （multi-column layout）<br>阴影和反射    （Shadow\Reflect）<br>文字特效        （text-shadow）<br>文字渲染        （Text-decoration）<br>线性渐变        （gradient）<br>旋转            （transform）<br>缩放，定位，倾斜，动画，多背景<br>例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</p></blockquote></li></ul><ul><li><strong>一个满屏品字布局如何设计?</strong><br>简单的方式：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的div宽100%，               </span></span><br><span class="line"><span class="comment">// 下面的两个div分别宽50%，            </span></span><br><span class="line"><span class="comment">// 然后用float或者inline使其不换行即可</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>CSS 多列等高如何实现？</strong><blockquote><p>（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p><p>（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。</p><p>（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度的特性，来实现多列等高。</p></blockquote></li></ul><ul><li><strong>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</strong><blockquote><p>（1）png24位的图片在iE6浏览器上出现背景。解决方案：做成PNG8，也可以引用一段脚本处理。</p></blockquote></li></ul><blockquote><p>（2）浏览器默认的margin和padding不同。解决方案：加一个全局的*{margin:0;padding:0;}来统一。</p></blockquote><blockquote><p>（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">10px</span>;<span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;&#125;</span><br></pre></td></tr></table></figure><p>这种情况之下IE会产生20px的距离<br>解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p><blockquote><p>（4）渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用”\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用”+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bb</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f1ee18</span>;<span class="comment">/*所有识别*/</span></span><br><span class="line">  <span class="selector-class">.background-color</span>: <span class="number">#00deff</span>\<span class="number">9</span>;<span class="comment">/*IE6、7、8识别*/</span></span><br><span class="line">  +<span class="attribute">background-color</span>: <span class="number">#a200ff</span>;<span class="comment">/*IE6、7识别*/</span></span><br><span class="line">  _background-<span class="attribute">color</span>: <span class="number">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义<br>属性；Firefox下，只能使用getAttribute()获取自定义属性<br>解决方法：统一通过getAttribute()获取自定义属性。</p></blockquote><blockquote><p>（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有<br>pageX、pageY属性，但是没有x、y属性。<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p></blockquote><blockquote><p>（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示<br>解决方法：</p></blockquote><p>1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome更新到27版本之后就不可以用了。</p><p>2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/…；</p><blockquote><p>（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了 解决方法：改变CSS属性的排列顺序L-V-H-A</p></blockquote><blockquote><p>（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</p></blockquote><ul><li>li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？<br>浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个<li>放在一行，这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</li></ul><p>解决办法：</p><blockquote><p>（1）为<code>&lt;li&gt;</code>设置<code>float:left</code>。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p><p>（2）将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</p><p>（3）将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即<code>font-size:0</code>。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p><p>（4）消除<code>&lt;ul&gt;</code>的字符间隔<code>letter-spacing:-8px</code>，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符间隔设为默认<code>letter-spacing:normal</code>。</p></blockquote><ul><li><strong>为什么要初始化 CSS 样式？</strong></li></ul><p>-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p><p>-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p><p>最简单的初始化方法：<code>*{padding:0;margin:0;}</code>（强烈不建议）</p><p>淘宝的样式初始化代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">hr</span>,<span class="selector-tag">p</span>,<span class="selector-tag">blockquote</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dt</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">li</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">form</span>,<span class="selector-tag">fieldset</span>,<span class="selector-tag">legend</span></span><br><span class="line">,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">th</span>,<span class="selector-tag">td</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">select</span>,<span class="selector-tag">textarea</span>&#123;<span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma,arial,\<span class="number">5</span>b8b\<span class="number">4</span>f53;&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;<span class="attribute">font-size</span>:<span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-tag">address</span>,<span class="selector-tag">cite</span>,<span class="selector-tag">dfn</span>,<span class="selector-tag">em</span>,<span class="selector-tag">var</span>&#123;<span class="attribute">font-style</span>:normal;&#125;</span><br><span class="line"><span class="selector-tag">code</span>,<span class="selector-tag">kbd</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">samp</span>&#123;<span class="attribute">font-family</span>:couriernew,courier,monospace;&#125;</span><br><span class="line"><span class="selector-tag">small</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br><span class="line"><span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>&#123;<span class="attribute">list-style</span>:none;&#125;</span><br><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">text-decoration</span>:none;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">text-decoration</span>:underline;&#125;</span><br><span class="line"><span class="selector-tag">sup</span>&#123;<span class="attribute">vertical-align</span>:text-top;&#125;</span><br><span class="line"><span class="selector-tag">sub</span>&#123;<span class="attribute">vertical-align</span>:text-bottom;&#125;</span><br><span class="line"><span class="selector-tag">legend</span>&#123;<span class="attribute">color</span>:<span class="number">#000</span>;&#125;</span><br><span class="line"><span class="selector-tag">fieldset</span>,<span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">select</span>,<span class="selector-tag">textarea</span>&#123;<span class="attribute">font-size</span>:<span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-tag">table</span>&#123;<span class="attribute">border-collapse</span>:collapse;<span class="attribute">border-spacing</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>什么是包含块，对于包含块的理解?</strong><br>包含块（containing block）就是元素用来计算和定位的一个框。</li></ul><blockquote><p>（1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</p><p>（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box边界形成。</p><p>（3）如果元素position:fixed，则“包含块”是“初始包含块”。</p><p>（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：</p></blockquote><p>如果该祖先元素是纯inline元素，则规则略复杂：</p><blockquote><p>假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包含块”；<br>如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的padding box边界形成。</p></blockquote><p>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</p><ul><li><strong>CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</strong><br>（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。</li></ul><p>（2）但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。</p><p>在不同浏览器下的区别：</p><p>在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。</p><p>在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</p><ul><li><strong>width:auto 和 width:100%的区别</strong><br>一般而言</li></ul><blockquote><p>width:100%会使元素box的宽度等于父元素的content box的宽度。</p><p>width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。</p></blockquote><ul><li><strong>绝对定位元素与非绝对定位元素的百分比计算的区别</strong><blockquote><p>绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。</p><p>非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。</p></blockquote></li><li><strong>简单介绍使用图片 base64 编码的优点和缺点。</strong><br>base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url属性。</li></ul><p>使用base64的优点是：</p><blockquote><p>（1）减少一个图片的HTTP请求</p></blockquote><p>使用base64的缺点是：</p><blockquote><p>（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</p></blockquote><blockquote><p>（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要差很多。</p></blockquote><blockquote><p>（3）兼容性的问题，ie8以前的浏览器不支持。</p></blockquote><p>一般一些网站的小图标可以使用base64图片来引入。</p><ul><li><strong>‘display’、’position’和’float’的相互关系？</strong><blockquote><p>（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p></blockquote></li></ul><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；<br>其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；<br>最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><ul><li><strong>margin 重叠问题的理解。</strong><br>相关知识点：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生折叠的必备条件：margin必须是**邻接的**!</span></span><br></pre></td></tr></table></figure></li></ul><p>margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。</p><p>一般来说可以分为四种情形：</p><blockquote><p>第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC来解决。</p><p>第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC来解决。</p><p>第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。</p><p>第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、padding或者高度来解决这个问题。</p></blockquote><ul><li>对 BFC 规范（块级格式化上下文：block formatting context）的理解？</li></ul><blockquote><p>BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。</p><p>一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。</p></blockquote><ul><li><strong>IFC 是什么？</strong><br>IFC指的是行级格式化上下文，它有这样的一些布局规则：</li></ul><blockquote><p>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。<br>（2）当一行不够的时候会自动切换到下一行。<br>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</p></blockquote><ul><li><p><strong>移动端的布局用过媒体查询吗？</strong></p><blockquote><p>假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</p><p>当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。</p><p>包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。</p></blockquote></li><li><p><strong>CSS 优化、提高性能的方法有哪些？</strong><br>加载性能：</p></li></ul><blockquote><p>（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。<br>（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。<br>（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p></blockquote><p>选择器性能：</p><blockquote><p>（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p><p>（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</p><p>（3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</p><p>（4）尽量少的去对标签进行选择，而是用class。</p><p>（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p><p>（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p></blockquote><p>渲染性能：</p><blockquote><p>（1）慎重使用高性能属性：浮动、定位。</p><p>（2）尽量减少页面重排、重绘。</p><p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</p><p>（4）属性值为0时，不加单位。</p><p>（5）属性值为浮动小数0.**，可以省略小数点之前的0。</p><p>（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</p><p>（7）不使用@import前缀，它会影响css的加载速度。</p><p>（8）选择器优化嵌套，尽量避免层级过深。</p><p>（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</p><p>（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p><p>（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</p></blockquote><p>可维护性、健壮性：</p><blockquote><p>（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。<br>（2）样式与内容分离：将css代码定义到外部css中。</p></blockquote><ul><li><p><strong>浏览器是怎样解析 CSS 选择器的？</strong></p><blockquote><p>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。</p><p>试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</p></blockquote></li><li><p><strong>在网页中应该使用奇数还是偶数的字体？为什么呢？</strong></p><blockquote><p>（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。<br>（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。<br>（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</p></blockquote></li><li><p><strong>margin 和 padding 分别适合什么场景使用？</strong></p><blockquote><p>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。<br>margin用于布局分开元素使元素与元素互不相干。<br>padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</p></blockquote></li></ul><p>何时应当使用margin：</p><blockquote><p>•需要在border外侧添加空白时。<br>•空白处不需要背景（色）时。<br>•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</p></blockquote><p>何时应当时用padding：</p><blockquote><p>•需要在border内测添加空白时。<br>•空白处需要背景（色）时。<br>•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</p></blockquote><ul><li><p><strong>抽离样式模块怎么写，说出思路，有无实践经验？</strong><br>我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。</p></li><li><p><strong>简单说一下 css3 的 all 属性。</strong></p><blockquote><p>all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</p><p>initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始值。</p><p>inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。</p><p>unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。</p></blockquote></li></ul><ul><li><strong>为什么不建议使用统配符初始化 css 样式。</strong><br>采用*{padding:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。</li></ul><p>出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即可，并不需使用通配符*来初始化。</p><ul><li><p><strong>absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</strong></p><blockquote><p>（1）内联元素也可以作为“包含块”所在的元素；</p><p>（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</p><p>（3）边界是padding box而不是content box。</p></blockquote></li><li><p><strong>对于 hasLayout 的理解？</strong></p><blockquote><p>hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。</p></blockquote></li><li><p><strong>元素竖向的百分比设定是相对于容器的高度吗？</strong></p><blockquote><p>如果是height的话，是相对于包含块的高度。</p><p>如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。</p></blockquote></li><li><p><strong>怎么让 Chrome 支持小于 12px 的文字？</strong><br>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p></li></ul><p>解决办法：</p><blockquote><p>（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</p><p>（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</p><p>（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</p></blockquote><ul><li><strong>让页面里的字体变清晰，变细用 CSS 怎么做？</strong><blockquote><p>webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</p></blockquote></li></ul><blockquote><p>在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。</p></blockquote><ul><li><p><strong>设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</strong></p><blockquote><p>设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</p><p>css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。</p><p>dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。</p><p>ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</p></blockquote></li><li><p><strong>layout viewport、visual viewport 和 ideal viewport 的区别？</strong><br>移动端一共需要理解三个viewport的概念的理解。</p></li></ul><blockquote><p>第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。</p></blockquote><blockquote><p>第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visual viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。</p></blockquote><blockquote><p>第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://jambo0624.github.io/2020-05-03-css-question.html&quot;&gt;前一篇文章&lt;/a&gt;整理了 css 在面试中可能会被问到的问题，现在把整理的第二部分记录下来。&lt;br&gt;我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』 css questions</title>
    <link href="https://jambo0624.github.io/2020-05-03-css-question.html"/>
    <id>https://jambo0624.github.io/2020-05-03-css-question.html</id>
    <published>2020-05-03T04:13:14.000Z</published>
    <updated>2020-10-19T08:55:11.002Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章总结了 html 部分针对面试的一些沉淀<br>今天主要是 css 部分内容，下面开始。 </p><a id="more"></a><ul><li><p>两种盒模型分别说一下<br>box-sizing：content-box（外加）<br>box-sizing：border-box（内减）        </p></li><li><p>水平居中<br>行内元素：text-align:center<br>块级元素：margin: 0 auto<br>绝对定位和移动：position:absolute; transform:translate()<br>绝对定位和负边距：position:absolute; margin:<br>flex布局：display:flex; justify-content:center;        </p></li><li><p>如何垂直居中        </p></li></ul><ol><li>不定高度,<code>padding:10px</code>        </li><li>定高度        <blockquote><p>1.table<br>2.伪装display:table<br>3.加上100%的before和after，并且display:inline-block<br>4.子绝父相，top和left为0，margin:auto<br>5.子绝父相，top和left为50%，margin调整<br>6.子绝父相，top和left为50%，translate调整<br>7.flex          </p></blockquote></li></ol><ul><li><p>BFC 是什么<br>块格式化上下文（Block Formatting Context，BFC）是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域<br>浮动元素、绝对定位元素、行内块元素、弹性元素、overflow 值不为 visible 的块元素会触发BFC        </p><blockquote><p>其中上外边距塌陷，解决方法如下        </p></blockquote><pre class="line-numbers language-css"><span class="selector-class">.selector</span><span class="selector-pseudo"><code class="language-css"><span class="selector-class">.selector</span><span class="selector-pseudo">::before</span>{          <span class="attribute">content</span>: <span class="string">""</span>;          <span class="attribute">display</span>:table;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>CSS 选择器优先级<br>越具体优先级越高<br>同样优先级写在后面的覆盖写在前面的<br>!important 优先级最高，但是要少用        </p></li></ul><ul><li><p>如何清除浮动        </p><pre class="line-numbers language-css"><span class="selector-class">.clearfix</span><span class="selector-pseudo"><code class="language-css"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> {          <span class="attribute">content</span>: <span class="string">''</span>;          <span class="attribute">display</span>: block; <span class="comment">/*或者 table*/</span>          <span class="attribute">clear</span>: both;        }        <span class="selector-class">.clearfix</span> {          <span class="attribute">zoom</span>: <span class="number">1</span>; <span class="comment">/* IE 兼容*/</span>        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>CSS 加载方式有几种<br>行内，内联，外链，import        </p></li><li><p>简述 src 和 href 的区别<br>href 时指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。<br>src 时指向外部的资源位置，指向的内容将会嵌入到文档中当前标签所在位置        </p></li><li><p>css选择器(e代表元素) <a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener">相关文章</a></p></li></ul><table><thead><tr><th>阐述</th><th>写法</th></tr></thead><tbody><tr><td>通用</td><td>*</td></tr><tr><td>元素</td><td>e</td></tr><tr><td>类</td><td>.class</td></tr><tr><td>id</td><td>#id</td></tr><tr><td>群组</td><td>e1,e2</td></tr><tr><td>后代</td><td>e1 e2</td></tr><tr><td>子代</td><td>e1&gt;e2</td></tr><tr><td>相邻兄弟</td><td>e1+e2</td></tr><tr><td>通用兄弟</td><td>e1~e2</td></tr><tr><td>属性</td><td>[attr] elem[attr] [attr1][attr2] [attr=value]</td></tr><tr><td>属性相关</td><td>[attr^=value] [attr$=value] [attr*=value] [attr~=value]</td></tr><tr><td>伪类– 链接伪类</td><td>:link  :visited</td></tr><tr><td>伪类– 动态伪类</td><td>:hover  :active  :focus</td></tr><tr><td>伪类– 结构伪类</td><td>:first-child :last-child :nth-child(n) :empty :only-child</td></tr><tr><td>伪类– 目标伪类</td><td>:target</td></tr><tr><td>伪类– 否定伪类</td><td>:not</td></tr><tr><td>伪元素</td><td>:first-letter :first-line ::selection</td></tr><tr><td>伪元素–内容生成</td><td>:before或::before :after或::after 必须要有content属性</td></tr></tbody></table><ul><li><p><a href="https://www.jianshu.com/p/d5cc4e169dfa" target="_blank" rel="noopener">CSS 继承，哪些属性能继承，哪些不能</a>        </p></li><li><p><a href="https://www.jianshu.com/p/82f02af17e78" target="_blank" rel="noopener">px、em、rem、%、vw、vh、vm这些单位的区别</a>        </p></li><li><p>line-height: 2和line-height: 200%的区别<br>两个属性设置给具体的某一个元素时是没有区别的<br>区别就是他们设置两种不同的属性后其子元素表现样式上的区别！2是子元素自身，200%是父元素，也就是固定值        </p></li><li><p>行内元素的“框属性”是 line-height 控制<br>对于行内元素来说，上下的 margin padding 不生效，只有左右的 margin padding 生效！        </p></li></ul><ul><li>inline-block 在实际工作中有什么作用<br>如果看到页面上有一排并列的按钮，如果不用浮动，就可以用 inline-block        </li></ul><ul><li><p>让一个元素“看不见”的几种方式        </p><blockquote><p>将元素设置为display:none后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。<br>visibility:hidden适用于那些元素隐藏后不希望页面布局会发生变化的场景.<br>opacity:0<br>设置height，width等盒模型属性为0<br>设置元素的position与left，top，bottom，right等，将元素移出至屏幕外<br>设置元素的position与z-index，将z-index设置成尽量小的负数<br>——能不能点击<br>display,visibility不能，opacity可以，height看情况<br>——能不能动画<br>display立即消失，没有动画<br>visibility按时消失，没有动画<br>opacity和height正常        </p></blockquote></li><li><p>css实现文本溢出显示省略号<br>单行文本        </p><pre class="line-numbers language-css"><span class="selector-tag"><code class="language-css"><span class="selector-tag">p</span> {          <span class="attribute">width</span>: <span class="number">300px</span>;          <span class="attribute">overflow</span>: hidden;          <span class="comment">/*文本不会换行*/</span>          <span class="attribute">white-space</span>: nowrap;          <span class="comment">/*当文本溢出包含元素时，以省略号表示超出的文本*/</span>          <span class="attribute">text-overflow</span>: ellipsis;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多行文本看链接<a href="https://www.jianshu.com/p/50bbd21c0c0f" target="_blank" rel="noopener">css多行文本溢出显示省略号</a>        </p></li></ul><ul><li>三栏布局        <blockquote><p>1.flex布局:容器flex，两边固定px，中间flex1<br>2.绝对定位布局：容器相对，两边绝对，中间margin固定<br>3.圣杯模式： 中间100%，fll，然后左边fll+负向ml再定位调整，右边同理<br>关键在于理解负边距的作用，left的margin-left:-100%使它上移一行        </p></blockquote><pre class="line-numbers language-css"><span class="selector-class"><code class="language-css"><span class="selector-class">.wrapper</span> {          <span class="attribute">overflow</span>: hidden;          <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;            }            <span class="selector-class">.middle</span> {          <span class="attribute">position</span>:relative;                      <span class="attribute">width</span>: <span class="number">100%</span>;          <span class="attribute">float</span>: left;          <span class="attribute">height</span>: <span class="number">80px</span>;          <span class="attribute">background</span>: green;            }        <span class="selector-class">.left</span> {          <span class="attribute">position</span>: relative;          <span class="attribute">float</span>: left;          <span class="attribute">width</span>: <span class="number">100px</span>;          <span class="attribute">background</span>: yellow;          <span class="attribute">height</span>: <span class="number">80px</span>;          <span class="attribute">left</span>: -<span class="number">100px</span>;          <span class="attribute">margin-left</span>: -<span class="number">100%</span>;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>4.双飞翼布局： 中间容器wrapper浮动，width100%，main的ml和mr固定，左右浮动和ml、mr<br>跟圣杯布局没多大区别，就是middle的实现不一样，圣杯布局是middle+padding，双飞翼采用子元素+margin，最主要的还是负边距的使用        </p></blockquote><ul><li>列举你了解的 HTML5、CSS3 新特性<br><a href="https://juejin.im/post/5cbffe386fb9a0322564c0e5" target="_blank" rel="noopener">CSS3 和 HTML5 新特性一览</a><br>CSS3:<br>选择器，边框，背景，渐变，转换，过渡，动画，盒模型，flex，媒体查询<br>HTML5:<br>语义标签，增强型表单，音频视频，canvas， svg，地理位置，webWorker，webStorage，webSocket（全双工通讯）        </li></ul><ul><li>flex：1代表什么意思<br><code>flex: flex-grow flex-shrink flex-basis</code></li></ul><table><thead><tr><th>取值</th><th>结果</th></tr></thead><tbody><tr><td>默认</td><td><code>0 1 auto</code></td></tr><tr><td>none</td><td><code>0 0 auto</code></td></tr><tr><td>auto</td><td><code>1 1 auto</code></td></tr><tr><td>非负数</td><td><code>非负数 1 0%</code></td></tr><tr><td>长度或百分比</td><td><code>1 1 长度或百分比</code></td></tr><tr><td>非负数 非负数</td><td><code>非负数 非负数 0%</code></td></tr><tr><td>非负数 长度或百分比</td><td><code>非负数 1 长度或百分比</code></td></tr></tbody></table><p>flex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。这里主要讨论以下 flex-basis 的取值情况：<br>auto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。<br>content：指根据该子元素的内容自动布局。有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto。<br>百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。        </p><p><img src="https://www.w3.org/html/ig/zh/css-flex-1/rel-vs-abs-flex.svg" alt="flex:0 和 flex:auto的区别"><br>👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆一个显示「绝对」伸缩（以零为基准值开始）与「相对」伸缩（以项目的内容大小为基准值开始）差异的图解。这三个项目的伸缩比例分别是「1」、「1」、「2」。        </p><ul><li>Canvas 和 SVG 有什么区别<br>SVG 矢量图优点：不失真，放大缩小图像都很清晰学习成本低，也是一种 DOM 结构使用方便，设计软件可以直接导出<br>Canvas 像素图优点（在元素特别多的情况 1000+）：性能高，可以自己控制绘制过程，还能使用 WebGL可控性高，像素级控制内存占用恒定，就是像素点个数<br>SVG 的应用范围更广一些。        </li></ul><ul><li>渐进增强和优雅降级分别是什么意思<br>渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br>优雅降级（graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。        </li></ul><ul><li>css reset 是什么？css 预编译器是什么？ 后编译器(post css)是什么？<br>css reset 即重置浏览器标签的样式表        <blockquote><p>现在所使用的主流浏览器对一些标签的默认属性上并没有做到统一，所以我们偶尔会发现，某个页面在chrome浏览器上很正常，到了firefox上面却有意想不到的偏差。当然编程人员不喜欢这样的兼容性问题的，而reset.css就是解决默认样式不兼容问题的办法之一。</p></blockquote></li></ul><p>预编译器        </p><blockquote><p>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。<br>CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。</p></blockquote><p>后编译器(post css)        </p><blockquote><p>PostCSS是一个使用JavaScript插件来转换CSS的工具。它将CSS转换成抽象语法树(AST)，也就是JavaScript可以操作的一种数据形式。基于JavaScript的PostCSS插件可以执行不同的代码操作。PostCSS本身并没有改变你的CSS，它请允许插件执行和转换你的代码。<br>实际上，对于CSS的操作，PostCSS插件并没有任何限制。只要你有想得到的，你都可以写一个PostCSS插件来实现。        </p></blockquote><ul><li>浅谈css预处理器，Sass、Less和Stylus<br>下面从特性上比较三者异同：        </li></ul><ol><li><p>变量：        </p><blockquote><p>Sass声明变量必须是『$』开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号：分隔开。<br>Less 声明变量用『@』开头，其余等同 Sass。<br>Stylus 中声明变量没有任何限定，结尾的分号可有可无，但变量名和变量值之间必须要有『等号』。但需要注意的是，如果用“@”符号来声明变量，Stylus会进行编译，但不会赋值给变量。就是说，Stylus 不要使用『@』声明变量。Stylus 调用变量的方法和Less、Sass完全相同。        </p></blockquote></li><li><p>作用域：<br>css 预编译器把变量赋予作用域，也就是存在生命周期。就像 js 一样，它会先从局部作用域查找变量，依次向上级作用域查找。        </p><blockquote><p>Sass：三者最差，不存在全局变量的概念。也就是说在 Sass 中定义了相同名字的变量时你就要小心蛋疼了。<br>Less：我认为跟 JS 一样，逐级查找，向上冒泡。<br>Stylus：完全等同 Less。Stylus 和 Sass 则更倾向于指令式。        </p></blockquote></li><li><p>嵌套：<br>十分真诚的说，三种 css 预编译器的「选择器嵌套」在使用上来说没有任何区别（也可能是我没发现）。Sass 除了常规的采用『&amp;』替代父级选择器之外，还提供了「奇葩的属性嵌套」：        </p></li></ol><pre class="line-numbers language-scss"><span class="selector-class"><code class="language-scss"><span class="selector-class">.footer</span> {          <span class="attribute">font</span>: {            family:  微软雅黑;            size: <span class="number">5rem</span>;            weight: bolder;          }        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了少打几个字，感觉没啥用啊。<br>4. 继承：<br>css 属性的继承是一个非常重要的特性，好消息是三种预编译器都对此做出了改善。        </p><blockquote><p>Sass和Stylus的继承非常像，能把一个选择器的所有样式继承到另一个选择器上。使用『@extend』开始，后面接被继承的选择器。        </p></blockquote><pre class="line-numbers language-scss"><span class="selector-class"><code class="language-scss"><span class="selector-class">.shit</span> {          <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span>;          <span class="attribute">padding</span>: <span class="number">2px</span>;        }        <span class="selector-tag">p</span> {          <span class="keyword">@extend</span> .shit;<span class="comment">/*继承.block*/</span>          <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#aaa</span>;        }         <span class="selector-tag">ul</span>,<span class="selector-tag">li</span> {          <span class="keyword">@extend</span> .shit; <span class="comment">/*继承.block*/</span>          <span class="attribute">color</span>: <span class="number">#aaa</span>;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将被编译成标准 css：        </p><pre class="line-numbers language-scss"><span class="selector-class">.shit</span>,<span class="selector-tag">p</span>,<span class="selector-tag">ul</span>,<span class="selector-tag"><code class="language-scss"><span class="selector-class">.shit</span>,<span class="selector-tag">p</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">ol</span> {          <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span>;          <span class="attribute">padding</span>:<span class="number">2px</span>;        }          <span class="selector-tag">p</span> {          <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#aaa</span>        }           ul,li {          color:<span class="number">#aaa</span>;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Less 继承：与前两者继承方式有所区别，它不是在选择器上继承，而是将Mixins中的样式嵌套到每个选择器里面。然而这样会带来一个明显的缺点：每个选择器中会出现重复的样式。        </p></blockquote><ol start="5"><li>导入@Import：<br>CSS中，不建议用@import导入css，因为会增加http请求。但 CSS 预处理器中的导入和CSS的有很大区别，它是将不同 css 是在语义上导入，最终编译结果会生成一个CSS文件。        </li></ol><p>值得注意的是，如果不同文件相互引入的时候，出现相同变量名时可能会引起错误。所以我的建议是单独有一个 var.sass/less/styl 文件来记录所有你定义的变量。        </p><p>Less 为@Import 扩展了语法，而 Sass 和 Stylus 并没有。具体扩展的 import 语法请见：Less 的 Import 扩展        </p><p>总结        </p><blockquote><p>Sass和Less语法严谨、Stylus相对自由。因为Less长得更像 css，所以它可能学习起来更容易。<br>Sass 和 Compass、Stylus 和 Nib 都是好基友。<br>Sass 和 Stylus 都具有类语言的逻辑方式处理：条件、循环等，而 Less 需要通过When等关键词模拟这些功能，这方面 Less 比不上 Sass 和 Stylus。<br>Less 在丰富性以及特色上都不及 Sass 和 Stylus，若不是因为 Bootstrap 引入了 Less，可能它不会像现在这样被广泛应用        </p></blockquote><ul><li>CSS中 link 和@import 的区别<br>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载<br>import只在IE5以上才能识别，而link是HTML标签，无兼容问题<br>link方式的样式的权重 高于@import的权重        </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇文章总结了 html 部分针对面试的一些沉淀&lt;br&gt;今天主要是 css 部分内容，下面开始。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』 html questions (part 2)</title>
    <link href="https://jambo0624.github.io/2020-04-12-html-question2.html"/>
    <id>https://jambo0624.github.io/2020-04-12-html-question2.html</id>
    <published>2020-04-12T03:16:23.000Z</published>
    <updated>2020-10-19T15:15:41.049Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jambo0624.github.io/2020-04-10-html-question.html">前一篇文章</a>整理了 html 在面试中可能会被问到的问题，现在把整理的第二部分记录下来。<br>我们开始吧。</p><a id="more"></a><ul><li>为什么操作 DOM 慢？（浏览器绘制过程）<blockquote><p>一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</p></blockquote></li><li>DOMContentLoaded 事件和 Load 事件的区别？<blockquote><p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。</p></blockquote></li></ul><blockquote><p>Load 事件是当所有资源加载完成后触发的。</p></blockquote><ul><li><p>HTML5 有哪些新特性、移除了那些元素？<br>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p><p>新增的有：</p></li></ul><blockquote><p>绘画 canvas;<br>用于媒介回放的 video 和 audio 元素;<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;<br>sessionStorage 的数据在浏览器关闭后自动删除;<br>语意化更好的内容元素，比如 article、footer、header、nav、section;<br>表单控件，calendar、date、time、email、url、search;<br>新的技术 webworker, websocket;<br>新的文档属性 document.visibilityState</p></blockquote><p> 移除的元素有：</p><blockquote><p>纯表现的元素：basefont，big，center，font, s，strike，tt，u;<br>对可用性产生负面影响的元素：frame，frameset，noframes；</p></blockquote><ul><li>如何处理 HTML5 新标签的浏览器兼容问题？<blockquote><p>（1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。</p></blockquote></li></ul><blockquote><p>（2） 当然也可以直接使用成熟的框架，比如 html5shim ;</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!--[<span class="keyword">if</span> lt IE <span class="number">9</span>]&gt;</span><br><span class="line"> &lt;script src=<span class="string">"http://html5shim.googlecode.com/svn/trunk/html5.js"</span>&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"> &lt;![endif]--&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。</span></span><br></pre></td></tr></table></figure><ul><li>简述一下你对 HTML 语义化的理解？</li></ul><blockquote><p>（1） 用正确的标签做正确的事情。<br>（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;<br>（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;<br>（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p></blockquote><p>总结：</p><blockquote><p>我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。<br>html 的本质作用其实就是定义网页文档的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。<br>这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读。<br>比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。<br>对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。<br>如果用户使用的是屏幕阅读器来访问网页的话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。<br>如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO 。<br>从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、footer 这些语义标签，删除了 big 、font 这些没有语义的标签。</p></blockquote><ul><li>b 与 strong 的区别和 i 与 em 的区别？<blockquote><p>从页面显示效果来看，被 <code>&lt;b&gt;</code> 和 <code>&lt;strong&gt;</code> 包围的文字将会被加粗，而被 <code>&lt;i&gt;</code> 和 <code>&lt;em&gt;</code> 包围的文字将以斜体的形式呈现。</p></blockquote></li></ul><blockquote><p>但是 <code>&lt;b&gt;</code> <code>&lt;i&gt;</code> 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 <code>{ font-weight: bolder}</code>，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。</p></blockquote><blockquote><p>而 <code>&lt;em&gt;</code> 和 <code>&lt;strong&gt;</code> 是语义样式标签。 <code>&lt;em&gt;</code> 表示一般的强调文本，而 <code>&lt;strong&gt;</code> 表示比 <code>&lt;em&gt;</code> 语义更强的强调文本。</p></blockquote><blockquote><p>使用阅读设备阅读网页时：<code>&lt;strong&gt;</code> 会重读，而 <code>&lt;b&gt;</code> 是展示强调内容。</p></blockquote><ul><li><p>前端需要注意哪些 SEO ？</p><blockquote><p>（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。</p><p>（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。</p><p>（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。</p><p>（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p><p>（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容</p><p>（6）非装饰性图片必须加 alt</p><p>（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</p></blockquote></li><li><p>HTML5 的离线储存怎么使用，工作原理能不能解释一下？<br>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p><p>原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>如何使用：</p></li></ul><p>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。 <code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></p><p>（2）在如下 cache.manifest 文件的编写离线存储的资源。</p><blockquote><p><code>CACHE MANIFEST</code><br><code>#v0.11</code><br><code>CACHE:</code><br><code>js/app.js</code><br><code>css/style.css</code><br><code>NETWORK:</code><br><code>resourse/logo.png</code><br><code>FALLBACK:</code><br><code>/ /offline.html</code></p><p>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</p><p>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</p><p>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</p></blockquote><p> （3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</p><p> 如何更新缓存：</p><blockquote><p>（1）更新 manifest 文件<br>（2）通过 javascript 操作<br>（3）清除浏览器缓存</p></blockquote><p> 注意事项：</p><blockquote><p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。<br>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。<br>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。<br>（4）FALLBACK 中的资源必须和 manifest 文件同源。<br>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。<br>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。<br>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p></blockquote><ul><li><p>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</p><blockquote><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p></blockquote><blockquote><p>离线的情况下，浏览器就直接使用离线存储的资源。</p></blockquote></li><li><p>常见的浏览器端的存储技术有哪些？</p><blockquote><p>浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。</p></blockquote><blockquote><p>还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。</p></blockquote><blockquote><p>IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。</p></blockquote></li><li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？<br>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储大小：</span><br><span class="line">  cookie 数据大小不能超过<span class="number">4</span> k 。</span><br><span class="line">  sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 <span class="number">5</span>M 或更大。</span><br><span class="line"></span><br><span class="line">有期时间：</span><br><span class="line">  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。</span><br><span class="line">  sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会</span><br><span class="line">                    保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。</span><br><span class="line">  cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</span><br><span class="line"> </span><br><span class="line">作用域：</span><br><span class="line">    sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。</span><br><span class="line">    localStorage    在所有同源窗口中都是共享的。</span><br><span class="line">    cookie          在所有同源窗口中都是共享的。</span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><blockquote><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p></blockquote><blockquote><p>cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</p></blockquote><blockquote><p>sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</p></blockquote><blockquote><p>localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</p></blockquote><blockquote><p>上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p></blockquote><ul><li><p>iframe 有那些缺点？<br>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><p>主要缺点有：</p><blockquote><p>（1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。<br>（2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。<br>（3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。<br>（4） 浏览器的后退按钮失效。<br>（5） 小型的移动设备无法完全显示框架。</p></blockquote></li><li><p>Label 的作用是什么？是怎么用的？<br>label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"Name"</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">“text“</span> <span class="attr">name</span>=<span class="string">"Name"</span> <span class="attr">id</span>=<span class="string">"Name"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>HTML5 的 form 的自动完成功能是什么？</p><blockquote><p>autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。</p><p>自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。</p><p>autocomplete 属性适用于 <code>&lt;form&gt;</code>，以及下面的 <code>&lt;input&gt;</code> 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。</p></blockquote></li><li><p>如何实现浏览器内多个标签页之间的通信?<br>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）如果我们能够获得对应标签页的引用，通过 <span class="string">`postMessage`</span> 方法也是可以实现多个标签页通信的。</span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><blockquote><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。</p><p>第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</p><p>第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</p><p>第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</p><p>还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。</p></blockquote><ul><li><p>webSocket 如何兼容低版本浏览器？</p><blockquote><p>Adobe Flash Socket 、<br>ActiveX HTMLFile (IE) 、<br>基于 multipart 编码发送 XHR 、<br>基于长轮询的 XHR</p></blockquote></li><li><p>页面可见性（Page Visibility API） 可以有哪些用途？<br>这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。</p><blockquote><p>（1）对服务器的轮询<br>（2）网页动画<br>（3）正在播放的音频或视频</p></blockquote></li><li><p>如何在页面上实现一个圆形的可点击区域？</p><blockquote><p>（1）纯 html 实现，使用 <area> 来给 <img> 图像标记热点区域的方式，<map> 标签用来定义一个客户端图像映射，<area> 标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击的圆形区域。</p><p>（2）纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。</p><p>（3）纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内。</p></blockquote></li><li><p>实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。<br><code>&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></p></li><li><p>title 与 h1 的区别？</p><blockquote><p>title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。</p></blockquote></li><li><p><img> 的 title 和 alt 有什么区别？<br>title 通常当鼠标滑动到元素上的时候显示</p><p>alt 是 <img> 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</p></li><li><p>Canvas 和 SVG 有什么区别？</p><blockquote><p>Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。</p><p>SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。</p></blockquote></li><li><p>网页验证码是干嘛的，是为了解决什么安全问题？</p><blockquote><p>（1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水<br>（2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</p></blockquote></li><li><p>渐进增强和优雅降级的定义</p><blockquote><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p>优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。</p></blockquote></li><li><p>attribute 和 property 的区别是什么？</p><blockquote><p>attribute 是 dom 元素在文档中作为 html 标签拥有的属性；<br>property 就是 dom 元素在 js 中作为对象拥有的属性。<br>对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，<br>但是对于自定义的属性来说，他们是不同步的。</p></blockquote></li><li><p>对 web 标准、可用性、可访问性的理解</p><blockquote><p>可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</p><p>可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性</p><p>可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</p></blockquote></li><li><p>IE 各版本和 Chrome 可以并行下载多少个资源？</p><blockquote><p>（1）  IE6 2 个并发<br>（2）  iE7 升级之后的 6 个并发，之后版本也是 6 个<br>（3）  Firefox，chrome 也是6个</p></blockquote></li><li><p>Flash、Ajax 各自的优缺点，在使用中如何取舍？</p><blockquote><p>Flash：（1） Flash 适合处理多媒体、矢量图形、访问机器（2） 对 CSS、处理文本上不足，不容易被搜索</p><p>Ajax：（1） Ajax 对 CSS、文本支持很好，支持搜索（2） 多媒体、矢量图形、机器访问不足</p></blockquote><p>共同点：</p><blockquote><p>（1） 与服务器的无刷新传递消息<br>（2） 可以检测用户离线和在线状态<br>（3） 操作 DOM</p></blockquote></li><li><p>怎么重构页面？</p><blockquote><p>（1） 编写 CSS<br>（2） 让页面结构更合理化，提升用户体验<br>（3） 实现良好的页面效果和提升性能</p></blockquote></li><li><p>浏览器架构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* 用户界面</span><br><span class="line">  * 主进程</span><br><span class="line">  * 内核</span><br><span class="line">      * 渲染引擎</span><br><span class="line">      * JS 引擎</span><br><span class="line">          * 执行栈</span><br><span class="line">      * 事件触发线程</span><br><span class="line">          * 消息队列</span><br><span class="line">              * 微任务</span><br><span class="line">              * 宏任务</span><br><span class="line">      * 网络异步线程</span><br><span class="line">      * 定时器线程</span><br></pre></td></tr></table></figure></li><li><p>常用的 meta 标签<br><code>&lt;meta&gt;</code> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。<br><code>&lt;meta&gt;</code> 标签位于文档的头部，不包含任何内容。<code>&lt;meta&gt;</code> 标签的属性定义了与文档相关联的名称/值对。</p></li></ul><blockquote><p><code>&lt;!DOCTYPE html&gt;</code>  H5标准声明，使用 HTML5 doctype，不区分大小写<br><code>&lt;head lang=”en”&gt;</code> 标准的 lang 属性写法<br><code>&lt;meta charset=’utf-8′&gt;</code>    声明文档使用的字符编码<br><code>&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt;</code>   优先使用 IE 最新版本和 Chrome<br><code>&lt;meta name=”description” content=”不超过150个字符”/&gt;</code>       页面描述<br><code>&lt;meta name=”keywords” content=””/&gt;</code>      页面关键词者<br><code>&lt;meta name=”author” content=”name, email@gmail.com”/&gt;</code>    网页作<br><code>&lt;meta name=”robots” content=”index,follow”/&gt;</code>      搜索引擎抓取<br><code>&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt;</code> 为移动设备添加 viewport<br><code>&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt;</code> iOS 设备 begin<br><code>&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;</code>  添加到主屏后的标题（iOS 6 新增）<br><code>&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;</code> 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏<br><code>&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;</code> 添加智能 App 广告条 Smart App Banner(iOS 6+ Safari)<br><code>&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;</code>  设置苹果工具栏颜色<br><code>&lt;meta name=”renderer” content=”webkit”&gt;</code>  启用360浏览器的极速模式(webkit)<br><code>&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;</code>     避免IE使用兼容模式<br><code>&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;</code>    不让百度转码<br><code>&lt;meta name=”HandheldFriendly” content=”true”&gt;</code>     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓<br><code>&lt;meta name=”MobileOptimized” content=”320″&gt;</code>   微软的老式浏览器<br><code>&lt;meta name=”screen-orientation” content=”portrait”&gt;</code>   uc强制竖屏<br><code>&lt;meta name=”x5-orientation” content=”portrait”&gt;</code>    QQ强制竖屏<br><code>&lt;meta name=”full-screen” content=”yes”&gt;</code>              UC强制全屏<br><code>&lt;meta name=”x5-fullscreen” content=”true”&gt;</code>       QQ强制全屏<br><code>&lt;meta name=”browsermode” content=”application”&gt;</code>   UC应用模式<br><code>&lt;meta name=”x5-page-mode” content=”app”&gt;</code>    QQ应用模式<br><code>&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;</code>    windows phone 点击无高光<br><code>&lt;meta http-equiv=”pragma” content=”no-cache”&gt;</code>   设置页面不缓存<br><code>&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;</code>    设置页面不缓存<br><code>&lt;meta http-equiv=”expires” content=”0″&gt;</code>   设置页面不缓存  </p></blockquote><ul><li>css reset 和 normalize.css 有什么区别？<br>相关知识点：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多</span><br><span class="line">兼容性问题。</span><br><span class="line"></span><br><span class="line">reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。</span><br><span class="line"></span><br><span class="line">normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>Normalize.css 保护了有价值的默认值</span><br><span class="line"></span><br><span class="line">Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize.css 保持了许多默认的浏览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normalize.css 会力求让这些样式保持一致并尽可能与现代标准相符合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Normalize.css 修复了浏览器的 bug</span><br><span class="line"></span><br><span class="line">它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize.css 修复的问题包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中的与表单相关的 bug。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>Normalize.css 没有复杂的继承链</span><br><span class="line"></span><br><span class="line">使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize.css 中就不会有这样的问题，因为在我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Normalize.css 是模块化的</span><br><span class="line"></span><br><span class="line">这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己选择性地移除掉某些永远不会用到部分（比如表单的一般化）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>Normalize.css 拥有详细的文档</span><br><span class="line"></span><br><span class="line">Normalize.css 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己的测试。</span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><blockquote><p>css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器样式保持一致的效果。<br>但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成画蛇添足的效果。<br>后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。<br>相对与 css reset，normalize.css 的方法保留了有价值的默认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。</p></blockquote><ul><li>用于预格式化文本的标签是？<blockquote><p>预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。</p></blockquote></li></ul><blockquote><p><code>&lt;pre&gt;</code> 定义预格式文本，保持文本原有的格式</p></blockquote><ul><li><p>head 标签中必不少的是？</p><blockquote><p><code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。<code>&lt;head&gt;</code> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<code>&lt;base&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code>, 以及 <code>&lt;title&gt;</code>。</p><p><code>&lt;title&gt;</code> 定义文档的标题，它是 head 部分中唯一必需的元素。</p></blockquote></li><li><p>HTML5 新增的表单元素有？</p><blockquote><p>datalist 规定输入域的选项列表，通过 option 创建！ </p><p>keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！</p><p>output 元素用于不同类型的输出！</p></blockquote></li><li><p>在 HTML5 中，哪个方法用于获得用户的当前位置？<br><code>getCurrentPosition()</code></p></li><li><p>文档的不同注释方式？<br><code>HTML 的注释方法 &lt;!--注释内容--&gt;</code> </p><p><code>CSS 的��释方法 /*注释内容*/</code> </p><p><code>JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式</code></p></li><li><p>disabled 和 readonly 的区别？</p><blockquote><p>disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。</p><p>readonly 规定输入字段为只读。input 内容会随着表单提交。</p><p>无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value</p></blockquote></li><li><p>主流浏览器内核私有属性 css 前缀？</p><blockquote><p>mozilla 内核 （firefox,flock 等）    -moz<br>webkit  内核 （safari,chrome 等）   -webkit<br>opera   内核 （opera 浏览器）        -o<br>trident 内核 （ie 浏览器）           -ms</p></blockquote></li><li><p>前端性能优化？<br>前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。</p><p>第一个方面是页面的内容方面</p><blockquote><p>（1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。</p><p>（2）通过 DNS 缓存等机制来减少 DNS 的查询次数。</p><p>（3）通过设置缓存策略，对常用不变的资源进行缓存。</p><p>（4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。</p><p>（5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。</p></blockquote><p>第二个方面是服务器方面</p><blockquote><p>（1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。</p><p>（2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。</p><p>（3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie</p></blockquote><p>第三个方面是 CSS 和 JavaScript 方面</p><blockquote><p>（1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。</p><p>（2）避免使用 @import 标签。</p><p>（3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。</p><p>（4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。</p></blockquote></li></ul><ul><li><p>扫描二维码登录网页是什么原理，前后两个事件是如何联系的？<br>核心过程应该是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server的帐号信息进行展示。</span><br><span class="line">并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。</span><br><span class="line">在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。</span><br></pre></td></tr></table></figure><p>我的理解</p><blockquote><p>二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。<br>对应的二维码对应了一个对应 uid 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。<br>比如微信的二维码登录，只有用微信识这个二维码才有效。<br>当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。<br>这个时候登录网页根据先前的长连接获取到服务器传过来的用户信息进行显示。<br>然后提前预加载一些登录后可能用到的信息。<br>当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。<br>由于整个授权的过程都是在手机端进行的，因此能够很好的防止 PC 上泛滥的病毒。<br>并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成有效的安全防护。</p></blockquote></li><li><p>Html 规范中为什么要求引用资源不加协议头http或者https？</p><blockquote><p>如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现警告信息，不同浏览器警告信息展现形式不同。</p><p>为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为<code>protocol-relative URL</code>，暂且可译作协议相对 URL。</p><p>如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似的警告信息，同时还可以节省5字节的数据量。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://jambo0624.github.io/2020-04-10-html-question.html&quot;&gt;前一篇文章&lt;/a&gt;整理了 html 在面试中可能会被问到的问题，现在把整理的第二部分记录下来。&lt;br&gt;我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jambo0624.github.io/categories/html/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』html questions</title>
    <link href="https://jambo0624.github.io/2020-04-10-html-question.html"/>
    <id>https://jambo0624.github.io/2020-04-10-html-question.html</id>
    <published>2020-04-10T13:26:34.000Z</published>
    <updated>2020-10-19T08:55:56.106Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是前期针对面试的一些沉淀，全都来自于各题目的汇总。首先是html部分内容，下面我们开始。 </p><a id="more"></a><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li>你是如何理解html语义化的<br>一句话就是该用什么标签时，就要用什么标签。<br>因为更好地用户体验，SEO，其他特殊设备的解析，更好地团队开发<br>比如常用的结构标记        <blockquote><p>1.header 定义网页的头部<br>2.nav 定义导航链接内部<br>3.section 定义网页主体<br>4.aside 定义网页的侧边栏内容<br>5.footer 定义网页偏底部内容<br>6.article 定义与文字描述相关的内容，如果，论坛中帖子，微博条目，用户评论等等。        </p></blockquote></li></ul><ul><li><p>img的title和alt有什么区别？<br>title是鼠标覆盖时显示的文字，在其他方面也可以使用；而alt是网页无法加载图片时代替的文字，只针对img。        </p></li><li><p>对web标准以及W3C的理解与认识?<br>web标准：是一系列标准的集合，标签闭合，标签小写，使用外链等。<br>W3C：只是一个web开发的联盟        </p></li><li><p>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code><br>html5不再基于标准通用标记语言（SGML）        </p></li><li><p>DOCTYPE 作用？严格模式与混杂模式如何区分？它们有何意义？        </p><!DOCTYPE><p>是为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档。<br>严格模式与混杂模式在DOCTYPE声明中区分。历史产物，现在几乎没意义。        </p></li><li><p>HTML 全局属性（Global Attribute）有哪些</p></li></ul><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>accesskey</td><td>规定激活元素的快捷键</td></tr><tr><td>class</td><td>规定元素的一个或多个类名（引用样式表中的类）</td></tr><tr><td>contenteditable</td><td>规定元素内容是否可编辑</td></tr><tr><td>contextmenu</td><td>规定元素的上下文菜单。上下文菜单在用户点击元素时示</td></tr><tr><td>data-*</td><td>用于存储页面或应用程序的私有定制数据</td></tr><tr><td>dir</td><td>规定元素中内容的文本方向</td></tr><tr><td>draggable</td><td>规定元素是否可拖动</td></tr><tr><td>dropzone</td><td>规定在拖动被拖动数据时是否进行复制、移动或链接</td></tr><tr><td>hidden</td><td>样式上会导致元素不显示，但是不能用这个属性实现样式</td></tr><tr><td>id</td><td>规定元素的唯一</td></tr><tr><td>lang</td><td>规定元素内容的语言</td></tr><tr><td>spellcheck</td><td>规定是否对元素进行拼写和语法检查</td></tr><tr><td>style</td><td>规定元素的CSS行内元素</td></tr><tr><td>tabindex</td><td>规定元素的tab键次序</td></tr><tr><td>title</td><td>规定有关元素的额外信息</td></tr><tr><td>translate</td><td>规定是否应该翻译元素内容</td></tr></tbody></table><ul><li><p>meta 有哪些常见的值？<br>http-equiv + content<br>name + content        </p></li><li><p>前端需要注意哪些SEO?        </p><blockquote><p>1.合理的title、description、keywords：搜索对着三项的权重逐个减小<br>2.语义化的HTML代码<br>3.重要内容HTML代码放在最前<br>4.重要内容不要用js输出：爬虫不会执行js获取内容<br>5.少用iframe：搜索引擎不会抓取iframe中的内容<br>6.非装饰性图片必须加alt<br>7.提高网站速度</p></blockquote></li><li><p>DOCTYPE 的作用是什么？</p></li></ul><blockquote><p><code>&lt;!DOCTYPE&gt;</code>  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。</p></blockquote><blockquote><p>在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。</p></blockquote><ul><li>标准模式与兼容模式各有什么区别？</li></ul><blockquote><p>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</p></blockquote><ul><li>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>，而不需要引入 DTD？<blockquote><p>HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。</p></blockquote></li></ul><blockquote><p>而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</p></blockquote><ul><li>SGML 、 HTML 、XML 和 XHTML 的区别？<blockquote><p>SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</p></blockquote></li></ul><blockquote><p>HTML 是超文本标记语言，主要是用于规定怎么显示网页。</p></blockquote><blockquote><p>XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。</p></blockquote><blockquote><p>XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p></blockquote><ul><li>DTD 介绍<blockquote><p>DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。</p></blockquote></li></ul><blockquote><p>DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。</p></blockquote><ul><li>行内元素定义<blockquote><p>HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空<br>间。</p></blockquote></li></ul><blockquote><p>常见的行内元素有 a b span img strong sub sup button input label select textarea</p></blockquote><ul><li>块级元素定义<blockquote><p>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。</p></blockquote></li></ul><blockquote><p>常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</p></blockquote><ul><li>行内元素与块级元素的区别？<br>HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。</li></ul><blockquote><p>（1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。<br>（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。<br>（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei<br>     ght），设置 margin 和 padding 的上下不会对其他元素产生影响。</p></blockquote><ul><li>HTML5 元素的分类</li></ul><blockquote><p>HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为inline 与 block 已经不再符合实际需求。</p></blockquote><blockquote><p>HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive</p></blockquote><ul><li>空元素定义<blockquote><p>标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。</p></blockquote></li></ul><blockquote><p>常见的空元素有：br hr img input link meta</p></blockquote><ul><li>link 标签定义<blockquote><p>link 标签定义文档与外部资源的关系。</p></blockquote></li></ul><blockquote><p>link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。</p></blockquote><blockquote><p>link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。</p></blockquote><ul><li>页面导入样式时，使用 link 和 @import 有什么区别？<blockquote><p>（1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。</p></blockquote></li></ul><blockquote><p>（2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</p></blockquote><blockquote><p>（3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼性问题。</p></blockquote><blockquote><p>（4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式。</p></blockquote><ul><li>你对浏览器的理解？<blockquote><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p></blockquote></li></ul><blockquote><p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。</p></blockquote><blockquote><p>但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p></blockquote><blockquote><p>简单来说浏览器可以分为两部分，shell 和 内核。</p></blockquote><p>其中 shell 的种类相对比较多，内核则比较少。<br>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。<br>它是调用内核来实现各种功能的。内核才是浏览器的核心。<br>内核是基于标记语言显示内容的程序或模块。<br>也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p><ul><li>介绍一下你对浏览器内核的理解？<blockquote><p>主要分成两部分：渲染引擎和 JS 引擎。</p></blockquote></li></ul><blockquote><p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</p></blockquote><blockquote><p>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</p></blockquote><p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><ul><li>常见的浏览器内核比较<blockquote><p>Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</p></blockquote></li></ul><blockquote><p>Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</p></blockquote><blockquote><p>Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</p></blockquote><blockquote><p>Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</p></blockquote><blockquote><p>Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</p></blockquote><ul><li><p>常见浏览器所用内核</p><blockquote><p>（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p><p>（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p><p>（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p><p>（4） Safari 浏览器内核：Webkit 内核；</p><p>（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p><p>（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p><p>（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p><p>（8） 百度浏览器、世界之窗内核：IE 内核；</p><p>（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p><p>（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p></blockquote></li><li><p>浏览器的渲染原理？</p><blockquote><p>（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</p><p>（2）然后对 CSS 进行解析，生成 CSSOM 规则树。</p><p>（3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p><p>（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p><p>（5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p></blockquote></li></ul><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><ul><li>渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）<blockquote><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p></blockquote></li></ul><blockquote><p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p></blockquote><ul><li><p>async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</p><blockquote><p>（1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><p>（2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</p><p>（3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</p></blockquote></li><li><p>什么是文档的预解析？（浏览器解析过程）</p><blockquote><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p></blockquote></li><li><p>CSS 如何阻塞文档解析？（浏览器解析过程）</p><blockquote><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</p></blockquote></li></ul><blockquote><p>所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p></blockquote><ul><li>渲染页面时常见哪些不良现象？（浏览器渲染过程）<blockquote><p>FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。</p></blockquote></li></ul><blockquote><p>白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</p></blockquote><ul><li>如何优化关键渲染路径？（浏览器渲染过程）<br>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</li></ul><blockquote><p>（1）关键资源的数量。<br>（2）关键路径长度。<br>（3）关键字节的数量。</p></blockquote><p> 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</p><p> 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。</p><p> 最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p><p> 优化关键渲染路径的常规步骤如下：</p><blockquote><p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。<br>（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。<br>（3）优化关键字节数以缩短下载时间（往返次数）。<br>（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</p></blockquote><ul><li>什么是重绘和回流？（浏览器绘制过程）<blockquote><p>重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。</p></blockquote></li></ul><blockquote><p>回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p></blockquote><p>常见引起回流属性和方法：<br>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p><blockquote><p>（1）添加或者删除可见的 DOM 元素；<br>（2）元素尺寸改变——边距、填充、边框、宽度和高度<br>（3）内容变化，比如用户在 input 框中输入文字<br>（4）浏览器窗口尺寸改变——resize事件发生时<br>（5）计算 offsetWidth 和 offsetHeight 属性<br>（6）设置 style 属性的值<br>（7）当你修改网页的默认字体时。</p></blockquote><p> 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列<br> 回流。</p><ul><li>如何减少回流？（浏览器绘制过程）<blockquote><p>（1）使用 transform 替代 top</p><p>（2）不要把节点的属性值放在一个循环里当成循环里的变量</p><p>（3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</p><p>（4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</p><p>（5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是前期针对面试的一些沉淀，全都来自于各题目的汇总。首先是html部分内容，下面我们开始。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jambo0624.github.io/categories/html/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>轮播图在切换页面时，显示凌乱的问题</title>
    <link href="https://jambo0624.github.io/2020-03-27-swiperIntervalBug.html"/>
    <id>https://jambo0624.github.io/2020-03-27-swiperIntervalBug.html</id>
    <published>2020-03-27T02:53:24.000Z</published>
    <updated>2020-10-19T03:51:06.350Z</updated>
    
    <content type="html"><![CDATA[<p>自己写轮播图时，发现轮播图效果在切换页面后，首先会有一段加速过程，之后才会正常播放。这是什么原因呢？<br>今天我们来解决这个问题。<br>下面开始。</p><a id="more"></a><p>原因是浏览器本着节省内存的原则，在页面切换到其他页面时，定时器不运动，但是动画依然排列，当切换回来的时候，动画加速运动，出现错误，在轮播图之类的页面经常会发生这样的情况      </p><p>具体需要三个知识点</p><ul><li>document.onvisibilitychange<br>只要页面发生变化，就会触发这个事件    </li><li>document.hidden<br>这个是指当页面不是当前页面时为true，否则为false   </li><li>document.visibilityState<br>visible 表示当前网页是可见或者是部分可见的。<br>hidden：当前网页是不可见的<br>prerender 网页内容被预渲染并且用户不可见<br>unloaded 如果文档被卸载，那么这个值将被返回      <h3 id="解决setInterval在浏览器切换中的问题："><a href="#解决setInterval在浏览器切换中的问题：" class="headerlink" title="解决setInterval在浏览器切换中的问题："></a>解决setInterval在浏览器切换中的问题：</h3>思路：如果页面是不可见的，那么我们就会清除定时器，如果页面是可见的，那么我们就重新开启定时器。<br>所以我们需要用<code>document.onvisibilitychange</code>进行监听，然后用<code>document.visibilityState</code>或者是<code>document.hidden</code>进行判断。<br>实际操作:    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onvisibilitychange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">document</span>.visibilityState==<span class="string">"visible"</span>)&#123;</span><br><span class="line">      timer=setInterval(slidemove, <span class="number">1000</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="jq中animate的解决"><a href="#jq中animate的解决" class="headerlink" title="jq中animate的解决"></a>jq中animate的解决</h3><p>如果用的是jq的animate这个方法，就只需要到这个方法的前面加上<code>stop(true,true)</code>       </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".slidePanel"</span>).stop(<span class="literal">true</span>,<span class="literal">true</span>).animate(&#123;</span><br><span class="line">  <span class="string">"left"</span>: -iNow*varWidth+<span class="string">"px"</span>,</span><br><span class="line">  <span class="string">"speed"</span>:<span class="number">300</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己写轮播图时，发现轮播图效果在切换页面后，首先会有一段加速过程，之后才会正常播放。这是什么原因呢？&lt;br&gt;今天我们来解决这个问题。&lt;br&gt;下面开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="interval" scheme="https://jambo0624.github.io/tags/interval/"/>
    
  </entry>
  
  <entry>
    <title>Promise 知识梳理</title>
    <link href="https://jambo0624.github.io/2020-03-08-promise.html"/>
    <id>https://jambo0624.github.io/2020-03-08-promise.html</id>
    <published>2020-03-08T07:13:32.000Z</published>
    <updated>2020-10-19T03:46:17.253Z</updated>
    
    <content type="html"><![CDATA[<p>最近会梳理一些带题目的知识点，除了让知识更系统。也让知识更具有细节，也更经得起考验。<br>今天先从 Promise 开始。</p><a id="more"></a><p>promise 知识梳理</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><code>event loop</code>它的执行顺序：  </p><blockquote><p>一开始整个脚本作为一个宏任务执行<br>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列<br>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完<br>执行浏览器<code>UI线程</code>的渲染工作<br>检查是否有<code>Web Worker</code>任务，有则执行<br>执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空 </p></blockquote><p>微任务包括：<code>MutationObserver</code>、<code>Promise.then()</code>或<code>reject()</code>、<code>Promise</code>为基础开发的其它技术，比如<code>fetch API</code>、<code>V8的垃圾回收过程</code>、Node独有的<code>process.nextTick</code><br>宏任务包括：<code>script</code> 、<code>setTimeout</code>、<code>setInterval</code> 、<code>setImmediate</code> 、<code>I/O</code>、<code>UI rendering</code>。<br>注意⚠️：在所有任务开始的时候，由于宏任务中包括了<code>script</code>，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如<code>setTimeout</code>)将被放到下一轮宏任务中来执行。  </p><h3 id="1-Promise的几道基础题"><a href="#1-Promise的几道基础题" class="headerlink" title="1. Promise的几道基础题"></a>1. Promise的几道基础题</h3><ul><li><p>题目一  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, promise1)</span><br></pre></td></tr></table></figure><p>过程分析：<br>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code><br>然后执行同步代码<code>1</code>，此时<code>promise1</code>没有被<code>resolve</code>或者<code>reject</code>，因此状态还是<code>pending</code><br>结果：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure></li><li><p>题目二  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>过程分析：<br>从上至下，先遇到<code>new Promise</code>，执行其中的同步代码<code>1</code><br>再遇到<code>resolve(&#39;success&#39;)</code>， 将<code>promise</code>的状态改为了<code>resolved</code>并且将值保存下来<br>继续执行同步代码<code>2</code><br>跳出<code>promise</code>，往下执行，碰到<code>promise.then</code>这个微任务，将其加入微任务队列<br>执行同步代码<code>4</code><br>本轮宏任务全部执行完毕，检查微任务队列，发现<code>promise.then</code>这个微任务且状态为<code>resolved</code>，执行它。<br>结果：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目三  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>过程分析<br>和题目二相似，只不过在<code>promise</code>中并没有<code>resolve</code>或者<code>reject</code><br>因此<code>promise.then</code>并不会执行，它只有在被改变了状态之后才会执行。<br>结果：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目四   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve(<span class="string">'resolve1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>,promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>,promise2)</span><br></pre></td></tr></table></figure>过程分析：<br>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code><br>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来<br>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列<br><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code><br>执行同步代码<code>1</code>， 同时打印出<code>promise1</code>的状态是<code>resolved</code><br>执行同步代码<code>2</code>，同时打印出<code>promise2</code>的状态是<code>pending</code><br>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。<br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">'resolve1'</span>&#125;</span><br><span class="line"><span class="string">'2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'resolve1'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目五  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>结果：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'success'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目六  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>是的，现在<code>start</code>就在<code>1</code>之前打印出来了，因为<code>fn</code>函数是之后执行的。<br>注意⚠️：之前我们很容易就以为看到<code>new Promise()</code>就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。<br>结果：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start"</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Promise结合setTimeout"><a href="#Promise结合setTimeout" class="headerlink" title="Promise结合setTimeout"></a>Promise结合setTimeout</h3><ul><li><p>题目一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'time'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><p>过程分析：<br>刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出<code>start</code>和<code>end</code>。<br><code>setTimout</code>作为一个宏任务被放入宏任务队列(下一个)<br><code>Promise.then</code>作为一个微任务被放入微任务队列<br>本次宏任务执行完，检查微任务，发现<code>Promise.then</code>，执行它<br>接下来进入下一个宏任务，发现<code>setTimeout</code>，执行。<br>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'end'</span></span><br><span class="line"><span class="string">'resolve'</span></span><br><span class="line"><span class="string">'time'</span></span><br></pre></td></tr></table></figure></li><li><p>题目二  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timerStart"</span>);</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timerEnd"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>过程分析：<br>和题目<code>1.2</code>很像，不过在<code>resolve</code>的外层加了一层<code>setTimeout</code>定时器。<br>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>1</code><br>然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行<br>执行同步代码<code>2</code><br>跳出<code>promise</code>函数，遇到<code>promise.then</code>，但其状态还是为<code>pending</code>，这里理解为先不执行<br>执行同步代码<code>4</code><br>一轮循环过后，进入第二次宏任务，发现延迟队列中有<code>setTimeout</code>定时器，执行它<br>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列<br>继续执行同步代码<code>timerEnd</code><br>宏任务全部执行完毕，查找微任务队列，发现<code>promise.then</code>这个微任务，执行它。<br>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="string">"timerStart"</span></span><br><span class="line"><span class="string">"timerEnd"</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure></li><li><p>题目三<br>题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么：<br>(1)  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer3'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure><p>(2)  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure><p>结果：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer3'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br></pre></td></tr></table></figure><p>这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。<br>一个是为定时器<code>timer3</code>，一个是为<code>Promise.then</code><br>但是如果是定时器<code>timer3</code>的话，它会在<code>timer2</code>后执行，而<code>Promise.then</code>却是在<code>timer2</code>之前执行。<br>你可以这样理解，<code>Promise.then</code>是微任务，它会被加入到本轮中的微任务列表，而定时器<code>timer3</code>是宏任务，它会被加入到下一轮的宏任务中。<br>理解完这两个案例，可以来看看下面一道比较难的题目了。     </p></li></ul><ul><li>题目四<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  <span class="keyword">const</span> timer2 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> timer1 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>这道题稍微的难一些，在promise中执行定时器，又在定时器中执行promise；<br>并且要注意的是，这里的Promise是直接resolve的，而之前的new Promise不一样。<br>因此过程分析为：<br>刚开始整个脚本作为第一次宏任务来执行，我们将它标记为<strong>宏1</strong>，从上至下执行<br>遇到<code>Promise.resolve().then</code>这个微任务，将<code>then</code>中的内容加入第一次的微任务队列标记为<strong>微1</strong><br>遇到定时器<code>timer1</code>，将它加入下一次宏任务的延迟列表，标记为<strong>宏2</strong>，等待执行(先不管里面是什么内容)<br>执行<strong>宏1</strong>中的同步代码<code>start</code><br>第一次宏任务(<strong>宏1</strong>)执行完毕，检查第一次的微任务队列(<strong>微1</strong>)，发现有一个<code>promise.then</code>这个微任务需要执行<br>执行打印出<strong>微1</strong>中同步代码<code>promise1</code>，然后发现定时器<code>timer2</code>，将它加入<strong>宏2</strong>的后面，标记为<strong>宏3</strong><br>第一次微任务队列(<strong>微1</strong>)执行完毕，执行第二次宏任务(<strong>宏2</strong>)，首先执行同步代码<code>timer1</code><br>然后遇到了<code>promise2</code>这个微任务，将它加入此次循环的微任务队列，标记为<strong>微2</strong><br><strong>宏2</strong>中没有同步代码可执行了，查找本次循环的微任务队列(<strong>微2</strong>)，发现了<code>promise2</code>，执行它<br>第二轮执行完毕，执行<strong>宏3</strong>，打印出<code>timer2</code><br>所以结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br></pre></td></tr></table></figure><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>从上至下，先执行第一个new Promise中的函数，碰到setTimeout将它加入下一个宏任务列表<br>跳出new Promise，碰到promise1.then这个微任务，但其状态还是为pending，这里理解为先不执行<br>promise2是一个新的状态为pending的Promise<br>执行同步代码console.log(‘promise1’)，且打印出的promise1的状态为pending<br>执行同步代码console.log(‘promise2’)，且打印出的promise2的状态为pending<br>碰到第二个定时器，将其放入下一个宏任务列表<br>第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务<br>先执行第一个定时器里的内容，将promise1的状态改为resolved且保存结果并将之前的promise1.then推入微任务队列<br>该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是promise1.then，它抛出了一个错误，且将promise2的状态设置为了rejected<br>第一个定时器执行完毕，开始执行第二个定时器中的内容<br>打印出’promise1’，且此时promise1的状态为resolved<br>打印出’promise2’，且此时promise2的状态为rejected    </p><p>完整的结果为：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line">test5.html:<span class="number">102</span> Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!! at test.html:<span class="number">102</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">"success"</span>&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;rejected&gt;: <span class="built_in">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure><ul><li>题目六<br>如果你上面这道题搞懂了之后，我们就可以来做做这道了，你应该能很快就给出答案：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timer1"</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1里的内容"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error!!!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"timer2"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1里的内容'</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line">test5.html:<span class="number">102</span> Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!! at test.html:<span class="number">102</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">"success"</span>&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;rejected&gt;: <span class="built_in">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Promise中的then、catch、finally"><a href="#Promise中的then、catch、finally" class="headerlink" title="Promise中的then、catch、finally"></a>Promise中的then、catch、finally</h3><p>总结：</p><blockquote><p>Promise的状态一经改变就不能再改变。(见3.1)<br>.then和.catch都会返回一个新的Promise。(上面的👆1.4证明了)<br>catch不管被连接到哪里，都能捕获上层的错误。(见3.2)<br>在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。<br>Promise 的 .then 或者 .catch 可以被调用多次, 当如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。(见3.5)<br>.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。(见3.6)<br>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。(见3.7)<br>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。(见3.8)<br>.then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。(见3.9)<br>.finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。  </p></blockquote><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then: "</span>, res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"then: success1"</span></span><br></pre></td></tr></table></figure>构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用 。验证了第一个结论，Promise的状态一经改变就不能再改变。</li></ul><hr><ul><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then1: "</span>, res);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then2: "</span>, res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then3: "</span>, res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"catch: "</span> <span class="string">"error"</span></span><br><span class="line"><span class="string">"then3: "</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>验证了第三个结论，catch不管被连接到哪里，都能捕获上层的错误。<br>至于then3也会被执行，那是因为catch()也会返回一个Promise，且由于这个Promise没有返回值，所以打印出来的是undefined。   </li></ul><hr><ul><li>题目三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>Promise可以链式调用，不过promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般我们任务的链式调用一样return this。<br>上面的输出结果之所以依次打印出1和2，那是因为resolve(1)之后走的是第一个then方法，并没有走catch里，所以第二个then中的res得到的实际上是第一个then的返回值。<br>且return 2会被包装成resolve(2)。  </li></ul><hr><ul><li>题目四<br>如果把3.3中的Promise.resolve(1)改为Promise.reject(1)又会怎么样呢？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>结果打印的当然是 1 和 3啦，因为reject(1)此时走的就是catch，且第二个then中的res得到的就是catch中的返回值。  </li></ul><hr><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'timer'</span></span><br><span class="line">success <span class="number">1001</span></span><br><span class="line">success <span class="number">1002</span></span><br></pre></td></tr></table></figure>当然，如果你足够快的话，也可能两个都是1001。<br>Promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。  </li></ul><hr><ul><li>题目六<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then: "</span>, res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>你可能想到的是进入.catch然后被捕获了错误。</li></ul><p>结果并不是这样的，它走的是.then里面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"then: "</span> <span class="string">"Error: error!!!"</span></span><br></pre></td></tr></table></figure><p>这也验证了第4点和第6点，返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的return new Error(‘error!!!’)也被包裹成了return Promise.resolve(new Error(‘error!!!’))。<br>当然如果你抛出一个错误的话，可以用下面👇两的任意一种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>));</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br></pre></td></tr></table></figure><ul><li>题目七<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="built_in">console</span>.err)</span><br></pre></td></tr></table></figure>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。  </li></ul><p>因此结果会报错： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure><ul><li>题目八<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="number">2</span>)</span><br><span class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>其实你只要记住原则8：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。  </li></ul><p>第一个then和第二个then中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将resolve(1) 的值直接传到最后一个then里。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>题目九<br>下面来介绍一下.then函数中的两个参数。  </li></ul><p>第一个参数是用来处理Promise成功的函数，第二个则是处理失败的函数。  </p><p>也就是说Promise.resolve(‘1’)的值会进入成功的函数，Promise.reject(‘2’)的值会进入失败的函数。<br>让我们来看看这个例子🌰：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err!!!'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'catch'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的执行结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'error'</span> <span class="string">'error!!!'</span></span><br></pre></td></tr></table></figure><p>它进入的是then()中的第二个参数里面，而如果把第二个参数去掉，就进入了catch()中：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err!!!'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'catch'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'catch'</span> <span class="string">'error!!!'</span></span><br></pre></td></tr></table></figure><p>但是有一个问题，如果是这个案例呢？  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> <span class="title">success</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail1</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fail1'</span>, err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">fail2</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fail2'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于Promise调用的是resolve()，因此.then()执行的应该是success()函数，可是success()函数抛出的是一个错误，它会被后面的catch()给捕获到，而不是被fail1函数捕获。  </p><p>因此执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fail2 <span class="built_in">Error</span>: error!!!</span><br></pre></td></tr></table></figure><ul><li>题目十<br>接着来看看.finally()，这个功能一般不太用在面试中，不过如果碰到了你也应该知道该如何处理。<br>其实你只要记住它三个很重要的知识点就可以了：  </li></ul><blockquote><p>.finally()方法不管Promise对象最后的状态如何都会执行<br>.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的<br>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。  </p></blockquote><p>来看看这个简单的例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'2'</span>)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally2'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我是finally2返回的值'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally2后面的then函数'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这两个Promise的.finally都会执行，且就算finally2返回了新的值，它后面的then()函数接收到的结果却还是’2’，因此打印结果为：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="string">'finally2'</span></span><br><span class="line"><span class="string">'finally'</span></span><br><span class="line"><span class="string">'finally2后面的then函数'</span> <span class="string">'2'</span></span><br></pre></td></tr></table></figure><p>至于为什么finally2的打印要在finally前面，请看下一个例子中的解析。  </p><p>不过在此之前让我们再来确认一下，finally中要是抛出的是一个异常是怎样的：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally1'</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'我是finally中抛出的异常'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally后面的then函数'</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获错误'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'finally1'</span></span><br><span class="line"><span class="string">'捕获错误'</span> <span class="built_in">Error</span>: 我是<span class="keyword">finally</span>中抛出的异常</span><br></pre></td></tr></table></figure><p>但是如果改为return new Error(‘我是finally中抛出的异常’)，打印出来的就是’finally后面的then函数 1’   </p><p>OK，👌，让我们来看一个比较难的例子🌰：   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve(<span class="string">'1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally1'</span>))</span><br><span class="line"></span><br><span class="line">promise2()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally2'</span>))</span><br></pre></td></tr></table></figure><p>执行过程：  </p><p>首先定义了两个函数promise1和promise2，先不管接着往下看。<br>promise1函数先被调用了，然后执行里面new Promise的同步代码打印出promise1<br>之后遇到了resolve(1)，将p的状态改为了resolved并将结果保存下来。<br>此时promise1内的函数内容已经执行完了，跳出该函数<br>碰到了promise1().then()，由于promise1的状态已经发生了改变且为resolved因此将promise1().then()这条微任务加入本轮的微任务列表(这是第一个微任务)<br>这时候要注意了，代码并不会接着往链式调用的下面走，也就是不会先将.finally加入微任务列表，那是因为.then本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管.finally()<br>再往下走碰到了promise2()函数，其中返回的new Promise中并没有同步代码需要执行，所以执行reject(‘error’)的时候将promise2函数中的Promise的状态变为了rejected<br>跳出promise2函数，遇到了promise2().then()，将其加入当前的微任务队列(这是第二个微任务)，且链式调用后面的内容得等该任务执行完后才执行，和.then()一样。<br>OK， 本轮的宏任务全部执行完了，来看看微任务列表，存在promise1().then()，执行它，打印出1，然后遇到了.finally()这个微任务将它加入微任务列表(这是第三个微任务)等待执行<br>再执行promise2().catch()打印出error，执行完后将finally2加入微任务加入微任务列表(这是第四个微任务)<br>OK， 本轮又全部执行完了，但是微任务列表还有两个新的微任务没有执行完，因此依次执行finally1和finally2。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="string">'error'</span></span><br><span class="line"><span class="string">'finally1'</span></span><br><span class="line"><span class="string">'finally2'</span></span><br></pre></td></tr></table></figure><p>在这道题中其实能拓展的东西挺多的，之前没有提到，那就是你可以理解为链式调用后面的内容需要等前一个调用执行完才会执行。<br>就像是这里的finally()会等promise1().then()执行完才会将finally()加入微任务队列，其实如果这道题中你把finally()换成是then()也是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve(<span class="string">'1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally1'</span>))</span><br><span class="line"></span><br><span class="line">promise2()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally2'</span>))</span><br></pre></td></tr></table></figure><h3 id="Promise中的all和race"><a href="#Promise中的all和race" class="headerlink" title="Promise中的all和race"></a>Promise中的all和race</h3><p>在做下面👇的题目之前，让我们先来了解一下Promise.all()和Promise.race()的用法。<br>通俗来说，.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。<br>.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</p><ul><li>题目一<br>我们知道如果直接在脚本文件中定义一个Promise，它构造函数的第一个参数是会立即执行的，就像这样：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'立即打印'</span>))</span><br></pre></td></tr></table></figure>控制台中会立即打印出 “立即打印”。</li></ul><p>因此为了控制它什么时候执行，我们可以用一个函数包裹着它，在需要它执行的时候，调用这个函数就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runP1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'立即打印'</span>))</span><br><span class="line">  <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runP1() <span class="comment">// 调用此函数时才执行</span></span><br></pre></td></tr></table></figure><p>OK 👌， 让我们回归正题。</p><p>现在来构建这么一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数传入一个值x，然后间隔一秒后打印出这个x。</p><p>如果我用.all()来执行它会怎样呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>先来想想此段代码在浏览器中会如何执行？</p><p>没错，当你打开页面的时候，在间隔一秒后，控制台会同时打印出1, 2, 3，还有一个数组[1, 2, 3]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>所以你现在能理解这句话的意思了吗：有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。<br>.all()后面的.then()里的回调函数接收的就是所有异步操作的结果。<br>而且这个结果中数组的顺序和Promise.all()接收到的数组顺序一致！！！</p><blockquote><p>有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p></blockquote><ul><li>题目二<br>我新增了一个runReject函数，它用来在1000 * x秒后reject一个错误。</li></ul><p>同时.catch()函数能够捕获到.all()里最先的那个异常，并且只执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> rej(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="built_in">console</span>.log(x)), <span class="number">1000</span> * x))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 2s后输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">Error</span>: <span class="number">2</span></span><br><span class="line"><span class="comment">// 4s后输出</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>没错，就像我之前说的，.catch是会捕获最先的那个异常，在这道题目中最先的异常就是runReject(2)的结果。<br>另外，如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。</p><p>哈哈，大家别忘了.then()方法的第二个参数也是可以捕获错误的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), </span><br><span class="line">err =&gt; <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><ul><li>题目三<br>所以使用.race()方法，它只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，不过race已经不管那些任务的结果了。</li></ul><p>来，改造一下4.1这道题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'result: '</span>, res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'result: '</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p></blockquote><ul><li>题目四<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> rej(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="built_in">console</span>.log(x)), <span class="number">1000</span> * x)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([runReject(<span class="number">0</span>), runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"result: "</span>, res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>遇到错误的话，也是一样的，在这道题中，runReject(0)最先执行完，所以进入了catch()中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="string">'Error: 0'</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>总结<br>好的，让我们来总结一下.then()和.race()吧，😄</li></ul><blockquote><p>Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。<br>.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。<br>Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。</p></blockquote><h3 id="async-await的几道题"><a href="#async-await的几道题" class="headerlink" title="async/await的几道题"></a>async/await的几道题</h3><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>答案：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>首先一进来是创建了两个函数的，我们先不看函数的创建位置，而是看它的调用位置<br>发现async1函数被调用了，然后去看看调用的内容<br>执行函数中的同步代码async1 start，之后碰到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1<br>跳出async1函数后，执行同步代码start<br>在一轮宏任务全部执行完之后，再来执行刚刚await后面的内容async1 end。</p><p>在这里，你可以理解为await后面的内容就相当于放到了Promise.then的里面。<br>让我们来看看将await转换为Promise.then的伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="comment">// 原来代码</span></span><br><span class="line">  <span class="comment">// await async2();</span></span><br><span class="line">  <span class="comment">// console.log("async1 end");</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 转换后代码</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async2"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><p>另外关于await和Promise的区别，如果我们把await async2()换成一个new Promise呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><p>此时的执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async start'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'start'</span></span><br></pre></td></tr></table></figure><p><strong>可以看到new Promise()并不会阻塞后面的同步代码async1 end的执行。</strong></p><ul><li>题目二<br>现在将async结合定时器看看。<br>给题目一中的 async2函数中加上一个定时器：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure>没错，定时器始终还是最后执行的，它被放到下一条宏任务的延迟队列中。<br>答案：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'timer'</span></span><br></pre></td></tr></table></figure></li><li>题目三<br>来吧，小伙伴们，让我们多加几个定时器看看。😁<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer3'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer3'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br></pre></td></tr></table></figure>复制代码定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是0，所以只要关注谁先被调用的。</li></ul><hr><ul><li>题目四<br>正常情况下，async中的await命令是一个Promise对象，返回该对象的结果。</li></ul><p>但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return await 1234</span></span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt end'</span>)</span><br></pre></td></tr></table></figure>这道题目比较有意思，大家要注意了。<br>在async1中await后面的Promise是没有返回值的，也就是它的状态始终是pending状态，因此相当于一直在await，await，await却始终没有响应…<br>所以在await之后的内容是不会执行的，也包括async1后面的 .then。<br>答案为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目六<br>让我们给5.5中的Promise加上resolve：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve(<span class="string">'promise1 resolve'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt end'</span>)</span><br></pre></td></tr></table></figure>现在Promise有了返回值了，因此await后面的内容将会被执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="string">'promise1 resolve'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目七<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve(<span class="string">'promise resolve'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>这道题应该也不难，不过有一点需要注意的，在async1中的new Promise它的resovle的值和async1().then()里的值是没有关系的，很多小伙伴可能看到resovle(‘promise resolve’)就会误以为是async1().then()中的返回值。<br>因此这里的执行结果为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br><span class="line"><span class="string">'sync1 end'</span></span><br><span class="line"><span class="string">'timer'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目八<br>我们再来看一道头条曾经的面试题：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'setTimeout'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目九<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testSometing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行testSometing"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"testSometing"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行testAsync"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"hello async"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test start..."</span>);</span><br><span class="line">  <span class="keyword">const</span> v1 = <span class="keyword">await</span> testSometing();</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line">  <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise start..."</span>);</span><br><span class="line">  resolve(<span class="string">"promise"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"test end..."</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'test start...'</span></span><br><span class="line"><span class="string">'执行testSometing'</span></span><br><span class="line"><span class="string">'promise start...'</span></span><br><span class="line"><span class="string">'test end...'</span></span><br><span class="line"><span class="string">'testSometing'</span></span><br><span class="line"><span class="string">'执行testAsync'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'hello async'</span></span><br><span class="line"><span class="string">'testSometing'</span> <span class="string">'hello async'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="async处理错误"><a href="#async处理错误" class="headerlink" title="async处理错误"></a>async处理错误</h3><ul><li>题目一<br>在async中，如果 await后面的内容是一个异常或者错误的话，会怎样呢？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>例如这道题中，await后面跟着的是一个状态为rejected的promise。</li></ul><p><strong>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</strong></p><p>所以答案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async2'</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) error</span><br></pre></td></tr></table></figure><p>如果改为throw new Error也是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1'</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!!</span><br></pre></td></tr></table></figure><ul><li>题目二<br>如果想要使得错误的地方不影响async函数后续的执行的话，可以使用try catch<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error!!!'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'async1 success'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br></pre></td></tr></table></figure>这里的结果为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'error!!!'</span></span><br><span class="line"><span class="string">'async1'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br></pre></td></tr></table></figure>或者你可以直接在Promise.reject后面跟着一个catch()方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// try &#123;</span></span><br><span class="line">  <span class="comment">//   await Promise.reject('error!!!')</span></span><br><span class="line">  <span class="comment">// &#125; catch(e) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(e)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error!!!'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'async1 success'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br></pre></td></tr></table></figure>运行结果是一样的</li></ul><h3 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h3><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">          resolve(<span class="number">6</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(p)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">  p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(arg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在4之前，所以可以来看看first函数里面的内容了。(这一步有点类似于题目1.5)<br>函数first返回的是一个new Promise()，因此先执行里面的同步代码3<br>接着又遇到了一个new Promise()，直接执行里面的同步代码7<br>执行完7之后，在p中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走<br>碰到了resolve(1)，这里就把p的状态改为了resolved，且返回值为1，不过这里也先不执行<br>跳出p，碰到了resolve(2)，这里的resolve(2)，表示的是把first函数返回的那个Promise的状态改了，也先不管它。<br>然后碰到了p.then，将它加入本次循环的微任务列表，等待执行<br>跳出first函数，遇到了first().then()，将它加入本次循环的微任务列表(p.then的后面执行)<br>然后执行同步代码4<br>本轮的同步代码全部执行完毕，查找微任务列表，发现p.then和first().then()，依次执行，打印出1和2<br>本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码5<br>然后又遇到了一个resolve(6)，它是放在p里的，但是p的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说resolve(6)相当于没任何用处，因此打印出来的p为<code>Promise{&lt;resolved&gt;: 1}</code>。(这一步类似于题目3.1)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async1 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="number">2</span>)</span><br><span class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">.catch(<span class="number">4</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>注意的知识点：</li></ul><p>async函数中await的new Promise要是没有返回值的话则不执行后面的内容(类似题5.5)<br>.then函数中的参数期待的是函数，如果不是函数的话会发生透传(类似题3.8 )<br>注意定时器的延迟时间<br>因此本题答案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br></pre></td></tr></table></figure><ul><li>题目三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'resolve3'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  resolve(<span class="string">'resovle1'</span>);</span><br><span class="line">  resolve(<span class="string">'resolve2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p1)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>注意的知识点：</li></ul><p>Promise的状态一旦改变就无法改变(类似题目3.5)<br>finally不管Promise的状态是resolved还是rejected都会执行，且它的回调函数是接收不到Promise的结果的，所以finally()中的res是一个迷惑项(类似3.10)。<br>最后一个定时器打印出的p1其实是.finally的返回值，我们知道.finally的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值(3.10中也有提到), 而这道题中.finally上一个Promise是.then()，但是这个.then()并没有返回值，所以p1打印出来的Promise的值会是undefined，如果你在定时器的下面加上一个return 1，则值就会变成1(感谢掘友JS丛中过的指出)。</p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'resolve1'</span></span><br><span class="line"><span class="string">'finally'</span> <span class="literal">undefined</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="literal">undefined</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="几道大厂的面试题"><a href="#几道大厂的面试题" class="headerlink" title="几道大厂的面试题"></a>几道大厂的面试题</h3><ul><li>使用Promise实现每隔1秒输出1<br>这道题比较简单的一种做法是可以用Promise配合着reduce不停的在promise后面叠加.then，请看下面的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">p, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(<span class="built_in">console</span>.log(x)), <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure>或者你可以更简单一点写：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">p, x</span>) =&gt;</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(<span class="built_in">console</span>.log(x)), <span class="number">1000</span>))), <span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></li></ul><ul><li>使用Promise实现红绿灯交替重复亮</li></ul><p>红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"red"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"green"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"yellow"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> light = <span class="function"><span class="keyword">function</span> (<span class="params">timer, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      cb()</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> step = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">3000</span>, red)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">2000</span>, green)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">1000</span>, yellow)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> step()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step();</span><br></pre></td></tr></table></figure><ul><li>实现mergePromise函数<br>实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="function">(<span class="params">timer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里写代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"done"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>这道题有点类似于Promise.all()，不过.all()不需要管执行顺序，只需要并发执行就行了。但是这里需要等上一个执行完毕之后才能执行下一个。<br>解题思路：</li></ul><p>定义一个数组data用于保存所有异步操作的结果<br>初始化一个const promise = Promise.resolve()，然后循环遍历数组，在promise后面添加执行ajax任务，同时要将添加的结果重新赋值到promise上。</p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span> (<span class="params">ajaxArray</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放每个ajax的结果</span></span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  ajaxArray.forEach(<span class="function"><span class="params">ajax</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次的then为了用来调用ajax</span></span><br><span class="line">    <span class="comment">// 第二次的then是为了获取ajax的结果</span></span><br><span class="line">    promise = promise.then(ajax).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      data.push(res);</span><br><span class="line">      <span class="keyword">return</span> data; <span class="comment">// 把每次的结果返回</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最后得到的promise它的值就是data</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据promiseA+实现一个自己的promise<br><a href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b#heading-7" target="_blank" rel="noopener">Promise不会？？看这里！！！史上最通俗易懂的Promise</a><br><a href="https://zhuanlan.zhihu.com/p/23312442" target="_blank" rel="noopener">写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近会梳理一些带题目的知识点，除了让知识更系统。也让知识更具有细节，也更经得起考验。&lt;br&gt;今天先从 Promise 开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="ES6" scheme="https://jambo0624.github.io/tags/ES6/"/>
    
      <category term="promise" scheme="https://jambo0624.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>Vue 登录业务及上线注意事项</title>
    <link href="https://jambo0624.github.io/2020-02-25-management.html"/>
    <id>https://jambo0624.github.io/2020-02-25-management.html</id>
    <published>2020-02-25T08:23:41.000Z</published>
    <updated>2020-10-17T08:17:27.171Z</updated>
    
    <content type="html"><![CDATA[<p>前些天读完几本书之后，现在准备整理一下去年工作的一些收获。<br>尤其是将其中一些自己没有参与，但是还比较关键的环节进行梳理。希望能有进一步的感想。<br>下面开始</p><a id="more"></a><h2 id="登录退出功能"><a href="#登录退出功能" class="headerlink" title="登录退出功能"></a>登录退出功能</h2><ul><li>登录业务的相关技术点</li></ul><ol><li>http是无状态的</li><li>通过cookie在客户端记录状态</li><li>通过session在服务端记录状态</li><li>通过token方式维持状态<br>如果前后端是存在跨域问题，那么推荐使用token方式。反之，就用cookie和session方式。</li></ol><p><img src="https://s1.ax1x.com/2020/05/18/YWh1pT.png" alt="token" title="token原理"></p><ul><li><p>登录按钮所对应方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">login() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$refs.loginFormRef.validate(<span class="keyword">async</span> validate =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validate) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: result &#125; = <span class="keyword">this</span>.$http.post(<span class="string">'login'</span>, <span class="keyword">this</span>.loginForm)</span><br><span class="line">    <span class="keyword">if</span> (result.data.meta !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'登录失败'</span>)</span><br><span class="line">    <span class="keyword">this</span>.$message.success(<span class="string">'登录成功'</span>)</span><br><span class="line">     <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">'token'</span>, result.data.token)</span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/home'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是仅网页打开期间需要，不用永久化存储，所以用sessionStorage。而不用localStorage</p></li><li><p>路由守卫控制访问权限</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为路由对象添加路由守卫</span></span><br><span class="line">router.beforeEach(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 如果访问的是login页面，直接放行</span></span><br><span class="line">  <span class="keyword">if</span>( to.path === <span class="string">'/login'</span> ) <span class="keyword">return</span> next()</span><br><span class="line">  <span class="comment">// 从sessionStorage获取token</span></span><br><span class="line">  <span class="keyword">const</span> tokenStr = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">  <span class="comment">// 如果没有token，强制跳转到login页面</span></span><br><span class="line">  <span class="keyword">if</span>( !tokenStr ) <span class="keyword">return</span> next(<span class="string">'/login'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>退出功能实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.clear()</span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="主页内容"><a href="#主页内容" class="headerlink" title="主页内容"></a>主页内容</h2><ul><li>发送请求的权限获取<br>因为是后台管理系统，所以除了login页面外，发送请求都需要Authorization<br>我们采取的是axios拦截器的方法<br>意思就是请求发起之前，在请求头中添加Authorization字段，并且将之设置为token<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">  request.headers.Authorization = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><ul><li><p>二级菜单点击可跳转，是因为el-menu设置了router</p></li><li><p>element-ui和vue中的插槽</p><blockquote><p>个人理解的就是，如果某个元素内部还要依据自己的数据，进行下一步的处理。那么可以在内部使用插槽获取上级元素数据。比如dialog组件等</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">  &#123;&#123;scope.row&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>表单预验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.addFormRef.validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!valid) <span class="keyword">return</span> </span><br><span class="line">  <span class="comment">// 说明通过验证了，下一步发起请求</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>权限管理部分-分配权限功能<br>首先是点击分配权限按钮，获取所有被选中的三级标签。采用递归的方法，具体实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getLeafKeys(node, arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.children) &#123;</span><br><span class="line">    arr.push(node.id)</span><br><span class="line">  &#125;</span><br><span class="line">  node.children.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getLeafKeys(item, arr)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>其次是提交时，获取所有选中和半选中的标签。调用element-ui提供的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = [...this.$refs.treeRef.getCheckedKeys(),...this.$refs.treeRef.getHalfCheckedKeys()]</span><br></pre></td></tr></table></figure><h2 id="商品管理"><a href="#商品管理" class="headerlink" title="商品管理"></a>商品管理</h2><ul><li><p>分类参数-标签管理<br>参数管理页面在添加tags时，当tags变成input之后，input自动获取焦点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showInput(row) &#123;</span><br><span class="line">  row.inputVisible = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// $nextTick当页面上元素被重新渲染之后，才会指定回调函数中的代码</span></span><br><span class="line">    <span class="comment">// 👆注释的意思就是说等tags变成input之后再获取焦点，保证不出bug</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$refs.saveTagInput.$refs.input.focus()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>商品列表-添加时间<br>在main.js里面添加一个filter。主要解决的是时间格式的问题。具体来说是后台返回的是毫秒数，我们需要对应格式的时间。实现方式如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dateFormat'</span>,(originVal)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(originVal)</span><br><span class="line">  <span class="keyword">const</span> y = dt.getFullYear()</span><br><span class="line">  <span class="keyword">const</span> m = (dt.getMonth()+<span class="number">1</span>+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> d = (dt.getDate() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> hh = (dt.getHours() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> mm = (dt.getMinutes() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> ss = (dt.getSeconds() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//String.prototype.padStart()</span></span><br><span class="line">str.padStart(targetLength [, padString])  <span class="comment">//语法</span></span><br><span class="line"><span class="comment">//例子如下</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>);         <span class="comment">// "       abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">"foo"</span>);  <span class="comment">// "foofoofabc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">6</span>,<span class="string">"123465"</span>); <span class="comment">// "123abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">8</span>, <span class="string">"0"</span>);     <span class="comment">// "00000abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">1</span>);          <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure></li></ul><p>使用方法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"创建时间"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span>&#123;&#123;scope.row.add_time | dateFormat&#125;&#125;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在数组中，找到指定index的元素，并返回index<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleRemove(file) &#123;</span><br><span class="line">  <span class="comment">// console.log(file)</span></span><br><span class="line">  <span class="comment">// 获取将要删除的图片的临时路径</span></span><br><span class="line">  <span class="keyword">const</span> filePath = file.response.data.tmp_path</span><br><span class="line">  <span class="comment">// 从pics数组中，找到这个图片对应的索引值</span></span><br><span class="line">  <span class="keyword">const</span> i = <span class="keyword">this</span>.addForm.pics.findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x.pic === filePath)</span><br><span class="line">  <span class="comment">// 调用splice方法，把图片移除</span></span><br><span class="line">  <span class="keyword">this</span>.addForm.pics.splice(i, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// console.log(this.addForm.pics)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="项目优化上线"><a href="#项目优化上线" class="headerlink" title="项目优化上线"></a>项目优化上线</h2><p>项目优化策略</p><h4 id="1-生成打包报告–命令行和图形界面"><a href="#1-生成打包报告–命令行和图形界面" class="headerlink" title="1. 生成打包报告–命令行和图形界面"></a>1. 生成打包报告–命令行和图形界面</h4><h4 id="2-第三方库开启-CDN"><a href="#2-第三方库开启-CDN" class="headerlink" title="2. 第三方库开启 CDN"></a>2. 第三方库开启 CDN</h4><ul><li><p>通过修改<code>vue.config.js</code>来修改webpack的配置<br>vue-cli3.0 默认隐藏了所有webpack的配置项，目的是为了屏蔽项目的配置过程，让具体功能和业务逻辑的实现称为中心</p></li><li><p>为开发模式与发布模式指定不同的打包入口  通过externals加载外部CDN资源  首页内容定制</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 发布模式</span></span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'production'</span>,config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-prod.js'</span>)</span><br><span class="line">      config.set(<span class="string">'externals'</span>,&#123;</span><br><span class="line">        vue: <span class="string">'Vue'</span>,</span><br><span class="line">        <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">        axios: <span class="string">'axios'</span>,</span><br><span class="line">        echarts: <span class="string">'echarts'</span>,</span><br><span class="line">        nprogress: <span class="string">'NProgress'</span>,</span><br><span class="line">        <span class="string">'vue-quill-editor'</span>: <span class="string">'VueQuillEditor'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">        args[<span class="number">0</span>].isProd = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开发模式</span></span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'development'</span>,config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main.js'</span>)</span><br><span class="line">      config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">        args[<span class="number">0</span>].isProd = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-通过CDN优化element-ui的打包"><a href="#3-通过CDN优化element-ui的打包" class="headerlink" title="3. 通过CDN优化element-ui的打包"></a>3. 通过CDN优化element-ui的打包</h4><p>注释掉elemen-ui的引入，然后在<code>index.html</code>头部引入element-ui的js和css文件</p><h4 id="4-路由懒加载"><a href="#4-路由懒加载" class="headerlink" title="4. 路由懒加载"></a>4. 路由懒加载</h4><p>安装<code>bebel/plugin-syntax-dynamic-import</code><br>在<code>babel.config.js</code>中声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "index" */</span> <span class="string">'../components/Login.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "index" */</span> <span class="string">'../components/Home.vue'</span>)</span><br></pre></td></tr></table></figure><h4 id="5-一些小点"><a href="#5-一些小点" class="headerlink" title="5. 一些小点"></a>5. 一些小点</h4><ul><li><p>添加NProcess<br>这个插件的作用就是在页面顶部添加一个加载的进度条。在请求开始时出现，得到相应后结束<br>具体实现如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use( <span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">  NProcess.start()</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;)</span><br><span class="line">axios.interceptors.response.use( <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  NProcess.done()</span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>build之后去除console<br>解决方法就是添加<code>babel-plugin-transform-remove-console</code></p></li></ul><h2 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h2><p>开启gzip配置，配置https服务，使用pm2管理应用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天读完几本书之后，现在准备整理一下去年工作的一些收获。&lt;br&gt;尤其是将其中一些自己没有参与，但是还比较关键的环节进行梳理。希望能有进一步的感想。&lt;br&gt;下面开始&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="login" scheme="https://jambo0624.github.io/tags/login/"/>
    
      <category term="CDN" scheme="https://jambo0624.github.io/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (下卷)--ES6+》</title>
    <link href="https://jambo0624.github.io/2020-02-16-dont-know-js-last2.html"/>
    <id>https://jambo0624.github.io/2020-02-16-dont-know-js-last2.html</id>
    <published>2020-02-16T05:14:16.000Z</published>
    <updated>2020-10-16T13:38:42.528Z</updated>
    
    <content type="html"><![CDATA[<p>近期的生活，是一种非常规的模式。<br>自己一方面期待着什么时候能自由地活动；另一方面也想着成年以来，第一次能有这么长时间陪着父母，挺好。<br>今天我们继续将《你不知道的js (下卷)》读完，下面开始。</p><a id="more"></a><h2 id="ES？现在与未来"><a href="#ES？现在与未来" class="headerlink" title="ES？现在与未来"></a>ES？现在与未来</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>2009年，ES5正式发布<br>2015年，ES6发布</p><p>有人建议未来的版本应该改成基于年份，比如ES2016（也就是ES7）来标示在2016年结束之前敲定的任何版本的规范。<br>尽管有异议，但比起后来提出的方案ES2015，很可能保持统治地位的版本命名仍是ES6。<br>而ES2016可能会采用新的基于年份的命名方案。</p><h3 id="transpiling"><a href="#transpiling" class="headerlink" title="transpiling"></a>transpiling</h3><p>简单地说，其思路是利用专门的工具把你的ES6代码转化为等价（或近似！）的可以在ES5环境下工作的代码。</p><h2 id="新语法"><a href="#新语法" class="headerlink" title="新语法"></a>新语法</h2><h3 id="块作用域声明"><a href="#块作用域声明" class="headerlink" title="块作用域声明"></a>块作用域声明</h3><p><a href="https://jambo0624.github.io/2019-11-09-const-let-var.html">let, const声明</a>，我在之前的文章做了比较。<br>这里就不再记录了。</p><h3 id="spread-rest"><a href="#spread-rest" class="headerlink" title="spread/rest"></a>spread/rest</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>这种用法最好的一点是，它为弃用很久的arguments数组 —— 实际上它并不是真正的数组，而是类似数组的对象——提供了一个非常可靠的替代形式。<br>因为args是一个真正的数组，前ES6中有很多技巧用来把arguments转变为某种我们可以当作数组来使用的东西，现在我们可以摆脱这些愚蠢的技巧了。<br>考虑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照新的 ES6 的行为方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// args 已经是一个真正的数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 丢弃 args 中第一个元素</span></span><br><span class="line">  args.shift()  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把整个 args 作为参数传给 console.log()</span></span><br><span class="line">  <span class="built_in">console</span>.log( ...args )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照前 ES6 的老派行为方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把 arguments 转换为一个真正的数组</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在尾端添加几个元素</span></span><br><span class="line">  args.push(<span class="number">4</span>, <span class="number">5</span>)  </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 过滤掉奇数</span></span><br><span class="line">  args = args.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  &#125;) </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 把整个 args 作为参数传给 foo()</span></span><br><span class="line">  foo.apply(<span class="literal">null</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">11</span>, y=<span class="number">31</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x+y)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 42</span></span><br><span class="line">foo(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 11</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="number">42</span>) <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 36</span></span><br><span class="line">foo(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 36 &lt;-- 丢了undefined</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="number">42</span>) <span class="comment">// 5 &lt;-- null被强制转换为 0</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 17 &lt;--  丢了undefined</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="number">42</span>) <span class="comment">// 6 &lt;-- null被强制转换为 0</span></span><br></pre></td></tr></table></figure><p>函数默认值可以不只是像31这样的简单值；它们可以是任意合法表达式，甚至是函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar called! '</span>)</span><br><span class="line">  <span class="keyword">return</span> y + val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=y+<span class="number">3</span>, z=bar(x</span>)) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">5</span></span><br><span class="line">foo() <span class="comment">// 'bar called' // 8 13</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>) <span class="comment">// 'bar called' // 10 15</span></span><br><span class="line"></span><br><span class="line">y=<span class="number">6</span></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="number">10</span>) <span class="comment">// 9 10</span></span><br></pre></td></tr></table></figure><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>可以把将数组或者对象属性中带索引的值手动赋值看作结构化赋值。<br>ES6为解构新增了一个专门语法，专用于<strong>数组解构</strong>和<strong>对象解构</strong>。<br>这个语法消除了前面代码中对临时变量tmp的需求，使代码简洁很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c] = foo()</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y, <span class="attr">z</span>: z &#125; = bar()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) <span class="comment">// 4 5 6</span></span><br></pre></td></tr></table></figure><p><strong>对象属性赋值模式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了 source: target</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: bam, <span class="attr">y</span>: baz, <span class="attr">z</span>: bap &#125; = bar()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bam, baz, bap) <span class="comment">// 4 5 6</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>这里的语法模式是<code>souce: target</code>（或者说是value:variable-alias)。<br>x: bam表示x属性是源值，而bam是要赋值的目标变量。<br>换句话说，对象字面值是target &lt;–source，而对象解构赋值是source –&gt; target。</p><p><strong>不只是声明</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>, y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// 20 10</span></span><br></pre></td></tr></table></figure><p><strong>重复赋值</strong><br>对象解构形式允许多次列出同一个源属性（持有值类型任意）。举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: X, <span class="attr">a</span>: Y &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">X  <span class="comment">// 1</span></span><br><span class="line">Y  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这也意味着可以解构子对象/数组属性，同时捕获子对象/类的值本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: &#123; <span class="attr">x</span>: X, <span class="attr">x</span>: Y&#125;, a &#125; = &#123; <span class="attr">a</span>: &#123; <span class="attr">x</span>: <span class="number">1</span> &#125; &#125;</span><br><span class="line">X <span class="comment">// 1</span></span><br><span class="line">Y <span class="comment">// 1</span></span><br><span class="line">a <span class="comment">// &#123; x: 1 &#125;</span></span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">a</span>: X, <span class="attr">a</span>: Y, <span class="attr">a</span>: [ Z ] &#125; = &#123; <span class="attr">a</span>: [<span class="number">1</span>] &#125;)</span><br><span class="line"></span><br><span class="line">x.push(<span class="number">2</span>)</span><br><span class="line">Y[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">X <span class="comment">// [10, 2]</span></span><br><span class="line">Y <span class="comment">// [10, 2]</span></span><br><span class="line">Z <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>记住：解构的目的不只是为了打字更少，而是为了可读性更强。</p><h3 id="太多，太少，刚刚好"><a href="#太多，太少，刚刚好" class="headerlink" title="太多，太少，刚刚好"></a>太多，太少，刚刚好</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> [b, ...c] = a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b, c) <span class="comment">// 2 [3, 4]</span></span><br></pre></td></tr></table></figure><p><strong>默认值赋值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; x, y, z, <span class="attr">w</span>: WW =<span class="number">20</span>&#125; = bar()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z, w) <span class="comment">// 4 5 6 20</span></span><br></pre></td></tr></table></figure><p><strong>嵌套解构</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">x</span>: &#123; <span class="attr">y</span>: &#123;<span class="attr">z</span> :<span class="number">6</span>&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, [b, c, d], e] = a1</span><br><span class="line"><span class="keyword">var</span> [x: &#123;<span class="attr">y</span>:&#123;<span class="attr">z</span>:w&#125;&#125;] = o1</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d, e) <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">console</span>.log(w) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><strong>解构参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line">foo([<span class="number">1</span>,<span class="number">2</span>]) <span class="comment">// 1 2</span></span><br><span class="line">foo([<span class="number">1</span>]) <span class="comment">// 1 undefined</span></span><br><span class="line">foo() <span class="comment">// undefined undefined</span></span><br></pre></td></tr></table></figure><h3 id="对象字面量扩展"><a href="#对象字面量扩展" class="headerlink" title="对象字面量扩展"></a>对象字面量扩展</h3><p><strong>简洁属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">x:x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line">&#123;x&#125;</span><br></pre></td></tr></table></figure><p><strong>简洁方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  x: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line">&#123;</span><br><span class="line">  x()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">'hello '</span> + name + <span class="string">'! '</span></span><br><span class="line"><span class="comment">//新的方式可以写为</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">`hello <span class="subst">$&#123;name&#125;</span>! `</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>虽然不是一条严格的规律，但我认为=&gt;箭头函数转变带来的可读性提升与被转化函数的长度负相关。<br>这个函数越长，=&gt;带来的好处就越小；函数越短，=&gt;带来的好处就越大。<br>我认为更合理的做法是只在确实需要简短的在线函数表达式的时候才采用=&gt;，而对于那些一般长度的函数则无需改变。</p><p><strong>不只是更短的语法，而是this</strong><br>实际上，=&gt;箭头函数的主要设计目的就是以特定的方式改变this的行为特性，解决this相关编码的一个特殊而又常见的痛点。</p><h3 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for..of循环"></a>for..of循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> idx <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(idx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> val <span class="keyword">of</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a' 'b' 'c'</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h3 id="数字字面量扩展"><a href="#数字字面量扩展" class="headerlink" title="数字字面量扩展"></a>数字字面量扩展</h3><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>下面是创建symbol的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'some optional description'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> sym <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure><p>以下几点需要注意。</p><ul><li>不能也不应该对Symbol(..)使用new。它并不是一个构造器，也不会创建一个对象。</li><li>传给Symbol(..)的参数是可选的。如果传入了的话，应该是一个为这个symbol的用途给出用户友好描述的字符串。</li><li>typeof的输出是一个新的值(“symbol”)，这是识别symbol的首选方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期的生活，是一种非常规的模式。&lt;br&gt;自己一方面期待着什么时候能自由地活动；另一方面也想着成年以来，第一次能有这么长时间陪着父母，挺好。&lt;br&gt;今天我们继续将《你不知道的js (下卷)》读完，下面开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (下卷)》</title>
    <link href="https://jambo0624.github.io/2020-02-04-dont-know-js-last.html"/>
    <id>https://jambo0624.github.io/2020-02-04-dont-know-js-last.html</id>
    <published>2020-02-04T00:03:09.000Z</published>
    <updated>2020-10-16T11:10:27.827Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点流年不利，不论是大环境还是个人的境遇。<br>好的方面是又可以静下心来，读书，学习新的东西。要一直保持积极乐观的心态啊！<br>今天我们继续读《你不知道的js》的最后一卷。开始吧。</p><a id="more"></a><h2 id="深入编程"><a href="#深入编程" class="headerlink" title="深入编程"></a>深入编程</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>程序常被称为源码或代码，它是一组特定的指令，用来指示计算机要执行哪些任务。</p><p>指令的格式和组合规则被称为计算机语言，有时也被称为语法，这非常类似于英语中告诉你如何拼写单词以及如何使用单词和标点符号来构造有效的句子。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>语句由一个或多个表达式组成。<br>一个表达式是对一个变量或值的引用，或者是一组值和变量与运算符的组合。<br>举例来说，a = b ＊ 2；这个语句中有四个表达式。</p><ul><li>2是一个<strong>字面值表达式</strong>。</li><li>b是一个<strong>变量表达式</strong>，表示获取它的当前值。</li><li>b ＊ 2是一个<strong>算术表达式</strong>，表示进行乘法运算。</li><li>a = b ＊ 2是一个<strong>赋值表达式</strong>，意思是将表达式b ＊ 2的结果赋值给变量a。</li></ul><p>程序需要被执行，我们也将这一过程称为<strong>运行程序</strong>。</p><p>a = b ＊ 2这样的语句便于开发者读写，但实际上计算机并不能直接理解这种形式。<br>因此，需要通过计算机上一个专门的工具（解释器或编译器）将你编写的代码翻译成计算机可以理解的命令。</p><p>对某些计算机语言来说，在程序被执行时，对命令的翻译通常是自上而下逐行执行的，这通常被称为<strong>代码解释</strong>。</p><p>对另外一些语言来说，这种翻译是预先进行的，被称为<strong>代码编译</strong>，这样一来，当执行程序时，实际上运行的是已经编译好的、可以执行的计算机指令。</p><p>基本上可以说JavaScript是<strong>解释型</strong>的，因为每次执行JavaScript源码时都需要进行处理。<br>但这么说并不完全精确。JavaScript引擎实际上是<strong>动态编译程序</strong>，然后立即执行编译后的代码。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>学习编程的最好方法就是编写代码！</strong></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>赋值=，如a = 2就表示将值2保存在变量a中。</li><li>算术+（加）、-（减）、＊（乘）、/（除），如a ＊ 3。</li><li>复合赋值+=、-=、＊=和/=是复合运算符，可以将算术运算符与赋值组合起来，比如，a += 2等同于a = a + 2。</li><li>递增/递减++表示递增，–表示递减，比如a++就类似于a = a + 1。</li><li>对象属性访问如console.log()中的.。</li><li>相等==（粗略相等）、===（严格相等）、! =（粗略不等）和！==（严格不等），如a == b</li><li>比较&lt;（小于）、&gt;（大于）、&lt;=（小于或粗略等于）和&gt;=（大于或粗略等于），如a &lt;= b</li><li>逻辑&amp;&amp;（与）和||（或），如a || b就表示a或者b</li></ul><h3 id="值与类型"><a href="#值与类型" class="headerlink" title="值与类型"></a>值与类型</h3><p>在编程术语中，对<strong>值</strong>的不同表示方法称为<strong>类型</strong></p><h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>有关如何编写注释良好的代码有很多种观点；我们确实无法定义绝对的普遍标准。但是以下这些观察结论和指导原则是很有用的。</p><ul><li>没有注释的代码不是最优的。</li><li>过多注释（比如每行一个）可能是拙劣代码的征兆。</li><li>代码应该解释为什么，而非是什么。如果编写的代码特别容易令人迷惑的话，那么注释也可以解释一下实现原理。</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在程序中实现这一点的最简单方法是将值赋给一个符号容器，这个符号容器称为变量，使用这个名字是因为这个容器中的值是可以变化的。</p><p>在某些编程语言中，你需要声明一个变量（容器）用于存放指定类型的值（如数字或字符串）。通过避免不想要的值转换，人们认为这种<strong>静态类型</strong>（也称为类型强制）提高了程序的正确性。</p><p>其他语言强调的是值的类型而不是变量的类型。<strong>弱类型</strong>（也称为动态类型）允许一个变量在任意时刻存放任意类型的值。这种方式允许一个变量在程序的逻辑流中的任意时刻代表任意类型的值，人们认为这样可以提高程序的灵活性。</p><p>JavaScript采用了后一种机制——动态类型，这也就是说，变量可以持有任意类型值而不存在类型强制。</p><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>我们常常需要将在代码中的一系列语句组织到一起，这些语句通常被称为块。<br>在JavaScript中，使用一对大括号{ .. }在一个或多个语句外来表示块。</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>程序中有很多种方法可以用于表示条件判断（也就是决策）。<br>最常用的是if语句。本质上就是在表达“如果这个条件是真的，那么进行后续这些……”。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>重复一系列动作，直到不满足某个条件，换句话说，重复只发生在满足条件的情况下，这就是程序循环的工作。</p><p>循环包括测试条件以及一个块（通常就是{ .. }）。循环块的每次执行被称为一个<strong>迭代</strong>。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>程序也几乎总是需要将代码的任务分割成可复用的片段，而不是一直重复编码。<br>实现这一点的方法就是定义一个函数。</p><h2 id="深入-JavaScript"><a href="#深入-JavaScript" class="headerlink" title="深入 JavaScript"></a>深入 JavaScript</h2><h3 id="值与类型-1"><a href="#值与类型-1" class="headerlink" title="值与类型"></a>值与类型</h3><p><strong>对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'hello world'</span>,</span><br><span class="line">  b: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">obj[b] <span class="comment">// 'hello world</span></span><br><span class="line">obj[<span class="string">'b'</span>] <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p><strong>内置类型方法</strong><br>内置类型和子类型拥有作为属性和方法暴露出来的行为，这是非常强大有力的功能。<br>举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 11</span></span><br><span class="line">a.toUpperCase() <span class="comment">// 'HELLO WORLD'</span></span><br><span class="line">b.toFixed(<span class="number">4</span>) <span class="comment">// '3.1416'</span></span><br></pre></td></tr></table></figure><p><strong>值的比较</strong><br>1.类型转换<br>JavaScript中有两种类型转换：显式的类型转换与隐式的类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'42'</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">Number</span>(a)</span><br><span class="line">  a <span class="comment">// '42'</span></span><br><span class="line">  b <span class="comment">// 42</span></span><br><span class="line"><span class="comment">// 隐式</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'42'</span></span><br><span class="line">  <span class="keyword">var</span> b = a*<span class="number">1</span></span><br><span class="line">  a <span class="comment">// '42'</span></span><br><span class="line">  b <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>2.真与假<br>JavaScript中“假”值的详细列表如下：</p><ul><li>“”（空字符串）</li><li>0、-0、NaN(无效数字）</li><li>null、undefined</li><li>false</li></ul><p>3.相等<br>==检查的是允许类型转换情况下的值的相等性，而===检查不允许类型转换情况下的值的相等性；<br>因此，===经常被称为“严格相等”。</p><p>4.不等关系<br>运算符&lt;, &gt;、&lt;=和&gt;=用于表示不等关系，在规范中被称为“关系比较”。</p><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p>1.提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>2.嵌套作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">      <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    baz()</span><br><span class="line">    <span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>c在bar()的内部是不可访问的，因为它只声明在内层baz()作用域，b在foo()中是不可访问的，也是同样的原因。</p><h3 id="条件判断-1"><a href="#条件判断-1" class="headerlink" title="条件判断"></a>条件判断</h3><p>在JavaScript中，条件判断的另一种形式是“条件运算符”，通常被称为“三进制运算符”。<br>它更像是单个if..else语句的紧凑版，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = (a&gt;<span class="number">41</span>)? <span class="string">'hello'</span>:<span class="string">'world'</span></span><br></pre></td></tr></table></figure><p>如果条件表达式（这里是a &gt; 41）求值为真，那么就会返回第一个子句（”hello”）；否则，结果就是第二个子句（”world”），不论结果是什么，都会赋给b。<br>条件运算符并不一定要用在赋值上，但这肯定是最常见的用法。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>遵循严格模式也更容易让引擎优化你的代码。<br>严格模式是代码的一次重大突破，你应该在自己的程序中一直使用。</p><p>使用严格模式的一个关键区别（改进！）是，不允许省略var的隐式自动全局变量声明</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>不仅你可以向函数传入值（参数），<strong>函数本身也可以作为值</strong>赋给变量或者向其他函数传入，又或者从其他函数传出。<br>因此，应该将函数值视为一个表达式，与其他的值或者表达式类似。</p><p><strong>立即调用函数表达式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello! '</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 'Hello! '</span></span><br></pre></td></tr></table></figure><p><strong>闭包</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数x是一个内层变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 内层函数 add() 使用x，所以它外围有一个'闭包'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y + x</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用外层<code>makeAdder(..)</code>返回的、指向内层<code>add(..)</code>函数的引用能够记忆传入<code>makeAdder(..)</code>的<code>x</code>值。<br>现在，我们来使用<code>makeAdder(..)</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = makeAdder(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plusTen = makeAdder(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plusOne(<span class="number">3</span>)  <span class="comment">// 4 &lt;-- 1+3</span></span><br><span class="line">plusOne(<span class="number">41</span>)  <span class="comment">// 42 &lt;-- 1+41</span></span><br><span class="line"></span><br><span class="line">plusTen(<span class="number">13</span>) <span class="comment">// 23 &lt;-- 10+13</span></span><br></pre></td></tr></table></figure><p>我们来详细说明一下这段代码是如何执行的。<br>(1)调用<code>makeAdder(1)</code>时得到了内层<code>add(..)</code>的一个引用，它会将x记为1。我们将这个函数引用命名为<code>plusOne()</code>。<br>(2)调用<code>makeAdder(10)</code>时得到了内层<code>add(..)</code>的另一个引用，它会将x记为10，我们将这个函数引用命名为<code>plusTen()</code>。<br>(3)调用<code>plusOne(3)</code>时，它会向1（记住的x）加上3（内层y），从而得到结果4。<br>(4)调用<code>plusTen(13)</code>时，它会向10（记住的x）加上13（内层y），从而得到结果23。</p><p><strong>模块</strong><br>在JavaScript中，闭包最常见的应用是模块模式。<br>模块允许你定义外部不可见的私有实现细节（变量、函数），同时也可以提供允许从外部访问的公开API。</p><h3 id="this标识符"><a href="#this标识符" class="headerlink" title="this标识符"></a>this标识符</h3><p>关于如何设置this有4条规则，上述代码中的最后4行展示了这4条规则。<br>(1) 在非严格模式下，foo()最后会将this设置为全局对象。在严格模式下，这是未定义的行为，在访问bar属性时会出错——因此”global”是为this.bar创建的值。<br>(2) obj1.foo()将this设置为对象obj1。<br>(3) foo.call(obj2)将this设置为对象obj2。<br>(4) new foo()将this设置为一个全新的空对象。</p><p>底线：为了搞清楚this指向什么，你必须检查相关的函数是如何被调用的。<br>调用方式会是以上4种之一，这也会回答“this是什么”这个问题。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>当引用对象的某个属性时，如果这个属性并不存在，那么JavaScript会自动使用对象的内部原型引用找到另外一个对象来寻找这个属性。<br>你可以将这点看作是<strong>属性缺失情况的备用模式</strong>。</p><h3 id="旧与新"><a href="#旧与新" class="headerlink" title="旧与新"></a>旧与新</h3><p><strong>polyfilling</strong><br>单词“polyfill”是由Remy Sharp发明的一个<a href="https://remysharp.com/2010/10/08/what-is-a-polyfill" target="_blank" rel="noopener">新术语</a>，用于<strong>表示根据新特性的定义，创建一段与之行为等价但能够在旧的JavaScript环境中运行的代码</strong>。</p><p>ES6定义了一个名为Number.isNaN(..)的工具，用于提供一个精确无bug的NaN值检查，取代原来的isNaN(..)。但对这个工具进行兼容处理很容易，这样一来，无论终端用户是否使用ES6浏览器，你都能够开始使用它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Number</span>.isNaN)&#123;</span><br><span class="line">  <span class="built_in">Number</span>.isNaN = <span class="function"><span class="keyword">function</span> <span class="title">isNaN</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许更好的办法是，使用一个已有的、可信任的polyfilling版本，比如由<a href="https://github.com/es-shims/es5-shim" target="_blank" rel="noopener">ES5-Shim</a>和<a href="https://github.com/es-shims/es6-shim" target="_blank" rel="noopener">ES6-Shim</a>提供的版本。</p><p><strong>transpiling</strong><br>语言中新增的语法是无法进行polyfilling的。<br>新语法在旧版JavaScript引擎上会抛出未识别/无效错误。<br>因此，更好的方法是，通过工具将新版代码转换为等价的旧版代码。<br>这个过程通常被称为“transpiling”。它是由transforming（转换）和compiling（编译）组合而成的术语。</p><p>有几点重要原因使得transpiling值得被关注。</p><ul><li>语言中新添加的语法的设计目的是让代码更容易阅读和维护。等价的旧版本通常更加繁复。你应该编写更新、更简洁的语法，这不只是为你自己，同时也是为开发组中的所有其他成员着想。</li><li>如果只是为旧版本进行编译转换，对新版本应用新语法，那么你就得到了新语法浏览器性能优化的好处。这也使得浏览器开发者可以拥有更真实的代码，以便测试它们的实现和优化。</li><li>越早使用新语法，就可以越早在现实世界中更健壮地测试这些语法，也就可以越早地为JavaScript委员会（TC39）提供反馈。如果能够很早就发现问题，那么就能够在这些语言设计错误被固化前对其进行修改/修复。</li></ul><p>以下是transpiling的一个简单示例。ES6新增了一个名为“默认参数值”的新特性。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a=<span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 2</span></span><br><span class="line">foo(<span class="number">42</span>) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>很简单，对不对？但也非常有用！<br>然而这个新语法在ES6前的引擎中是无效的。<br>那么transpiler是如何改变这段代码，从而让其能够在旧环境下运行的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">arguments</span>[<span class="number">0</span>] !== (<span class="keyword">void</span> <span class="number">0</span>) ? <span class="built_in">arguments</span>[<span class="number">0</span>] : <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你可以看到的，它会检查arguments[0]的值是否为void 0（也就是undefined），如果是的话就提供默认值2；否则就使用传入值。</p><p>除了能够在旧版浏览器中使用更好的新语法，编译转换后的代码实际上也更好地表达了编程意图。<br>单看这段ES6版本的代码，你可能不会意识到undefined是唯一一个无法作为默认值参数显式传入的值。<br>而编译转换后的代码就更清楚地展示了这一点。</p><p>有很多很棒的transpiler可供选择。<br>以下是编写本部分时几个很好的选择：<br>· <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 从ES6+编译转换到ES5<br>· <a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a> 将ES6、ES7及后续版本转换到ES5</p><h3 id="非JavaScript"><a href="#非JavaScript" class="headerlink" title="非JavaScript"></a>非JavaScript</h3><p>你将遇到的最常见的非JavaScript就是DOM API。举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><p>当你的代码在浏览器中运行时，变量document作为一个全局变量存在。<br>它既不是由JavaScript引擎提供的，也不由JavaScript标准控制。<br>它的存在形式看起来非常类似于普通的JavaScript对象，但实际上并不完全是这样。<br>它是一个特殊的对象，通常被称为<strong>宿主对象</strong>。</p><h2 id="深入“你不知道的JavaScript”系列"><a href="#深入“你不知道的JavaScript”系列" class="headerlink" title="深入“你不知道的JavaScript”系列"></a>深入“你不知道的JavaScript”系列</h2><h3 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h3><p>JavaScript引擎在执行前（有时是执行中！）就编译了代码。<br>因此，通过深入理解编译器对代码的处理方式，我们可以尝试理解它是如何找到并处理变量和函数声明的。<br>沿着这条路，我们看到了JavaScript变量作用域管理的常见方式——“提升”。</p><p>闭包可能是JavaScript所有概念中最重要的一个，但如果你没有深刻了解作用域的工作原理，那么很可能就无法理解闭包。</p><p>正如我们在第2章中简单提到的那样，闭包的一个重要应用就是模块模式。<br>模块模式可能是JavaScript所有代码组织模式中最普遍的方法；深入理解模块模式应该是你最高优先级的任务之一。</p><h3 id="this和对象"><a href="#this和对象" class="headerlink" title="this和对象"></a>this和对象</h3><p>关键词this是根据相关函数的执行方式而动态绑定的，事实证明，可以通过4条简单的规则理解并完全确定this绑定。</p><p>与this紧密关联的是对象原型机制，这种机制是一个<strong>属性查找链</strong>，与寻找词法作用域变量的方式类似。</p><h3 id="类型和语法"><a href="#类型和语法" class="headerlink" title="类型和语法"></a>类型和语法</h3><p>到底类型转换的哪些部分是出乎意料的，哪些部分在花费精力学习后则是完全可以理解的。</p><p>这不仅仅只是声称类型转换是合理的、可学习的；我想表明的是，类型转换是非常有用且被低估了的工具，<strong>你应该在自己的代码中使用它</strong>。<br>在我看来，如果能够正确使用的话，类型转换不仅能够工作，而且也会让你的代码质量更高。</p><h3 id="异步和性能"><a href="#异步和性能" class="headerlink" title="异步和性能"></a>异步和性能</h3><p>“作用域和闭包”“this和对象原型”以及“类型和语法”关注的都是语言的核心机制，而“异步和性能”则稍微偏重于在语言机制之上处理异步编程的模式。<br>异步不只是对应用的性能至关重要，而且正在慢慢成为代码易写性和可维护性方面的关键因素。</p><p><strong>promise</strong>是对“未来值”的与时间无关的封装，使得不管这个值是否已经可用，你都可以推导和组合使用它们。<br>另外，通过一种可信任的、可组合的promise机制，分发回调它们也有效地解决了IoC信任问题。</p><p><strong>生成器</strong>为JavaScript函数引入了一种新的执行模式，其中生成器可以暂停在yield点上，并在之后被异步继续。<br>暂停与继续的能力使得生成器中同步的、看似连续的代码可以在后台异步执行。<br>通过这种方式，我们解决了回调的非线性、非局部跳转引发的代码混乱问题，因而让我们的异步代码看似同步，更容易追踪。</p><p>编写高效的JavaScript代码意味着，你编写的代码可以打破不同浏览器和环境的壁垒，达到动态运行。<br>这要求大量复杂而详细的计划和努力，只有这样，才能让程序从“可以运行”到“可以很好地运行”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有点流年不利，不论是大环境还是个人的境遇。&lt;br&gt;好的方面是又可以静下心来，读书，学习新的东西。要一直保持积极乐观的心态啊！&lt;br&gt;今天我们继续读《你不知道的js》的最后一卷。开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>axios 知识梳理</title>
    <link href="https://jambo0624.github.io/2020-01-04-axios.html"/>
    <id>https://jambo0624.github.io/2020-01-04-axios.html</id>
    <published>2020-01-04T14:03:54.000Z</published>
    <updated>2020-10-16T08:35:39.798Z</updated>
    
    <content type="html"><![CDATA[<p>axios是一个非常小巧而好用的http请求库，支持promise以及同时支持浏览器和node端。<br>axios使用简单，配置灵活，也是vue官方推荐的请求库。<br>今天我们就对 axios 相关知识进行整理。</p><a id="more"></a><p>首先介绍一下他的特性</p><blockquote><p>从浏览器中创建 XMLHttpRequest<br>从 node.js 发出 http 请求<br>支持 Promise API<br>拦截请求和响应<br>转换请求和响应数据<br>取消请求<br>自动转换JSON数据<br>客户端支持防止 CSRF/XSRF</p></blockquote><p>接下来看几个使用的栗子🌰：<br><strong>执行 GET 请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向具有指定ID的用户发出请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 params 对象传递参数</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>执行 POST 请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>执行多个并发请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//两个请求现已完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><p>可以通过将相关配置传递给 axios 来进行请求。</p><p><strong>axios(config)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Aaa'</span>,</span><br><span class="line">    lastName: <span class="string">'Bbb'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>axios(url[, config])</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个 GET 请求 (GET请求是默认请求模式)</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure><p><strong>请求方法别名</strong><br>为了方便起见，已经为所有支持的请求方法提供了别名。</p><ul><li><code>axios.request(config)</code></li><li><code>axios.get(url[,config])</code></li><li><code>axios.delete(url[,config])</code></li><li><code>axios.head(url[,config])</code></li><li><code>axios.post(url[,data[,config]])</code></li><li><code>axios.put(url [,data[,config]])</code></li><li><code>axios.patch(url[,data[,config]])</code><br>注意: 当使用别名方法时，不需要在config中指定url，method和data属性。</li></ul><p><strong>并发</strong><br>帮助函数处理并发请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.all（iterable）</span><br><span class="line">axios.spread（callback）</span><br></pre></td></tr></table></figure><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><p>这些是用于发出请求的可用配置选项。 只有url是必需的。 如果未指定方法，请求将默认为GET。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `url`是将用于请求的服务器URL</span></span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method`是发出请求时使用的请求方法</span></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL`将被添加到`url`前面，除非`url`是绝对的。</span></span><br><span class="line">  <span class="comment">// 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。</span></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest`允许在请求数据发送到服务器之前对其进行更改</span></span><br><span class="line">  <span class="comment">// 这只适用于请求方法'PUT'，'POST'和'PATCH'</span></span><br><span class="line">  <span class="comment">// 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做任何你想要的数据转换</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse`允许在 then / catch之前对响应数据进行更改</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers`是要发送的自定义 headers</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params`是要与请求一起发送的URL参数</span></span><br><span class="line">  <span class="comment">// 必须是纯对象或URLSearchParams对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer`是一个可选的函数，负责序列化`params`</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data`是要作为请求主体发送的数据</span></span><br><span class="line">  <span class="comment">// 仅适用于请求方法“PUT”，“POST”和“PATCH”</span></span><br><span class="line">  <span class="comment">// 当没有设置`transformRequest`时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - Browser only: FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node only: Stream</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout`指定请求超时之前的毫秒数。</span></span><br><span class="line">  <span class="comment">// 如果请求的时间超过'timeout'，请求将被中止。</span></span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials`指示是否跨站点访问控制请求</span></span><br><span class="line">  <span class="comment">// should be made using credentials</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter'允许自定义处理请求，这使得测试更容易。</span></span><br><span class="line">  <span class="comment">// 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api））</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;, </span><br><span class="line"></span><br><span class="line">  <span class="comment">// `auth'表示应该使用 HTTP 基本认证，并提供凭据。</span></span><br><span class="line">  <span class="comment">// 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// “responseType”表示服务器将响应的数据类型</span></span><br><span class="line">  <span class="comment">// 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称</span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName`是携带xsrf令牌值的http头的名称</span></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress`允许处理上传的进度事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用本地 progress 事件做任何你想要做的</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress`允许处理下载的进度事件</span></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength`定义允许的http响应内容的最大大小</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus`定义是否解析或拒绝给定的promise</span></span><br><span class="line">  <span class="comment">// HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被</span></span><br><span class="line">  <span class="comment">// 拒绝。</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects`定义在node.js中要遵循的重定向的最大数量。</span></span><br><span class="line">  <span class="comment">// 如果设置为0，则不会遵循重定向。</span></span><br><span class="line">  maxRedirects: <span class="number">5</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。</span></span><br><span class="line">  <span class="comment">// 允许配置类似`keepAlive`的选项，</span></span><br><span class="line">  <span class="comment">// 默认情况下不启用。</span></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'proxy'定义代理服务器的主机名和端口</span></span><br><span class="line">  <span class="comment">// `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。</span></span><br><span class="line">  <span class="comment">// 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: : &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// “cancelToken”指定可用于取消请求的取消令牌</span></span><br><span class="line">  <span class="comment">// (see Cancellation section below for details)</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>使用 then 时，您将收到如下响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="配置默认值"><a href="#配置默认值" class="headerlink" title="配置默认值"></a>配置默认值</h3><p>您可以指定将应用于每个请求的配置默认值。</p><p><strong>全局axios默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure><p><strong>自定义实例默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在创建实例时设置配置默认值</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create（&#123;</span><br><span class="line">   baseURL：<span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在实例创建后改变默认值</span></span><br><span class="line">instance.defaults.headers.common [<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure><p><strong>配置优先级顺序</strong><br>配置将与优先顺序合并。<br>顺序是<code>lib/defaults.js</code>中的库默认值，然后是实例的defaults属性，最后是请求的config参数。<br>后者将优先于前者。<br>这里有一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用库提供的配置默认值创建实例</span></span><br><span class="line"><span class="comment">//此时，超时配置值为`0`，这是库的默认值</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create（）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//覆盖库的超时默认值</span></span><br><span class="line"><span class="comment">//现在所有请求将在超时前等待2.5秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//覆盖此请求的超时，因为它知道需要很长时间</span></span><br><span class="line">instance.get（<span class="string">'/ longRequest'</span>，&#123;</span><br><span class="line">   timeout：<span class="number">5000</span></span><br><span class="line">&#125;）;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>你可以截取请求或响应在被 then 或者 catch 处理之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use（<span class="function"><span class="keyword">function</span>（<span class="title">config</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//在发送请求之前做某事</span></span><br><span class="line">     <span class="keyword">return</span> config;</span><br><span class="line">   &#125;，<span class="function"><span class="keyword">function</span>（<span class="title">error</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//请求错误时做些事</span></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Promise</span>.reject（error）;</span><br><span class="line">   &#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use（<span class="function"><span class="keyword">function</span>（<span class="title">response</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//对响应数据做些事</span></span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">   &#125;，<span class="function"><span class="keyword">function</span>（<span class="title">error</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//请求错误时做些事</span></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Promise</span>.reject（error）;</span><br><span class="line">   &#125;）;</span><br></pre></td></tr></table></figure><p>如果你以后可能需要删除拦截器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure><p>你可以将拦截器添加到axios的自定义实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios.get（<span class="string">'/ user / 12345'</span>）</span><br><span class="line">   .catch（<span class="function"><span class="keyword">function</span>（<span class="title">error</span>）</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>（error.response）&#123;</span><br><span class="line">       <span class="comment">//请求已发出，但服务器使用状态代码进行响应</span></span><br><span class="line">       <span class="comment">//落在2xx的范围之外</span></span><br><span class="line">       <span class="built_in">console</span>.log（error.response.data）;</span><br><span class="line">       <span class="built_in">console</span>.log（error.response.status）;</span><br><span class="line">       <span class="built_in">console</span>.log（error.response.headers）;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//在设置触发错误的请求时发生了错误</span></span><br><span class="line">       <span class="built_in">console</span>.log（<span class="string">'Error'</span>，error.message）;</span><br><span class="line">     &#125;&#125;</span><br><span class="line">     <span class="built_in">console</span>.log（error.config）;</span><br><span class="line">   &#125;）;</span><br></pre></td></tr></table></figure><p>您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get（<span class="string">'/ user / 12345'</span>，&#123;</span><br><span class="line">   validateStatus：<span class="function"><span class="keyword">function</span>（<span class="title">status</span>）</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">//仅当状态代码大于或等于500时拒绝</span></span><br><span class="line">   &#125;&#125;</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><h3 id="消除"><a href="#消除" class="headerlink" title="消除"></a>消除</h3><p>您可以使用取消令牌取消请求。</p><blockquote><p>axios cancel token API基于可取消的promise提议，目前处于阶段1。</p></blockquote><p>您可以使用CancelToken.source工厂创建一个取消令牌，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> source = CancelToken.source（）;</span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//取消请求（消息参数是可选的）</span></span><br><span class="line">source.cancel（<span class="string">'操作被用户取消。'</span>）;</span><br></pre></td></tr></table></figure><p>您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> cancel;</span><br><span class="line"> </span><br><span class="line">axios.get（<span class="string">'/ user / 12345'</span>，&#123;</span><br><span class="line">   cancelToken：<span class="keyword">new</span> CancelToken（<span class="function"><span class="keyword">function</span> <span class="title">executor</span>（<span class="title">c</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//一个执行器函数接收一个取消函数作为参数</span></span><br><span class="line">     cancel = c;</span><br><span class="line">   &#125;）</span><br><span class="line">&#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">clear();</span><br></pre></td></tr></table></figure><p>注意：<strong>您可以使用相同的取消令牌取消几个请求。</strong></p><h3 id="使用application-x-www-form-urlencoded格式"><a href="#使用application-x-www-form-urlencoded格式" class="headerlink" title="使用application / x-www-form-urlencoded格式"></a>使用application / x-www-form-urlencoded格式</h3><p>默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。</p><p><strong>浏览器</strong><br>在浏览器中，您可以使用URLSearchParams API，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, params);</span><br></pre></td></tr></table></figure><p>请注意，<strong>所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。</strong></p><p>或者，您可以使用qs库对数据进行编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, qs.stringify(&#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>Node.js</strong><br>在node.js中，可以使用querystring模块，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">axios.post(<span class="string">'http://something.com/'</span>, querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;);</span><br></pre></td></tr></table></figure><p>你也可以使用qs库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;axios是一个非常小巧而好用的http请求库，支持promise以及同时支持浏览器和node端。&lt;br&gt;axios使用简单，配置灵活，也是vue官方推荐的请求库。&lt;br&gt;今天我们就对 axios 相关知识进行整理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="http" scheme="https://jambo0624.github.io/tags/http/"/>
    
      <category term="axios" scheme="https://jambo0624.github.io/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (中卷)--程序性能》</title>
    <link href="https://jambo0624.github.io/2019-12-22-dont-know-js-second3.html"/>
    <id>https://jambo0624.github.io/2019-12-22-dont-know-js-second3.html</id>
    <published>2019-12-22T06:13:49.000Z</published>
    <updated>2020-10-16T07:35:33.228Z</updated>
    
    <content type="html"><![CDATA[<p>对于中卷的部分，之前已经分了两篇文章进行了介绍。<br>分别是<a href="https://jambo0624.github.io/2019-03-19-dont-know-js-second.html">中卷一</a>和<a href="https://jambo0624.github.io/2019-07-07-dont-know-js-second2.html">中卷二</a><br>但是真的由于内容很多，很精华，每一章节单拿出来都可以写成几篇文章。<br>就算仅仅记录表面意思，仍然足以撑满篇幅。<br>今天我们开始记录性能部分内容，真的是中卷的最后一篇文章啦。</p><a id="more"></a><h2 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h2><h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><p>如果你有一些处理密集型的任务要执行，但不希望它们都在主线程运行（这可能会减慢浏览器/UI），可能你就会希望JavaScript能够以多线程的方式运行。</p><p>像浏览器这样的环境，很容易提供多个JavaScript引擎实例，各自运行在自己的线程上，这样你可以在每个线程上运行不同的程序。<br>程序中每一个这样的独立的多线程部分被称为一个（Web）Worker。<br>这种类型的并行化被称为任务并行，因为其重点在于把程序划分为多个块来并发运行。</p><p>从JavaScript主程序（或另一个Worker）中，可以这样实例化一个Worker：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w1 = <span class="keyword">new</span> Worker(<span class="string">'http://some.url.1/mycoolworker.js'</span>)</span><br></pre></td></tr></table></figure><p>这个URL应该指向一个JavaScript文件的位置（而不是一个HTML页面！），这个文件将被加载到一个Worker中。<br>然后浏览器启动一个独立的线程，让这个文件在这个线程中作为独立的程序运行。</p><p>Worker之间以及它们和主程序之间，<strong>不会共享任何作用域或资源</strong>，那会把所有多线程编程的噩梦带到前端领域，而是<strong>通过一个基本的事件消息机制</strong>相互联系。<br>Worker w1对象是一个事件侦听者和触发者，可以通过订阅它来获得这个Worker发出的事件以及发送事件给这个Worker。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'mycoolworker.js'</span></span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// evt.data</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">postMessage(<span class="string">'a really cool reply'</span>)</span><br></pre></td></tr></table></figure><p>注意，专用Worker和创建它的程序之间是一对一的关系。<br>也就是说，”message”事件没有任何歧义需要消除，因为我们确定它只能来自这个一对一的关系：<strong>它要么来自这个Worker，要么来自主页面。</strong></p><p><strong>Worker环境</strong><br>在Worker内部是无法访问主程序的任何资源的。<br>这意味着你不能访问它的任何全局变量，也不能访问页面的DOM或者其他资源。<br>记住，这是一个完全独立的线程。</p><p>但是，你可以执行网络操作（Ajax、WebSockets）以及设定定时器。<br>还有，Worker可以访问几个重要的全局变量和功能的本地复本，包括navigator、location、JSON和applicationCache。</p><p>你还可以通过importScripts(..)向Worker加载额外的JavaScript脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker 内部</span></span><br><span class="line">importScripts(<span class="string">'foo.js'</span>, <span class="string">'bar.js'</span>)</span><br></pre></td></tr></table></figure><p>这些脚本加载是同步的。<br>也就是说，<code>importScripts(..)</code>调用会阻塞余下Worker的执行，直到文件加载和执行完成。</p><p><strong>数据传递</strong><br>如果要传递一个对象，可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">结构化克隆算法</a>(structured clone algorithm)把这个对象复制到另一边。<br>这个算法非常高级，甚至可以处理要复制的对象有循环引用的情况。<br>这样就不用付出to-string和from-string的性能损失了，但是这种方案还是要使用双倍的内存。IE10及更高版本以及所有其他主流浏览器都支持这种方案。<br>这里有一篇文章关于<a href="https://zhuanlan.zhihu.com/p/33489557" target="_blank" rel="noopener">结构化克隆算法</a>的<strong>应用</strong>。</p><p>还有一个更好的选择，特别是对于大数据集而言，就是使用<a href="http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast" target="_blank" rel="noopener">Transferable对象</a>。<br>这时发生的是对象所有权的转移，数据本身并没有移动。<br>一旦你把对象传递到一个Worker中，在原来的位置上，它就变为空的或者是不可访问的，这样就消除了多线程编程作用域共享带来的混乱。<br>当然，所有权传递是可以双向进行的。</p><p>如果选择Transferable对象的话，其实不需要做什么。<br>任何实现了<a href="http://developer.mozilla.org/en-US/docs/Web/API/Transferable" target="_blank" rel="noopener">Transferable接口</a>的数据结构就自动按照这种方式传输（Firefox和Chrome都支持）</p><p>下面是如何使用postMessage(..)发送一个Transferable对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如 Unit8Array</span></span><br><span class="line">postMessage( foo.buffer, [foo.buffer] )</span><br></pre></td></tr></table></figure><p>第一个参数是一个原始缓冲区，第二个是一个要传输的内容的列表。<br>不支持Transferable对象的浏览器就降级到结构化克隆，这会带来性能下降而不是彻底的功能失效。```</p><p><strong>共享Worker</strong><br>共享Worker可以与站点的多个程序实例或多个页面连接，所以这个Worker需要通过某种方式来得知消息来自于哪个程序。<br>这个唯一标识符称为端口（port），可以类比网络socket的端口。因此，调用程序必须使用Worker的port对象用于通信：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w1.port.addEventListener(<span class="string">'message'</span>,handleMessage)</span><br><span class="line">w1.port.postMessage(<span class="string">'something cool'</span>)</span><br></pre></td></tr></table></figure><p>还有，端口连接必须要初始化，形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w1.port.start()</span><br></pre></td></tr></table></figure><p>在共享Worker内部，必须要处理额外的一个事件：”connect”。<br>这个事件为这个特定的连接提供了端口对象。<br>保持多个连接独立的最简单办法就是使用port上的闭包，就像下面的代码一样，把这个链接上的事件侦听和传递定义在”connect”事件的处理函数内部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker 内部</span></span><br><span class="line">addEventListener(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> port = evt.ports[<span class="number">0</span>]</span><br><span class="line">  port.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    port.postMessage()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  port.start()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="SMID"><a href="#SMID" class="headerlink" title="SMID"></a>SMID</h3><p>单指令多数据（SIMD）是一种数据并行（data parallelism）方式，与WebWorker的任务并行（task parallelism）相对，因为这里的重点实际上不再是把程序逻辑分成并行的块，而是并行处理数据的多个位。</p><p>通过SIMD，线程不再提供并行。<br>取而代之的是，现代CPU通过数字“向量”（特定类型的数组），以及可以在所有这些数字上并行操作的指令，来提供SIMD功能。<br>这是利用低级指令级并行的底层运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = SMID.float32x4(<span class="number">3.14159</span>, <span class="number">21.0</span>, <span class="number">32.3</span>, <span class="number">55.55</span>)</span><br><span class="line"><span class="keyword">var</span> v2 = SMID.float32x4(<span class="number">2.1</span>, <span class="number">3.2</span>, <span class="number">4.3</span>, <span class="number">5.4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v3 = SMID.int32x4(<span class="number">10</span>, <span class="number">101</span>, <span class="number">1001</span>, <span class="number">10001</span>)</span><br><span class="line"><span class="keyword">var</span> v4 = SMID.int32x4(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">SMID.float32x4.mul(v1, v2) <span class="comment">// [6.597339, 67.2, 138.89, 299.97]</span></span><br><span class="line">SMID.int32x4.mul(v3, v4) <span class="comment">// [20, 121, 1031, 10041]</span></span><br></pre></td></tr></table></figure><h3 id="asm-js"><a href="#asm-js" class="headerlink" title="asm.js"></a>asm.js</h3><p><a href="http://asmjs.org" target="_blank" rel="noopener">asm.js</a>这个标签是指JavaScript语言中可以高度优化的一个子集。<br>通过小心避免某些难以优化的机制和模式（垃圾收集、类型强制转换，等等）, asm.js风格的代码可以被JavaScript引擎识别并进行特别激进的底层优化。</p><h2 id="性能测试与调优"><a href="#性能测试与调优" class="headerlink" title="性能测试与调优"></a>性能测试与调优</h2><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> end = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Duration:'</span>,(end-start))</span><br></pre></td></tr></table></figure><p>使用这个方法测试某个运算的速度（执行时间）<strong>有很多错误</strong>。</p><p><strong>重复</strong><br>如果想要用重复来测试，要确保把异常因素排除，你需要大量的样本来平均化。<br>你还会想要知道最差样本有多慢，最好的样本有多快，以及最好和最差情况之间的偏离度有多大，等等。<br>司仪重复也不是正确的方法。</p><p><strong>Benchmark.js</strong><br>任何有意义且可靠的性能测试都应该基于统计学上合理的实践。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 要测试的运算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bench= <span class="keyword">new</span> Benchmark(      </span><br><span class="line"> <span class="string">'foo test'</span>,  <span class="comment">// 测试名称</span></span><br><span class="line">  foo,  <span class="comment">// 要测试的函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 可选的额外选项</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">bench.hz <span class="comment">// 每秒运算数</span></span><br><span class="line">bench.stats.moe <span class="comment">// 出错边界</span></span><br><span class="line">bench.stats.variance <span class="comment">// 样本方差</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="环境为王"><a href="#环境为王" class="headerlink" title="环境为王"></a>环境为王</h3><p>对特定的性能测试来说，不要忘了检查测试环境，特别是比较任务Ⅹ和Y这样的比对测试。<br>仅仅因为你的测试显示Ⅹ比Y快，并不能说明结论Ⅹ比Y快就有实际的意义。</p><p><strong>引擎优化</strong><br>我们设想的所有优化可能性在受限的测试中都有可能发生，而且在更复杂的程序中（出于各种各样的原因），引擎可能不会进行这样的优化。<br>也可能恰恰相反，引擎可能不会优化这样无关紧要的代码，但是在系统已经在运行更复杂的程序时可能会倾向于激进的优化。</p><p>这是不是意味着无法真正进行任何有用的测试呢？绝对不是！<br>测试不真实的代码只能得出不真实的结论。<br>如果有实际可能的话，你应该测试实际的而非无关紧要的代码，测试条件与你期望的真实情况越接近越好。<br>只有这样得出的结果才有可能接近事实。<br>像++x对比x++这样的微观性能测试结果为虚假的可能性相当高，可能我们最好就假定它们是假的。</p><h3 id="jsPerf-com"><a href="#jsPerf-com" class="headerlink" title="jsPerf.com"></a>jsPerf.com</h3><p>如果想要在不止一个环境下得出像“Ⅹ比Y快”这样的有意义的结论成立，那你需要在尽可能多的真实环境下进行实际测试。仅仅因为在Chrome上某个Ⅹ运算比Y快并不意味着这在所有的浏览器中都成立。<br>当然你可能还想要交叉引用多个浏览器上的测试运行结果，并有用户的图形展示。</p><p>有一个很棒的网站正是因这样的需求而诞生的，名为<a href="http://jsperf.com" target="_blank" rel="noopener">jsPerf</a></p><h3 id="写好测试"><a href="#写好测试" class="headerlink" title="写好测试"></a>写好测试</h3><p>要写好测试，需要认真分析和思考两个测试用例之间有什么区别，以及这些区别是有意还是无意的。</p><p>编写更好更清晰的测试。<br>但还有，花一些时间来编写文档（使用jsPerf.com上的Description字段和/或代码注释）精确表达你的测试目的，甚至对于那些微小的细节也要如此。<br>找出那些有意的区别，这会帮助别人和未来的你更好地识别出那些可能扭曲测试结果的无意区别。</p><p>不要试图窄化到真实代码的微小片段，以及脱离上下文而只测量这一小部分的性能，因为包含更大（仍然有意义的）上下文时功能测试和性能测试才会更好。<br>这些测试可能也会运行得慢一点，这意味着环境中发现的任何差异都更有意义。</p><h3 id="微性能"><a href="#微性能" class="headerlink" title="微性能"></a>微性能</h3><p>在考虑对代码进行性能测试时，你应该习惯的第一件事情就是你所写的代码并不总是引擎真正运行的代码。</p><p>来考虑下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">41</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> baz = foo + baz</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)(<span class="number">1</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>可能你会认为最内层函数中的引用foo需要进行三层作用域查找。<br>事实上，编译器通常会缓存这样的查找结果，使得从不同的作用域引用foo实际上并没有任何额外的花费。<br>但是，还有一些更深入的问题需要思考。<br>如果编译器意识到这个foo只在一个位置被引用而别处没有任何引用，并且注意到这个值只是41而从来不会变成其他值呢？</p><p>JavaScript可能决定完全去掉foo变量，将其值在线化，这不是很可能发生也可以接受的吗？就像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> baz = <span class="number">41</span> + baz</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)(<span class="number">1</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>当你把JavaScript代码看作对引擎要做什么的提示和建议，而不是逐字逐句的要求时，你就会意识到，对于具体语法细节的很多执着迷恋已经烟消云散了。</p><p>这里是另一个常见的愚蠢的执迷于微观性能的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [...]</span><br><span class="line"><span class="comment">// 选择1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;x.length;i++)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=x.length;i&lt;len;i++)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上说，这里应该在变量len中缓存x数组的长度，因为表面上它不会改变，来避免在每个循环迭代中计算x.length的代价。<br>如果运行性能测试来比较使用x.length和将其缓存到len变量中的方案，你会发现尽管理论听起来没错，但实际的可测差别在统计上是<strong>完全无关紧要</strong>的。</p><p>实际上，在某些像v8这样的引擎中，可以<a href="http://mrale.ph/blog/2014/12/24/array-length-caching.html" target="_blank" rel="noopener">看到</a>，预先缓存长度而不是让引擎为你做这件事情，会使性能稍微下降一点。<br>不要试图和JavaScript引擎比谁聪明。对性能优化来说，你很可能会输。</p><p><strong>不是所有的引擎都类似</strong><br>引擎可以自由决定一个运算是否需要优化，可能进行权衡，替换掉运算次要性能。<br>对一个运算来说，很难找到一种方法使其在所有浏览器中都运行得较快</p><p>在一些JavaScript开发社区有一场运动，特别是在那些使用Node.js工作的开发者中间。<br>这场运动是要分析v8 JavaScript引擎的特定内部实现细节，决定编写裁剪过的JavaScript代码来最大程度地利用v8的工作模式。<br>通过这样的努力，你可能会获得令人吃惊的高度性能优化。因此，这种努力的回报可能会很高。</p><p><strong>大局</strong><br>怎么知道什么是大局呢？<br>首先要了解你的代码是否运行在关键路径上。<br>如果不在关键路径上，你的优化就很可能得不到很大的收益。</p><p>有没有听过“这是过早优化”这样的警告？<br>这来自于高德纳著名的一句话：<strong>“过早优化是万恶之源。”</strong><br>很多开发者都会引用这句话来说明多数优化都是“过早的”，因此是白费力气。和通常情况一样，事实要更加微妙一些。</p><p>尽管程序关键路径上的性能非常重要，但这并不是唯一要考虑的因素。<br>在性能方面大体相似的几个选择中，<strong>可读性</strong>应该是另外一个重要的考量因素。</p><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用优化（Tail Call Optimization, TCO）<br>尾调用就是一个出现在另一个函数“结尾”处的函数调用。<br>这个调用结束后就没有其余事情要做了（除了可能要返回结果值）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(y+<span class="number">1</span>) <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + bar(<span class="number">40</span>) <span class="comment">// 非尾调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz() <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>调用一个新的函数需要额外的一块预留内存来管理调用栈，称为<strong>栈帧</strong>。<br>所以前面的代码一般会同时需要为每个baz()、bar(..)和foo(..)保留一个栈帧。</p><p>然而，如果支持TCO的引擎能够意识到foo(y+1)调用位于尾部，这意味着bar(..)基本上已经完成了，那么在调用foo(..)时，它就不需要创建一个新的栈帧，而是可以重用已有的bar(..)的栈帧。<br>这样不仅速度更快，也更节省内存。</p><p>在简单的代码片段中，这类优化算不了什么，但是在处理递归时，这就解决了大问题，特别是如果递归可能会导致成百上千个栈帧的时候。<br>有了TCO，引擎可以用同一个栈帧执行所有这类调用！</p><p>递归是JavaScript中一个纷繁复杂的主题。<br>因为如果没有TCO的话，引擎需要实现一个随意（还彼此不同！）的限制来界定递归栈的深度，达到了就得停止，以防止内存耗尽。<br>有了TCO，尾调用的递归函数本质上就可以任意运行，因为再也不需要使用额外的内存！</p><p>ES6之所以要求引擎实现TCO而不是将其留给引擎自由决定，一个原因是缺乏TCO会导致一些JavaScript算法因为害怕调用栈限制而降低了通过递归实现的概率。</p><p>最后今天冬至了，愿大家都能吃上一碗热乎的饺子🥟！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于中卷的部分，之前已经分了两篇文章进行了介绍。&lt;br&gt;分别是&lt;a href=&quot;https://jambo0624.github.io/2019-03-19-dont-know-js-second.html&quot;&gt;中卷一&lt;/a&gt;和&lt;a href=&quot;https://jambo0624.github.io/2019-07-07-dont-know-js-second2.html&quot;&gt;中卷二&lt;/a&gt;&lt;br&gt;但是真的由于内容很多，很精华，每一章节单拿出来都可以写成几篇文章。&lt;br&gt;就算仅仅记录表面意思，仍然足以撑满篇幅。&lt;br&gt;今天我们开始记录性能部分内容，真的是中卷的最后一篇文章啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>vim命令</title>
    <link href="https://jambo0624.github.io/2019-12-09-vim-command.html"/>
    <id>https://jambo0624.github.io/2019-12-09-vim-command.html</id>
    <published>2019-12-09T02:08:25.000Z</published>
    <updated>2020-10-15T12:29:23.002Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇文章摘转了一篇 vim 的教程。今天我们用简短集中的方式来梳理 vim 相关的知识。<br>大致意思就是去掉说明性的文字，直接让代码说话。<br>下面我们开始吧。</p><a id="more"></a><h1 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h1><p><a href="https://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">Vim命令合集</a><br><strong>退出方式</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>保存文件但不退出vi</td></tr><tr><td>:w</td><td>file 将修改另外保存到file中，不退出vi</td></tr><tr><td>:w!</td><td>强制保存，不推出vi</td></tr><tr><td>:wq</td><td>保存文件并退出vi</td></tr><tr><td>:wq!</td><td>强制保存文件，并退出vi</td></tr><tr><td>q:</td><td>不保存文件，退出vi</td></tr><tr><td>:q!</td><td>不保存文件，强制退出vi</td></tr><tr><td>:e!</td><td>放弃所有修改，从上次保存文件开始再编辑</td></tr></tbody></table><p><strong>命令历史</strong></p><blockquote><p>以<code>:</code>和<code>/</code>开头的命令都有历史记录，可以首先键入<code>:</code>或<code>/</code>然后按上下箭头来选择某个历史命令。</p></blockquote><p><strong>文件命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>vim file</td><td>打开单个文件</td></tr><tr><td>vim file1 file2 file3 …</td><td>同时打开多个文件</td></tr><tr><td>:open file</td><td>在vim窗口中打开一个新文件</td></tr><tr><td>:split file</td><td>在新窗口中打开文件</td></tr><tr><td>:bn</td><td>切换到下一个文件</td></tr><tr><td>:bp</td><td>切换到上一个文件</td></tr><tr><td>:args</td><td>查看当前打开的文件列表，当前正在编辑的文件会用<code>[]</code>括起来</td></tr><tr><td><code>:e ftp://192.168.10.76/abc.txt</code></td><td>打开远程文件，比如ftp</td></tr><tr><td>:e \qadrive\test\1.txt</td><td>打开远程文件，比如share folder</td></tr></tbody></table><p><strong>vim的模式</strong></p><table><thead><tr><th>模式</th><th>状态</th></tr></thead><tbody><tr><td>正常模式</td><td>（按Esc或Ctrl+[进入） 左下角显示文件名或为空</td></tr><tr><td>插入模式</td><td>（按i键进入） 左下角显示–INSERT–</td></tr><tr><td>可视模式</td><td>左下角显示–VISUAL–</td></tr></tbody></table><p><strong>导航命令</strong></p><blockquote><p>% 括号匹配</p></blockquote><p><strong>插入命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>在当前位置生前插入</td></tr><tr><td>I</td><td>在当前行首插入</td></tr><tr><td>a</td><td>在当前位置后插入</td></tr><tr><td>A</td><td>在当前行尾插入</td></tr><tr><td>o</td><td>在当前行之后插入一行</td></tr><tr><td>O</td><td>在当前行之前插入一行</td></tr></tbody></table><p><strong>查找命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>/text</td><td>查找text，按n健查找下一个，按N健查找前一个。</td></tr><tr><td>?text</td><td>查找text，反向查找，按n健查找下一个，按N健查找前一个。</td></tr><tr><td>:set ignorecase</td><td>忽略大小写的查找</td></tr><tr><td>:set noignorecase</td><td>不忽略大小写的查找</td></tr><tr><td>:set hlsearch</td><td>高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</td></tr><tr><td>:set nohlsearch</td><td>关闭高亮搜索显示</td></tr><tr><td>:nohlsearch</td><td>关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</td></tr><tr><td>:set incsearch</td><td>逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</td></tr><tr><td>:set wrapscan</td><td>重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</td></tr></tbody></table><ul><li>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</li><li>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</li></ul><p><strong>替换命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ra</td><td>将当前字符替换为a，当期字符即光标所在字符。</td></tr><tr><td>s/old/new/</td><td>用old替换new，替换当前行的第一个匹配</td></tr><tr><td>s/old/new/g</td><td>用old替换new，替换当前行的所有匹配</td></tr><tr><td>%s/old/new/</td><td>用old替换new，替换所有行的第一个匹配</td></tr><tr><td>%s/old/new/g</td><td>用old替换new，替换整个文件的所有匹配</td></tr><tr><td>:10,20 s/^//g</td><td>在第10行知第20行每行前面加四个空格，用于缩进。</td></tr><tr><td>ddp</td><td>交换光标所在行和其下紧邻的一行。</td></tr></tbody></table><p><strong>移动命令</strong></p><blockquote><p>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符</p></blockquote><p>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<code>&lt;Esc&gt;</code>，这里的Esc是必须的，否则命令不生效。</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>w</td><td>向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</td></tr><tr><td>b</td><td>向后移动一个单词 2b 向后移动2个单词</td></tr><tr><td>e，同w，</td><td>只不过是光标停在单词尾部</td></tr><tr><td>ge，同b，</td><td>光标停在单词尾部。</td></tr><tr><td>^</td><td>移动到本行第一个非空白字符上。</td></tr><tr><td>0</td><td>（数字0）移动到本行第一个字符上，</td></tr><tr><td><code>&lt;HOME&gt;</code></td><td>移动到本行第一个字符。同0健。</td></tr><tr><td>$</td><td>移动到行尾 3$ 移动到下面3行的行尾</td></tr><tr><td>gg( [[)</td><td>移动到文件头。</td></tr><tr><td>G（shift + g）( ]])</td><td>移动到文件尾。</td></tr><tr><td>f（find）</td><td>命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</td></tr><tr><td>F 同f</td><td>反向查找</td></tr><tr><td>Ctrl + e</td><td>向下滚动一行</td></tr><tr><td>Ctrl + y</td><td>向上滚动一行</td></tr><tr><td>Ctrl + d</td><td>向下滚动半屏</td></tr><tr><td>Ctrl + u</td><td>向上滚动半屏</td></tr><tr><td>Ctrl + f</td><td>向下滚动一屏</td></tr><tr><td>Ctrl + b</td><td>向上滚动一屏</td></tr><tr><td>跳到指定行，冒号+行号，回车</td><td>比如跳到240行就是 <code>:240回车</code>。另一个方法是行号+G，比如230G跳到230行。</td></tr></tbody></table><p><strong>撤销和重做</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>u</td><td>撤销（Undo）</td></tr><tr><td>U</td><td>撤销对整行的操作</td></tr><tr><td>Ctrl + r</td><td>重做（Redo），即撤销的撤销</td></tr></tbody></table><p><strong>删除命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>x</td><td>删除当前字符</td></tr><tr><td>3x</td><td>删除当前光标开始向后三个字符</td></tr><tr><td>X</td><td>删除当前字符的前一个字符。X=dh</td></tr><tr><td>dl</td><td>删除当前字符， dl=x</td></tr><tr><td>dh</td><td>删除前一个字符</td></tr><tr><td>dd</td><td>删除当前行</td></tr><tr><td>dj</td><td>删除上一行</td></tr><tr><td>dk</td><td>删除下一行</td></tr><tr><td>10d</td><td>删除当前行开始的10行。</td></tr><tr><td>D</td><td>删除当前字符至行尾。D=d$</td></tr><tr><td>d$</td><td>删除当前字符之后的所有字符（本行）</td></tr><tr><td>kdgg</td><td>删除当前行之前所有行（不包括当前行）</td></tr><tr><td>jdG（jd shift + g）</td><td>删除当前行之后所有行（不包括当前行）</td></tr><tr><td>:1,10d</td><td>删除1-10行</td></tr><tr><td>:11,$d</td><td>删除11行及以后所有的行</td></tr><tr><td>:1,$d</td><td>删除所有行</td></tr><tr><td>J(shift + j)</td><td>删除两行之间的空行，实际上是合并两行。</td></tr></tbody></table><p><strong>拷贝和粘贴</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>yy</td><td>拷贝当前行</td></tr><tr><td>nyy</td><td>拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</td></tr><tr><td>p</td><td>在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</td></tr><tr><td>shift+p</td><td>在当前行前粘贴</td></tr><tr><td>:1,10 co 20</td><td>将1-10行插入到第20行之后。</td></tr><tr><td>:1,$ co $</td><td>将整个文件复制一份并添加到文件尾部。</td></tr><tr><td>ddp</td><td>交换当前行和其下一行</td></tr><tr><td>xp</td><td>交换当前字符和其后一个字符</td></tr><tr><td>+ 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</td><td></td></tr></tbody></table><p><strong>剪切命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ndd</td><td>剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</td></tr><tr><td>:1,10d</td><td>将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</td></tr><tr><td>:1, 10 m 20</td><td>将第1-10行移动到第20行之后。</td></tr><tr><td>+ 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</td><td></td></tr></tbody></table><p><strong>退出命令</strong></p><blockquote><p>:wq 保存并退出<br>ZZ 保存并退出<br>:q! 强制退出并忽略所有更改<br>:e! 放弃所有修改，并打开原来文件。</p></blockquote><p><strong>窗口命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:split或new</td><td>打开一个新窗口，光标停在顶层的窗口上</td></tr><tr><td>:split file或:new file</td><td>用新窗口打开文件</td></tr><tr><td>Ctrl+ww</td><td>移动到下一个窗口</td></tr><tr><td>Ctrl+wj</td><td>移动到下方的窗口</td></tr><tr><td>Ctrl+wk</td><td>移动到上方的窗口</td></tr><tr><td>+ split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。</td><td></td></tr></tbody></table><p><strong>关闭窗口</strong></p><blockquote><p>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。<br>:q 如果是最后一个被关闭的窗口，那么将退出vim。<br>ZZ 保存并退出。<br>关闭所有窗口，只保留当前窗口 :only</p></blockquote><p><strong>录制宏</strong></p><blockquote><p>按<code>q</code>键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p></blockquote><p><strong>执行shell命令</strong></p><blockquote><p>:!command<br>:!ls 列出当前目录下文件<br>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。<br>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。<br>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p></blockquote><p><strong>注释命令</strong></p><blockquote><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#<br>3,5 s/^/#/g 注释第3-5行<br>3,5 s/^#//g 解除3-5行的注释<br>1,$ s/^/#/g 注释整个文档。<br>:%s/^/#/g 注释整个文档，此法更快。</p></blockquote><p><strong>帮助命令</strong></p><blockquote><p><code>:help or F1</code> 显示整个帮助<br><code>:help xxx</code> 显示xxx的帮助，比如 <code>:help i, :help CTRL-[</code>（即<code>Ctrl+[的帮助</code>）<br><code>:help &#39;number&#39;</code> Vim选项的帮助用单引号括起<br><code>:help &lt;Esc&gt;</code> 特殊键的帮助用&lt;&gt;扩起<br><code>:help -t</code> Vim启动参数的帮助用-<br><code>:help i_&lt;Esc&gt;</code> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</p></blockquote><p>其他非编辑命令</p><blockquote><p><code>.</code> 重复前一次命令<br><code>:set ruler?</code>　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看<br><code>:scriptnames</code>　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。<br><code>:set list</code> 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</p></blockquote><p>Vim教程<br>在Unix系统上</p><blockquote><p>$ vimtutor</p></blockquote><p>在Windows系统上</p><blockquote><p>:help tutor<br>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一篇文章摘转了一篇 vim 的教程。今天我们用简短集中的方式来梳理 vim 相关的知识。&lt;br&gt;大致意思就是去掉说明性的文字，直接让代码说话。&lt;br&gt;下面我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/categories/vim/"/>
    
    
      <category term="command" scheme="https://jambo0624.github.io/tags/command/"/>
    
      <category term="vim" scheme="https://jambo0624.github.io/tags/vim/"/>
    
  </entry>
  
</feed>
