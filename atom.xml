<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You should know</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jambo0624.github.io/"/>
  <updated>2020-09-26T02:38:56.990Z</updated>
  <id>https://jambo0624.github.io/</id>
  
  <author>
    <name>Jambo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读《程序是怎么跑起来的》</title>
    <link href="https://jambo0624.github.io/2020-07-26-how-program-works.html"/>
    <id>https://jambo0624.github.io/2020-07-26-how-program-works.html</id>
    <published>2020-07-26T07:47:59.000Z</published>
    <updated>2020-09-26T02:38:56.990Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是《程序是怎么跑起来的》读书笔记。<br>在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。<br>下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: </p><a id="more"></a><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>程序是由指令和数据构成的。<br>CPU所负责的就是解释和运行最终转换成机器语言的程序内容。<br>从功能方面来看， CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。<br><strong>寄存器</strong> 可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。<br><strong>控制器</strong> 负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。<br><strong>运算器</strong> 负责运算从内存读入寄存器的数据。<br><strong>时钟</strong> 负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。</p><p>汇编语言 (assembly) 采用助记符 (memonic) 来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符，助记符通常为指令功能的英语单词的简写。<br>通常我们将汇编语言编写的程序转化成机器语言的过程称为 <strong>汇编</strong> ；反之，机器语言程序转化成汇编语言程序的过程则称为 <strong>反汇编</strong> 。  </p><p>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器 (基址，变址，通用) 一般有多个。<br>CPU每执行一个指令，程序计数器的值就会自动加1。也就是说，<strong>程序计数器</strong> 决定着程序的流程。<br><strong>标志寄存器</strong> 实现了对程序的流程控制。<br>函数调用处理是通过把程序计数器的值设定成函数的<strong>存储地址</strong>来实现的。<br>函数调用使用的是call指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call指令会把 <strong>调用函数后要执行的指令地址</strong> 存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行<code>return</code>命令。<code>return</code>命令的功能是把保存在栈中的地址设定到程序计数器中。  </p><p>第一张结束了，通过第一章。我们要知道几个基本的知识:</p><ol><li>程序就是数据和指令</li><li><code>高级编程语言</code>-&gt;<code>汇编语言</code>-&gt;<code>机器语言</code></li></ol><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>因为 IC 的所有引脚，只有直流电压 0V 或 5V 两个状态。所以，决定了计算机的信息数据只能用二进制数来处理。<br>计算机处理信息的最小单位——位，就相当于二进制中的一位。位的英文 <code>bit</code> 是二进制数位<code>(binary digit)</code>的缩写。<br>8位二进制数被称为一个 <strong>字节</strong> 。字节是最基本的信息计量单位。位是最小单位，字节是基本单位。   </p><p>二进制数的值转换成十进制数的值，只需将二进制数的各数位的值和 <strong>位权</strong> 相乘，然后将相乘的结果相加即可。<br><strong>移位运算</strong> 指的是将二进制数值的各数位进行左右移位 (shift=移位) 的运算。移位有左移 &lt;&lt; (向高位方向) 和右移 &gt;&gt; (向低位方向) 两种。      </p><p>为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加1。<strong>将二进制数的值取反后加1的结果，和原来的值相加，结果为 0</strong><br>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为<strong>逻辑右移</strong>。<br>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值 (0或1) 。这就称为<strong>算术右移</strong>。如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2、1/4、1/8等的数值运算。如果是正数，只需在最高位补0即可。<br>只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式 (逻辑左移) 还是相乘运算 (算术左移) ，都只需在空出来的低位补 0 即可。   </p><p><strong>符号扩充</strong>就是指在保持值不变的前提下将其转换成16位和32位的二进制数。也就是说，不管是正数还是用补数表示的负数，都只需用符号位的值 (0或者1) 填充高位即可。     </p><p>计算机能处理的运算，大体可分为<strong>算术运算</strong>和<strong>逻辑运算</strong>。算术运算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算，包括逻辑非（NOT运算）、逻辑与（AND运算）、逻辑或（OR运算）和逻辑异或（XOR运算）四种。  </p><h3 id="计算机中进行小数计算时出错的原因"><a href="#计算机中进行小数计算时出错的原因" class="headerlink" title="计算机中进行小数计算时出错的原因"></a>计算机中进行小数计算时出错的原因</h3><p>经典面试题目: 0.1 + 0.2 = ?<br>是因为 <strong>“有一些十进制数的小数无法转换成二进制数”</strong>    </p><p><strong>双精度浮点数</strong> 类型用64位、<strong>单精度浮点数</strong> 类型用32位来表示全体小数<br><strong>浮点数</strong> 是指用符号、尾数、基数和指数这四部分来表示的小数<br>64: 1位符号，11位指数，52位尾数<br>32: 1位符号，8位指数，23位尾数</p><p>如何避免计算机计算出错  </p><blockquote><p>首先是回避策略，即无视这些错误。根据程序目的的不同，有时一些微小的偏差并不会造成什么问题。<br>把小数转换成整数来计算。计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题。</p></blockquote><p>在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD方法，以确保最终得到准确的数值。BCD (Binary Coded Decimal) 是一种使用二进制表示十进制的方法。  </p><p>在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。因此，在实际程序中，也经常会用十六进制数来代替二进制数。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><strong>内存</strong> 实际上是一种名为内存IC的电子元件。内存IC中有<code>电源</code>、<code>地址信号</code>、<code>数据信号</code>、<code>控制信号</code>等用于输入输出的大量引脚（IC的引脚），通过为其指定地址（address），来进行数据的读写。  </p><p>编程语言中的<strong>数据类型</strong>表示存储的是何种类型的数据。<br>从内存来看，就是占用的内存大小的意思。<br>即使是物理上以1个字节为单位来逐一读写数据的内存，在程序中，通过指定其类型（变量的数据类型等），也能实现以特定字节数为单位来进行读写。      </p><p><strong>指针</strong>也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写。   </p><p>数组是高效实用内存的基础。<br><strong>数组</strong>是指多个同样数据类型的数据在内存中连续排列的形式。<br>作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引<code>(index)</code>。<br>指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由<strong>编译器</strong>自动实现的。<br>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。  </p><p><strong>栈</strong>用的是<code>LIFO</code>（Last Input First Out，后入先出）方式，而队列用的则是<code>FIFO</code>（First Input First Out，先入先出）方式。<br><strong>队列</strong>一般是以<code>环状缓冲区</code>（ring buffer）的方式来实现的  </p><p>在数组的各个元素中，除了数据的值之外，通过为其附带上下一个元素的索引，即可实现<strong>链表</strong>。使用<strong>链表</strong>来追加或删除数据则毫不费事。   </p><h3 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h3><blockquote><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。即使CPU可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低。总之，存储在磁盘中的程序需要读入到内存后才能运行。</p></blockquote><p>磁盘缓存 (disk cache) 指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。使用磁盘缓存可以大大改善磁盘数据的访问速度<br>虚拟内存 (virtual memory) 是指把磁盘的一部分作为假想的内存来使用。<br>虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的。也就是说，为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。    </p><p>节约内存的编程方法<br>(1) 通过DLL文件实现函数共有<br>DLL（Dynamic Link Library）文件，顾名思义，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。此外，还有一个需要大家注意的地方，那就是多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。<br>Windows的操作系统本身也是多个DLL文件的集合体。有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。<br>(2) 通过调用_stdcall来减小程序文件的大小<br><strong>栈清理处理</strong>是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。<br>该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。<br>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。这时所使用的就是_stdcall。<br>在函数前加上_stdcall，就可以把栈清理处理变为在被调用函数一方进行。</p><p>磁盘的物理结构<br>扇区是对磁盘进行物理读写的最小单位。<br>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用1簇的空间。这样一来，所有的文件都会占用1簇的整数倍的磁盘空间。<br>以簇为单位进行读写时，1簇中没有填满的区域会保持不被使用的状态。虽然这看起来是有点浪费，不过该机制就是如此规定的，所以我们也没有什么好办法。另外，如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。由于在磁盘表面上，表示扇区区分的领域是必要的，因此，如果簇的容量过小，磁盘的整体容量也会减少。扇区和簇的大小，是由处理速度和存储容量的平衡来决定的。   </p><h3 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h3><p>RLE算法: 把文件内容用<code>数据×重复次数</code>的形式来表示的压缩方法称为RLE (Run Length Encoding，行程长度编码) 算法。<br>在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE算法可以发挥不错的效果，但它并不适合文本文件的压缩。   </p><p><strong>莫尔斯编码</strong>是根据日常文本中各字符的出现频率来决定表示各字符的编码的数据长度的。<br>使用<strong>哈夫曼树</strong>后，出现频率越高的数据所占用的数据位数就越少，而且数据的区分也可以很清晰地实现。   </p><h3 id="程序是在何种环境中运行的"><a href="#程序是在何种环境中运行的" class="headerlink" title="程序是在何种环境中运行的"></a>程序是在何种环境中运行的</h3><p>应用的运行环境，是指<code>操作系统</code>和<code>计算机本身(硬件)</code>的种类   </p><p>机器语言的程序称为<strong>本地代码</strong> (native code)<br>程序员用C语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为<strong>源代码</strong>。    </p><p>应用程序向操作系统传递指令的途径称为API (ApplicationProgramming Interface)<br>BIOS (BasicInput/Output System)。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。<br><strong>引导程序</strong>是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。   </p><h3 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h3><p>源代码完成后，就可以编译生成可执行文件了。负责实现该功能的是编译器。<br><code>Dump</code> 是指把文件的内容，每个字节用2位十六进制数来表示的方式。</p><p>能够把C语言等高级编程语言编写的源代码转换成本地代码的程序称为<strong>编译器</strong>。<br>但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p><p>编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理。<br>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行连接的程序就称为<strong>链接器</strong>（linkage editor或连结器）  </p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ilink32 -Tpe -c -x -aa c0w32.obj Sample1.obj, Sample1.exe, ,</span><br><span class="line">import32.lib cw32.lib</span><br></pre></td></tr></table></figure><p>c0w32.obj这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的<strong>启动</strong>。<br>因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来。     </p><p>像import32.lib及cw32.lib这样的文件称为库文件。<br><strong>库文件</strong>指的是把多个目标文件集成保存到一个文件中的形式。<br><strong>链接器</strong>指定<strong>库文件</strong>后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件。    </p><p><code>sprintf()</code>等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为<code>标准函数</code>。<br>之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这一过程。   </p><p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL（Dynamic Link Library）文件的特殊库文件中。<br>就如Dynamic这一名称所表示的那样，DLL文件是程序运行时动态结合的文件。  </p><p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为<strong>静态链接库</strong>。<br>静态（static=静态的）同动态（dynamic=动态的）是相反的意思。存储着<code>sprintf()</code>的目标文件的cw32lib就是静态链接库。<br><code>sprintf()</code>提供了通过指定格式把数值转换成字符串的功能。   </p><p>那就是EXE文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在EXE文件的开头，追加转换内存地址所需的必要信息。这个信息称为<strong>再配置信息</strong>。<br>EXE文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离。   </p><p>EXE文件的内容分为再配置信息、变量组和函数组<br>当程序加载到内存后，除此之外还会额外生成两个组，那就是栈和堆。<br><strong>栈</strong>是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域。<br><strong>堆</strong>是用来存储程序运行时的任意数据及对象的内存领域<br>EXE文件中并不存在栈及堆的组。栈和堆需要的内存空间是在EXE文件加载到内存后开始运行时得到分配的。<br>因而，内存中的程序，就是由<code>用于变量的内存空间</code>、<code>用于函数的内存空间</code>、<code>用于栈的内存空间</code>、<code>用于堆的内存空间</code>这4部分构成的。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。不过，在内存的使用方法上，二者存在些许不同。栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。与此相对，堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。<br><strong>栈</strong>中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。<br>与此相对，<strong>堆</strong>的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。<br>如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为<strong>内存泄露</strong>（memory leak）   </p><blockquote><p>Q：编译器和解释器有什么不同？<br>A：<strong>编译器</strong>是在运行前对所有源代码进行解释处理的。而<strong>解释器</strong>则是在运行时对源代码的内容一行一行地进行解释处理的。<br>Q：“分割编译”指的是什么？<br>A：将整个程序分为多个源代码来编写，然后分别进行编译，最后链接成一个EXE文件。这样每个源代码都相对变短，便于程序管理。<br>Q：“Build”指的是什么？<br>A：根据开发工具种类的不同，有的编译器可以通过选择“Build”菜单来生成EXE文件。这种情况下，<strong><code>Build</code>指的是连续执行编译和链接</strong>。<br>Q：使用DLL文件的好处是什么？<br>A: DLL文件中的函数可以被多个程序共用。因此，借助该功能可以节约内存和磁盘。此外，在对函数的内容进行修正时，还不需要重新链接（静态链接）使用这个函数的程序。<br>Q：不链接导入库的话就无法调用DLL文件中的函数吗？<br>A：通过使用LoadLibrary()及GetProcAddress()这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。不过使用导入库更简单一些。<br>Q：“叠加链接”这个术语指的是什么？<br>A：将不会同时执行的函数，交替加载到同一个地址中运行。通过使用“叠加链接器”这一特殊的链接器即可实现。在计算机中配置的内存容量不多的MS-DOS时代，经常使用叠加链接。</p></blockquote><p>IDE: Integrated Development Environment，即继承了变成所需的各种工具的开发软件。<br>CPU: Central Processing Unit (中央处理器)<br>IC: Integrated Circuit (集成电路)<br>DLL: Dynamic Link Library</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是《程序是怎么跑起来的》读书笔记。&lt;br&gt;在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。&lt;br&gt;下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: &lt;/p&gt;
    
    </summary>
    
    
      <category term="program" scheme="https://jambo0624.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://jambo0624.github.io/tags/program/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>CodeStandard</title>
    <link href="https://jambo0624.github.io/2020-07-19-code-standard.html"/>
    <id>https://jambo0624.github.io/2020-07-19-code-standard.html</id>
    <published>2020-07-19T03:16:16.000Z</published>
    <updated>2020-08-12T14:31:54.468Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：</p><ul><li>谨记代码是给人看的，它们只是恰巧能跑而已<a id="more"></a></li></ul><h4 id="能愿动词说明"><a href="#能愿动词说明" class="headerlink" title="能愿动词说明"></a>能愿动词说明</h4><p> 本文统一采用以下几个能愿动词作为规范的约束强度。</p><ul><li><code>必须（Must）</code>：只能这样做，请无条件遵守</li><li><code>绝不（Must Not）</code>：严令禁止，在任何情况下都不能这么做</li><li><code>应该（Should）</code>：强烈建议这样做，但是并不强求</li><li><code>不应该（Should Not）</code>：强烈建议不这样做，但是并不强求</li><li><code>可以（May）</code>：你可以按照自己的喜好去做</li></ul><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><p>下面几个词组指代四种命名风格。</p><ul><li><code>camelCase</code>：小驼峰</li><li><code>PascalCase</code>：大驼峰</li><li><code>kebab-case</code>：小写 + 中划线</li><li><code>kebab_ase</code>：小写 + 下划线</li></ul><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h3 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h3><h4 id="lang属性"><a href="#lang属性" class="headerlink" title="lang属性"></a>lang属性</h4><p>html 标签 <strong>必须</strong> 设置 lang 属性，此属性值 <strong>应该</strong> 与目标用户的第一语言保持一致。<br>当使用i18n等工具进行页面语言的切换时，此属性值也 <strong>应该</strong> 一并切换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh_CN"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="img-标签的-alt-属性"><a href="#img-标签的-alt-属性" class="headerlink" title="img 标签的 alt 属性"></a>img 标签的 alt 属性</h4><p>每一个 img 标签都 <strong>应该</strong> 有一个 alt 属性， 且它的内容 <strong>应该</strong> 尽可能详尽地描述这张图片的作用。<br>它除了能提供信息以及更好的 seo 之外，还能帮助视障人士。</p><h4 id="中文和西文之间的空格"><a href="#中文和西文之间的空格" class="headerlink" title="中文和西文之间的空格"></a>中文和西文之间的空格</h4><p>页面上的中文和西文（数字）之间 <strong>必须</strong> 有一个空格。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia是混成词，分别取自于网站核心技术Wiki以及英文中百科全书之意的encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia 是混成词，分别取自于网站核心技术 Wiki 以及英文中百科全书之意的 encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>皇后乐队是英国摇滚乐乐队，成立于 1970 年。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><h4 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h4><p><strong>必须</strong> 在所有样式文件前引入 <a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a> 用于消除各个浏览器之间的差异。<br>对于不同的项目，<strong>应该</strong> 根据需求设立 reset 样式集，并在 Normalize.css 之后引入。 Reset 样式集应该秉承最小化原则。</p><h4 id="简化版的CSS-BEM"><a href="#简化版的CSS-BEM" class="headerlink" title="简化版的CSS BEM"></a>简化版的CSS BEM</h4><p><a href="http://getbem.com/introduction/" target="_blank" rel="noopener">CSS BEM</a>是一种可以有效降低样式冲突概率的 css 选择器方法，但这种风格的代码对绝大部分项目来说是 too heavy 的。<br>这里提出一种简化的方案，只有”层级”和”断字”的概念。使用中划线 <code>-</code> 表示层级，使用下划线 <code>_</code> 表示断字。项目 <strong>必须</strong> 严格遵守该规范。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-img"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-login"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-sign_up"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>如果项目要使用 Css 预处理器， <strong>应该</strong>优先使用 Sass，且 <strong>必须</strong> 使用 Scss 语法。使用 Scss 语法对上方的 html 代码进行选择会变得非常简单易行。<br>每一个 Scss 选择器后面 <strong>必须</strong> 有一个空行。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  &amp;-logo &#123;</span><br><span class="line">    &amp;-<span class="selector-tag">img</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    &amp;-text &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &amp;-navbar &#123;</span><br><span class="line">    &amp;-item &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &amp;-login &#123;&#125;</span><br><span class="line">    &amp;-sign_up &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择器命名"><a href="#选择器命名" class="headerlink" title="选择器命名"></a>选择器命名</h4><p>选择器命名的第一要务是见名知意。</p><ul><li>对于一些常见的、约定俗成的单词简写，<strong>可以</strong> 使用简写形式。如：<code>description</code>-&gt;<code>desc</code></li><li><strong>绝不</strong> 使用简写后有多种释义，或是简写后无法辨别含义的单词简写。如：<code>description</code>-&gt;<code>des</code>,<code>fc</code></li><li>嵌套层级 <strong>不应该</strong> 过深，当出现三到四层嵌套后，可以使用全新的选择器名称。如：<code>.page-header-logo{ .title ...}</code></li></ul><h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>所有项目都 <strong>应该</strong> 使用 Babel 进行转义，而源码都 <strong>应该</strong> 拥抱已经发布的 ECMAScript 特性。</p><h4 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h4><p>所有项目都 <strong>应该</strong> 使用 ESLint 进行代码格式检查。</p><h4 id="const-let-和-var"><a href="#const-let-和-var" class="headerlink" title="const, let 和 var"></a>const, let 和 var</h4><p><code>const</code> <strong>必须</strong> 是第一公民，次之是 <code>let</code>。被 Babel (或其他转义工具)转义的项目中 <strong>绝不</strong> 出现 <code>var</code>。</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>变量命名的第一要务是见名知意。</p><ul><li>布尔型的变量 <strong>应该</strong> 以 <code>is</code> 或 <code>flag</code> 开头。如：<code>isVisible</code></li><li>数值类型的变量 <strong>必须</strong> 采用复数形式的名词。如：<code>users</code>,<code>categories</code></li><li>对于单复同行的数值型变量，<strong>应该</strong> 添加其他的单词进行辅助释义。如：<code>newsList</code></li><li>对象类型的变量 <strong>必须</strong> 采用单数形式的名词。如:<code>user</code></li><li>函数 (方法) 命名 <strong>必须</strong> 是以动词开头的 camelCase 风格。如: <code>createUser</code>, <code>validateForm</code></li><li>对于项目中约定的常量 (如配置项等)，<strong>应该</strong> 使用 PASCAL_CASE 风格。如: <code>HEADER_MENU</code>, <code>PRIMARY_COLOR</code></li><li>类( Class )的名称 <strong>必须</strong> 采用 PascalCase 形式，且 <strong>应该</strong> 拟人化。如: <code>Permission</code>, <code>FormValidator</code></li><li>任何变量的命名都 <strong>不应该</strong> 过于生僻和抽象</li></ul><h4 id="一些推荐使用的函数首部动词"><a href="#一些推荐使用的函数首部动词" class="headerlink" title="一些推荐使用的函数首部动词"></a>一些推荐使用的函数首部动词</h4><ul><li><code>do</code>/<code>deal</code>：做某些事情</li><li><code>go</code>：跳转、前往</li><li><code>get</code>/<code>fetch</code>：获取某些事物</li><li><code>set</code>：设置某些事物</li><li><code>make</code>/<code>create</code>：创建</li><li><code>edit</code>/<code>update</code>：编辑</li><li><code>delete</code>/<code>destory</code>：删除</li><li><code>handle</code>：被其他操作触发了</li></ul><h4 id="Restful-Actions"><a href="#Restful-Actions" class="headerlink" title="Restful Actions"></a>Restful Actions</h4><p>对于项目中的接口，<strong>应该</strong> 将 ajax 请求拆分为请求函数以实现复用以及提高项目的可维护性。<br>如果接口使用 Restful API，那么前端对应的方法名 <strong>可以</strong> 按照下面的规范来进行命名。</p><ul><li><code>get</code> <code>/books</code>=&gt;<code>reqFetchBooks</code></li><li><code>get</code> <code>/books/:id</code>=&gt;<code>reqShowBooks</code></li><li><code>post</code> <code>/books</code>=&gt;<code>reqCreateBooks</code></li><li><code>post,put,patch</code> <code>/books/:id</code>=&gt;<code>reqUpdateBooks</code></li><li><code>delete</code> <code>/books/:id</code>=&gt;<code>reqDestoryBooks</code></li></ul><h4 id="数组的循环"><a href="#数组的循环" class="headerlink" title="数组的循环"></a>数组的循环</h4><p>在使用循环时， <strong>不应该</strong> 使用<code>item</code>作为数组的元素名，而 <strong>应该</strong> 使用数组的单数形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">books.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; &#125;);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">books.map(<span class="function"><span class="params">book</span> =&gt;</span> &#123; &#125;);</span><br><span class="line">newsList.map(<span class="function"><span class="params">news</span> =&gt;</span> &#123; &#125;)</span><br></pre></td></tr></table></figure><h4 id="if的处理"><a href="#if的处理" class="headerlink" title="if的处理"></a>if的处理</h4><p>每一个<code>if</code>都 <strong>必须</strong> 囊括所有情况，也就是说每一种逻辑都可以被 if 处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125; <span class="keyword">else</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>部分<code>if else</code>逻辑 <strong>可以</strong> 通过及时 <code>return</code> 减少嵌套层数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// correct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (a !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br></pre></td></tr></table></figure><p>过多的<code>!a || b</code> <strong>应该</strong> 被转换为<code>!(a &amp;&amp; b)</code>，这种逻辑更符合直觉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not bad</span></span><br><span class="line"><span class="keyword">if</span> (!a || !b) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (!(a &amp;&amp; b)) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>注释本身 <strong>不应该</strong> 对变量或方法本身是做什么的进行解释。这要求变量命名尽可能得见名知意。</li></ul><h3 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h3><p><strong>NOTICE HERE</strong>： Vue 的相关规范全部基于官方的<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">风格指南</a>， 并在此基础上进行了一些修改和约束。</p><h4 id="组件文件命名"><a href="#组件文件命名" class="headerlink" title="组件文件命名"></a>组件文件命名</h4><ul><li>页面、路由相关的组件 <strong>应该</strong> 使用一个单词命名</li><li>非页面、路由相关的组件 <strong>应该</strong> 使用<code>PascalCase</code>风格命名</li><li>组件 <strong>应该</strong> 拟人化。如：<code>UserCreator</code>,<code>Selector</code></li></ul><h4 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h4><p>如果文件夹内拥有<code>index.vue</code>，那么引入时 <strong>应该</strong> 省略 index 字样， 并在末尾添加 <code>/</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/'</span></span><br></pre></td></tr></table></figure><p>引入组件时，模块名 <strong>必须</strong> 为 <code>PascalCase</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="根标签书写规范"><a href="#根标签书写规范" class="headerlink" title="根标签书写规范"></a>根标签书写规范</h4><p>vue 文件中的标签书写顺序 <strong>必须</strong> 为：</p><ol><li><code>&lt;template&gt;&lt;/template&gt;</code></li><li><code>&lt;script&gt;&lt;/script&gt;</code></li><li><code>&lt;style&gt;&lt;/style&gt;</code></li></ol><h3 id="lt-template-gt-lt-template-gt-根标签"><a href="#lt-template-gt-lt-template-gt-根标签" class="headerlink" title="&lt;template&gt;&lt;/template&gt;根标签"></a><code>&lt;template&gt;&lt;/template&gt;</code>根标签</h3><p>每一个根标签下的顶级元素都 <strong>必须</strong> 有一个与当前文件名对应的 css 选择器。在本规范中， <strong>应该</strong> 使用<code>文件名</code>的<code>kebab_case</code>结构作为该 css 选择器。如：<code>SelectorGender</code>-&gt;<code>selector_gender</code><br>如果为了进一步降低组件间的样式冲突的可能性， <strong>可以</strong> 使用 <code>文件夹层级</code> + <code>文件名</code> 共同组装成根组件的根选择器。假定有以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- common &lt;dir&gt;</span><br><span class="line">|  |-- selectors &lt;dir&gt;</span><br><span class="line">|  |  |-- SelectorGender &lt;file&gt;</span><br></pre></td></tr></table></figure><p>那么其对应的唯一 css 选择器名应该为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;common-selectors-selector_gender&quot;&gt;</span><br><span class="line">     &lt;!--    --&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-script-gt-lt-script-gt-根标签"><a href="#lt-script-gt-lt-script-gt-根标签" class="headerlink" title="&lt;script&gt;&lt;/script&gt;根标签"></a><code>&lt;script&gt;&lt;/script&gt;</code>根标签</h3><p>实例选项顺序<br>组件实例中的选项顺序 <strong>必须</strong> 按照 vue 风格指南的要求进行排版</p><ol><li><code>el</code></li><li><code>name</code></li><li><code>parent</code></li><li><code>functional</code></li><li><code>delemiters</code></li><li><code>comments</code></li><li><code>components</code></li><li><code>directives</code></li><li><code>filters</code></li><li><code>extends</code></li><li><code>mixins</code></li><li><code>inheritAttrs</code></li><li><code>model</code></li><li><code>props/prosData</code></li><li><code>data</code></li><li><code>computed</code></li><li><code>watch</code></li><li><code>beforeCreated</code></li><li><code>created</code></li><li><code>beforeMounted</code></li><li><code>mounted</code></li><li><code>beforeUpdate</code></li><li><code>updated</code></li><li><code>activated</code></li><li><code>deactivated</code></li><li><code>beforeDestory</code></li><li><code>destoryed</code></li><li><code>methods</code></li><li><code>template/render</code></li><li><code>renderError</code></li></ol><h4 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h4><p>各个选项间 <strong>必须</strong> 间隔一个空行，而内部的值或方法不空行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Demo'</span>,</span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tableData: <span class="string">''</span>,</span><br><span class="line">      userInfo: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    getTableData () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getUserInfo () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：name"><a href="#实例选项：name" class="headerlink" title="实例选项：name"></a>实例选项：<code>name</code></h4><p>每一个组件 <strong>必须</strong> 有一个 <code>name</code> 实例选项，其值 <strong>必须</strong> 为被其他组件引入时的模块名。如果你的组件命名完全符合本规范，那么一般情况下，此属性的值应与组件的文件名保持一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file name: MyComponent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// worst</span></span><br><span class="line">  <span class="comment">// no name</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'my-component'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'myComponent'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  name: <span class="string">'MyComponent'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * use this component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'../common/MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="实例选项：props"><a href="#实例选项：props" class="headerlink" title="实例选项：props"></a>实例选项：<code>props</code></h4><p>组件需要的参数，都 <strong>应该</strong> 拥有完善的验证规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    demo:&#123;</span><br><span class="line">      type: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="params">val</span> =&gt;</span> [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'first'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="string">'second'</span>].includes(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：data"><a href="#实例选项：data" class="headerlink" title="实例选项：data"></a>实例选项：<code>data</code></h4><ul><li><strong>不应该</strong> 使用 <code>Vue.set()</code> 方式为组件扩展响应式的 data</li><li><strong>应该</strong> 将一些同属于某一块页面元素的 data 合并为对象的形式，避免 data 的扁平化</li><li>每一个 data 都 <strong>必须</strong> 是被使用到的</li></ul><h4 id="实例选项-生命周期函数"><a href="#实例选项-生命周期函数" class="headerlink" title="实例选项: 生命周期函数"></a>实例选项: 生命周期函数</h4><p>生命周期函数内 <strong>不应该</strong> 直接书写过多的业务逻辑。如果逻辑过多，<strong>应该</strong> 在 methods 中定义独立的函数并在生命周期函数中进行调用。</p><h3 id="lt-style-gt-lt-style-gt-根标签"><a href="#lt-style-gt-lt-style-gt-根标签" class="headerlink" title="&lt;style&gt;&lt;/style&gt;根标签"></a><code>&lt;style&gt;&lt;/style&gt;</code>根标签</h3><ul><li><strong>必须</strong> 添加 scoped 属性</li><li><strong>必须</strong> 使用 sass 预处理器，并且使用 scss 语法</li><li>所有的组件内样式 <strong>必须</strong> 被该组件的唯一 css 选择器包裹<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"selector_gender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.selector_gender</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* ... */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="关于命名的（最佳）实践"><a href="#关于命名的（最佳）实践" class="headerlink" title="关于命名的（最佳）实践"></a>关于命名的（最佳）实践</h3><ul><li>在 Dom 上绑定的事件回调方法 <strong>应该</strong> 使用<code>on</code>+<code>动词</code>+<code>名词</code>形式。如：<code>@click=&quot;onCreateUser&quot;</code></li><li>子组件 emit 的事件名称 <strong>应该</strong> 使用 <code>动词的一般现在时</code>。如：<code>@click</code>,<code>@submit</code></li><li>子组件 emit 的事件回调方法 <strong>应该</strong> 使用<code>handle</code>+<code>名词</code>+<code>动词过去式</code>形式。如：<code>@submit=&quot;handleUserCreated&quot;</code></li><li><strong>应该</strong> 正确使用<code>or</code>和<code>and</code>。详见下方示例<br>一个完整的例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"users"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onCreateUser"</span>&gt;</span>Create User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onEditUser(scope.row)"</span>&gt;</span>Edit User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">:loading</span>=<span class="string">"isDeletingUser"</span> @<span class="attr">click</span>=<span class="string">"onDeleteUser(scope.row)"</span>&gt;</span>Delete User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">user-creator-and-editor</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ref</span>=<span class="string">"userCreatorAndEditor"</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">submit</span>=<span class="string">"handleUserCreatedOrEdited"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user-creator-and-editor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> UserCreatorAndEditor <span class="keyword">from</span> <span class="string">'./UserCreatorAndEditor'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; reqDestoryUser &#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'Users'</span>,</span></span><br><span class="line"></span><br><span class="line">    components: &#123; UserCreatorAndEditor &#125;,</span><br><span class="line"></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        isDeletingUser: <span class="literal">false</span>,</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">      onCreateUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'create'</span> &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      onEditUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'edit'</span>, userId: id &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      handleUserCreatedOrEdited(result) &#123;</span><br><span class="line">        if(result) &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line">        &#125;     </span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="keyword">async</span> onDeleteUser(&#123; id &#125;) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">await</span> reqDestoryUser(id);</span></span><br><span class="line"><span class="actionscript">           <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">finally</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">false</span></span></span><br><span class="line">        &#125;   </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>每个方法和变量都见名知意，并且永不重复！</li></ul><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><p><strong>不应该</strong> 使用路由大量传递参数,请尽可能地保证<code>clean and beautiful</code>。</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p><strong>应该</strong> 使用<code>module</code>组织 vuex，而非全部注册在顶级。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>绝不</strong> 给 Vue 挂载大体量的插件或扩展， <strong>应该</strong> 在需要用到的页面进行按需引入</li><li><strong>不应该</strong> 直接选取某个 dom 元素进行直接的 dom 操作( Echarts 等插件除外)</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>项目的技术文档 <strong>必须</strong> 使用 Markdown 格式编写。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><ul><li>英文文档 <strong>必须</strong> 使用半角标点符号</li><li>中文文档中以下标点符号 <strong>必须</strong> 使用半角，并在其后添加一个空格<ul><li>引号: <code>&quot;&quot;</code></li><li>冒号: <code>:</code></li><li>感叹号: <code>!</code></li><li>问号: <code>?</code></li><li>所有的括号: <code>() [] {}</code></li></ul></li><li>中文文档中以下标点符号 <strong>必须</strong> 使用全角，其后不需要添加空格<ul><li>逗号: <code>，</code></li><li>句号: <code>。</code></li><li>省略号: <code>……</code></li></ul></li></ul><h3 id="Markdown-语法约束"><a href="#Markdown-语法约束" class="headerlink" title="Markdown 语法约束"></a>Markdown 语法约束</h3><ul><li><strong>必须</strong> 有且仅有一个一级标题</li><li>标题的层级最多 <strong>不应该</strong> 超过三级</li><li>句子的末尾 <strong>必须</strong> 有句号</li><li>无序列表和有序列表的末尾 <strong>不应该</strong> 添加句号</li><li><strong>应该</strong> 优先选用无需列表而非有序列表</li><li>用于表明格式的关键字符 <strong>必须</strong> 前后各留一个空格</li><li>标题与段落之间 <strong>必须</strong> 前后各留一个空行</li></ul><h3 id="的，得，地"><a href="#的，得，地" class="headerlink" title="的，得，地"></a>的，得，地</h3><p><strong>必须</strong> 正确使用<code>的</code>，<code>得</code>，<code>地</code>。</p><h3 id="项目版本"><a href="#项目版本" class="headerlink" title="项目版本"></a>项目版本</h3><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>项目开发过程中的版本迭代 <strong>应该</strong> 遵循类似 npm 的版本定义方法。即:</p><ul><li><code>1.1.1</code> -&gt; <code>1.1.2</code>: 向下兼容的问题修复</li><li><code>1.1.1</code> -&gt; <code>1.2.1</code>: 向下兼容的功能迭代</li><li><code>1.1.1</code> -&gt; <code>2.1.1</code>: 发生了非向下兼容的功能迭代</li></ul><h4 id="版本迭代及分支管理"><a href="#版本迭代及分支管理" class="headerlink" title="版本迭代及分支管理"></a>版本迭代及分支管理</h4><ul><li><code>master</code>分支 <strong>必须</strong> 对应线上代码</li><li>对于开发告一段落，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><ul><li>安装依赖时 <strong>必须</strong> 按照功能严格区分生产环境依赖和开发环境依赖</li><li><strong>绝不</strong> 遗留未被使用的依赖。如果不使用某个依赖时， <strong>必须</strong> 第一时间进行卸载</li><li><strong>绝不</strong> 在未获得其他开发人员同意的情况下升级依赖版本</li><li><strong>应该</strong> 优先使用使用量大、受众面广的依赖</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="使用If"><a href="#使用If" class="headerlink" title="使用If"></a>使用If</h4><p>Windows 下的 Git 默认使用<code>crlf</code>作为换行符，甚至会将<code>lf</code>转换为<code>crlf</code>。本规范要求所有的换行都 <strong>必须</strong> 使用<code>lf</code>风格。</p><p>Q: 安装 Git 时，忘记去勾了 crlf 自动替换的选项，怎么办？<br>A: 执行以下命令:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.eol lf</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><ul><li>开发分支 <strong>必须</strong> 是<code>develop</code></li><li>功能分支 <strong>必须</strong> 以<code>feature/</code>开头。如: <code>feature/user_system</code></li><li>开发完毕，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h4 id="Merge-Request-Pull-Request"><a href="#Merge-Request-Pull-Request" class="headerlink" title="Merge Request(Pull Request)"></a>Merge Request(Pull Request)</h4><p>每一次分支合并都 <strong>必须</strong> 发起一个<code>Merge Request</code>，并且交由他人评审。</p><h3 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h3><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><ul><li><code>src</code><ul><li><code>api</code>: 存放 API 资源</li><li><code>assets</code>: 存放需要被 Webpack 处理的静态资源</li><li><code>components</code>: 存放于项目无关的公共组件。理论上这些组件可以被任何项目直接使用</li><li><code>config</code>: 存放一些项目配置文件</li><li><code>models</code>: 存放前端的数据模型。如果项目使用了 Typescript， 理论上不需要设置改目录</li><li><code>router</code>: Vue 路由</li><li><code>store</code>: Vuex。 <strong>应该</strong> 只包含<code>modules</code>和<code>index.js</code>，保证 vuex 所有功能都尽可能按照模块划分<ul><li><code>modules</code>: Vuex 的模块</li><li><code>index.js</code></li></ul></li><li><code>styles</code>: 存放全局样式。样式文件 <strong>必须</strong> 使用 Scss 进行组织; 作为子文件的样式文件 <strong>必须</strong> 使用 <code>_</code>开头<ul><li><code>_common.scss</code>: 公共样式文件</li><li><code>_hack.scss</code>: 对各种组件库或其他样式进行加强修改。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>_mixins.scss</code>: 提供全局的 Scss Mixins</li><li><code>_reset.scss</code>: 对页面样式进行重置。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>main.scss</code>: 按照一定的顺序注册全部样式文件。被<code>main.js</code>引入</li><li><code>resource.scss</code>: 被<code>scss-loader</code>处理，注册全局可用的 Scss 资源</li></ul></li><li><code>utils</code>: 各种工具<ul><li><code>http.js</code>: 请求层。<strong>必须</strong> 优先使用<code>axios</code></li></ul></li><li><code>views</code>: 视图层</li><li><code>App.vue</code></li><li><code>main.js</code>: 文件内容 <strong>必须</strong> 尽可能短小且清晰</li></ul></li><li><code>.editorconfig</code></li><li><code>.prettierignore</code></li><li><code>.prettierrc.js</code></li><li><code>.prettierrc.js</code></li><li><code>CHANGELOG.md</code>: 项目更新日志。在每一次上线前都 <strong>必须</strong> 进行补全</li><li><code>README.md</code>: 用来说明项目，以及帮助其他人快速上手项目</li></ul><h4 id="main-scss-组织"><a href="#main-scss-组织" class="headerlink" title="main.scss 组织"></a>main.scss 组织</h4><p>由于样式存在后者覆盖前者的问题，因此 main.scss <strong>必须</strong> 按照一定的顺序进行组织。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络资源 (network resources)</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">"https://fonts.googleapis.com/css?family=Nunito"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地资源 (local resources)。如: 变量，mixin，图标</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"iconfont"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式重置 (reset)。推荐优先使用 normalize.css，自己书写的 reset 文件的内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~normalize.css/normalize.css"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"reset"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方库 (libraries)</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~element-ui/packages/theme-chalk/src/index"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~swiper/css/swiper"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共样式 (common)。如果有需要的话，给公共样式加入一个前缀以作区分，如 ` g-container `</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"common"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图 (views)。对于一个 vue 项目，可能不需要引入视图内的样式</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/layout/home"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/widgets/header"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强行重置某些样式 (hack)。内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"hack"</span>;</span><br></pre></td></tr></table></figure><h4 id="Scss全局资源"><a href="#Scss全局资源" class="headerlink" title="Scss全局资源"></a>Scss全局资源</h4><blockquote><p>参考官方文档: <a href="https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项</a></p></blockquote><p>在<code>src/styles/</code>目录下创建<code>resources.scss</code>文件，用于存放全局可以使用的样式资源，如变量，mixin 等。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br></pre></td></tr></table></figure><p>在<code>vue.config.js</code>中进行了配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: <span class="string">`@import "@/styles/resources.scss";`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Editorconfig"><a href="#Editorconfig" class="headerlink" title="Editorconfig"></a>Editorconfig</h3><p>每一个项目都 <strong>必须</strong> 添加<code>Editorconfig</code>文件，并且每一个开发人员的编辑器都 <strong>必须</strong> 安装该插件。<br>下面是一份推荐使用的 editorconfig 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset = utf<span class="number">-8</span></span><br><span class="line">end_of_line = lf</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = <span class="number">2</span></span><br><span class="line">tab_width = <span class="number">2</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p>所有项目都 <strong>必须</strong> 使用<code>Prettier</code>进行代码的格式化。<br>下面是一份推荐使用的 prettier 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line">modules.export = &#123;</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: <span class="string">"*.&#123;js,ts,jsx,tsx,vue&#125;"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        singleQuote: <span class="literal">true</span>,</span><br><span class="line">        printWidth: <span class="number">100</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谨记代码是给人看的，它们只是恰巧能跑而已
    
    </summary>
    
    
      <category term="standard" scheme="https://jambo0624.github.io/categories/standard/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="standard" scheme="https://jambo0624.github.io/tags/standard/"/>
    
  </entry>
  
  <entry>
    <title>Promise 知识梳理</title>
    <link href="https://jambo0624.github.io/2020-03-08-promise.html"/>
    <id>https://jambo0624.github.io/2020-03-08-promise.html</id>
    <published>2020-03-08T08:23:41.000Z</published>
    <updated>2020-10-19T03:42:18.707Z</updated>
    
    <content type="html"><![CDATA[<p>最近会梳理一些带题目的知识点，除了让知识更系统。也让知识更具有细节，也更经得起考验。<br>今天先从 Promise 开始。</p><a id="more"></a><p>promise 知识梳理</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><code>event loop</code>它的执行顺序：  </p><blockquote><p>一开始整个脚本作为一个宏任务执行<br>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列<br>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完<br>执行浏览器<code>UI线程</code>的渲染工作<br>检查是否有<code>Web Worker</code>任务，有则执行<br>执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空 </p></blockquote><p>微任务包括：<code>MutationObserver</code>、<code>Promise.then()</code>或<code>reject()</code>、<code>Promise</code>为基础开发的其它技术，比如<code>fetch API</code>、<code>V8的垃圾回收过程</code>、Node独有的<code>process.nextTick</code><br>宏任务包括：<code>script</code> 、<code>setTimeout</code>、<code>setInterval</code> 、<code>setImmediate</code> 、<code>I/O</code>、<code>UI rendering</code>。<br>注意⚠️：在所有任务开始的时候，由于宏任务中包括了<code>script</code>，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如<code>setTimeout</code>)将被放到下一轮宏任务中来执行。  </p><h3 id="1-Promise的几道基础题"><a href="#1-Promise的几道基础题" class="headerlink" title="1. Promise的几道基础题"></a>1. Promise的几道基础题</h3><ul><li><p>题目一  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, promise1)</span><br></pre></td></tr></table></figure><p>过程分析：<br>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code><br>然后执行同步代码<code>1</code>，此时<code>promise1</code>没有被<code>resolve</code>或者<code>reject</code>，因此状态还是<code>pending</code><br>结果：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure></li><li><p>题目二  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>过程分析：<br>从上至下，先遇到<code>new Promise</code>，执行其中的同步代码<code>1</code><br>再遇到<code>resolve(&#39;success&#39;)</code>， 将<code>promise</code>的状态改为了<code>resolved</code>并且将值保存下来<br>继续执行同步代码<code>2</code><br>跳出<code>promise</code>，往下执行，碰到<code>promise.then</code>这个微任务，将其加入微任务队列<br>执行同步代码<code>4</code><br>本轮宏任务全部执行完毕，检查微任务队列，发现<code>promise.then</code>这个微任务且状态为<code>resolved</code>，执行它。<br>结果：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目三  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>过程分析<br>和题目二相似，只不过在<code>promise</code>中并没有<code>resolve</code>或者<code>reject</code><br>因此<code>promise.then</code>并不会执行，它只有在被改变了状态之后才会执行。<br>结果：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目四   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve(<span class="string">'resolve1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>,promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>,promise2)</span><br></pre></td></tr></table></figure>过程分析：<br>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code><br>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来<br>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列<br><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code><br>执行同步代码<code>1</code>， 同时打印出<code>promise1</code>的状态是<code>resolved</code><br>执行同步代码<code>2</code>，同时打印出<code>promise2</code>的状态是<code>pending</code><br>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。<br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">'resolve1'</span>&#125;</span><br><span class="line"><span class="string">'2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'resolve1'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目五  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>结果：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'success'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目六  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>是的，现在<code>start</code>就在<code>1</code>之前打印出来了，因为<code>fn</code>函数是之后执行的。<br>注意⚠️：之前我们很容易就以为看到<code>new Promise()</code>就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。<br>结果：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start"</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Promise结合setTimeout"><a href="#Promise结合setTimeout" class="headerlink" title="Promise结合setTimeout"></a>Promise结合setTimeout</h3><ul><li><p>题目一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'time'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><p>过程分析：<br>刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出<code>start</code>和<code>end</code>。<br><code>setTimout</code>作为一个宏任务被放入宏任务队列(下一个)<br><code>Promise.then</code>作为一个微任务被放入微任务队列<br>本次宏任务执行完，检查微任务，发现<code>Promise.then</code>，执行它<br>接下来进入下一个宏任务，发现<code>setTimeout</code>，执行。<br>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'end'</span></span><br><span class="line"><span class="string">'resolve'</span></span><br><span class="line"><span class="string">'time'</span></span><br></pre></td></tr></table></figure></li><li><p>题目二  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timerStart"</span>);</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timerEnd"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>过程分析：<br>和题目<code>1.2</code>很像，不过在<code>resolve</code>的外层加了一层<code>setTimeout</code>定时器。<br>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>1</code><br>然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行<br>执行同步代码<code>2</code><br>跳出<code>promise</code>函数，遇到<code>promise.then</code>，但其状态还是为<code>pending</code>，这里理解为先不执行<br>执行同步代码<code>4</code><br>一轮循环过后，进入第二次宏任务，发现延迟队列中有<code>setTimeout</code>定时器，执行它<br>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列<br>继续执行同步代码<code>timerEnd</code><br>宏任务全部执行完毕，查找微任务队列，发现<code>promise.then</code>这个微任务，执行它。<br>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="string">"timerStart"</span></span><br><span class="line"><span class="string">"timerEnd"</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure></li><li><p>题目三<br>题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么：<br>(1)  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer3'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure><p>(2)  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure><p>结果：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer3'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br></pre></td></tr></table></figure><p>这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。<br>一个是为定时器<code>timer3</code>，一个是为<code>Promise.then</code><br>但是如果是定时器<code>timer3</code>的话，它会在<code>timer2</code>后执行，而<code>Promise.then</code>却是在<code>timer2</code>之前执行。<br>你可以这样理解，<code>Promise.then</code>是微任务，它会被加入到本轮中的微任务列表，而定时器<code>timer3</code>是宏任务，它会被加入到下一轮的宏任务中。<br>理解完这两个案例，可以来看看下面一道比较难的题目了。     </p></li></ul><ul><li>题目四<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  <span class="keyword">const</span> timer2 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> timer1 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>这道题稍微的难一些，在promise中执行定时器，又在定时器中执行promise；<br>并且要注意的是，这里的Promise是直接resolve的，而之前的new Promise不一样。<br>因此过程分析为：<br>刚开始整个脚本作为第一次宏任务来执行，我们将它标记为<strong>宏1</strong>，从上至下执行<br>遇到<code>Promise.resolve().then</code>这个微任务，将<code>then</code>中的内容加入第一次的微任务队列标记为<strong>微1</strong><br>遇到定时器<code>timer1</code>，将它加入下一次宏任务的延迟列表，标记为<strong>宏2</strong>，等待执行(先不管里面是什么内容)<br>执行<strong>宏1</strong>中的同步代码<code>start</code><br>第一次宏任务(<strong>宏1</strong>)执行完毕，检查第一次的微任务队列(<strong>微1</strong>)，发现有一个<code>promise.then</code>这个微任务需要执行<br>执行打印出<strong>微1</strong>中同步代码<code>promise1</code>，然后发现定时器<code>timer2</code>，将它加入<strong>宏2</strong>的后面，标记为<strong>宏3</strong><br>第一次微任务队列(<strong>微1</strong>)执行完毕，执行第二次宏任务(<strong>宏2</strong>)，首先执行同步代码<code>timer1</code><br>然后遇到了<code>promise2</code>这个微任务，将它加入此次循环的微任务队列，标记为<strong>微2</strong><br><strong>宏2</strong>中没有同步代码可执行了，查找本次循环的微任务队列(<strong>微2</strong>)，发现了<code>promise2</code>，执行它<br>第二轮执行完毕，执行<strong>宏3</strong>，打印出<code>timer2</code><br>所以结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br></pre></td></tr></table></figure><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>从上至下，先执行第一个new Promise中的函数，碰到setTimeout将它加入下一个宏任务列表<br>跳出new Promise，碰到promise1.then这个微任务，但其状态还是为pending，这里理解为先不执行<br>promise2是一个新的状态为pending的Promise<br>执行同步代码console.log(‘promise1’)，且打印出的promise1的状态为pending<br>执行同步代码console.log(‘promise2’)，且打印出的promise2的状态为pending<br>碰到第二个定时器，将其放入下一个宏任务列表<br>第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务<br>先执行第一个定时器里的内容，将promise1的状态改为resolved且保存结果并将之前的promise1.then推入微任务队列<br>该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是promise1.then，它抛出了一个错误，且将promise2的状态设置为了rejected<br>第一个定时器执行完毕，开始执行第二个定时器中的内容<br>打印出’promise1’，且此时promise1的状态为resolved<br>打印出’promise2’，且此时promise2的状态为rejected    </p><p>完整的结果为：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line">test5.html:<span class="number">102</span> Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!! at test.html:<span class="number">102</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">"success"</span>&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;rejected&gt;: <span class="built_in">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure><ul><li>题目六<br>如果你上面这道题搞懂了之后，我们就可以来做做这道了，你应该能很快就给出答案：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timer1"</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1里的内容"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error!!!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"timer2"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1里的内容'</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line">test5.html:<span class="number">102</span> Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!! at test.html:<span class="number">102</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">"success"</span>&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;rejected&gt;: <span class="built_in">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Promise中的then、catch、finally"><a href="#Promise中的then、catch、finally" class="headerlink" title="Promise中的then、catch、finally"></a>Promise中的then、catch、finally</h3><p>总结：</p><blockquote><p>Promise的状态一经改变就不能再改变。(见3.1)<br>.then和.catch都会返回一个新的Promise。(上面的👆1.4证明了)<br>catch不管被连接到哪里，都能捕获上层的错误。(见3.2)<br>在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。<br>Promise 的 .then 或者 .catch 可以被调用多次, 当如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。(见3.5)<br>.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。(见3.6)<br>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。(见3.7)<br>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。(见3.8)<br>.then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。(见3.9)<br>.finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。  </p></blockquote><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then: "</span>, res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"then: success1"</span></span><br></pre></td></tr></table></figure>构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用 。验证了第一个结论，Promise的状态一经改变就不能再改变。</li></ul><hr><ul><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then1: "</span>, res);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then2: "</span>, res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then3: "</span>, res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"catch: "</span> <span class="string">"error"</span></span><br><span class="line"><span class="string">"then3: "</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>验证了第三个结论，catch不管被连接到哪里，都能捕获上层的错误。<br>至于then3也会被执行，那是因为catch()也会返回一个Promise，且由于这个Promise没有返回值，所以打印出来的是undefined。   </li></ul><hr><ul><li>题目三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>Promise可以链式调用，不过promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般我们任务的链式调用一样return this。<br>上面的输出结果之所以依次打印出1和2，那是因为resolve(1)之后走的是第一个then方法，并没有走catch里，所以第二个then中的res得到的实际上是第一个then的返回值。<br>且return 2会被包装成resolve(2)。  </li></ul><hr><ul><li>题目四<br>如果把3.3中的Promise.resolve(1)改为Promise.reject(1)又会怎么样呢？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>结果打印的当然是 1 和 3啦，因为reject(1)此时走的就是catch，且第二个then中的res得到的就是catch中的返回值。  </li></ul><hr><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'timer'</span></span><br><span class="line">success <span class="number">1001</span></span><br><span class="line">success <span class="number">1002</span></span><br></pre></td></tr></table></figure>当然，如果你足够快的话，也可能两个都是1001。<br>Promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。  </li></ul><hr><ul><li>题目六<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then: "</span>, res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>你可能想到的是进入.catch然后被捕获了错误。</li></ul><p>结果并不是这样的，它走的是.then里面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"then: "</span> <span class="string">"Error: error!!!"</span></span><br></pre></td></tr></table></figure><p>这也验证了第4点和第6点，返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的return new Error(‘error!!!’)也被包裹成了return Promise.resolve(new Error(‘error!!!’))。<br>当然如果你抛出一个错误的话，可以用下面👇两的任意一种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>));</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br></pre></td></tr></table></figure><ul><li>题目七<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="built_in">console</span>.err)</span><br></pre></td></tr></table></figure>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。  </li></ul><p>因此结果会报错： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure><ul><li>题目八<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="number">2</span>)</span><br><span class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>其实你只要记住原则8：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。  </li></ul><p>第一个then和第二个then中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将resolve(1) 的值直接传到最后一个then里。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>题目九<br>下面来介绍一下.then函数中的两个参数。  </li></ul><p>第一个参数是用来处理Promise成功的函数，第二个则是处理失败的函数。  </p><p>也就是说Promise.resolve(‘1’)的值会进入成功的函数，Promise.reject(‘2’)的值会进入失败的函数。<br>让我们来看看这个例子🌰：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err!!!'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'catch'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的执行结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'error'</span> <span class="string">'error!!!'</span></span><br></pre></td></tr></table></figure><p>它进入的是then()中的第二个参数里面，而如果把第二个参数去掉，就进入了catch()中：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err!!!'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'catch'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'catch'</span> <span class="string">'error!!!'</span></span><br></pre></td></tr></table></figure><p>但是有一个问题，如果是这个案例呢？  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> <span class="title">success</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail1</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fail1'</span>, err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">fail2</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fail2'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于Promise调用的是resolve()，因此.then()执行的应该是success()函数，可是success()函数抛出的是一个错误，它会被后面的catch()给捕获到，而不是被fail1函数捕获。  </p><p>因此执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fail2 <span class="built_in">Error</span>: error!!!</span><br></pre></td></tr></table></figure><ul><li>题目十<br>接着来看看.finally()，这个功能一般不太用在面试中，不过如果碰到了你也应该知道该如何处理。<br>其实你只要记住它三个很重要的知识点就可以了：  </li></ul><blockquote><p>.finally()方法不管Promise对象最后的状态如何都会执行<br>.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的<br>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。  </p></blockquote><p>来看看这个简单的例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'2'</span>)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally2'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我是finally2返回的值'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally2后面的then函数'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这两个Promise的.finally都会执行，且就算finally2返回了新的值，它后面的then()函数接收到的结果却还是’2’，因此打印结果为：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="string">'finally2'</span></span><br><span class="line"><span class="string">'finally'</span></span><br><span class="line"><span class="string">'finally2后面的then函数'</span> <span class="string">'2'</span></span><br></pre></td></tr></table></figure><p>至于为什么finally2的打印要在finally前面，请看下一个例子中的解析。  </p><p>不过在此之前让我们再来确认一下，finally中要是抛出的是一个异常是怎样的：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally1'</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'我是finally中抛出的异常'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally后面的then函数'</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获错误'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'finally1'</span></span><br><span class="line"><span class="string">'捕获错误'</span> <span class="built_in">Error</span>: 我是<span class="keyword">finally</span>中抛出的异常</span><br></pre></td></tr></table></figure><p>但是如果改为return new Error(‘我是finally中抛出的异常’)，打印出来的就是’finally后面的then函数 1’   </p><p>OK，👌，让我们来看一个比较难的例子🌰：   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve(<span class="string">'1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally1'</span>))</span><br><span class="line"></span><br><span class="line">promise2()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally2'</span>))</span><br></pre></td></tr></table></figure><p>执行过程：  </p><p>首先定义了两个函数promise1和promise2，先不管接着往下看。<br>promise1函数先被调用了，然后执行里面new Promise的同步代码打印出promise1<br>之后遇到了resolve(1)，将p的状态改为了resolved并将结果保存下来。<br>此时promise1内的函数内容已经执行完了，跳出该函数<br>碰到了promise1().then()，由于promise1的状态已经发生了改变且为resolved因此将promise1().then()这条微任务加入本轮的微任务列表(这是第一个微任务)<br>这时候要注意了，代码并不会接着往链式调用的下面走，也就是不会先将.finally加入微任务列表，那是因为.then本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管.finally()<br>再往下走碰到了promise2()函数，其中返回的new Promise中并没有同步代码需要执行，所以执行reject(‘error’)的时候将promise2函数中的Promise的状态变为了rejected<br>跳出promise2函数，遇到了promise2().then()，将其加入当前的微任务队列(这是第二个微任务)，且链式调用后面的内容得等该任务执行完后才执行，和.then()一样。<br>OK， 本轮的宏任务全部执行完了，来看看微任务列表，存在promise1().then()，执行它，打印出1，然后遇到了.finally()这个微任务将它加入微任务列表(这是第三个微任务)等待执行<br>再执行promise2().catch()打印出error，执行完后将finally2加入微任务加入微任务列表(这是第四个微任务)<br>OK， 本轮又全部执行完了，但是微任务列表还有两个新的微任务没有执行完，因此依次执行finally1和finally2。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="string">'error'</span></span><br><span class="line"><span class="string">'finally1'</span></span><br><span class="line"><span class="string">'finally2'</span></span><br></pre></td></tr></table></figure><p>在这道题中其实能拓展的东西挺多的，之前没有提到，那就是你可以理解为链式调用后面的内容需要等前一个调用执行完才会执行。<br>就像是这里的finally()会等promise1().then()执行完才会将finally()加入微任务队列，其实如果这道题中你把finally()换成是then()也是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve(<span class="string">'1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally1'</span>))</span><br><span class="line"></span><br><span class="line">promise2()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally2'</span>))</span><br></pre></td></tr></table></figure><h3 id="Promise中的all和race"><a href="#Promise中的all和race" class="headerlink" title="Promise中的all和race"></a>Promise中的all和race</h3><p>在做下面👇的题目之前，让我们先来了解一下Promise.all()和Promise.race()的用法。<br>通俗来说，.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。<br>.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</p><ul><li>题目一<br>我们知道如果直接在脚本文件中定义一个Promise，它构造函数的第一个参数是会立即执行的，就像这样：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'立即打印'</span>))</span><br></pre></td></tr></table></figure>控制台中会立即打印出 “立即打印”。</li></ul><p>因此为了控制它什么时候执行，我们可以用一个函数包裹着它，在需要它执行的时候，调用这个函数就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runP1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'立即打印'</span>))</span><br><span class="line">  <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runP1() <span class="comment">// 调用此函数时才执行</span></span><br></pre></td></tr></table></figure><p>OK 👌， 让我们回归正题。</p><p>现在来构建这么一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数传入一个值x，然后间隔一秒后打印出这个x。</p><p>如果我用.all()来执行它会怎样呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>先来想想此段代码在浏览器中会如何执行？</p><p>没错，当你打开页面的时候，在间隔一秒后，控制台会同时打印出1, 2, 3，还有一个数组[1, 2, 3]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>所以你现在能理解这句话的意思了吗：有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。<br>.all()后面的.then()里的回调函数接收的就是所有异步操作的结果。<br>而且这个结果中数组的顺序和Promise.all()接收到的数组顺序一致！！！</p><blockquote><p>有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p></blockquote><ul><li>题目二<br>我新增了一个runReject函数，它用来在1000 * x秒后reject一个错误。</li></ul><p>同时.catch()函数能够捕获到.all()里最先的那个异常，并且只执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> rej(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="built_in">console</span>.log(x)), <span class="number">1000</span> * x))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 2s后输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">Error</span>: <span class="number">2</span></span><br><span class="line"><span class="comment">// 4s后输出</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>没错，就像我之前说的，.catch是会捕获最先的那个异常，在这道题目中最先的异常就是runReject(2)的结果。<br>另外，如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。</p><p>哈哈，大家别忘了.then()方法的第二个参数也是可以捕获错误的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), </span><br><span class="line">err =&gt; <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><ul><li>题目三<br>所以使用.race()方法，它只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，不过race已经不管那些任务的结果了。</li></ul><p>来，改造一下4.1这道题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'result: '</span>, res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'result: '</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p></blockquote><ul><li>题目四<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> rej(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="built_in">console</span>.log(x)), <span class="number">1000</span> * x)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([runReject(<span class="number">0</span>), runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"result: "</span>, res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>遇到错误的话，也是一样的，在这道题中，runReject(0)最先执行完，所以进入了catch()中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="string">'Error: 0'</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>总结<br>好的，让我们来总结一下.then()和.race()吧，😄</li></ul><blockquote><p>Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。<br>.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。<br>Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。</p></blockquote><h3 id="async-await的几道题"><a href="#async-await的几道题" class="headerlink" title="async/await的几道题"></a>async/await的几道题</h3><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>答案：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>首先一进来是创建了两个函数的，我们先不看函数的创建位置，而是看它的调用位置<br>发现async1函数被调用了，然后去看看调用的内容<br>执行函数中的同步代码async1 start，之后碰到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1<br>跳出async1函数后，执行同步代码start<br>在一轮宏任务全部执行完之后，再来执行刚刚await后面的内容async1 end。</p><p>在这里，你可以理解为await后面的内容就相当于放到了Promise.then的里面。<br>让我们来看看将await转换为Promise.then的伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="comment">// 原来代码</span></span><br><span class="line">  <span class="comment">// await async2();</span></span><br><span class="line">  <span class="comment">// console.log("async1 end");</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 转换后代码</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async2"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><p>另外关于await和Promise的区别，如果我们把await async2()换成一个new Promise呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><p>此时的执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async start'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'start'</span></span><br></pre></td></tr></table></figure><p><strong>可以看到new Promise()并不会阻塞后面的同步代码async1 end的执行。</strong></p><ul><li>题目二<br>现在将async结合定时器看看。<br>给题目一中的 async2函数中加上一个定时器：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure>没错，定时器始终还是最后执行的，它被放到下一条宏任务的延迟队列中。<br>答案：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'timer'</span></span><br></pre></td></tr></table></figure></li><li>题目三<br>来吧，小伙伴们，让我们多加几个定时器看看。😁<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer3'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer3'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br></pre></td></tr></table></figure>复制代码定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是0，所以只要关注谁先被调用的。</li></ul><hr><ul><li>题目四<br>正常情况下，async中的await命令是一个Promise对象，返回该对象的结果。</li></ul><p>但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return await 1234</span></span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt end'</span>)</span><br></pre></td></tr></table></figure>这道题目比较有意思，大家要注意了。<br>在async1中await后面的Promise是没有返回值的，也就是它的状态始终是pending状态，因此相当于一直在await，await，await却始终没有响应…<br>所以在await之后的内容是不会执行的，也包括async1后面的 .then。<br>答案为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目六<br>让我们给5.5中的Promise加上resolve：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve(<span class="string">'promise1 resolve'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt end'</span>)</span><br></pre></td></tr></table></figure>现在Promise有了返回值了，因此await后面的内容将会被执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="string">'promise1 resolve'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目七<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve(<span class="string">'promise resolve'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>这道题应该也不难，不过有一点需要注意的，在async1中的new Promise它的resovle的值和async1().then()里的值是没有关系的，很多小伙伴可能看到resovle(‘promise resolve’)就会误以为是async1().then()中的返回值。<br>因此这里的执行结果为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br><span class="line"><span class="string">'sync1 end'</span></span><br><span class="line"><span class="string">'timer'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目八<br>我们再来看一道头条曾经的面试题：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'setTimeout'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目九<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testSometing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行testSometing"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"testSometing"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行testAsync"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"hello async"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test start..."</span>);</span><br><span class="line">  <span class="keyword">const</span> v1 = <span class="keyword">await</span> testSometing();</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line">  <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise start..."</span>);</span><br><span class="line">  resolve(<span class="string">"promise"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"test end..."</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'test start...'</span></span><br><span class="line"><span class="string">'执行testSometing'</span></span><br><span class="line"><span class="string">'promise start...'</span></span><br><span class="line"><span class="string">'test end...'</span></span><br><span class="line"><span class="string">'testSometing'</span></span><br><span class="line"><span class="string">'执行testAsync'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'hello async'</span></span><br><span class="line"><span class="string">'testSometing'</span> <span class="string">'hello async'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="async处理错误"><a href="#async处理错误" class="headerlink" title="async处理错误"></a>async处理错误</h3><ul><li>题目一<br>在async中，如果 await后面的内容是一个异常或者错误的话，会怎样呢？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>例如这道题中，await后面跟着的是一个状态为rejected的promise。</li></ul><p><strong>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</strong></p><p>所以答案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async2'</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) error</span><br></pre></td></tr></table></figure><p>如果改为throw new Error也是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1'</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!!</span><br></pre></td></tr></table></figure><ul><li>题目二<br>如果想要使得错误的地方不影响async函数后续的执行的话，可以使用try catch<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error!!!'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'async1 success'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br></pre></td></tr></table></figure>这里的结果为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'error!!!'</span></span><br><span class="line"><span class="string">'async1'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br></pre></td></tr></table></figure>或者你可以直接在Promise.reject后面跟着一个catch()方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// try &#123;</span></span><br><span class="line">  <span class="comment">//   await Promise.reject('error!!!')</span></span><br><span class="line">  <span class="comment">// &#125; catch(e) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(e)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error!!!'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'async1 success'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br></pre></td></tr></table></figure>运行结果是一样的</li></ul><h3 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h3><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">          resolve(<span class="number">6</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(p)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">  p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(arg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在4之前，所以可以来看看first函数里面的内容了。(这一步有点类似于题目1.5)<br>函数first返回的是一个new Promise()，因此先执行里面的同步代码3<br>接着又遇到了一个new Promise()，直接执行里面的同步代码7<br>执行完7之后，在p中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走<br>碰到了resolve(1)，这里就把p的状态改为了resolved，且返回值为1，不过这里也先不执行<br>跳出p，碰到了resolve(2)，这里的resolve(2)，表示的是把first函数返回的那个Promise的状态改了，也先不管它。<br>然后碰到了p.then，将它加入本次循环的微任务列表，等待执行<br>跳出first函数，遇到了first().then()，将它加入本次循环的微任务列表(p.then的后面执行)<br>然后执行同步代码4<br>本轮的同步代码全部执行完毕，查找微任务列表，发现p.then和first().then()，依次执行，打印出1和2<br>本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码5<br>然后又遇到了一个resolve(6)，它是放在p里的，但是p的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说resolve(6)相当于没任何用处，因此打印出来的p为<code>Promise{&lt;resolved&gt;: 1}</code>。(这一步类似于题目3.1)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async1 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="number">2</span>)</span><br><span class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">.catch(<span class="number">4</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>注意的知识点：</li></ul><p>async函数中await的new Promise要是没有返回值的话则不执行后面的内容(类似题5.5)<br>.then函数中的参数期待的是函数，如果不是函数的话会发生透传(类似题3.8 )<br>注意定时器的延迟时间<br>因此本题答案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br></pre></td></tr></table></figure><ul><li>题目三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'resolve3'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  resolve(<span class="string">'resovle1'</span>);</span><br><span class="line">  resolve(<span class="string">'resolve2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p1)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>注意的知识点：</li></ul><p>Promise的状态一旦改变就无法改变(类似题目3.5)<br>finally不管Promise的状态是resolved还是rejected都会执行，且它的回调函数是接收不到Promise的结果的，所以finally()中的res是一个迷惑项(类似3.10)。<br>最后一个定时器打印出的p1其实是.finally的返回值，我们知道.finally的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值(3.10中也有提到), 而这道题中.finally上一个Promise是.then()，但是这个.then()并没有返回值，所以p1打印出来的Promise的值会是undefined，如果你在定时器的下面加上一个return 1，则值就会变成1(感谢掘友JS丛中过的指出)。</p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'resolve1'</span></span><br><span class="line"><span class="string">'finally'</span> <span class="literal">undefined</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="literal">undefined</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="几道大厂的面试题"><a href="#几道大厂的面试题" class="headerlink" title="几道大厂的面试题"></a>几道大厂的面试题</h3><ul><li>使用Promise实现每隔1秒输出1<br>这道题比较简单的一种做法是可以用Promise配合着reduce不停的在promise后面叠加.then，请看下面的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">p, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(<span class="built_in">console</span>.log(x)), <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure>或者你可以更简单一点写：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">p, x</span>) =&gt;</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(<span class="built_in">console</span>.log(x)), <span class="number">1000</span>))), <span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></li></ul><ul><li>使用Promise实现红绿灯交替重复亮</li></ul><p>红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"red"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"green"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"yellow"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> light = <span class="function"><span class="keyword">function</span> (<span class="params">timer, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      cb()</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> step = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">3000</span>, red)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">2000</span>, green)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">1000</span>, yellow)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> step()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step();</span><br></pre></td></tr></table></figure><ul><li>实现mergePromise函数<br>实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="function">(<span class="params">timer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里写代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"done"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>这道题有点类似于Promise.all()，不过.all()不需要管执行顺序，只需要并发执行就行了。但是这里需要等上一个执行完毕之后才能执行下一个。<br>解题思路：</li></ul><p>定义一个数组data用于保存所有异步操作的结果<br>初始化一个const promise = Promise.resolve()，然后循环遍历数组，在promise后面添加执行ajax任务，同时要将添加的结果重新赋值到promise上。</p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span> (<span class="params">ajaxArray</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放每个ajax的结果</span></span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  ajaxArray.forEach(<span class="function"><span class="params">ajax</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次的then为了用来调用ajax</span></span><br><span class="line">    <span class="comment">// 第二次的then是为了获取ajax的结果</span></span><br><span class="line">    promise = promise.then(ajax).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      data.push(res);</span><br><span class="line">      <span class="keyword">return</span> data; <span class="comment">// 把每次的结果返回</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最后得到的promise它的值就是data</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据promiseA+实现一个自己的promise<br><a href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b#heading-7" target="_blank" rel="noopener">Promise不会？？看这里！！！史上最通俗易懂的Promise</a><br><a href="https://zhuanlan.zhihu.com/p/23312442" target="_blank" rel="noopener">写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近会梳理一些带题目的知识点，除了让知识更系统。也让知识更具有细节，也更经得起考验。&lt;br&gt;今天先从 Promise 开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="login" scheme="https://jambo0624.github.io/tags/login/"/>
    
      <category term="CDN" scheme="https://jambo0624.github.io/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>Vue 登录业务及上线注意事项</title>
    <link href="https://jambo0624.github.io/2020-02-25-management.html"/>
    <id>https://jambo0624.github.io/2020-02-25-management.html</id>
    <published>2020-02-25T08:23:41.000Z</published>
    <updated>2020-10-17T08:17:27.171Z</updated>
    
    <content type="html"><![CDATA[<p>前些天读完几本书之后，现在准备整理一下去年工作的一些收获。<br>尤其是将其中一些自己没有参与，但是还比较关键的环节进行梳理。希望能有进一步的感想。<br>下面开始</p><a id="more"></a><h2 id="登录退出功能"><a href="#登录退出功能" class="headerlink" title="登录退出功能"></a>登录退出功能</h2><ul><li>登录业务的相关技术点</li></ul><ol><li>http是无状态的</li><li>通过cookie在客户端记录状态</li><li>通过session在服务端记录状态</li><li>通过token方式维持状态<br>如果前后端是存在跨域问题，那么推荐使用token方式。反之，就用cookie和session方式。</li></ol><p><img src="https://s1.ax1x.com/2020/05/18/YWh1pT.png" alt="token" title="token原理"></p><ul><li><p>登录按钮所对应方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">login() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$refs.loginFormRef.validate(<span class="keyword">async</span> validate =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validate) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: result &#125; = <span class="keyword">this</span>.$http.post(<span class="string">'login'</span>, <span class="keyword">this</span>.loginForm)</span><br><span class="line">    <span class="keyword">if</span> (result.data.meta !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'登录失败'</span>)</span><br><span class="line">    <span class="keyword">this</span>.$message.success(<span class="string">'登录成功'</span>)</span><br><span class="line">     <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">'token'</span>, result.data.token)</span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/home'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是仅网页打开期间需要，不用永久化存储，所以用sessionStorage。而不用localStorage</p></li><li><p>路由守卫控制访问权限</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为路由对象添加路由守卫</span></span><br><span class="line">router.beforeEach(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 如果访问的是login页面，直接放行</span></span><br><span class="line">  <span class="keyword">if</span>( to.path === <span class="string">'/login'</span> ) <span class="keyword">return</span> next()</span><br><span class="line">  <span class="comment">// 从sessionStorage获取token</span></span><br><span class="line">  <span class="keyword">const</span> tokenStr = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">  <span class="comment">// 如果没有token，强制跳转到login页面</span></span><br><span class="line">  <span class="keyword">if</span>( !tokenStr ) <span class="keyword">return</span> next(<span class="string">'/login'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>退出功能实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.clear()</span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="主页内容"><a href="#主页内容" class="headerlink" title="主页内容"></a>主页内容</h2><ul><li>发送请求的权限获取<br>因为是后台管理系统，所以除了login页面外，发送请求都需要Authorization<br>我们采取的是axios拦截器的方法<br>意思就是请求发起之前，在请求头中添加Authorization字段，并且将之设置为token<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">  request.headers.Authorization = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><ul><li><p>二级菜单点击可跳转，是因为el-menu设置了router</p></li><li><p>element-ui和vue中的插槽</p><blockquote><p>个人理解的就是，如果某个元素内部还要依据自己的数据，进行下一步的处理。那么可以在内部使用插槽获取上级元素数据。比如dialog组件等</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">  &#123;&#123;scope.row&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>表单预验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.addFormRef.validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!valid) <span class="keyword">return</span> </span><br><span class="line">  <span class="comment">// 说明通过验证了，下一步发起请求</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>权限管理部分-分配权限功能<br>首先是点击分配权限按钮，获取所有被选中的三级标签。采用递归的方法，具体实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getLeafKeys(node, arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.children) &#123;</span><br><span class="line">    arr.push(node.id)</span><br><span class="line">  &#125;</span><br><span class="line">  node.children.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getLeafKeys(item, arr)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>其次是提交时，获取所有选中和半选中的标签。调用element-ui提供的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = [...this.$refs.treeRef.getCheckedKeys(),...this.$refs.treeRef.getHalfCheckedKeys()]</span><br></pre></td></tr></table></figure><h2 id="商品管理"><a href="#商品管理" class="headerlink" title="商品管理"></a>商品管理</h2><ul><li><p>分类参数-标签管理<br>参数管理页面在添加tags时，当tags变成input之后，input自动获取焦点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showInput(row) &#123;</span><br><span class="line">  row.inputVisible = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// $nextTick当页面上元素被重新渲染之后，才会指定回调函数中的代码</span></span><br><span class="line">    <span class="comment">// 👆注释的意思就是说等tags变成input之后再获取焦点，保证不出bug</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$refs.saveTagInput.$refs.input.focus()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>商品列表-添加时间<br>在main.js里面添加一个filter。主要解决的是时间格式的问题。具体来说是后台返回的是毫秒数，我们需要对应格式的时间。实现方式如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dateFormat'</span>,(originVal)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(originVal)</span><br><span class="line">  <span class="keyword">const</span> y = dt.getFullYear()</span><br><span class="line">  <span class="keyword">const</span> m = (dt.getMonth()+<span class="number">1</span>+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> d = (dt.getDate() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> hh = (dt.getHours() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> mm = (dt.getMinutes() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> ss = (dt.getSeconds() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//String.prototype.padStart()</span></span><br><span class="line">str.padStart(targetLength [, padString])  <span class="comment">//语法</span></span><br><span class="line"><span class="comment">//例子如下</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>);         <span class="comment">// "       abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">"foo"</span>);  <span class="comment">// "foofoofabc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">6</span>,<span class="string">"123465"</span>); <span class="comment">// "123abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">8</span>, <span class="string">"0"</span>);     <span class="comment">// "00000abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">1</span>);          <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure></li></ul><p>使用方法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"创建时间"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span>&#123;&#123;scope.row.add_time | dateFormat&#125;&#125;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在数组中，找到指定index的元素，并返回index<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleRemove(file) &#123;</span><br><span class="line">  <span class="comment">// console.log(file)</span></span><br><span class="line">  <span class="comment">// 获取将要删除的图片的临时路径</span></span><br><span class="line">  <span class="keyword">const</span> filePath = file.response.data.tmp_path</span><br><span class="line">  <span class="comment">// 从pics数组中，找到这个图片对应的索引值</span></span><br><span class="line">  <span class="keyword">const</span> i = <span class="keyword">this</span>.addForm.pics.findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x.pic === filePath)</span><br><span class="line">  <span class="comment">// 调用splice方法，把图片移除</span></span><br><span class="line">  <span class="keyword">this</span>.addForm.pics.splice(i, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// console.log(this.addForm.pics)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="项目优化上线"><a href="#项目优化上线" class="headerlink" title="项目优化上线"></a>项目优化上线</h2><p>项目优化策略</p><h4 id="1-生成打包报告–命令行和图形界面"><a href="#1-生成打包报告–命令行和图形界面" class="headerlink" title="1. 生成打包报告–命令行和图形界面"></a>1. 生成打包报告–命令行和图形界面</h4><h4 id="2-第三方库开启-CDN"><a href="#2-第三方库开启-CDN" class="headerlink" title="2. 第三方库开启 CDN"></a>2. 第三方库开启 CDN</h4><ul><li><p>通过修改<code>vue.config.js</code>来修改webpack的配置<br>vue-cli3.0 默认隐藏了所有webpack的配置项，目的是为了屏蔽项目的配置过程，让具体功能和业务逻辑的实现称为中心</p></li><li><p>为开发模式与发布模式指定不同的打包入口  通过externals加载外部CDN资源  首页内容定制</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 发布模式</span></span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'production'</span>,config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-prod.js'</span>)</span><br><span class="line">      config.set(<span class="string">'externals'</span>,&#123;</span><br><span class="line">        vue: <span class="string">'Vue'</span>,</span><br><span class="line">        <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">        axios: <span class="string">'axios'</span>,</span><br><span class="line">        echarts: <span class="string">'echarts'</span>,</span><br><span class="line">        nprogress: <span class="string">'NProgress'</span>,</span><br><span class="line">        <span class="string">'vue-quill-editor'</span>: <span class="string">'VueQuillEditor'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">        args[<span class="number">0</span>].isProd = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开发模式</span></span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'development'</span>,config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main.js'</span>)</span><br><span class="line">      config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">        args[<span class="number">0</span>].isProd = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-通过CDN优化element-ui的打包"><a href="#3-通过CDN优化element-ui的打包" class="headerlink" title="3. 通过CDN优化element-ui的打包"></a>3. 通过CDN优化element-ui的打包</h4><p>注释掉elemen-ui的引入，然后在<code>index.html</code>头部引入element-ui的js和css文件</p><h4 id="4-路由懒加载"><a href="#4-路由懒加载" class="headerlink" title="4. 路由懒加载"></a>4. 路由懒加载</h4><p>安装<code>bebel/plugin-syntax-dynamic-import</code><br>在<code>babel.config.js</code>中声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "index" */</span> <span class="string">'../components/Login.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "index" */</span> <span class="string">'../components/Home.vue'</span>)</span><br></pre></td></tr></table></figure><h4 id="5-一些小点"><a href="#5-一些小点" class="headerlink" title="5. 一些小点"></a>5. 一些小点</h4><ul><li><p>添加NProcess<br>这个插件的作用就是在页面顶部添加一个加载的进度条。在请求开始时出现，得到相应后结束<br>具体实现如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use( <span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">  NProcess.start()</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;)</span><br><span class="line">axios.interceptors.response.use( <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  NProcess.done()</span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>build之后去除console<br>解决方法就是添加<code>babel-plugin-transform-remove-console</code></p></li></ul><h2 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h2><p>开启gzip配置，配置https服务，使用pm2管理应用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天读完几本书之后，现在准备整理一下去年工作的一些收获。&lt;br&gt;尤其是将其中一些自己没有参与，但是还比较关键的环节进行梳理。希望能有进一步的感想。&lt;br&gt;下面开始&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="login" scheme="https://jambo0624.github.io/tags/login/"/>
    
      <category term="CDN" scheme="https://jambo0624.github.io/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (下卷)--ES6+》</title>
    <link href="https://jambo0624.github.io/2020-02-16-dont-know-js-last2.html"/>
    <id>https://jambo0624.github.io/2020-02-16-dont-know-js-last2.html</id>
    <published>2020-02-16T05:14:16.000Z</published>
    <updated>2020-10-16T13:38:42.528Z</updated>
    
    <content type="html"><![CDATA[<p>近期的生活，是一种非常规的模式。<br>自己一方面期待着什么时候能自由地活动；另一方面也想着成年以来，第一次能有这么长时间陪着父母，挺好。<br>今天我们继续将《你不知道的js (下卷)》读完，下面开始。</p><a id="more"></a><h2 id="ES？现在与未来"><a href="#ES？现在与未来" class="headerlink" title="ES？现在与未来"></a>ES？现在与未来</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>2009年，ES5正式发布<br>2015年，ES6发布</p><p>有人建议未来的版本应该改成基于年份，比如ES2016（也就是ES7）来标示在2016年结束之前敲定的任何版本的规范。<br>尽管有异议，但比起后来提出的方案ES2015，很可能保持统治地位的版本命名仍是ES6。<br>而ES2016可能会采用新的基于年份的命名方案。</p><h3 id="transpiling"><a href="#transpiling" class="headerlink" title="transpiling"></a>transpiling</h3><p>简单地说，其思路是利用专门的工具把你的ES6代码转化为等价（或近似！）的可以在ES5环境下工作的代码。</p><h2 id="新语法"><a href="#新语法" class="headerlink" title="新语法"></a>新语法</h2><h3 id="块作用域声明"><a href="#块作用域声明" class="headerlink" title="块作用域声明"></a>块作用域声明</h3><p><a href="https://jambo0624.github.io/2019-11-09-const-let-var.html">let, const声明</a>，我在之前的文章做了比较。<br>这里就不再记录了。</p><h3 id="spread-rest"><a href="#spread-rest" class="headerlink" title="spread/rest"></a>spread/rest</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>这种用法最好的一点是，它为弃用很久的arguments数组 —— 实际上它并不是真正的数组，而是类似数组的对象——提供了一个非常可靠的替代形式。<br>因为args是一个真正的数组，前ES6中有很多技巧用来把arguments转变为某种我们可以当作数组来使用的东西，现在我们可以摆脱这些愚蠢的技巧了。<br>考虑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照新的 ES6 的行为方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// args 已经是一个真正的数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 丢弃 args 中第一个元素</span></span><br><span class="line">  args.shift()  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把整个 args 作为参数传给 console.log()</span></span><br><span class="line">  <span class="built_in">console</span>.log( ...args )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照前 ES6 的老派行为方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把 arguments 转换为一个真正的数组</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在尾端添加几个元素</span></span><br><span class="line">  args.push(<span class="number">4</span>, <span class="number">5</span>)  </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 过滤掉奇数</span></span><br><span class="line">  args = args.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  &#125;) </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 把整个 args 作为参数传给 foo()</span></span><br><span class="line">  foo.apply(<span class="literal">null</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">11</span>, y=<span class="number">31</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x+y)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 42</span></span><br><span class="line">foo(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 11</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="number">42</span>) <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 36</span></span><br><span class="line">foo(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 36 &lt;-- 丢了undefined</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="number">42</span>) <span class="comment">// 5 &lt;-- null被强制转换为 0</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 17 &lt;--  丢了undefined</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="number">42</span>) <span class="comment">// 6 &lt;-- null被强制转换为 0</span></span><br></pre></td></tr></table></figure><p>函数默认值可以不只是像31这样的简单值；它们可以是任意合法表达式，甚至是函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar called! '</span>)</span><br><span class="line">  <span class="keyword">return</span> y + val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=y+<span class="number">3</span>, z=bar(x</span>)) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">5</span></span><br><span class="line">foo() <span class="comment">// 'bar called' // 8 13</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>) <span class="comment">// 'bar called' // 10 15</span></span><br><span class="line"></span><br><span class="line">y=<span class="number">6</span></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="number">10</span>) <span class="comment">// 9 10</span></span><br></pre></td></tr></table></figure><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>可以把将数组或者对象属性中带索引的值手动赋值看作结构化赋值。<br>ES6为解构新增了一个专门语法，专用于<strong>数组解构</strong>和<strong>对象解构</strong>。<br>这个语法消除了前面代码中对临时变量tmp的需求，使代码简洁很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c] = foo()</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y, <span class="attr">z</span>: z &#125; = bar()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) <span class="comment">// 4 5 6</span></span><br></pre></td></tr></table></figure><p><strong>对象属性赋值模式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了 source: target</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: bam, <span class="attr">y</span>: baz, <span class="attr">z</span>: bap &#125; = bar()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bam, baz, bap) <span class="comment">// 4 5 6</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>这里的语法模式是<code>souce: target</code>（或者说是value:variable-alias)。<br>x: bam表示x属性是源值，而bam是要赋值的目标变量。<br>换句话说，对象字面值是target &lt;–source，而对象解构赋值是source –&gt; target。</p><p><strong>不只是声明</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>, y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// 20 10</span></span><br></pre></td></tr></table></figure><p><strong>重复赋值</strong><br>对象解构形式允许多次列出同一个源属性（持有值类型任意）。举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: X, <span class="attr">a</span>: Y &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">X  <span class="comment">// 1</span></span><br><span class="line">Y  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这也意味着可以解构子对象/数组属性，同时捕获子对象/类的值本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: &#123; <span class="attr">x</span>: X, <span class="attr">x</span>: Y&#125;, a &#125; = &#123; <span class="attr">a</span>: &#123; <span class="attr">x</span>: <span class="number">1</span> &#125; &#125;</span><br><span class="line">X <span class="comment">// 1</span></span><br><span class="line">Y <span class="comment">// 1</span></span><br><span class="line">a <span class="comment">// &#123; x: 1 &#125;</span></span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">a</span>: X, <span class="attr">a</span>: Y, <span class="attr">a</span>: [ Z ] &#125; = &#123; <span class="attr">a</span>: [<span class="number">1</span>] &#125;)</span><br><span class="line"></span><br><span class="line">x.push(<span class="number">2</span>)</span><br><span class="line">Y[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">X <span class="comment">// [10, 2]</span></span><br><span class="line">Y <span class="comment">// [10, 2]</span></span><br><span class="line">Z <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>记住：解构的目的不只是为了打字更少，而是为了可读性更强。</p><h3 id="太多，太少，刚刚好"><a href="#太多，太少，刚刚好" class="headerlink" title="太多，太少，刚刚好"></a>太多，太少，刚刚好</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> [b, ...c] = a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b, c) <span class="comment">// 2 [3, 4]</span></span><br></pre></td></tr></table></figure><p><strong>默认值赋值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; x, y, z, <span class="attr">w</span>: WW =<span class="number">20</span>&#125; = bar()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z, w) <span class="comment">// 4 5 6 20</span></span><br></pre></td></tr></table></figure><p><strong>嵌套解构</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">x</span>: &#123; <span class="attr">y</span>: &#123;<span class="attr">z</span> :<span class="number">6</span>&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, [b, c, d], e] = a1</span><br><span class="line"><span class="keyword">var</span> [x: &#123;<span class="attr">y</span>:&#123;<span class="attr">z</span>:w&#125;&#125;] = o1</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d, e) <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">console</span>.log(w) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><strong>解构参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line">foo([<span class="number">1</span>,<span class="number">2</span>]) <span class="comment">// 1 2</span></span><br><span class="line">foo([<span class="number">1</span>]) <span class="comment">// 1 undefined</span></span><br><span class="line">foo() <span class="comment">// undefined undefined</span></span><br></pre></td></tr></table></figure><h3 id="对象字面量扩展"><a href="#对象字面量扩展" class="headerlink" title="对象字面量扩展"></a>对象字面量扩展</h3><p><strong>简洁属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">x:x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line">&#123;x&#125;</span><br></pre></td></tr></table></figure><p><strong>简洁方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  x: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line">&#123;</span><br><span class="line">  x()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">'hello '</span> + name + <span class="string">'! '</span></span><br><span class="line"><span class="comment">//新的方式可以写为</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">`hello <span class="subst">$&#123;name&#125;</span>! `</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>虽然不是一条严格的规律，但我认为=&gt;箭头函数转变带来的可读性提升与被转化函数的长度负相关。<br>这个函数越长，=&gt;带来的好处就越小；函数越短，=&gt;带来的好处就越大。<br>我认为更合理的做法是只在确实需要简短的在线函数表达式的时候才采用=&gt;，而对于那些一般长度的函数则无需改变。</p><p><strong>不只是更短的语法，而是this</strong><br>实际上，=&gt;箭头函数的主要设计目的就是以特定的方式改变this的行为特性，解决this相关编码的一个特殊而又常见的痛点。</p><h3 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for..of循环"></a>for..of循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> idx <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(idx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> val <span class="keyword">of</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a' 'b' 'c'</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h3 id="数字字面量扩展"><a href="#数字字面量扩展" class="headerlink" title="数字字面量扩展"></a>数字字面量扩展</h3><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>下面是创建symbol的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'some optional description'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> sym <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure><p>以下几点需要注意。</p><ul><li>不能也不应该对Symbol(..)使用new。它并不是一个构造器，也不会创建一个对象。</li><li>传给Symbol(..)的参数是可选的。如果传入了的话，应该是一个为这个symbol的用途给出用户友好描述的字符串。</li><li>typeof的输出是一个新的值(“symbol”)，这是识别symbol的首选方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期的生活，是一种非常规的模式。&lt;br&gt;自己一方面期待着什么时候能自由地活动；另一方面也想着成年以来，第一次能有这么长时间陪着父母，挺好。&lt;br&gt;今天我们继续将《你不知道的js (下卷)》读完，下面开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (下卷)》</title>
    <link href="https://jambo0624.github.io/2020-02-04-dont-know-js-last.html"/>
    <id>https://jambo0624.github.io/2020-02-04-dont-know-js-last.html</id>
    <published>2020-02-04T00:03:09.000Z</published>
    <updated>2020-10-16T11:10:27.827Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点流年不利，不论是大环境还是个人的境遇。<br>好的方面是又可以静下心来，读书，学习新的东西。要一直保持积极乐观的心态啊！<br>今天我们继续读《你不知道的js》的最后一卷。开始吧。</p><a id="more"></a><h2 id="深入编程"><a href="#深入编程" class="headerlink" title="深入编程"></a>深入编程</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>程序常被称为源码或代码，它是一组特定的指令，用来指示计算机要执行哪些任务。</p><p>指令的格式和组合规则被称为计算机语言，有时也被称为语法，这非常类似于英语中告诉你如何拼写单词以及如何使用单词和标点符号来构造有效的句子。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>语句由一个或多个表达式组成。<br>一个表达式是对一个变量或值的引用，或者是一组值和变量与运算符的组合。<br>举例来说，a = b ＊ 2；这个语句中有四个表达式。</p><ul><li>2是一个<strong>字面值表达式</strong>。</li><li>b是一个<strong>变量表达式</strong>，表示获取它的当前值。</li><li>b ＊ 2是一个<strong>算术表达式</strong>，表示进行乘法运算。</li><li>a = b ＊ 2是一个<strong>赋值表达式</strong>，意思是将表达式b ＊ 2的结果赋值给变量a。</li></ul><p>程序需要被执行，我们也将这一过程称为<strong>运行程序</strong>。</p><p>a = b ＊ 2这样的语句便于开发者读写，但实际上计算机并不能直接理解这种形式。<br>因此，需要通过计算机上一个专门的工具（解释器或编译器）将你编写的代码翻译成计算机可以理解的命令。</p><p>对某些计算机语言来说，在程序被执行时，对命令的翻译通常是自上而下逐行执行的，这通常被称为<strong>代码解释</strong>。</p><p>对另外一些语言来说，这种翻译是预先进行的，被称为<strong>代码编译</strong>，这样一来，当执行程序时，实际上运行的是已经编译好的、可以执行的计算机指令。</p><p>基本上可以说JavaScript是<strong>解释型</strong>的，因为每次执行JavaScript源码时都需要进行处理。<br>但这么说并不完全精确。JavaScript引擎实际上是<strong>动态编译程序</strong>，然后立即执行编译后的代码。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>学习编程的最好方法就是编写代码！</strong></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>赋值=，如a = 2就表示将值2保存在变量a中。</li><li>算术+（加）、-（减）、＊（乘）、/（除），如a ＊ 3。</li><li>复合赋值+=、-=、＊=和/=是复合运算符，可以将算术运算符与赋值组合起来，比如，a += 2等同于a = a + 2。</li><li>递增/递减++表示递增，–表示递减，比如a++就类似于a = a + 1。</li><li>对象属性访问如console.log()中的.。</li><li>相等==（粗略相等）、===（严格相等）、! =（粗略不等）和！==（严格不等），如a == b</li><li>比较&lt;（小于）、&gt;（大于）、&lt;=（小于或粗略等于）和&gt;=（大于或粗略等于），如a &lt;= b</li><li>逻辑&amp;&amp;（与）和||（或），如a || b就表示a或者b</li></ul><h3 id="值与类型"><a href="#值与类型" class="headerlink" title="值与类型"></a>值与类型</h3><p>在编程术语中，对<strong>值</strong>的不同表示方法称为<strong>类型</strong></p><h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>有关如何编写注释良好的代码有很多种观点；我们确实无法定义绝对的普遍标准。但是以下这些观察结论和指导原则是很有用的。</p><ul><li>没有注释的代码不是最优的。</li><li>过多注释（比如每行一个）可能是拙劣代码的征兆。</li><li>代码应该解释为什么，而非是什么。如果编写的代码特别容易令人迷惑的话，那么注释也可以解释一下实现原理。</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在程序中实现这一点的最简单方法是将值赋给一个符号容器，这个符号容器称为变量，使用这个名字是因为这个容器中的值是可以变化的。</p><p>在某些编程语言中，你需要声明一个变量（容器）用于存放指定类型的值（如数字或字符串）。通过避免不想要的值转换，人们认为这种<strong>静态类型</strong>（也称为类型强制）提高了程序的正确性。</p><p>其他语言强调的是值的类型而不是变量的类型。<strong>弱类型</strong>（也称为动态类型）允许一个变量在任意时刻存放任意类型的值。这种方式允许一个变量在程序的逻辑流中的任意时刻代表任意类型的值，人们认为这样可以提高程序的灵活性。</p><p>JavaScript采用了后一种机制——动态类型，这也就是说，变量可以持有任意类型值而不存在类型强制。</p><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>我们常常需要将在代码中的一系列语句组织到一起，这些语句通常被称为块。<br>在JavaScript中，使用一对大括号{ .. }在一个或多个语句外来表示块。</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>程序中有很多种方法可以用于表示条件判断（也就是决策）。<br>最常用的是if语句。本质上就是在表达“如果这个条件是真的，那么进行后续这些……”。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>重复一系列动作，直到不满足某个条件，换句话说，重复只发生在满足条件的情况下，这就是程序循环的工作。</p><p>循环包括测试条件以及一个块（通常就是{ .. }）。循环块的每次执行被称为一个<strong>迭代</strong>。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>程序也几乎总是需要将代码的任务分割成可复用的片段，而不是一直重复编码。<br>实现这一点的方法就是定义一个函数。</p><h2 id="深入-JavaScript"><a href="#深入-JavaScript" class="headerlink" title="深入 JavaScript"></a>深入 JavaScript</h2><h3 id="值与类型-1"><a href="#值与类型-1" class="headerlink" title="值与类型"></a>值与类型</h3><p><strong>对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'hello world'</span>,</span><br><span class="line">  b: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">obj[b] <span class="comment">// 'hello world</span></span><br><span class="line">obj[<span class="string">'b'</span>] <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p><strong>内置类型方法</strong><br>内置类型和子类型拥有作为属性和方法暴露出来的行为，这是非常强大有力的功能。<br>举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 11</span></span><br><span class="line">a.toUpperCase() <span class="comment">// 'HELLO WORLD'</span></span><br><span class="line">b.toFixed(<span class="number">4</span>) <span class="comment">// '3.1416'</span></span><br></pre></td></tr></table></figure><p><strong>值的比较</strong><br>1.类型转换<br>JavaScript中有两种类型转换：显式的类型转换与隐式的类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'42'</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">Number</span>(a)</span><br><span class="line">  a <span class="comment">// '42'</span></span><br><span class="line">  b <span class="comment">// 42</span></span><br><span class="line"><span class="comment">// 隐式</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'42'</span></span><br><span class="line">  <span class="keyword">var</span> b = a*<span class="number">1</span></span><br><span class="line">  a <span class="comment">// '42'</span></span><br><span class="line">  b <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>2.真与假<br>JavaScript中“假”值的详细列表如下：</p><ul><li>“”（空字符串）</li><li>0、-0、NaN(无效数字）</li><li>null、undefined</li><li>false</li></ul><p>3.相等<br>==检查的是允许类型转换情况下的值的相等性，而===检查不允许类型转换情况下的值的相等性；<br>因此，===经常被称为“严格相等”。</p><p>4.不等关系<br>运算符&lt;, &gt;、&lt;=和&gt;=用于表示不等关系，在规范中被称为“关系比较”。</p><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p>1.提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>2.嵌套作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">      <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    baz()</span><br><span class="line">    <span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>c在bar()的内部是不可访问的，因为它只声明在内层baz()作用域，b在foo()中是不可访问的，也是同样的原因。</p><h3 id="条件判断-1"><a href="#条件判断-1" class="headerlink" title="条件判断"></a>条件判断</h3><p>在JavaScript中，条件判断的另一种形式是“条件运算符”，通常被称为“三进制运算符”。<br>它更像是单个if..else语句的紧凑版，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = (a&gt;<span class="number">41</span>)? <span class="string">'hello'</span>:<span class="string">'world'</span></span><br></pre></td></tr></table></figure><p>如果条件表达式（这里是a &gt; 41）求值为真，那么就会返回第一个子句（”hello”）；否则，结果就是第二个子句（”world”），不论结果是什么，都会赋给b。<br>条件运算符并不一定要用在赋值上，但这肯定是最常见的用法。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>遵循严格模式也更容易让引擎优化你的代码。<br>严格模式是代码的一次重大突破，你应该在自己的程序中一直使用。</p><p>使用严格模式的一个关键区别（改进！）是，不允许省略var的隐式自动全局变量声明</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>不仅你可以向函数传入值（参数），<strong>函数本身也可以作为值</strong>赋给变量或者向其他函数传入，又或者从其他函数传出。<br>因此，应该将函数值视为一个表达式，与其他的值或者表达式类似。</p><p><strong>立即调用函数表达式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello! '</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 'Hello! '</span></span><br></pre></td></tr></table></figure><p><strong>闭包</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数x是一个内层变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 内层函数 add() 使用x，所以它外围有一个'闭包'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y + x</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用外层<code>makeAdder(..)</code>返回的、指向内层<code>add(..)</code>函数的引用能够记忆传入<code>makeAdder(..)</code>的<code>x</code>值。<br>现在，我们来使用<code>makeAdder(..)</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = makeAdder(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plusTen = makeAdder(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plusOne(<span class="number">3</span>)  <span class="comment">// 4 &lt;-- 1+3</span></span><br><span class="line">plusOne(<span class="number">41</span>)  <span class="comment">// 42 &lt;-- 1+41</span></span><br><span class="line"></span><br><span class="line">plusTen(<span class="number">13</span>) <span class="comment">// 23 &lt;-- 10+13</span></span><br></pre></td></tr></table></figure><p>我们来详细说明一下这段代码是如何执行的。<br>(1)调用<code>makeAdder(1)</code>时得到了内层<code>add(..)</code>的一个引用，它会将x记为1。我们将这个函数引用命名为<code>plusOne()</code>。<br>(2)调用<code>makeAdder(10)</code>时得到了内层<code>add(..)</code>的另一个引用，它会将x记为10，我们将这个函数引用命名为<code>plusTen()</code>。<br>(3)调用<code>plusOne(3)</code>时，它会向1（记住的x）加上3（内层y），从而得到结果4。<br>(4)调用<code>plusTen(13)</code>时，它会向10（记住的x）加上13（内层y），从而得到结果23。</p><p><strong>模块</strong><br>在JavaScript中，闭包最常见的应用是模块模式。<br>模块允许你定义外部不可见的私有实现细节（变量、函数），同时也可以提供允许从外部访问的公开API。</p><h3 id="this标识符"><a href="#this标识符" class="headerlink" title="this标识符"></a>this标识符</h3><p>关于如何设置this有4条规则，上述代码中的最后4行展示了这4条规则。<br>(1) 在非严格模式下，foo()最后会将this设置为全局对象。在严格模式下，这是未定义的行为，在访问bar属性时会出错——因此”global”是为this.bar创建的值。<br>(2) obj1.foo()将this设置为对象obj1。<br>(3) foo.call(obj2)将this设置为对象obj2。<br>(4) new foo()将this设置为一个全新的空对象。</p><p>底线：为了搞清楚this指向什么，你必须检查相关的函数是如何被调用的。<br>调用方式会是以上4种之一，这也会回答“this是什么”这个问题。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>当引用对象的某个属性时，如果这个属性并不存在，那么JavaScript会自动使用对象的内部原型引用找到另外一个对象来寻找这个属性。<br>你可以将这点看作是<strong>属性缺失情况的备用模式</strong>。</p><h3 id="旧与新"><a href="#旧与新" class="headerlink" title="旧与新"></a>旧与新</h3><p><strong>polyfilling</strong><br>单词“polyfill”是由Remy Sharp发明的一个<a href="https://remysharp.com/2010/10/08/what-is-a-polyfill" target="_blank" rel="noopener">新术语</a>，用于<strong>表示根据新特性的定义，创建一段与之行为等价但能够在旧的JavaScript环境中运行的代码</strong>。</p><p>ES6定义了一个名为Number.isNaN(..)的工具，用于提供一个精确无bug的NaN值检查，取代原来的isNaN(..)。但对这个工具进行兼容处理很容易，这样一来，无论终端用户是否使用ES6浏览器，你都能够开始使用它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Number</span>.isNaN)&#123;</span><br><span class="line">  <span class="built_in">Number</span>.isNaN = <span class="function"><span class="keyword">function</span> <span class="title">isNaN</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许更好的办法是，使用一个已有的、可信任的polyfilling版本，比如由<a href="https://github.com/es-shims/es5-shim" target="_blank" rel="noopener">ES5-Shim</a>和<a href="https://github.com/es-shims/es6-shim" target="_blank" rel="noopener">ES6-Shim</a>提供的版本。</p><p><strong>transpiling</strong><br>语言中新增的语法是无法进行polyfilling的。<br>新语法在旧版JavaScript引擎上会抛出未识别/无效错误。<br>因此，更好的方法是，通过工具将新版代码转换为等价的旧版代码。<br>这个过程通常被称为“transpiling”。它是由transforming（转换）和compiling（编译）组合而成的术语。</p><p>有几点重要原因使得transpiling值得被关注。</p><ul><li>语言中新添加的语法的设计目的是让代码更容易阅读和维护。等价的旧版本通常更加繁复。你应该编写更新、更简洁的语法，这不只是为你自己，同时也是为开发组中的所有其他成员着想。</li><li>如果只是为旧版本进行编译转换，对新版本应用新语法，那么你就得到了新语法浏览器性能优化的好处。这也使得浏览器开发者可以拥有更真实的代码，以便测试它们的实现和优化。</li><li>越早使用新语法，就可以越早在现实世界中更健壮地测试这些语法，也就可以越早地为JavaScript委员会（TC39）提供反馈。如果能够很早就发现问题，那么就能够在这些语言设计错误被固化前对其进行修改/修复。</li></ul><p>以下是transpiling的一个简单示例。ES6新增了一个名为“默认参数值”的新特性。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a=<span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 2</span></span><br><span class="line">foo(<span class="number">42</span>) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>很简单，对不对？但也非常有用！<br>然而这个新语法在ES6前的引擎中是无效的。<br>那么transpiler是如何改变这段代码，从而让其能够在旧环境下运行的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">arguments</span>[<span class="number">0</span>] !== (<span class="keyword">void</span> <span class="number">0</span>) ? <span class="built_in">arguments</span>[<span class="number">0</span>] : <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你可以看到的，它会检查arguments[0]的值是否为void 0（也就是undefined），如果是的话就提供默认值2；否则就使用传入值。</p><p>除了能够在旧版浏览器中使用更好的新语法，编译转换后的代码实际上也更好地表达了编程意图。<br>单看这段ES6版本的代码，你可能不会意识到undefined是唯一一个无法作为默认值参数显式传入的值。<br>而编译转换后的代码就更清楚地展示了这一点。</p><p>有很多很棒的transpiler可供选择。<br>以下是编写本部分时几个很好的选择：<br>· <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 从ES6+编译转换到ES5<br>· <a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a> 将ES6、ES7及后续版本转换到ES5</p><h3 id="非JavaScript"><a href="#非JavaScript" class="headerlink" title="非JavaScript"></a>非JavaScript</h3><p>你将遇到的最常见的非JavaScript就是DOM API。举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><p>当你的代码在浏览器中运行时，变量document作为一个全局变量存在。<br>它既不是由JavaScript引擎提供的，也不由JavaScript标准控制。<br>它的存在形式看起来非常类似于普通的JavaScript对象，但实际上并不完全是这样。<br>它是一个特殊的对象，通常被称为<strong>宿主对象</strong>。</p><h2 id="深入“你不知道的JavaScript”系列"><a href="#深入“你不知道的JavaScript”系列" class="headerlink" title="深入“你不知道的JavaScript”系列"></a>深入“你不知道的JavaScript”系列</h2><h3 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h3><p>JavaScript引擎在执行前（有时是执行中！）就编译了代码。<br>因此，通过深入理解编译器对代码的处理方式，我们可以尝试理解它是如何找到并处理变量和函数声明的。<br>沿着这条路，我们看到了JavaScript变量作用域管理的常见方式——“提升”。</p><p>闭包可能是JavaScript所有概念中最重要的一个，但如果你没有深刻了解作用域的工作原理，那么很可能就无法理解闭包。</p><p>正如我们在第2章中简单提到的那样，闭包的一个重要应用就是模块模式。<br>模块模式可能是JavaScript所有代码组织模式中最普遍的方法；深入理解模块模式应该是你最高优先级的任务之一。</p><h3 id="this和对象"><a href="#this和对象" class="headerlink" title="this和对象"></a>this和对象</h3><p>关键词this是根据相关函数的执行方式而动态绑定的，事实证明，可以通过4条简单的规则理解并完全确定this绑定。</p><p>与this紧密关联的是对象原型机制，这种机制是一个<strong>属性查找链</strong>，与寻找词法作用域变量的方式类似。</p><h3 id="类型和语法"><a href="#类型和语法" class="headerlink" title="类型和语法"></a>类型和语法</h3><p>到底类型转换的哪些部分是出乎意料的，哪些部分在花费精力学习后则是完全可以理解的。</p><p>这不仅仅只是声称类型转换是合理的、可学习的；我想表明的是，类型转换是非常有用且被低估了的工具，<strong>你应该在自己的代码中使用它</strong>。<br>在我看来，如果能够正确使用的话，类型转换不仅能够工作，而且也会让你的代码质量更高。</p><h3 id="异步和性能"><a href="#异步和性能" class="headerlink" title="异步和性能"></a>异步和性能</h3><p>“作用域和闭包”“this和对象原型”以及“类型和语法”关注的都是语言的核心机制，而“异步和性能”则稍微偏重于在语言机制之上处理异步编程的模式。<br>异步不只是对应用的性能至关重要，而且正在慢慢成为代码易写性和可维护性方面的关键因素。</p><p><strong>promise</strong>是对“未来值”的与时间无关的封装，使得不管这个值是否已经可用，你都可以推导和组合使用它们。<br>另外，通过一种可信任的、可组合的promise机制，分发回调它们也有效地解决了IoC信任问题。</p><p><strong>生成器</strong>为JavaScript函数引入了一种新的执行模式，其中生成器可以暂停在yield点上，并在之后被异步继续。<br>暂停与继续的能力使得生成器中同步的、看似连续的代码可以在后台异步执行。<br>通过这种方式，我们解决了回调的非线性、非局部跳转引发的代码混乱问题，因而让我们的异步代码看似同步，更容易追踪。</p><p>编写高效的JavaScript代码意味着，你编写的代码可以打破不同浏览器和环境的壁垒，达到动态运行。<br>这要求大量复杂而详细的计划和努力，只有这样，才能让程序从“可以运行”到“可以很好地运行”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有点流年不利，不论是大环境还是个人的境遇。&lt;br&gt;好的方面是又可以静下心来，读书，学习新的东西。要一直保持积极乐观的心态啊！&lt;br&gt;今天我们继续读《你不知道的js》的最后一卷。开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>axios 知识梳理</title>
    <link href="https://jambo0624.github.io/2020-01-04-axios.html"/>
    <id>https://jambo0624.github.io/2020-01-04-axios.html</id>
    <published>2020-01-04T14:03:54.000Z</published>
    <updated>2020-10-16T08:35:39.798Z</updated>
    
    <content type="html"><![CDATA[<p>axios是一个非常小巧而好用的http请求库，支持promise以及同时支持浏览器和node端。<br>axios使用简单，配置灵活，也是vue官方推荐的请求库。<br>今天我们就对 axios 相关知识进行整理。</p><a id="more"></a><p>首先介绍一下他的特性</p><blockquote><p>从浏览器中创建 XMLHttpRequest<br>从 node.js 发出 http 请求<br>支持 Promise API<br>拦截请求和响应<br>转换请求和响应数据<br>取消请求<br>自动转换JSON数据<br>客户端支持防止 CSRF/XSRF</p></blockquote><p>接下来看几个使用的栗子🌰：<br><strong>执行 GET 请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向具有指定ID的用户发出请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 params 对象传递参数</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>执行 POST 请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>执行多个并发请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//两个请求现已完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><p>可以通过将相关配置传递给 axios 来进行请求。</p><p><strong>axios(config)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Aaa'</span>,</span><br><span class="line">    lastName: <span class="string">'Bbb'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>axios(url[, config])</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个 GET 请求 (GET请求是默认请求模式)</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure><p><strong>请求方法别名</strong><br>为了方便起见，已经为所有支持的请求方法提供了别名。</p><ul><li><code>axios.request(config)</code></li><li><code>axios.get(url[,config])</code></li><li><code>axios.delete(url[,config])</code></li><li><code>axios.head(url[,config])</code></li><li><code>axios.post(url[,data[,config]])</code></li><li><code>axios.put(url [,data[,config]])</code></li><li><code>axios.patch(url[,data[,config]])</code><br>注意: 当使用别名方法时，不需要在config中指定url，method和data属性。</li></ul><p><strong>并发</strong><br>帮助函数处理并发请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.all（iterable）</span><br><span class="line">axios.spread（callback）</span><br></pre></td></tr></table></figure><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><p>这些是用于发出请求的可用配置选项。 只有url是必需的。 如果未指定方法，请求将默认为GET。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `url`是将用于请求的服务器URL</span></span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method`是发出请求时使用的请求方法</span></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL`将被添加到`url`前面，除非`url`是绝对的。</span></span><br><span class="line">  <span class="comment">// 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。</span></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest`允许在请求数据发送到服务器之前对其进行更改</span></span><br><span class="line">  <span class="comment">// 这只适用于请求方法'PUT'，'POST'和'PATCH'</span></span><br><span class="line">  <span class="comment">// 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做任何你想要的数据转换</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse`允许在 then / catch之前对响应数据进行更改</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers`是要发送的自定义 headers</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params`是要与请求一起发送的URL参数</span></span><br><span class="line">  <span class="comment">// 必须是纯对象或URLSearchParams对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer`是一个可选的函数，负责序列化`params`</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data`是要作为请求主体发送的数据</span></span><br><span class="line">  <span class="comment">// 仅适用于请求方法“PUT”，“POST”和“PATCH”</span></span><br><span class="line">  <span class="comment">// 当没有设置`transformRequest`时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - Browser only: FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node only: Stream</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout`指定请求超时之前的毫秒数。</span></span><br><span class="line">  <span class="comment">// 如果请求的时间超过'timeout'，请求将被中止。</span></span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials`指示是否跨站点访问控制请求</span></span><br><span class="line">  <span class="comment">// should be made using credentials</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter'允许自定义处理请求，这使得测试更容易。</span></span><br><span class="line">  <span class="comment">// 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api））</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;, </span><br><span class="line"></span><br><span class="line">  <span class="comment">// `auth'表示应该使用 HTTP 基本认证，并提供凭据。</span></span><br><span class="line">  <span class="comment">// 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// “responseType”表示服务器将响应的数据类型</span></span><br><span class="line">  <span class="comment">// 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称</span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName`是携带xsrf令牌值的http头的名称</span></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress`允许处理上传的进度事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用本地 progress 事件做任何你想要做的</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress`允许处理下载的进度事件</span></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength`定义允许的http响应内容的最大大小</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus`定义是否解析或拒绝给定的promise</span></span><br><span class="line">  <span class="comment">// HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被</span></span><br><span class="line">  <span class="comment">// 拒绝。</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects`定义在node.js中要遵循的重定向的最大数量。</span></span><br><span class="line">  <span class="comment">// 如果设置为0，则不会遵循重定向。</span></span><br><span class="line">  maxRedirects: <span class="number">5</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。</span></span><br><span class="line">  <span class="comment">// 允许配置类似`keepAlive`的选项，</span></span><br><span class="line">  <span class="comment">// 默认情况下不启用。</span></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'proxy'定义代理服务器的主机名和端口</span></span><br><span class="line">  <span class="comment">// `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。</span></span><br><span class="line">  <span class="comment">// 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: : &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// “cancelToken”指定可用于取消请求的取消令牌</span></span><br><span class="line">  <span class="comment">// (see Cancellation section below for details)</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>使用 then 时，您将收到如下响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="配置默认值"><a href="#配置默认值" class="headerlink" title="配置默认值"></a>配置默认值</h3><p>您可以指定将应用于每个请求的配置默认值。</p><p><strong>全局axios默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure><p><strong>自定义实例默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在创建实例时设置配置默认值</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create（&#123;</span><br><span class="line">   baseURL：<span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在实例创建后改变默认值</span></span><br><span class="line">instance.defaults.headers.common [<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure><p><strong>配置优先级顺序</strong><br>配置将与优先顺序合并。<br>顺序是<code>lib/defaults.js</code>中的库默认值，然后是实例的defaults属性，最后是请求的config参数。<br>后者将优先于前者。<br>这里有一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用库提供的配置默认值创建实例</span></span><br><span class="line"><span class="comment">//此时，超时配置值为`0`，这是库的默认值</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create（）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//覆盖库的超时默认值</span></span><br><span class="line"><span class="comment">//现在所有请求将在超时前等待2.5秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//覆盖此请求的超时，因为它知道需要很长时间</span></span><br><span class="line">instance.get（<span class="string">'/ longRequest'</span>，&#123;</span><br><span class="line">   timeout：<span class="number">5000</span></span><br><span class="line">&#125;）;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>你可以截取请求或响应在被 then 或者 catch 处理之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use（<span class="function"><span class="keyword">function</span>（<span class="title">config</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//在发送请求之前做某事</span></span><br><span class="line">     <span class="keyword">return</span> config;</span><br><span class="line">   &#125;，<span class="function"><span class="keyword">function</span>（<span class="title">error</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//请求错误时做些事</span></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Promise</span>.reject（error）;</span><br><span class="line">   &#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use（<span class="function"><span class="keyword">function</span>（<span class="title">response</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//对响应数据做些事</span></span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">   &#125;，<span class="function"><span class="keyword">function</span>（<span class="title">error</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//请求错误时做些事</span></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Promise</span>.reject（error）;</span><br><span class="line">   &#125;）;</span><br></pre></td></tr></table></figure><p>如果你以后可能需要删除拦截器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure><p>你可以将拦截器添加到axios的自定义实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios.get（<span class="string">'/ user / 12345'</span>）</span><br><span class="line">   .catch（<span class="function"><span class="keyword">function</span>（<span class="title">error</span>）</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>（error.response）&#123;</span><br><span class="line">       <span class="comment">//请求已发出，但服务器使用状态代码进行响应</span></span><br><span class="line">       <span class="comment">//落在2xx的范围之外</span></span><br><span class="line">       <span class="built_in">console</span>.log（error.response.data）;</span><br><span class="line">       <span class="built_in">console</span>.log（error.response.status）;</span><br><span class="line">       <span class="built_in">console</span>.log（error.response.headers）;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//在设置触发错误的请求时发生了错误</span></span><br><span class="line">       <span class="built_in">console</span>.log（<span class="string">'Error'</span>，error.message）;</span><br><span class="line">     &#125;&#125;</span><br><span class="line">     <span class="built_in">console</span>.log（error.config）;</span><br><span class="line">   &#125;）;</span><br></pre></td></tr></table></figure><p>您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get（<span class="string">'/ user / 12345'</span>，&#123;</span><br><span class="line">   validateStatus：<span class="function"><span class="keyword">function</span>（<span class="title">status</span>）</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">//仅当状态代码大于或等于500时拒绝</span></span><br><span class="line">   &#125;&#125;</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><h3 id="消除"><a href="#消除" class="headerlink" title="消除"></a>消除</h3><p>您可以使用取消令牌取消请求。</p><blockquote><p>axios cancel token API基于可取消的promise提议，目前处于阶段1。</p></blockquote><p>您可以使用CancelToken.source工厂创建一个取消令牌，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> source = CancelToken.source（）;</span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//取消请求（消息参数是可选的）</span></span><br><span class="line">source.cancel（<span class="string">'操作被用户取消。'</span>）;</span><br></pre></td></tr></table></figure><p>您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> cancel;</span><br><span class="line"> </span><br><span class="line">axios.get（<span class="string">'/ user / 12345'</span>，&#123;</span><br><span class="line">   cancelToken：<span class="keyword">new</span> CancelToken（<span class="function"><span class="keyword">function</span> <span class="title">executor</span>（<span class="title">c</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//一个执行器函数接收一个取消函数作为参数</span></span><br><span class="line">     cancel = c;</span><br><span class="line">   &#125;）</span><br><span class="line">&#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">clear();</span><br></pre></td></tr></table></figure><p>注意：<strong>您可以使用相同的取消令牌取消几个请求。</strong></p><h3 id="使用application-x-www-form-urlencoded格式"><a href="#使用application-x-www-form-urlencoded格式" class="headerlink" title="使用application / x-www-form-urlencoded格式"></a>使用application / x-www-form-urlencoded格式</h3><p>默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。</p><p><strong>浏览器</strong><br>在浏览器中，您可以使用URLSearchParams API，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, params);</span><br></pre></td></tr></table></figure><p>请注意，<strong>所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。</strong></p><p>或者，您可以使用qs库对数据进行编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, qs.stringify(&#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>Node.js</strong><br>在node.js中，可以使用querystring模块，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">axios.post(<span class="string">'http://something.com/'</span>, querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;);</span><br></pre></td></tr></table></figure><p>你也可以使用qs库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;axios是一个非常小巧而好用的http请求库，支持promise以及同时支持浏览器和node端。&lt;br&gt;axios使用简单，配置灵活，也是vue官方推荐的请求库。&lt;br&gt;今天我们就对 axios 相关知识进行整理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="http" scheme="https://jambo0624.github.io/tags/http/"/>
    
      <category term="axios" scheme="https://jambo0624.github.io/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (中卷)--程序性能》</title>
    <link href="https://jambo0624.github.io/2019-12-22-dont-know-js-second3.html"/>
    <id>https://jambo0624.github.io/2019-12-22-dont-know-js-second3.html</id>
    <published>2019-12-22T06:13:49.000Z</published>
    <updated>2020-10-16T07:35:33.228Z</updated>
    
    <content type="html"><![CDATA[<p>对于中卷的部分，之前已经分了两篇文章进行了介绍。<br>分别是<a href="https://jambo0624.github.io/2019-03-19-dont-know-js-second.html">中卷一</a>和<a href="https://jambo0624.github.io/2019-07-07-dont-know-js-second2.html">中卷二</a><br>但是真的由于内容很多，很精华，每一章节单拿出来都可以写成几篇文章。<br>就算仅仅记录表面意思，仍然足以撑满篇幅。<br>今天我们开始记录性能部分内容，真的是中卷的最后一篇文章啦。</p><a id="more"></a><h2 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h2><h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><p>如果你有一些处理密集型的任务要执行，但不希望它们都在主线程运行（这可能会减慢浏览器/UI），可能你就会希望JavaScript能够以多线程的方式运行。</p><p>像浏览器这样的环境，很容易提供多个JavaScript引擎实例，各自运行在自己的线程上，这样你可以在每个线程上运行不同的程序。<br>程序中每一个这样的独立的多线程部分被称为一个（Web）Worker。<br>这种类型的并行化被称为任务并行，因为其重点在于把程序划分为多个块来并发运行。</p><p>从JavaScript主程序（或另一个Worker）中，可以这样实例化一个Worker：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w1 = <span class="keyword">new</span> Worker(<span class="string">'http://some.url.1/mycoolworker.js'</span>)</span><br></pre></td></tr></table></figure><p>这个URL应该指向一个JavaScript文件的位置（而不是一个HTML页面！），这个文件将被加载到一个Worker中。<br>然后浏览器启动一个独立的线程，让这个文件在这个线程中作为独立的程序运行。</p><p>Worker之间以及它们和主程序之间，<strong>不会共享任何作用域或资源</strong>，那会把所有多线程编程的噩梦带到前端领域，而是<strong>通过一个基本的事件消息机制</strong>相互联系。<br>Worker w1对象是一个事件侦听者和触发者，可以通过订阅它来获得这个Worker发出的事件以及发送事件给这个Worker。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'mycoolworker.js'</span></span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// evt.data</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">postMessage(<span class="string">'a really cool reply'</span>)</span><br></pre></td></tr></table></figure><p>注意，专用Worker和创建它的程序之间是一对一的关系。<br>也就是说，”message”事件没有任何歧义需要消除，因为我们确定它只能来自这个一对一的关系：<strong>它要么来自这个Worker，要么来自主页面。</strong></p><p><strong>Worker环境</strong><br>在Worker内部是无法访问主程序的任何资源的。<br>这意味着你不能访问它的任何全局变量，也不能访问页面的DOM或者其他资源。<br>记住，这是一个完全独立的线程。</p><p>但是，你可以执行网络操作（Ajax、WebSockets）以及设定定时器。<br>还有，Worker可以访问几个重要的全局变量和功能的本地复本，包括navigator、location、JSON和applicationCache。</p><p>你还可以通过importScripts(..)向Worker加载额外的JavaScript脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker 内部</span></span><br><span class="line">importScripts(<span class="string">'foo.js'</span>, <span class="string">'bar.js'</span>)</span><br></pre></td></tr></table></figure><p>这些脚本加载是同步的。<br>也就是说，<code>importScripts(..)</code>调用会阻塞余下Worker的执行，直到文件加载和执行完成。</p><p><strong>数据传递</strong><br>如果要传递一个对象，可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">结构化克隆算法</a>(structured clone algorithm)把这个对象复制到另一边。<br>这个算法非常高级，甚至可以处理要复制的对象有循环引用的情况。<br>这样就不用付出to-string和from-string的性能损失了，但是这种方案还是要使用双倍的内存。IE10及更高版本以及所有其他主流浏览器都支持这种方案。<br>这里有一篇文章关于<a href="https://zhuanlan.zhihu.com/p/33489557" target="_blank" rel="noopener">结构化克隆算法</a>的<strong>应用</strong>。</p><p>还有一个更好的选择，特别是对于大数据集而言，就是使用<a href="http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast" target="_blank" rel="noopener">Transferable对象</a>。<br>这时发生的是对象所有权的转移，数据本身并没有移动。<br>一旦你把对象传递到一个Worker中，在原来的位置上，它就变为空的或者是不可访问的，这样就消除了多线程编程作用域共享带来的混乱。<br>当然，所有权传递是可以双向进行的。</p><p>如果选择Transferable对象的话，其实不需要做什么。<br>任何实现了<a href="http://developer.mozilla.org/en-US/docs/Web/API/Transferable" target="_blank" rel="noopener">Transferable接口</a>的数据结构就自动按照这种方式传输（Firefox和Chrome都支持）</p><p>下面是如何使用postMessage(..)发送一个Transferable对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如 Unit8Array</span></span><br><span class="line">postMessage( foo.buffer, [foo.buffer] )</span><br></pre></td></tr></table></figure><p>第一个参数是一个原始缓冲区，第二个是一个要传输的内容的列表。<br>不支持Transferable对象的浏览器就降级到结构化克隆，这会带来性能下降而不是彻底的功能失效。```</p><p><strong>共享Worker</strong><br>共享Worker可以与站点的多个程序实例或多个页面连接，所以这个Worker需要通过某种方式来得知消息来自于哪个程序。<br>这个唯一标识符称为端口（port），可以类比网络socket的端口。因此，调用程序必须使用Worker的port对象用于通信：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w1.port.addEventListener(<span class="string">'message'</span>,handleMessage)</span><br><span class="line">w1.port.postMessage(<span class="string">'something cool'</span>)</span><br></pre></td></tr></table></figure><p>还有，端口连接必须要初始化，形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w1.port.start()</span><br></pre></td></tr></table></figure><p>在共享Worker内部，必须要处理额外的一个事件：”connect”。<br>这个事件为这个特定的连接提供了端口对象。<br>保持多个连接独立的最简单办法就是使用port上的闭包，就像下面的代码一样，把这个链接上的事件侦听和传递定义在”connect”事件的处理函数内部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker 内部</span></span><br><span class="line">addEventListener(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> port = evt.ports[<span class="number">0</span>]</span><br><span class="line">  port.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    port.postMessage()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  port.start()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="SMID"><a href="#SMID" class="headerlink" title="SMID"></a>SMID</h3><p>单指令多数据（SIMD）是一种数据并行（data parallelism）方式，与WebWorker的任务并行（task parallelism）相对，因为这里的重点实际上不再是把程序逻辑分成并行的块，而是并行处理数据的多个位。</p><p>通过SIMD，线程不再提供并行。<br>取而代之的是，现代CPU通过数字“向量”（特定类型的数组），以及可以在所有这些数字上并行操作的指令，来提供SIMD功能。<br>这是利用低级指令级并行的底层运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = SMID.float32x4(<span class="number">3.14159</span>, <span class="number">21.0</span>, <span class="number">32.3</span>, <span class="number">55.55</span>)</span><br><span class="line"><span class="keyword">var</span> v2 = SMID.float32x4(<span class="number">2.1</span>, <span class="number">3.2</span>, <span class="number">4.3</span>, <span class="number">5.4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v3 = SMID.int32x4(<span class="number">10</span>, <span class="number">101</span>, <span class="number">1001</span>, <span class="number">10001</span>)</span><br><span class="line"><span class="keyword">var</span> v4 = SMID.int32x4(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">SMID.float32x4.mul(v1, v2) <span class="comment">// [6.597339, 67.2, 138.89, 299.97]</span></span><br><span class="line">SMID.int32x4.mul(v3, v4) <span class="comment">// [20, 121, 1031, 10041]</span></span><br></pre></td></tr></table></figure><h3 id="asm-js"><a href="#asm-js" class="headerlink" title="asm.js"></a>asm.js</h3><p><a href="http://asmjs.org" target="_blank" rel="noopener">asm.js</a>这个标签是指JavaScript语言中可以高度优化的一个子集。<br>通过小心避免某些难以优化的机制和模式（垃圾收集、类型强制转换，等等）, asm.js风格的代码可以被JavaScript引擎识别并进行特别激进的底层优化。</p><h2 id="性能测试与调优"><a href="#性能测试与调优" class="headerlink" title="性能测试与调优"></a>性能测试与调优</h2><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> end = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Duration:'</span>,(end-start))</span><br></pre></td></tr></table></figure><p>使用这个方法测试某个运算的速度（执行时间）<strong>有很多错误</strong>。</p><p><strong>重复</strong><br>如果想要用重复来测试，要确保把异常因素排除，你需要大量的样本来平均化。<br>你还会想要知道最差样本有多慢，最好的样本有多快，以及最好和最差情况之间的偏离度有多大，等等。<br>司仪重复也不是正确的方法。</p><p><strong>Benchmark.js</strong><br>任何有意义且可靠的性能测试都应该基于统计学上合理的实践。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 要测试的运算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bench= <span class="keyword">new</span> Benchmark(      </span><br><span class="line"> <span class="string">'foo test'</span>,  <span class="comment">// 测试名称</span></span><br><span class="line">  foo,  <span class="comment">// 要测试的函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 可选的额外选项</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">bench.hz <span class="comment">// 每秒运算数</span></span><br><span class="line">bench.stats.moe <span class="comment">// 出错边界</span></span><br><span class="line">bench.stats.variance <span class="comment">// 样本方差</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="环境为王"><a href="#环境为王" class="headerlink" title="环境为王"></a>环境为王</h3><p>对特定的性能测试来说，不要忘了检查测试环境，特别是比较任务Ⅹ和Y这样的比对测试。<br>仅仅因为你的测试显示Ⅹ比Y快，并不能说明结论Ⅹ比Y快就有实际的意义。</p><p><strong>引擎优化</strong><br>我们设想的所有优化可能性在受限的测试中都有可能发生，而且在更复杂的程序中（出于各种各样的原因），引擎可能不会进行这样的优化。<br>也可能恰恰相反，引擎可能不会优化这样无关紧要的代码，但是在系统已经在运行更复杂的程序时可能会倾向于激进的优化。</p><p>这是不是意味着无法真正进行任何有用的测试呢？绝对不是！<br>测试不真实的代码只能得出不真实的结论。<br>如果有实际可能的话，你应该测试实际的而非无关紧要的代码，测试条件与你期望的真实情况越接近越好。<br>只有这样得出的结果才有可能接近事实。<br>像++x对比x++这样的微观性能测试结果为虚假的可能性相当高，可能我们最好就假定它们是假的。</p><h3 id="jsPerf-com"><a href="#jsPerf-com" class="headerlink" title="jsPerf.com"></a>jsPerf.com</h3><p>如果想要在不止一个环境下得出像“Ⅹ比Y快”这样的有意义的结论成立，那你需要在尽可能多的真实环境下进行实际测试。仅仅因为在Chrome上某个Ⅹ运算比Y快并不意味着这在所有的浏览器中都成立。<br>当然你可能还想要交叉引用多个浏览器上的测试运行结果，并有用户的图形展示。</p><p>有一个很棒的网站正是因这样的需求而诞生的，名为<a href="http://jsperf.com" target="_blank" rel="noopener">jsPerf</a></p><h3 id="写好测试"><a href="#写好测试" class="headerlink" title="写好测试"></a>写好测试</h3><p>要写好测试，需要认真分析和思考两个测试用例之间有什么区别，以及这些区别是有意还是无意的。</p><p>编写更好更清晰的测试。<br>但还有，花一些时间来编写文档（使用jsPerf.com上的Description字段和/或代码注释）精确表达你的测试目的，甚至对于那些微小的细节也要如此。<br>找出那些有意的区别，这会帮助别人和未来的你更好地识别出那些可能扭曲测试结果的无意区别。</p><p>不要试图窄化到真实代码的微小片段，以及脱离上下文而只测量这一小部分的性能，因为包含更大（仍然有意义的）上下文时功能测试和性能测试才会更好。<br>这些测试可能也会运行得慢一点，这意味着环境中发现的任何差异都更有意义。</p><h3 id="微性能"><a href="#微性能" class="headerlink" title="微性能"></a>微性能</h3><p>在考虑对代码进行性能测试时，你应该习惯的第一件事情就是你所写的代码并不总是引擎真正运行的代码。</p><p>来考虑下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">41</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> baz = foo + baz</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)(<span class="number">1</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>可能你会认为最内层函数中的引用foo需要进行三层作用域查找。<br>事实上，编译器通常会缓存这样的查找结果，使得从不同的作用域引用foo实际上并没有任何额外的花费。<br>但是，还有一些更深入的问题需要思考。<br>如果编译器意识到这个foo只在一个位置被引用而别处没有任何引用，并且注意到这个值只是41而从来不会变成其他值呢？</p><p>JavaScript可能决定完全去掉foo变量，将其值在线化，这不是很可能发生也可以接受的吗？就像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> baz = <span class="number">41</span> + baz</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)(<span class="number">1</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>当你把JavaScript代码看作对引擎要做什么的提示和建议，而不是逐字逐句的要求时，你就会意识到，对于具体语法细节的很多执着迷恋已经烟消云散了。</p><p>这里是另一个常见的愚蠢的执迷于微观性能的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [...]</span><br><span class="line"><span class="comment">// 选择1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;x.length;i++)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=x.length;i&lt;len;i++)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上说，这里应该在变量len中缓存x数组的长度，因为表面上它不会改变，来避免在每个循环迭代中计算x.length的代价。<br>如果运行性能测试来比较使用x.length和将其缓存到len变量中的方案，你会发现尽管理论听起来没错，但实际的可测差别在统计上是<strong>完全无关紧要</strong>的。</p><p>实际上，在某些像v8这样的引擎中，可以<a href="http://mrale.ph/blog/2014/12/24/array-length-caching.html" target="_blank" rel="noopener">看到</a>，预先缓存长度而不是让引擎为你做这件事情，会使性能稍微下降一点。<br>不要试图和JavaScript引擎比谁聪明。对性能优化来说，你很可能会输。</p><p><strong>不是所有的引擎都类似</strong><br>引擎可以自由决定一个运算是否需要优化，可能进行权衡，替换掉运算次要性能。<br>对一个运算来说，很难找到一种方法使其在所有浏览器中都运行得较快</p><p>在一些JavaScript开发社区有一场运动，特别是在那些使用Node.js工作的开发者中间。<br>这场运动是要分析v8 JavaScript引擎的特定内部实现细节，决定编写裁剪过的JavaScript代码来最大程度地利用v8的工作模式。<br>通过这样的努力，你可能会获得令人吃惊的高度性能优化。因此，这种努力的回报可能会很高。</p><p><strong>大局</strong><br>怎么知道什么是大局呢？<br>首先要了解你的代码是否运行在关键路径上。<br>如果不在关键路径上，你的优化就很可能得不到很大的收益。</p><p>有没有听过“这是过早优化”这样的警告？<br>这来自于高德纳著名的一句话：<strong>“过早优化是万恶之源。”</strong><br>很多开发者都会引用这句话来说明多数优化都是“过早的”，因此是白费力气。和通常情况一样，事实要更加微妙一些。</p><p>尽管程序关键路径上的性能非常重要，但这并不是唯一要考虑的因素。<br>在性能方面大体相似的几个选择中，<strong>可读性</strong>应该是另外一个重要的考量因素。</p><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用优化（Tail Call Optimization, TCO）<br>尾调用就是一个出现在另一个函数“结尾”处的函数调用。<br>这个调用结束后就没有其余事情要做了（除了可能要返回结果值）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(y+<span class="number">1</span>) <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + bar(<span class="number">40</span>) <span class="comment">// 非尾调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz() <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>调用一个新的函数需要额外的一块预留内存来管理调用栈，称为<strong>栈帧</strong>。<br>所以前面的代码一般会同时需要为每个baz()、bar(..)和foo(..)保留一个栈帧。</p><p>然而，如果支持TCO的引擎能够意识到foo(y+1)调用位于尾部，这意味着bar(..)基本上已经完成了，那么在调用foo(..)时，它就不需要创建一个新的栈帧，而是可以重用已有的bar(..)的栈帧。<br>这样不仅速度更快，也更节省内存。</p><p>在简单的代码片段中，这类优化算不了什么，但是在处理递归时，这就解决了大问题，特别是如果递归可能会导致成百上千个栈帧的时候。<br>有了TCO，引擎可以用同一个栈帧执行所有这类调用！</p><p>递归是JavaScript中一个纷繁复杂的主题。<br>因为如果没有TCO的话，引擎需要实现一个随意（还彼此不同！）的限制来界定递归栈的深度，达到了就得停止，以防止内存耗尽。<br>有了TCO，尾调用的递归函数本质上就可以任意运行，因为再也不需要使用额外的内存！</p><p>ES6之所以要求引擎实现TCO而不是将其留给引擎自由决定，一个原因是缺乏TCO会导致一些JavaScript算法因为害怕调用栈限制而降低了通过递归实现的概率。</p><p>最后今天冬至了，愿大家都能吃上一碗热乎的饺子🥟！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于中卷的部分，之前已经分了两篇文章进行了介绍。&lt;br&gt;分别是&lt;a href=&quot;https://jambo0624.github.io/2019-03-19-dont-know-js-second.html&quot;&gt;中卷一&lt;/a&gt;和&lt;a href=&quot;https://jambo0624.github.io/2019-07-07-dont-know-js-second2.html&quot;&gt;中卷二&lt;/a&gt;&lt;br&gt;但是真的由于内容很多，很精华，每一章节单拿出来都可以写成几篇文章。&lt;br&gt;就算仅仅记录表面意思，仍然足以撑满篇幅。&lt;br&gt;今天我们开始记录性能部分内容，真的是中卷的最后一篇文章啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>vim命令</title>
    <link href="https://jambo0624.github.io/2019-12-09-vim-command.html"/>
    <id>https://jambo0624.github.io/2019-12-09-vim-command.html</id>
    <published>2019-12-09T02:08:25.000Z</published>
    <updated>2020-10-15T12:29:23.002Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇文章摘转了一篇 vim 的教程。今天我们用简短集中的方式来梳理 vim 相关的知识。<br>大致意思就是去掉说明性的文字，直接让代码说话。<br>下面我们开始吧。</p><a id="more"></a><h1 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h1><p><a href="https://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">Vim命令合集</a><br><strong>退出方式</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>保存文件但不退出vi</td></tr><tr><td>:w</td><td>file 将修改另外保存到file中，不退出vi</td></tr><tr><td>:w!</td><td>强制保存，不推出vi</td></tr><tr><td>:wq</td><td>保存文件并退出vi</td></tr><tr><td>:wq!</td><td>强制保存文件，并退出vi</td></tr><tr><td>q:</td><td>不保存文件，退出vi</td></tr><tr><td>:q!</td><td>不保存文件，强制退出vi</td></tr><tr><td>:e!</td><td>放弃所有修改，从上次保存文件开始再编辑</td></tr></tbody></table><p><strong>命令历史</strong></p><blockquote><p>以<code>:</code>和<code>/</code>开头的命令都有历史记录，可以首先键入<code>:</code>或<code>/</code>然后按上下箭头来选择某个历史命令。</p></blockquote><p><strong>文件命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>vim file</td><td>打开单个文件</td></tr><tr><td>vim file1 file2 file3 …</td><td>同时打开多个文件</td></tr><tr><td>:open file</td><td>在vim窗口中打开一个新文件</td></tr><tr><td>:split file</td><td>在新窗口中打开文件</td></tr><tr><td>:bn</td><td>切换到下一个文件</td></tr><tr><td>:bp</td><td>切换到上一个文件</td></tr><tr><td>:args</td><td>查看当前打开的文件列表，当前正在编辑的文件会用<code>[]</code>括起来</td></tr><tr><td><code>:e ftp://192.168.10.76/abc.txt</code></td><td>打开远程文件，比如ftp</td></tr><tr><td>:e \qadrive\test\1.txt</td><td>打开远程文件，比如share folder</td></tr></tbody></table><p><strong>vim的模式</strong></p><table><thead><tr><th>模式</th><th>状态</th></tr></thead><tbody><tr><td>正常模式</td><td>（按Esc或Ctrl+[进入） 左下角显示文件名或为空</td></tr><tr><td>插入模式</td><td>（按i键进入） 左下角显示–INSERT–</td></tr><tr><td>可视模式</td><td>左下角显示–VISUAL–</td></tr></tbody></table><p><strong>导航命令</strong></p><blockquote><p>% 括号匹配</p></blockquote><p><strong>插入命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>在当前位置生前插入</td></tr><tr><td>I</td><td>在当前行首插入</td></tr><tr><td>a</td><td>在当前位置后插入</td></tr><tr><td>A</td><td>在当前行尾插入</td></tr><tr><td>o</td><td>在当前行之后插入一行</td></tr><tr><td>O</td><td>在当前行之前插入一行</td></tr></tbody></table><p><strong>查找命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>/text</td><td>查找text，按n健查找下一个，按N健查找前一个。</td></tr><tr><td>?text</td><td>查找text，反向查找，按n健查找下一个，按N健查找前一个。</td></tr><tr><td>:set ignorecase</td><td>忽略大小写的查找</td></tr><tr><td>:set noignorecase</td><td>不忽略大小写的查找</td></tr><tr><td>:set hlsearch</td><td>高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</td></tr><tr><td>:set nohlsearch</td><td>关闭高亮搜索显示</td></tr><tr><td>:nohlsearch</td><td>关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</td></tr><tr><td>:set incsearch</td><td>逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</td></tr><tr><td>:set wrapscan</td><td>重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</td></tr></tbody></table><ul><li>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</li><li>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</li></ul><p><strong>替换命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ra</td><td>将当前字符替换为a，当期字符即光标所在字符。</td></tr><tr><td>s/old/new/</td><td>用old替换new，替换当前行的第一个匹配</td></tr><tr><td>s/old/new/g</td><td>用old替换new，替换当前行的所有匹配</td></tr><tr><td>%s/old/new/</td><td>用old替换new，替换所有行的第一个匹配</td></tr><tr><td>%s/old/new/g</td><td>用old替换new，替换整个文件的所有匹配</td></tr><tr><td>:10,20 s/^//g</td><td>在第10行知第20行每行前面加四个空格，用于缩进。</td></tr><tr><td>ddp</td><td>交换光标所在行和其下紧邻的一行。</td></tr></tbody></table><p><strong>移动命令</strong></p><blockquote><p>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符</p></blockquote><p>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<code>&lt;Esc&gt;</code>，这里的Esc是必须的，否则命令不生效。</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>w</td><td>向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</td></tr><tr><td>b</td><td>向后移动一个单词 2b 向后移动2个单词</td></tr><tr><td>e，同w，</td><td>只不过是光标停在单词尾部</td></tr><tr><td>ge，同b，</td><td>光标停在单词尾部。</td></tr><tr><td>^</td><td>移动到本行第一个非空白字符上。</td></tr><tr><td>0</td><td>（数字0）移动到本行第一个字符上，</td></tr><tr><td><code>&lt;HOME&gt;</code></td><td>移动到本行第一个字符。同0健。</td></tr><tr><td>$</td><td>移动到行尾 3$ 移动到下面3行的行尾</td></tr><tr><td>gg( [[)</td><td>移动到文件头。</td></tr><tr><td>G（shift + g）( ]])</td><td>移动到文件尾。</td></tr><tr><td>f（find）</td><td>命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</td></tr><tr><td>F 同f</td><td>反向查找</td></tr><tr><td>Ctrl + e</td><td>向下滚动一行</td></tr><tr><td>Ctrl + y</td><td>向上滚动一行</td></tr><tr><td>Ctrl + d</td><td>向下滚动半屏</td></tr><tr><td>Ctrl + u</td><td>向上滚动半屏</td></tr><tr><td>Ctrl + f</td><td>向下滚动一屏</td></tr><tr><td>Ctrl + b</td><td>向上滚动一屏</td></tr><tr><td>跳到指定行，冒号+行号，回车</td><td>比如跳到240行就是 <code>:240回车</code>。另一个方法是行号+G，比如230G跳到230行。</td></tr></tbody></table><p><strong>撤销和重做</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>u</td><td>撤销（Undo）</td></tr><tr><td>U</td><td>撤销对整行的操作</td></tr><tr><td>Ctrl + r</td><td>重做（Redo），即撤销的撤销</td></tr></tbody></table><p><strong>删除命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>x</td><td>删除当前字符</td></tr><tr><td>3x</td><td>删除当前光标开始向后三个字符</td></tr><tr><td>X</td><td>删除当前字符的前一个字符。X=dh</td></tr><tr><td>dl</td><td>删除当前字符， dl=x</td></tr><tr><td>dh</td><td>删除前一个字符</td></tr><tr><td>dd</td><td>删除当前行</td></tr><tr><td>dj</td><td>删除上一行</td></tr><tr><td>dk</td><td>删除下一行</td></tr><tr><td>10d</td><td>删除当前行开始的10行。</td></tr><tr><td>D</td><td>删除当前字符至行尾。D=d$</td></tr><tr><td>d$</td><td>删除当前字符之后的所有字符（本行）</td></tr><tr><td>kdgg</td><td>删除当前行之前所有行（不包括当前行）</td></tr><tr><td>jdG（jd shift + g）</td><td>删除当前行之后所有行（不包括当前行）</td></tr><tr><td>:1,10d</td><td>删除1-10行</td></tr><tr><td>:11,$d</td><td>删除11行及以后所有的行</td></tr><tr><td>:1,$d</td><td>删除所有行</td></tr><tr><td>J(shift + j)</td><td>删除两行之间的空行，实际上是合并两行。</td></tr></tbody></table><p><strong>拷贝和粘贴</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>yy</td><td>拷贝当前行</td></tr><tr><td>nyy</td><td>拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</td></tr><tr><td>p</td><td>在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</td></tr><tr><td>shift+p</td><td>在当前行前粘贴</td></tr><tr><td>:1,10 co 20</td><td>将1-10行插入到第20行之后。</td></tr><tr><td>:1,$ co $</td><td>将整个文件复制一份并添加到文件尾部。</td></tr><tr><td>ddp</td><td>交换当前行和其下一行</td></tr><tr><td>xp</td><td>交换当前字符和其后一个字符</td></tr><tr><td>+ 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</td><td></td></tr></tbody></table><p><strong>剪切命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ndd</td><td>剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</td></tr><tr><td>:1,10d</td><td>将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</td></tr><tr><td>:1, 10 m 20</td><td>将第1-10行移动到第20行之后。</td></tr><tr><td>+ 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</td><td></td></tr></tbody></table><p><strong>退出命令</strong></p><blockquote><p>:wq 保存并退出<br>ZZ 保存并退出<br>:q! 强制退出并忽略所有更改<br>:e! 放弃所有修改，并打开原来文件。</p></blockquote><p><strong>窗口命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:split或new</td><td>打开一个新窗口，光标停在顶层的窗口上</td></tr><tr><td>:split file或:new file</td><td>用新窗口打开文件</td></tr><tr><td>Ctrl+ww</td><td>移动到下一个窗口</td></tr><tr><td>Ctrl+wj</td><td>移动到下方的窗口</td></tr><tr><td>Ctrl+wk</td><td>移动到上方的窗口</td></tr><tr><td>+ split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。</td><td></td></tr></tbody></table><p><strong>关闭窗口</strong></p><blockquote><p>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。<br>:q 如果是最后一个被关闭的窗口，那么将退出vim。<br>ZZ 保存并退出。<br>关闭所有窗口，只保留当前窗口 :only</p></blockquote><p><strong>录制宏</strong></p><blockquote><p>按<code>q</code>键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p></blockquote><p><strong>执行shell命令</strong></p><blockquote><p>:!command<br>:!ls 列出当前目录下文件<br>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。<br>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。<br>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p></blockquote><p><strong>注释命令</strong></p><blockquote><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#<br>3,5 s/^/#/g 注释第3-5行<br>3,5 s/^#//g 解除3-5行的注释<br>1,$ s/^/#/g 注释整个文档。<br>:%s/^/#/g 注释整个文档，此法更快。</p></blockquote><p><strong>帮助命令</strong></p><blockquote><p><code>:help or F1</code> 显示整个帮助<br><code>:help xxx</code> 显示xxx的帮助，比如 <code>:help i, :help CTRL-[</code>（即<code>Ctrl+[的帮助</code>）<br><code>:help &#39;number&#39;</code> Vim选项的帮助用单引号括起<br><code>:help &lt;Esc&gt;</code> 特殊键的帮助用&lt;&gt;扩起<br><code>:help -t</code> Vim启动参数的帮助用-<br><code>:help i_&lt;Esc&gt;</code> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</p></blockquote><p>其他非编辑命令</p><blockquote><p><code>.</code> 重复前一次命令<br><code>:set ruler?</code>　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看<br><code>:scriptnames</code>　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。<br><code>:set list</code> 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</p></blockquote><p>Vim教程<br>在Unix系统上</p><blockquote><p>$ vimtutor</p></blockquote><p>在Windows系统上</p><blockquote><p>:help tutor<br>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一篇文章摘转了一篇 vim 的教程。今天我们用简短集中的方式来梳理 vim 相关的知识。&lt;br&gt;大致意思就是去掉说明性的文字，直接让代码说话。&lt;br&gt;下面我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/categories/vim/"/>
    
    
      <category term="command" scheme="https://jambo0624.github.io/tags/command/"/>
    
      <category term="vim" scheme="https://jambo0624.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>vim教程--vimtutor</title>
    <link href="https://jambo0624.github.io/2019-12-07-vim.html"/>
    <id>https://jambo0624.github.io/2019-12-07-vim.html</id>
    <published>2019-12-07T10:17:35.000Z</published>
    <updated>2020-10-15T11:46:08.840Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到别人在用一款及其酷炫的编辑器 <strong>vim</strong> ，操作起来的场景就是自己最初对程序员的认识。<br>虽然现在不是了，哈哈。今天在这里是摘录了官方的一个tutor，类似于教程。<br>我们开始吧。</p><a id="more"></a><blockquote><p>vim 是一个具有很多命令的功能非常强大的编辑器。<br>本教程的设计目标是讲述一些必要的基本命令。<br>而掌握好这些命令，您就能够很容易将vim当作一个通用的万能编辑器来使用了。<br>完成本教程的内容大约需要25-30分钟，取决于您训练的时间。<br>每一节的命令操作将会更改本文。<br>推荐您复制本文的一个副本，然后在副本上进行训练(如果您是通过”vimtutor”来启动教程的，那么本文就已经是副本了)。<br>切记一点∶<strong>本教程的设计思路是在使用中进行学习的</strong>。也就是说，您需要通过执行命令来学习它们本身的正确用法。<br>如果您只是阅读而不操作，那么您可能会很快遗忘这些命令的！<br>好了，现在请确定您的Shift-Lock(大小写锁定键)还没有按下，然后按键盘上的字母键 j 足够多的次数来移动光标，直到第一节的内容能够完全充满屏幕。</p></blockquote><h2 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h2><h3 id="第一节∶移动光标"><a href="#第一节∶移动光标" class="headerlink" title="第一节∶移动光标"></a>第一节∶移动光标</h3><p>※※ 要移动光标，请依照说明分别按下 h、j、k、l 键。 ※※</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     ^</span><br><span class="line">     k      提示∶ h 的键位于左边，每次按下就会向左移动。</span><br><span class="line">&lt; h     l &gt;      l 的键位于右边，每次按下就会向右移动。</span><br><span class="line">     j           j 键看起来很象一支尖端方向朝下的箭头。</span><br><span class="line">     v</span><br></pre></td></tr></table></figure><blockquote><p>1.请随意在屏幕内移动光标，直至您觉得舒服为止。<br>2.按下下行键(j)，直到出现光标重复下行。     —&gt; 现在您应该已经学会如何移动到下一讲吧。<br>3.现在请使用下行键，将光标移动到第二讲。</p></blockquote><p>提示∶<br><strong>如果您不敢确定您所按下的字母，请按下<ESC>键回到正常(Normal)模式。然后再次从键盘输入您想要的命令。</strong></p><p>提示∶<br><strong>光标键应当也能正常工作的。但是使用hjkl键，在习惯之后您就能够快速地在屏幕内四处移动光标了。</strong></p><h3 id="第二节∶Vim的进入和退出"><a href="#第二节∶Vim的进入和退出" class="headerlink" title="第二节∶Vim的进入和退出"></a>第二节∶Vim的进入和退出</h3><p>!! 特别提示∶敬请阅读完整本一节的内容，然后才能执行以下所讲解的命令。<br>1.请按<code>&lt;ESC&gt;</code>键(这是为了确保您处在正常模式)。</p><p>2.然后输入∶ <code>:q! &lt;回车&gt;</code> —&gt; 这种方式的退出编辑器绝<strong>不会保存</strong>您进入编辑器以来所做的改动。<br>如果您想<strong>保存</strong>更改再退出，请输入∶ <code>:wq &lt;回车&gt;</code></p><p>3.如果您看到了命令行提示符，请输入能够带您回到本教程的命令，那就是∶ <code>vimtutor &lt;回车&gt;</code><br>通常情况下您也可以用这种方式∶<code>vim tutor &lt;回车&gt;</code>  —&gt; 这里的 ‘vim’ 表示进入vim编辑器，而 ‘tutor’则是您准备要编辑的文件。</p><p>4.如果您自信已经牢牢记住了这些步骤的话，请从步骤1执行到步骤3退出，然后再次进入编辑器。接着将光标移动到第一讲第三节来继续我们的教程讲解。</p><h3 id="第三节∶文本编辑之删除"><a href="#第三节∶文本编辑之删除" class="headerlink" title="第三节∶文本编辑之删除"></a>第三节∶文本编辑之删除</h3><p><strong>在正常(Normal)模式下，可以按下 x 键来删除光标所在位置的字符</strong></p><p>1.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>2.为了修正输入错误，请将光标移至准备删除的字符的位置处。</p><p>3.然后按下 x 键将错误字符删除掉。</p><p>4.重复步骤2到步骤4，直到句子修正为止。 —&gt; The ccow jumpedd ovverr thhe mooon.</p><p>5.好了，该行已经修正了，下一节内容是第一讲第四节。</p><p>特别提示∶在您浏览本教程时，不要强行记忆。记住一点∶<strong>在使用中学习</strong></p><h3 id="第四节∶文本编辑之插入"><a href="#第四节∶文本编辑之插入" class="headerlink" title="第四节∶文本编辑之插入"></a>第四节∶文本编辑之插入</h3><p>** 在正常模式下，可以按下 i 键来插入文本。**</p><p>1.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>2.为了使得第一行内容雷同于第二行，请将光标移至文本第一个字符准备插入的位置。</p><p>3.然后按下 i 键，接着输入必要的文本字符。</p><p>4.所有文本都修正完毕，请按下 <code>&lt;ESC&gt;</code> 键返回正常模式。<br>重复步骤2至步骤4以便修正句子。</p><p>—&gt; There is text misng this .<br>—&gt; There is some text missing from this line.</p><p>5.如果您对文本插入操作已经很满意，请接着阅读下面的小结。</p><h3 id="第一讲小结"><a href="#第一讲小结" class="headerlink" title="第一讲小结"></a>第一讲小结</h3><p>1.光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 <code>h (左移)</code>  <code>j (下行)</code> <code>k (上行)</code> <code>l (右移)</code></p><p>2.欲进入vim编辑器(从命令行提示符)，请输入<code>∶vim 文件名 &lt;回车&gt;</code></p><p>3.欲退出vim编辑器，请输入以下命令放弃所有修改∶ <code>&lt;ESC&gt;   :q!  &lt;回车&gt;</code><br>  或者输入以下命令保存所有修改∶ <code>&lt;ESC&gt;   :wq  &lt;回车&gt;</code></p><p>4.在正常模式下删除光标所在位置的字符，请按∶ <code>x</code></p><p>5.在正常模式下要在光标所在位置开始插入文本，请按∶ <code>i     输入必要文本 &lt;ESC&gt;</code></p><p>特别提示∶按下 <code>&lt;ESC&gt;</code> 键会带您回到正常模式或者取消一个不期望或者部分完成的命令。<br>好了，第一讲到此结束。下面接下来继续第二讲的内容。</p><h2 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h2><h3 id="第一节∶删除类命令"><a href="#第一节∶删除类命令" class="headerlink" title="第一节∶删除类命令"></a>第一节∶删除类命令</h3><p><strong>输入 <code>dw</code> 可以从光标处删除至一个单字/单词的末尾。</strong><br>1.请按下 <code>&lt;ESC&gt;</code> 键确保您处于正常模式。</p><p>2.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>3.请将光标移至准备要删除的单词的开始。</p><p>4.接着输入 dw 删除掉该单词。</p><p>特别提示∶您所输入的 dw 会在您输入的同时出现在屏幕的最后一行。如果您输入有误，请按下 <ESC> 键取消，然后重新再来。</p><p>—&gt; There are a some words fun that don’t belong paper in this sentence.</p><p>5.重复步骤3至步骤4，直至句子修正完毕。接着继续第二讲第二节内容。</p><h3 id="第二节∶其他删除类命令"><a href="#第二节∶其他删除类命令" class="headerlink" title="第二节∶其他删除类命令"></a>第二节∶其他删除类命令</h3><p><strong>输入 <code>d$</code> 从当前光标删除到行末。</strong></p><p>  1.请按下 <ESC> 键确保您处于正常模式。</p><p>  2.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>  3.请将光标移动到该行的尾部(也就是在第一个点号‘.’后面)。</p><p>  4.然后输入 d$ 从光标处删至当前行尾部。</p><p>—&gt; Somebody typed the end of this line twice. end of this line twice.</p><p>  5.请继续学习第二讲第三节就知道是怎么回事了。</p><h3 id="第三节∶关于命令和对象"><a href="#第三节∶关于命令和对象" class="headerlink" title="第三节∶关于命令和对象"></a>第三节∶关于命令和对象</h3><p>删除命令 <code>d</code> 的格式如下∶<br><code>[number] d object</code> 或者 <code>d [number] object</code></p><p>其意如下∶</p><blockquote><p><code>number</code> - 代表执行命令的次数(可选项，缺省设置为 1 )。<br><code>d</code> - 代表删除。<br><code>object</code> - 代表命令所要操作的对象(下面有相关介绍)。</p></blockquote><p>一个简短的对象列表∶</p><blockquote><p><code>w</code> - 从当前光标当前位置直到单字/单词末尾，包括空格。<br><code>e</code> - 从当前光标当前位置直到单字/单词末尾，但是 不 包括空格。<br><code>$</code> - 从当前光标当前位置直到当前行末。</p></blockquote><p>特别提示∶<br>对于勇于探索者，请在正常模式下面仅按代表相应对象的键而不使用命令，则将看到光标的移动正如上面的对象列表所代表的一样。</p><h3 id="第四节∶对象命令的特殊情况"><a href="#第四节∶对象命令的特殊情况" class="headerlink" title="第四节∶对象命令的特殊情况"></a>第四节∶对象命令的特殊情况</h3><p><strong>输入 <code>dd</code> 可以删除整一个当前行。</strong></p><p>鉴于整行删除的高频度，VIM 的设计者决定要简化整行删除，仅需要在同一行上击打两次 d 就可以删除掉光标所在的整行了。<br>  1.请将光标移动到本节中下面的短句段落中的第二行。<br>  2.输入 <code>dd</code> 删除该行。<br>  3.然后移动到第四行。<br>  4.接着输入 <code>2dd</code> (还记得前面讲过的 number-command-object 吗？) 删除两行。</p><blockquote><p>Roses are red,<br>Mud is fun,<br>Violets are blue,<br>I have a car,<br>Clocks tell time,<br>Sugar is sweet<br>And so are you.</p></blockquote><h3 id="第五节∶撤消类命令"><a href="#第五节∶撤消类命令" class="headerlink" title="第五节∶撤消类命令"></a>第五节∶撤消类命令</h3><p><strong>输入 <code>u</code> 来撤消最后执行的命令，输入 <code>U</code> 来修正整行。</strong></p><p>1.请将光标移动到本节中下面标记有 —&gt; 的那一行，并将其置于第一个错误处。<br>2.输入 <code>x</code> 删除第一个不想保留的字母。<br>3.然后输入 <code>u</code> 撤消最后执行的(一次)命令。<br>4.这次要使用 <code>x</code> 修正本行的所有错误。<br>5.现在输入一个大写的 <code>U</code> ，恢复到该行的原始状态。<br>6.接着多次输入 <code>u</code> 以撤消 <code>U</code> 以及更前的命令。<br>7.然后多次输入 <code>CTRL-R</code> (先按下 CTRL 键不放开，接着输入 R 键) ，这样就可以执行恢复命令，也就是撤消掉撤消命令。</p><p>—&gt; Fiix the errors oon thhis line and reeplace them witth undo.</p><p>8.这些都是非常有用的命令。下面是第二讲的小结了。</p><h3 id="第二讲小结"><a href="#第二讲小结" class="headerlink" title="第二讲小结"></a>第二讲小结</h3><p>1.欲从当前光标删除至单字/单词末尾，请输入∶<code>dw</code></p><p>2.欲从当前光标删除至当前行末尾，请输入∶<code>d$</code></p><p>3.欲删除整行，请输入∶<code>dd</code></p><p>4.在正常模式下一个命令的格式是∶ <code>[number]   command   object</code>     或者     <code>command [number]   object</code><br>   其意是∶</p><blockquote><p><code>number</code> - 代表的是命令执行的次数<br><code>command</code> - 代表要做的事情，比如 d 代表删除<br><code>object</code> - 代表要操作的对象，比如 w 代表单字/单词，$ 代表到行末等等。<br>$ (to the end of line), etc.</p></blockquote><p>5.欲撤消以前的操作，请输入∶<code>u</code> (小写的u)<br>   欲撤消在一行中所做的改动，请输入∶<code>U</code> (大写的U)<br>   欲撤消以前的撤消命令，恢复以前的操作结果，请输入∶<code>CTRL-R</code></p><h2 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h2><h3 id="第一节∶置入类命令"><a href="#第一节∶置入类命令" class="headerlink" title="第一节∶置入类命令"></a>第一节∶置入类命令</h3><p><strong>输入 <code>p</code> 将最后一次删除的内容置入光标之后</strong><br>1.请将光标移动到本节中下面示范段落的首行。</p><p>2.输入 dd 将该行删除，这样会将该行保存到vim的缓冲区中。</p><p>3.接着将光标移动到准备置入的位置的上方。记住∶是上方哦。</p><p>4.然后在正常模式下(<ESC>键进入)，输入 p 将该行粘贴置入。</p><p>5.重复步骤2至步骤4，将所有的行依序放置到正确的位置上。</p><blockquote><p>Can you learn too?<br>Violets are blue,<br>Intelligence is learned,<br>Roses are red,                                 </p></blockquote><h3 id="第二节∶替换类命令"><a href="#第二节∶替换类命令" class="headerlink" title="第二节∶替换类命令"></a>第二节∶替换类命令</h3><p><strong>输入 <code>r</code> 和一个字符替换光标所在位置的字符。</strong></p><p>  1.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>  2.请移动光标到第一个错误的适当位置。</p><p>  3.接着输入 <code>r</code> ，这样就能将错误替换掉了。</p><p>  4.重复步骤2和步骤3，直到第一行已经修改完毕。</p><p>—&gt;  Whan this lime was tuoed in, someone presswd some wrojg keys!<br>—&gt;  When this line was typed in, someone pressed some wrong keys!</p><p>  5.然后我们继续学校第三讲第三节。</p><p>特别提示∶切记您要在使用中学习，而不是在记忆中学习。</p><h3 id="第三节∶更改类命令"><a href="#第三节∶更改类命令" class="headerlink" title="第三节∶更改类命令"></a>第三节∶更改类命令</h3><p><strong>要改变一个单字/单词的部分或者全部，请输入 <code>cw</code></strong><br>1.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>2.接着把光标放在单词 lubw 的字母 <code>u</code> 的位置那里。</p><p>3.然后输入 <code>cw</code> 就可以修正该单词了(在本例这里是输入 ine 。)</p><p>4.最后按 <code>&lt;ESC&gt;</code> 键，然后光标定位到下一个错误第一个准备更改的字母处。</p><p>5.重复步骤3和步骤4，直到第一个句子完全雷同第二个句子。</p><p>—&gt; This lubw has a few wptfd that mrrf changing usf the change command.<br>—&gt; This line has a few words that need changing using the change command.</p><p>提示∶请注意 <code>cw</code> 命令不仅仅是替换了一个单词，也让您进入文本插入状态了。</p><h3 id="第四节∶使用c指令的其他更改类命令"><a href="#第四节∶使用c指令的其他更改类命令" class="headerlink" title="第四节∶使用c指令的其他更改类命令"></a>第四节∶使用c指令的其他更改类命令</h3><p><strong>更改类指令可以使用同删除类命令所使用的对象参数。</strong></p><p>  1.更改类指令的工作方式跟删除类命令是一致的。操作格式是∶ <code>[number]   c   object</code> 或者   <code>c [number]   object</code></p><p>  2.对象参数也是一样的，比如 <code>w</code> 代表单字/单词，<code>$</code>代表行末等等。</p><p>  3.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>  4.接着将光标移动到第一个错误处。</p><p>  5.然后输入 <code>c$</code> 使得该行剩下的部分更正得同第二行一样。最后按 <code>&lt;ESC&gt;</code> 键。</p><p>—&gt; The end of this line needs some help to make it like the second.<br>—&gt; The end of this line needs to be corrected using the  c$  command.</p><h3 id="第三讲小结"><a href="#第三讲小结" class="headerlink" title="第三讲小结"></a>第三讲小结</h3><p>1.要重新置入已经删除的文本内容，请输入小写字母 p。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。</p><p>2.要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。</p><p>3.更改类命令允许您改变指定的对象，从当前光标所在位置直到对象的末尾。比如输入 cw 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。</p><p>4.更改类命令的格式是∶ <code>[number] c object</code> 或者 <code>c [number] object</code></p><h2 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h2><h3 id="第一节∶定位及文件状态"><a href="#第一节∶定位及文件状态" class="headerlink" title="第一节∶定位及文件状态"></a>第一节∶定位及文件状态</h3><p><strong>输入 <code>CTRL-g</code> 显示当前编辑文件中当前光标所在行位置以及文件状态信息。输入 <code>SHIFT-G</code> 则直接跳转到文件中的某一指定行。</strong><br>提示∶切记要先通读本节内容，之后才可以执行以下步骤!!!</p><p>  1.按下 <code>CTRL</code> 键不放开然后按 <code>g</code> 键。然后就会看到页面最底部出现一个状态信息行，显示的内容是当前编辑的文件名和文件的总行数。请记住步骤3的行号。</p><p>  2.按下 <code>SHIFT-G</code> 键可以使得当前光标直接跳转到文件最后一行。</p><p>  3.输入您曾停留的行号，然后按下 <code>SHIFT-G</code>。这样就可以返回到您第一次按下<code>CTRL-g</code> 时所在的行好了。注意∶输入行号时，行号是不会在屏幕上显示出来的。</p><p>  4.如果愿意，您可以继续执行步骤1至步骤三。</p><h3 id="第二节∶搜索类命令"><a href="#第二节∶搜索类命令" class="headerlink" title="第二节∶搜索类命令"></a>第二节∶搜索类命令</h3><p><strong>输入 <code>/</code> 以及尾随的字符串可以用以在当前文件中查找该字符串。</strong><br>1.在正常模式下输入 <code>/</code> 字符。您此时会注意到该字符和光标都会出现在屏幕底部，这跟 <code>:</code> 命令是一样的。</p><p>2.接着输入 <code>errroor &lt;回车&gt;</code>。那个<code>errroor</code>就是您要查找的字符串。</p><p>3.要查找同上一次的字符串，只需要按 <code>n</code> 键。要向相反方向查找同上一次的字符串，请输入 <code>Shift-N</code> 即可。</p><p>4.如果您想逆向查找字符串，请使用 <code>?</code> 代替 <code>/</code> 进行。</p><p>—&gt; When the search reaches the end of the file it will continue at the start.</p><p>“errroor” is not the way to spell error; errroor is an error.</p><p>提示∶如果查找已经到达文件末尾，查找会自动从文件头部继续查找。</p><h3 id="第三节∶配对括号的查找"><a href="#第三节∶配对括号的查找" class="headerlink" title="第三节∶配对括号的查找"></a>第三节∶配对括号的查找</h3><p><strong>按 <code>%</code> 可以查找配对的括号 )、]、}。</strong></p><p>  1.把光标放在本节下面标记有 –&gt; 那一行中的任何一个 (、[ 或 { 处。</p><p>  2.接着按 <code>%</code> 字符。</p><p>  3.此时光标的位置应当是在配对的括号处。</p><p>  4.再次按 <code>%</code> 就可以跳回配对的第一个括号处。</p><p>—&gt; This ( is a test line with (‘s, [‘s ] and {‘s } in it. ))</p><p>提示∶在程序调试时，这个功能用来查找不配对的括号是很有用的。</p><h3 id="第四节∶修正错误的方法之一"><a href="#第四节∶修正错误的方法之一" class="headerlink" title="第四节∶修正错误的方法之一"></a>第四节∶修正错误的方法之一</h3><p><strong>输入 <code>:s/old/new/g</code> 可以替换 old 为 new。</strong><br>1.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>2.输入 <code>:s/thee/the &lt;回车&gt;</code> 。请注意该命令只改变光标所在行的第一个匹配串。</p><p>3.输入 <code>:s/thee/the/g</code> 则是替换全行的匹配串。</p><p>—&gt; the best time to see thee flowers is in thee spring.</p><p>4.要替换两行之间出现的每个匹配串，请输入 <code>:#,#s/old/new/g</code> (#,#代表的是两行的行号)。<br>输入 <code>:%s/old/new/g</code> 则是替换整个文件中的每个匹配串。</p><h3 id="第四讲小结"><a href="#第四讲小结" class="headerlink" title="第四讲小结"></a>第四讲小结</h3><p>  1.<code>Ctrl-g</code> 用于显示当前光标所在位置和文件状态信息。<code>Shift-G</code> 用于将光标跳转至文件最后一行。先敲入一个行号然后按 <code>Shift-G</code> 则是将光标移动至该行号代表的行。</p><p>  2.输入 <code>/</code> 然后紧随一个字符串是则是在当前所编辑的文档中向后查找该字符串。输入问号 <code>?</code> 然后紧随一个字符串是则是在当前所编辑的文档中向前查找该字符串。<br>  完成一次查找之后按 <code>n</code> 键则是重复上一次的命令，可在同一方向上查找下一个字符串所在；或者按 <code>Shift-N</code> 向相反方向查找下该字符串所在。</p><p>  3.如果光标当前位置是括号(、)、[、]、{、}，按 <code>%</code> 可以将光标移动到配对的括号上。</p><p>  4.在一行内替换头一个字符串 old 为新的字符串 new，请输入  <code>:s/old/new</code><br>     在一行内替换所有的字符串 old 为新的字符串 new，请输入  <code>:s/old/new/g</code><br>     在两行内替换所有的字符串 old 为新的字符串 new，请输入  <code>:#,#s/old/new/g</code><br>     在文件内替换所有的字符串 old 为新的字符串 new，请输入  <code>:%s/old/new/g</code><br>     进行全文替换时询问用户确认每个替换需添加 c 选项，请输入 <code>:%s/old/new/gc</code></p><h2 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h2><h3 id="第一节∶在-VIM-内执行外部命令的方法"><a href="#第一节∶在-VIM-内执行外部命令的方法" class="headerlink" title="第一节∶在 VIM 内执行外部命令的方法"></a>第一节∶在 VIM 内执行外部命令的方法</h3><p><strong>输入 <code>:!</code> 然后紧随著输入一个外部命令可以执行该外部命令。</strong><br>1.按下我们所熟悉的 <code>:</code> 命令设置光标到屏幕底部。这样就可以让您输入命令了。</p><p>2.接着输入感叹号 <code>!</code> 这个字符，这样就允许您执行外部的 shell 命令了。</p><p>3.我们以 <code>ls</code> 命令为例。输入 <code>!ls &lt;回车&gt;</code> 。<br>该命令就会列举出您当前目录的内容，就如同您在命令行提示符下输入 <code>ls</code> 命令的结果一样。<br>如果 <code>!ls</code> 没起作用，您可以试试 <code>:!dir</code> 看看。</p><p>—&gt; 提示∶ 所有的外部命令都可以以这种方式执行。</p><p>—&gt; 提示∶ 所有的 <code>:</code> 命令都必须以 <code>&lt;回车&gt;</code> 告终。</p><h3 id="第二节∶关于保存文件的更多信息"><a href="#第二节∶关于保存文件的更多信息" class="headerlink" title="第二节∶关于保存文件的更多信息"></a>第二节∶关于保存文件的更多信息</h3><p><strong>要将对文件的改动保存到文件中，请输入 <code>:w FILENAME</code>。</strong></p><p>  1.输入 <code>:!dir</code> 或者 <code>:!ls</code> 获知当前目录的内容。您应当已知道最后还得敲 <code>&lt;回车&gt;</code> 吧。</p><p>  2.选择一个尚未存在文件名，比如 TEST 。</p><p>  3.接着输入 <code>:w TEST</code>  (此处 TEST 是您所选择的文件名。)</p><p>  4.该命令会以 TEST 为文件名保存整个文件 (VIM 教程)。为了确保正确保存，请再次输入 <code>:!dir</code> 查看您的目录列表内容。</p><p>—&gt; 请注意∶如果您退出 VIM 然后在以文件名 TEST 为参数进入，那么该文件内容应该同您保存时的文件内容是完全一样的。</p><p>  5.现在您可以通过输入 <code>:!rm TEST</code> 来删除 TEST 文件了。</p><h3 id="第三节∶一个具有选择性的保存命令"><a href="#第三节∶一个具有选择性的保存命令" class="headerlink" title="第三节∶一个具有选择性的保存命令"></a>第三节∶一个具有选择性的保存命令</h3><p><strong>要保存文件的部分内容，请输入 <code>:#,# w FILENAME</code></strong></p><p>1.再来执行一次 <code>:!dir</code> 或者 <code>:!ls</code> 获知当前目录的内容，然后选择一个合适的不重名的文件名，比如 TEST 。</p><p>2.接着将光标移动至本页的最顶端，然后按 <code>CTRL-g</code> 找到该行的行号。别忘了行号哦。</p><p>3.接着把光标移动至本页的最底端，再按一次 <code>CTRL-g</code> 。也别忘了这个行好哦。</p><p>4.为了只保存文章的某个部分，请输入 <code>:#,# w TEST</code>。这里的 <code>#</code>,<code>#</code> 就是上面要求您记住的行号(顶端行号,底端行号)，而 TEST 就是选定的文件名。</p><p>5.最后，用 <code>:!dir</code> 确认文件是否正确保存。但是这次先别删除掉。</p><h3 id="第四节∶提取和合并文件"><a href="#第四节∶提取和合并文件" class="headerlink" title="第四节∶提取和合并文件"></a>第四节∶提取和合并文件</h3><p><strong>要向当前文件中插入另外的文件的内容，请输入 <code>:r FILENAME</code></strong></p><p>  1.请键入 <code>:!dir</code> 确认您前面创建的 TEST 文件还在。</p><p>  2.然后将光标移动至当前页面的顶端。</p><p>特别提示∶ 执行步骤3之后您将看到第五讲第三节，请届时再往下移动回到这里来。</p><p>  3.接着通过 <code>:r TEST</code> 将前面创建的名为 TEST 的文件提取进来。</p><p>特别提示∶您所提取进来的文件将从光标所在位置处开始置入。</p><p>  4.为了确认文件已经提取成功，移动光标回到原来的位置就可以注意有两份第五讲第三节，一份是原本，另外一份是来自文件的副本。</p><h3 id="第五讲小结"><a href="#第五讲小结" class="headerlink" title="第五讲小结"></a>第五讲小结</h3><p>1.<code>:!command</code> 用于执行一个外部命令 command。</p><p>请看一些实际例子∶<br><code>:!dir</code> - 用于显示当前目录的内容。<br><code>:!rm FILENAME</code> - 用于删除名为 FILENAME 的文件。</p><p>2.<code>:w FILENAME</code> 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。</p><p>3.<code>:#,#w FILENAME</code> 可将当前编辑文件第 # 行至第 # 行的内容保存到文件FILENAME 中。</p><p>4.<code>:r FILENAME</code> 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。</p><h2 id="第六讲"><a href="#第六讲" class="headerlink" title="第六讲"></a>第六讲</h2><h3 id="第一节∶打开类命令"><a href="#第一节∶打开类命令" class="headerlink" title="第一节∶打开类命令"></a>第一节∶打开类命令</h3><p><strong>输入 <code>o</code> 将在光标的下方打开新的一行并进入插入模式。</strong></p><p>  1.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>  2.接着输入小写的 <code>o</code> 在光标 <em>下方</em> 打开新的一行并进入插入模式。</p><p>  3.然后复制标记有 —&gt; 的行并按 <code>&lt;ESC&gt;</code> 键退出插入模式而进入正常模式。</p><p>—&gt; After typing  o  the cursor is placed on the open line in Insert mode.</p><p>  4.为了在光标 <em>上方</em> 打开新的一行，只需要输入大写的 <code>O</code> 而不是小写的 <code>o</code> 就可以了。请在下行测试一下吧。当光标处在在该行上时，按 Shift-O可以在该行上方新开一行。</p><p>Open up a line above this by typing Shift-O while the cursor is on this line.</p><h3 id="第二节∶光标后插入类命令"><a href="#第二节∶光标后插入类命令" class="headerlink" title="第二节∶光标后插入类命令"></a>第二节∶光标后插入类命令</h3><p><strong>输入 <code>a</code> 将可在光标之后插入文本</strong><br>1.请在正常模式下通过输入 <code>$</code> 将光标移动到本节中下面标记有 —&gt; 的第一行的末尾。</p><p>2.接着输入小写的 <code>a</code> 则可在光标之后插入文本了。大写的 <code>A</code> 则可以直接在行末插入文本。</p><p>提示∶输入大写 <code>A</code> 的操作方法可以在行末插入文本，避免了输入 <code>i</code>，光标定位到最后一个字符，输入的文本，<code>&lt;ESC&gt;</code> 回复正常模式，箭头右键移动光标以及<code>x</code> 删除当前光标所在位置字符等等诸多繁杂的操作。</p><p>3.操作之后第一行就可以补充完整了。请注意光标后插入文本与插入模式是基本完全一致的，只是文本插入的位置定位稍有不同罢了。</p><p>—&gt; This line will allow you to practice<br>—&gt; This line will allow you to practice appending text to the end of a line.</p><h3 id="第三节∶另外一个置换类命令的版本"><a href="#第三节∶另外一个置换类命令的版本" class="headerlink" title="第三节∶另外一个置换类命令的版本"></a>第三节∶另外一个置换类命令的版本</h3><p><strong>输入大写的 <code>R</code> 可连续替换多个字符。</strong></p><p>  1.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>  2.移动光标到第一行中不同于标有 —&gt; 的第二行的第一个单词的开始，即单词 last 处。</p><p>  3.然后输入大写的 <code>R</code> 开始把第一行中的不同于第二行的剩余字符逐一输入，就可以全部替换掉原有的字符而使得第一行完全雷同第二行了。</p><p>—&gt; To make the first line the same as the last on this page use the keys.<br>—&gt; To make the first line the same as the second, type R and the new text.</p><p>  4.请注意∶如果您按 <code>&lt;ESC&gt;</code> 退出置换模式回复正常模式，尚未替换的文本将仍然保持原状。</p><h3 id="第四节∶设置类命令的选项"><a href="#第四节∶设置类命令的选项" class="headerlink" title="第四节∶设置类命令的选项"></a>第四节∶设置类命令的选项</h3><p>*<em>设置可使查找或者替换可忽略大小写的选项 *</em><br>1.要查找单词 ignore 可在正常模式下输入 <code>/ignore</code> 。要重复查找该词，可以重复按 <code>n</code> 键。</p><p>2.然后设置 <code>ic</code> 选项(ic就是英文忽略大小写Ignore Case的首字母缩写词)，即输入∶ <code>:set ic</code></p><p>3.现在可以通过键入 <code>n</code> 键再次查找单词 ignore。重复查找可以重复键入 <code>n</code> 键。</p><p>4.然后设置 hlsearch 和 incsearch 这两个选项，输入以下内容∶ <code>:set hls is</code></p><p>5.现在可以再次输入查找命令，看看会有什么效果∶ <code>/ignore</code></p><h3 id="第六讲小结"><a href="#第六讲小结" class="headerlink" title="第六讲小结"></a>第六讲小结</h3><p>  1.输入小写的 <code>o</code> 可以在光标下方打开新的一行并将光标置于新开的行首，进入插入模式。<br>    输入大写的 <code>O</code> 可以在光标上方打开新的一行并将光标置于新开的行首，进入插入模式。</p><p>  2.输入小写的 <code>a</code> 可以在光标所在位置之后插入文本。<br>    输入大写的 <code>A</code> 可以在光标所在行的行末之后插入文本。</p><p>  3.输入大写的 <code>R</code> 将进入替换模式，直至按 <code>&lt;ESC&gt;</code> 键退出替换模式而进入正常模式。</p><p>  4.输入 <code>:set xxx</code> 可以设置 xxx 选项。</p><h3 id="第七讲∶在线帮助命令"><a href="#第七讲∶在线帮助命令" class="headerlink" title="第七讲∶在线帮助命令"></a>第七讲∶在线帮助命令</h3><p><strong>使用在线帮助系统</strong><br>Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方法之一∶</p><p>按下 <code>&lt;HELP&gt;</code> 键 (如果键盘上有的话)<br>按下 <code>&lt;F1&gt;</code> 键 (如果键盘上有的话)<br>输入 <code>:help &lt;回车&gt;</code><br>输入 <code>:q &lt;回车&gt;</code> 可以关闭帮助窗口。</p><p>提供一个正确的参数给”:help”命令，您可以找到关于该主题的帮助。请试验以下参数(可别忘了按回车键哦。)</p><p><code>:help w &lt;回车&gt;</code><br><code>:help c_&lt;T &lt;回车&gt;</code><br><code>:help insert-index &lt;回车&gt;</code><br><code>:help user-manual &lt;回车&gt;</code></p><h3 id="第八讲∶创建一个启动脚本"><a href="#第八讲∶创建一个启动脚本" class="headerlink" title="第八讲∶创建一个启动脚本"></a>第八讲∶创建一个启动脚本</h3><p><strong>启用vim的功能</strong></p><p>Vim的功能特性要比vi多得多，但大部分功能都没有缺省激活。为了启动更多的功能，您得创建一个vimrc文件。</p><p>  1.开始编辑vimrc文件，这取决于您所使用的操作系统∶<br>  <code>:edit ~/.vimrc</code>  这是Unix系统所使用的命令<br>  <code>:edit $VIM/_vimrc</code>  这是Windows系统所使用的命令</p><p>  2.接着导入vimrc范例文件∶ <code>:read $VIMRUNTIME/vimrc_example.vim</code></p><p>  3.保存文件，命令为∶ <code>:write</code></p><p>  在下次您启动vim的时候，编辑器就会有了语法高亮的功能。您可以继续把您喜欢的其它功能设置添加到这个vimrc文件中。</p><p>  阅读vim手册，使用的命令是∶ <code>:help user-manual</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到别人在用一款及其酷炫的编辑器 &lt;strong&gt;vim&lt;/strong&gt; ，操作起来的场景就是自己最初对程序员的认识。&lt;br&gt;虽然现在不是了，哈哈。今天在这里是摘录了官方的一个tutor，类似于教程。&lt;br&gt;我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/categories/vim/"/>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/tags/vim/"/>
    
      <category term="tutor" scheme="https://jambo0624.github.io/tags/tutor/"/>
    
  </entry>
  
  <entry>
    <title>ES6新增的数组和字符串API</title>
    <link href="https://jambo0624.github.io/2019-11-24-es6-new-array-api.html"/>
    <id>https://jambo0624.github.io/2019-11-24-es6-new-array-api.html</id>
    <published>2019-11-24T01:07:44.000Z</published>
    <updated>2020-10-15T09:22:37.520Z</updated>
    
    <content type="html"><![CDATA[<p>之前整理过 string 和 array 的API，最近发现好多没有总结到的。ES6新出，用的比较少的，在这里补充一下。<br>话不多说，我们开始吧。</p><a id="more"></a><h3 id="es6数组新增API"><a href="#es6数组新增API" class="headerlink" title="es6数组新增API"></a>es6数组新增API</h3><p>ES6新增数组的方法</p><ul><li>Array.from()<br>Array.from 方法用于将两类对象转为真正的数组：<br>类似数组的对象（array-like object）<br>可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）    </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="string">"1"</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="string">"2"</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike)   <span class="comment">//[a, b, c]</span></span><br><span class="line"><span class="comment">//ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike) <span class="comment">//[a, b, c]</span></span><br><span class="line"><span class="comment">// 任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</span></span><br><span class="line"><span class="comment">// 扩展运算符只能对部署 Iterator 接口的类数组转换为真正的数组 </span></span><br><span class="line"><span class="comment">// console.log([...arrayLike]); // 报错 TypeError: Cannot spread non-iterable object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from还可以接受第二个参数，作用类似于数组的map方法</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.from(arrayLike, x =&gt; x + x)</span><br><span class="line"><span class="built_in">console</span>.log(map)  <span class="comment">// [aa,bb,cc]</span></span><br></pre></td></tr></table></figure><ul><li><p>Array.of()<br>Array.of 方法用于将一组值，转换为数组。弥补数组构造函数 Array()的不足。因为参数个数的不同，会导致 Array()的行为有差异    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下代码看出差异</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3,11,8]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3, 11, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.of方法可以用下面的代码模拟实现。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组实例的 find() 和 findIndex()<br>=&gt; find()方法找到第一个符合条件的成员,没有符合的则返回 undefined<br>=&gt; findIndex 方法的用法与 find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find()</span></span><br><span class="line"><span class="keyword">var</span> item = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// -5</span></span><br><span class="line"><span class="comment">// find 也支持这种复杂的查找</span></span><br><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">20</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">30</span>, <span class="attr">y</span>: <span class="number">40</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">40</span>, <span class="attr">y</span>: <span class="number">50</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>: <span class="number">60</span> &#125;</span><br><span class="line">];</span><br><span class="line">points.find(<span class="function"><span class="keyword">function</span> <span class="title">macther</span>(<span class="params">point</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point.x % <span class="number">3</span> === <span class="number">0</span> &amp;&amp; point.y % <span class="number">4</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>=&gt; findIndex()返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1<br>=&gt; indexOf(..) 会提供这些，但是无法控制匹配逻辑；它总是使用 === 严格相等。所以 ES6 的 findIndex(..) 才是解决方案    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">20</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">30</span>, <span class="attr">y</span>: <span class="number">40</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">40</span>, <span class="attr">y</span>: <span class="number">50</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>: <span class="number">60</span> &#125;</span><br><span class="line">];</span><br><span class="line">points.findIndex(<span class="function"><span class="keyword">function</span> <span class="title">matcher</span>(<span class="params">point</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point.x % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; point.y % <span class="number">4</span> == <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">// 2</span></span><br><span class="line">points.findIndex(<span class="function"><span class="keyword">function</span> <span class="title">matcher</span>(<span class="params">point</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point.x % <span class="number">6</span> == <span class="number">0</span> &amp;&amp; point.y % <span class="number">7</span> == <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><ul><li><p>数组实例的 fill()<br>=&gt; fill()方法使用给定值， 填充一个数组<br>=&gt; fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置   </p><pre class="line-numbers language-js"><span class="comment"><code class="language-js"><span class="comment">// fill方法使用给定值， 填充一个数组</span><span class="keyword">var</span> fillArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>).fill(<span class="number">1</span>)<span class="built_in">console</span>.log(fillArray)  <span class="comment">//[1,1,1,1,1,1]</span><span class="comment">//fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// ['a', 7, 'c']</span><span class="comment">// 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</span><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill({  name: <span class="string">"Mike"</span>})arr[<span class="number">0</span>].name = <span class="string">'Ben'</span><span class="built_in">console</span>.log(arr) <span class="comment">// [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>数组实例的 entries()，keys() 和 values()<br>entries()，keys()和 values()——用于遍历数组,可以用 for…of 循环进行遍历<br>唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历    </p><pre class="line-numbers language-js"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string"><code class="language-js"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].keys()) {  <span class="built_in">console</span>.log(index);}<span class="comment">// 0 1</span><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].values()) {  <span class="built_in">console</span>.log(elem);}<span class="comment">// a b</span><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].entries()) {  <span class="built_in">console</span>.log(index, elem);}<span class="comment">// 0 "a"</span><span class="comment">// 1 "b"</span><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];[...a.values()]; <span class="comment">// [1,2,3]</span>[...a.keys()]; <span class="comment">// [0,1,2]</span>[...a.entries()]; <span class="comment">// [ [0,1], [1,2], [2,3] ]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>includes()方法返回一个布尔值</p><pre class="line-numbers language-js">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>) <span class="comment"><code class="language-js">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>) <span class="comment">// true</span>[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].includes(<span class="number">4</span>) <span class="comment">// false</span>[(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>)].includes(<span class="literal">NaN</span>); <span class="comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>includes 方法弥补了 indexOf 方法不够语义化和误判 NaN 的缺点    </p><ul><li>数组实例的 flat()，flatMap()<br>=&gt; flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法<strong>返回一个新数组</strong>，对原数据没有影响。传参数代表拉平几层默认是一层<br>=&gt; flatMap()只能展开一层数组。方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法。该方法返回一个新数组，不改变原数组    <pre class="line-numbers language-js"><span class="comment"><code class="language-js"><span class="comment">// flat()</span>[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()   <span class="comment">// [1, 2, 3, [4, 5]]</span>[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)    <span class="comment">// [1, 2, 3, 4, 5]</span><span class="comment">//flatMap()</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =></span> [x, x * <span class="number">2</span>])  <span class="comment">//map执行完后是[[2, 4], [3, 6], [4, 8]]</span><span class="comment">// 然后在执行flat()方法得到下边的结果  // [2, 4, 3, 6, 4, 8]</span><span class="comment">// flatMap()只能展开一层数组  // 相当于 .flat()</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =></span> [ [x * <span class="number">2</span>] ])<span class="comment">// map执行完后是[[[2]], [[4]], [[6]], [[8]]]</span><span class="comment">// 然后在执行flat()方法得到如下结果</span><span class="comment">// [[2], [4], [6], [8]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="字符串API比较少"><a href="#字符串API比较少" class="headerlink" title="字符串API比较少"></a>字符串API比较少</h3><ul><li>includes(), startsWith(), endsWith()（常用）    </li><li>repeat()         </li><li>padStart()， padEnd()   –作用联想padding     </li><li>模板字符串          </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前整理过 string 和 array 的API，最近发现好多没有总结到的。ES6新出，用的比较少的，在这里补充一下。&lt;br&gt;话不多说，我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="array" scheme="https://jambo0624.github.io/tags/array/"/>
    
      <category term="string" scheme="https://jambo0624.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>const-let-var的区别</title>
    <link href="https://jambo0624.github.io/2019-11-09-const-let-var.html"/>
    <id>https://jambo0624.github.io/2019-11-09-const-let-var.html</id>
    <published>2019-11-09T10:17:35.000Z</published>
    <updated>2020-10-15T09:06:35.524Z</updated>
    
    <content type="html"><![CDATA[<p>let和const作为新的定义变量的方式，解决了var定义变量存在的一些问题。<br>但是前些天同时问我 const 定义的变量可不可更改，我只知道我们通常不会更改，但是其实也不是的。<br>某些情况还是可以更改的，于是我打算对这些情况一探究竟。<br>话不多说，我们开始吧。</p><a id="more"></a><p>首先，var定义变量存在的问题主要是  </p><ol><li>变量声明提升 </li><li>JS没有块级作用域</li><li>循环内变量过度共享，代码如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台输出了3个3</span></span><br></pre></td></tr></table></figure></li></ol><p>下面依次介绍let和const</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>let声明的变量拥有块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'a'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>let声明的全局变量不是全局对象的属性<br>这就意味着，你不可以通过window.变量名的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的外层块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="string">'c'</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">'d'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">//c</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.d) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li><li><p>形如for (let x…)的循环在每次迭代时都为x创建新的绑定<br>正因为let声明的变量不在全局中，而在一个不可见的作用域中。<br>所以，如果for循环执行多次并且循环保持了一个闭包，那么每个闭包将捕捉一个循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台输出1 2 3</span></span><br></pre></td></tr></table></figure></li></ul><p>这种情况适用于现有的三种循环方式：for-of、for-in、以及传统的用分号分隔的类C循环</p><ul><li>用let重定义变量会抛出一个语法错误（SyntaxError）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'b'</span> <span class="comment">// Uncaught SyntaxError:Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>在这些不同之外，let和var几乎很相似了。举个例子，它们都支持使用逗号分隔声明多重变量，它们也都支持解构特性。</strong></p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>一句话说明白，const 就是用来定义常量的！任何非主流的写法都是非法的<br>比如这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只声明变量不赋值</span></span><br><span class="line"><span class="keyword">const</span> a  <span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p>这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复声明变量</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'b'</span> <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><p>还有这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给变量重新赋值</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span></span><br><span class="line">a = <span class="string">'b'</span> <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><p>最后是经常容易忽略的特殊情况,看似黑科技</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不过不推荐这么干，实在没啥意思，常量常量，不变的才叫常量嘛~</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="comment">//重新赋值当然是行不通的了</span></span><br><span class="line">a = &#123;<span class="attr">a</span>:<span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="comment">//嘿嘿嘿科技</span></span><br><span class="line">a.a = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>其实不是黑科技</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="string">'a'</span>&#125;;  <span class="comment">// 绑定的是对象指针</span></span><br><span class="line"><span class="comment">//重新赋值当然是行不通的了</span></span><br><span class="line">a = &#123;<span class="attr">a</span>:<span class="string">'b'</span>&#125;;  <span class="comment">// 绑定新对象的指针</span></span><br><span class="line"><span class="comment">//并不是科技</span></span><br><span class="line">a.a = <span class="string">'b'</span> <span class="comment">// 对象指针没变，指针指向的内容可以随意改变。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;let和const作为新的定义变量的方式，解决了var定义变量存在的一些问题。&lt;br&gt;但是前些天同时问我 const 定义的变量可不可更改，我只知道我们通常不会更改，但是其实也不是的。&lt;br&gt;某些情况还是可以更改的，于是我打算对这些情况一探究竟。&lt;br&gt;话不多说，我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="basic" scheme="https://jambo0624.github.io/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>scss 知识点整理</title>
    <link href="https://jambo0624.github.io/2019-10-25-scss.html"/>
    <id>https://jambo0624.github.io/2019-10-25-scss.html</id>
    <published>2019-10-25T12:47:28.000Z</published>
    <updated>2020-10-15T08:57:38.945Z</updated>
    
    <content type="html"><![CDATA[<p>用了很久的 css 预处理工具，但是没有专门进行整理和记录，总感觉知识图谱差点什么。<br>话不多说，今天就整理一下最开始被广泛使用的 scss，下面我们开始吧。 </p><a id="more"></a><p><strong>为什么会有预处理工具？</strong></p><p>1.CSS有以下的几个缺点</p><blockquote><p>语法不够强大<br>没有变量和合理的复用机制<br>使用逻辑上相关的属性值必须重复编写，导致难以维护</p></blockquote><p>CSS的预处理器,就是用一种专门的编程语言，进行web页面样式的设计，再通过编译器转化为正常的css文件，以供项目使用 </p><p>动态样式语言为css赋予了动态语言的特性，极大的提高了样式语言的可维护性<br>常用的动态样式语言：css的预处理器（scss/sass、less、stylus）</p><p>scss是一款强化css的辅助工具，他在css语法的基础上增加了变量，嵌套，混合，导入，函数等高级功能，这些拓展相对于css更强大与优雅。<br>scss的作用:有助于更好的管理样式文件，以及更高效的开发项目。</p><p><strong>使用scss</strong><br>在服务器端使用<br>(1)安装NodeJS解释器<br>(2)安装scss编译程序<br>在命令行界面输入：<code>npm install -g node-sass</code><br>检查scss程序能否正常使用：<code>node-sass -v</code> 如果能查看到版本号，说明sass程序可用<br>(3)编译scss文件<br>1.创建一个scss文件，编写动态样式代码<br>2.通过以下命令行来完成编译</p><blockquote><p>单文件的转换命令：node-sass scss/input.scss  css/output.css<br>多文件的转换命令：node-sass scss文件夹名称 -o css文件夹名称<br>单文件监听命令：node-sass -w scss/input.scss css/output.css<br>多文件监听命令：node-sass -w scss文件夹名称 -o css文件夹名称</p></blockquote><h3 id="scss的基础语法"><a href="#scss的基础语法" class="headerlink" title="scss的基础语法"></a>scss的基础语法</h3><ul><li>1.变量<br>使用$符号标识变量。<br>变量命名规范遵循css中选择器的命令规范，不能以数字开头，不能包含特殊字符（可以包含_,-）,尽量见名知意。<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$jd_red</span>:<span class="number">#f10215</span>; <span class="comment">//颜色变量</span></span><br><span class="line"><span class="variable">$normal_width</span>:<span class="number">100px</span>; <span class="comment">//数值变量</span></span><br><span class="line"><span class="variable">$before_content</span>:<span class="string">"子曰："</span>; <span class="comment">//字符串变量</span></span><br><span class="line"><span class="variable">$border_style</span>:solid;  <span class="comment">//样式变量</span></span><br><span class="line"><span class="variable">$my_border</span>:<span class="number">1px</span> <span class="variable">$border_style</span> <span class="variable">$jd_red</span>; <span class="comment">//声明变量时，变量的值也可以是其它变量。</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="variable">$my_border</span>;</span><br><span class="line">  <span class="variable">$width</span>:<span class="number">200px</span>;  <span class="comment">//局部变量，只能在当前选择器中使用</span></span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">$width</span>;  <span class="comment">//在此可以调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">$width</span>;  <span class="comment">//不能调用$width</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>(1)声明变量时变量值可以引用其它变量。<br>(2)变量定义在{}规则块外，整个样式表中都可以引用，定义在{}规则内，它只能在规则块中使用。<br>(3)声明重复变量，只有最后一处有效，且他会覆盖前面的值，尽量不要重复。<br>(4)!default规则，如果变量已经声明赋值了，那就用他声明的值，否则就用当前这个默认值。</p><ul><li>2.嵌套规则<br>(1)在选择器中嵌套选择器<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">div</span><span class="selector-class">.top</span> <span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">div</span><span class="selector-class">.top</span> <span class="selector-tag">p</span>&#123;<span class="attribute">margin</span>:<span class="number">10px</span>;&#125;</span><br><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">div</span><span class="selector-class">.middle</span>&#123;<span class="attribute">background</span>:gray;&#125;</span><br></pre></td></tr></table></figure>将上面的css代码改成scss格式：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.top</span>&#123;</span><br><span class="line">  <span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line">  <span class="selector-tag">p</span>&#123;<span class="attribute">margin</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.middle</span>&#123;<span class="attribute">background</span>:gray;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">a</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:blue;&#125;</span><br></pre></td></tr></table></figure>改写scss方式：<br>在嵌套规则中，有时候需要使用嵌套外层的父选择器，可用&amp;代表嵌套规则外层的父选择器。<br>不添加&amp;,标签和：之间会一个空格，导致浏览器不读取这个伪类<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="selector-tag">a</span>&#123;<span class="attribute">color</span>:red;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>(2)群组选择器嵌套<br>css的写法<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span>,<span class="selector-tag">header</span> <span class="selector-tag">a</span>,<span class="selector-tag">section</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>用scss方式写：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span>,<span class="selector-tag">header</span>,<span class="selector-tag">section</span>&#123;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>(3)属性嵌套<br>在scss中除了选择器，属性也可以嵌套</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border-style</span>:solid;</span><br><span class="line">  <span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>:<span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用scss的方式写：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:&#123;</span><br><span class="line">    style:solid;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>3.导入文件<br>在scss中，局部文件名以_开头。<br>在scss编译时就不会编译这些以_开头的文件，而只是把这些文件用作导入，引入局部文件时可以不写文件的全名，即省略下划线，并且局部文件的后缀也可以不写。<br>同一个局部文件可以在不同的主文件中引用。<br>引入局部文件需用 <code>@import</code></p><blockquote><p>定义了一个局部文件<code>_myColors.scss</code><br>引入该文件： <code>@import &quot;myColors&quot;</code></p></blockquote></li><li><p>4.混合器——需要复用的样式封装</p></li></ul><p>1.普通混合器<br>使用 <code>@minix</code>标识符定义。<br>语法: <code>@minix 混合器名称{样式声明}</code></p><p>通过 <code>@include</code> 来使用混合器<br>语法：<code>选择器{ @include 混合器名称}</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> my_box_shadow &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">9px</span> <span class="number">2px</span> gray;</span><br><span class="line">  -moz-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">9px</span> <span class="number">2px</span> gray;</span><br><span class="line">  -ms-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">9px</span> <span class="number">2px</span> gray;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">9px</span> <span class="number">2px</span> gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.info</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:green;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">2px</span> solid <span class="variable">$jd_red</span>;</span><br><span class="line">  <span class="keyword">@include</span> my_box_shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.带参混合器</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> 混合器名称(参数<span class="number">1</span>，参数<span class="number">2</span>，...)&#123;</span><br><span class="line">  属性1：参数1；</span><br><span class="line">  属性2：参数2；</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用带参混合器<br><code>选择器{ @include 混合器名称(实参1，实参2，...)}</code></p><ul><li>5.继承<br>通过 <code>@extend</code>实现继承<br>继承是说一个选择器可以继承另一个选择器定义的所有样式。<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.round</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">border-radius</span>:<span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.round-shadow</span>&#123;</span><br><span class="line">  <span class="keyword">@extend</span> .round;</span><br><span class="line">  <span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="scss运算"><a href="#scss运算" class="headerlink" title="scss运算"></a>scss运算</h3><ul><li>1.数字：加减乘除，取整等运算（+,-,*,/,%）,如果必要会在不同单位间转换值（前提是scss能转）<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$my_width</span>:<span class="number">5%</span>;</span><br><span class="line"><span class="variable">$my_max_width</span>:<span class="variable">$my_width</span>*<span class="number">4</span>;</span><br><span class="line"><span class="variable">$other_size</span>:<span class="variable">$my_width</span>+<span class="variable">$my_max_width</span>;</span><br></pre></td></tr></table></figure></li></ul><p>(1)注意加法<br>+也可以用于连接字符串</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">"Microsoft"</span>+yahei;</span><br><span class="line">  <span class="attribute">font-family</span>: A+<span class="string">"rial"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用有引号的字符串去连接无引号的字符串，运算结果是由引号的，相反，无引号的字符串去连接有引号的字符串，运算结果则没有引号。—–（有没有双引号，以前面的为准）</p><p>(2)除法运算</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">10px</span>/<span class="number">80px</span>; <span class="comment">//分隔线</span></span><br><span class="line">  <span class="variable">$width</span>:<span class="number">1000px</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">$width</span>/<span class="number">2</span>;      <span class="comment">//除法</span></span><br><span class="line">  <span class="attribute">height</span>:(<span class="number">500px</span>/<span class="number">2</span>);    <span class="comment">//除法</span></span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">5px</span>+<span class="number">10px</span>/<span class="number">2px</span>; <span class="comment">//除法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在css中通常起到分隔数字的用途，同时也赋予除法的功能。<br>以下情况/被视为除法运算：</p><blockquote><p>1.如果值，或值的一部分，是变量或者是函数的返回值。<br>2.如果值被圆括号包裹时<br>3.如果值是算术运算的一部分</p></blockquote><p>(3)运算表达式与其他连用是，用空格做连接符</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">5px</span>+<span class="number">10px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)在有引号的文本字符串中使用#{}插值语句可以添加动态的值。(有点借鉴模板字符串)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">"I am #&#123;5+15&#125; years old"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.颜色：颜色值的运算是分段计算的，也就是分别计算红色，绿色，以及蓝色的值。<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="number">#010203</span>+<span class="number">#040506</span>&#125;;</span><br></pre></td></tr></table></figure>计算：01+04=05  02+05=07  03+06=09<br>结果：color:#050709;<br>值包含alpha(透明度)，必须有相等alpha值才能进行运算，因为算术运算不会作用于alpha。<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgba(125,25,10,<span class="selector-class">.5</span>)+rgba(245,65,90,<span class="selector-class">.5</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="scss函数"><a href="#scss函数" class="headerlink" title="scss函数"></a>scss函数</h3><p>scss定义了多种函数，有些甚至可以通过普通的css语句调用。<br>ex:rgba(10,30,40,.7);在普通的css中也可以使用<br>1.颜色<br>rgba();<br>hsl(hue,saturation,lightness);</p><blockquote><p>hue:色调，取值0-360，0-120红色，120-240绿色，240-360蓝色。<br>saturation:饱和度，取值为0%-100%<br>lightness:亮度，取值0%-100%</p></blockquote><p>2.数字函数</p><blockquote><p>round(value) 将数值进行四舍五入，转换成最接近的整数。<br>ceil(value) 向上取整<br>floor(value) 向下取整<br>min(num1,num2…)找出数值之间的最小值<br>max(num1,num2…)找最大值<br>random() 获取随机数</p></blockquote><p>3.字符串函数</p><blockquote><p>unquote(string) 删除字符串的引号<br>quote(string)   添加字符串的引号<br>to_upper_case(string) 将字符串小写字母转换为大写字母<br>to_lower_case(string) 将字符串大写字母转换为小写字母</p></blockquote><p>4.自定义函数<br>scss支持自定义函数使用关键词 @function定义，并能在任何属性或scss中使用，需要调用 @return输出结果。<br>语法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@function</span> 函数名(<span class="variable">$n</span>)&#123;</span><br><span class="line">  <span class="keyword">@return</span> 运算表达式；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.控制指令<br>1.当 @if 的表达式返回值不是false或null时，表示条件成立，执行{}内的代码。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span> &#123;<span class="attribute">border-radius</span>:<span class="number">5px</span>;&#125;</span><br><span class="line">  <span class="keyword">@if</span> <span class="number">5</span>&lt;<span class="number">3</span> &#123;<span class="attribute">border-radius</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">  <span class="keyword">@if</span> null &#123;<span class="attribute">border-radius</span>:<span class="number">20px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.@if 声明后面可以跟多个 @else if 声明，或者一个 @else声明。</p><pre class="line-numbers language-scss"><span class="variable"><code class="language-scss"><span class="variable">$type</span>:abc;<span class="selector-tag">nav</span>{  <span class="keyword">@if</span> <span class="variable">$type</span>==sun{      <span class="attribute">color</span>:yellow;  } <span class="keyword">@else</span> if <span class="variable">$type</span>==mars{      <span class="attribute">color</span>:red;  } <span class="keyword">@else</span> if <span class="variable">$type</span>==moon{      <span class="attribute">color</span>:blue;  } <span class="keyword">@else</span>{      <span class="attribute">color</span>:black;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用了很久的 css 预处理工具，但是没有专门进行整理和记录，总感觉知识图谱差点什么。&lt;br&gt;话不多说，今天就整理一下最开始被广泛使用的 scss，下面我们开始吧。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="scss" scheme="https://jambo0624.github.io/tags/scss/"/>
    
  </entry>
  
  <entry>
    <title>响应式布局原理及方案</title>
    <link href="https://jambo0624.github.io/2019-10-06-responsive.html"/>
    <id>https://jambo0624.github.io/2019-10-06-responsive.html</id>
    <published>2019-10-06T11:11:18.000Z</published>
    <updated>2020-10-14T09:49:24.657Z</updated>
    
    <content type="html"><![CDATA[<p>响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够，缺点就是CSS比较重。</p><a id="more"></a><p>响应式布局的实现方案</p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><ol><li>媒体查询<br>CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。<br>常见的如何选择屏幕大小分割点方案：<blockquote><p>600px,900px,1200px,1800px<br>480px,800px,1400px,1400px<br>768px,992px,1200px,1200px(bootstrap)</p></blockquote></li></ol><p>上面的分割方案不一定满足项目中的实际需求，我们可以先用跨度大的分割点进行分割，如果出现不适配的情况可以再根据实际情况增加新的分割点。</p><p><strong>移动优先 OR PC优先</strong><br>不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是min-width，PC端优先使用的max-width。<br><strong>移动优先:</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* iphone6 7 8 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone 5 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphoneX */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0FF000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone6 7 8 plus */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">414px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ipad */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ipad pro */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1024px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FF00FF</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* pc */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1100px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PC优先：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pc width &gt; 1024px */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ipad pro */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1024px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FF00FF</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ipad */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone6 7 8 plus */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">414px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphoneX */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0FF000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone6 7 8 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0FF000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone5 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0FF000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><ol start="2"><li>百分比布局<br>通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，CSS3支持最大最小高，可以将百分比和max(min)一起结合使用来定义元素在不同设备下的宽高。  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pc width &gt; 1100px */</span></span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123; </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ipad pro */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1024px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">8%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ipad */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span> - <span class="number">10%</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone6 7 8 plus */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">414px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">5%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span> - <span class="number">5%</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphoneX */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span> - <span class="number">10%</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone6 7 8 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">3%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span> - <span class="number">3%</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone5 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">7%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span> - <span class="number">7%</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是我们必须要弄清楚css中子元素的百分比到底是相对谁的百分比。直接上结论吧：   </li></ol><ul><li>子元素的<code>height</code>或<code>width</code>中使用百分比，是相对于子元素的直接父元素，<code>width</code>相对于父元素的<code>width</code>，<code>height</code>相对于父元素的<code>height</code>   </li><li>子元素的<code>top</code>和<code>bottom</code>如果设置百分比，则相对于直接非<code>static</code>定位(默认定位)的父元素的高度，同样子元素的<code>left</code>和<code>right</code>如果设置百分比，则相对于直接非<code>static</code>定位(默认定位的)父元素的宽度   </li><li>子元素的<code>padding</code>如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的<code>width</code>，而与父元素的<code>height</code>无关。跟<code>padding</code>一样，<code>margin</code>也是如此，子元素的<code>margin</code>如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的<code>width</code>   </li><li><code>border-radius</code>不一样，如果设置<code>border-radius</code>为百分比，则是相对于自身的宽度，除了<code>border-radius</code>外，还有比如<code>translate</code>、<code>background-size</code>等都是相对于自身的   </li></ul><p>从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：</p><ol><li>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。</li><li>可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</li></ol><h3 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h3><ol start="3"><li>rem布局<br>REM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。</li></ol><p>rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。</p><p>因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。</p><p><strong>rem响应式的布局思想：</strong></p><blockquote><p>一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值</p><p>高度值可以设置固定值，设计稿有多大，我们就严格有多大</p><p>所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值)</p><p>js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了</p></blockquote><p><strong>rem布局的缺点：</strong></p><blockquote><p>在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = doc.documentElement;</span><br><span class="line">    <span class="keyword">var</span> width = docEl.getBoundingClientRect().width;</span><br><span class="line">    <span class="keyword">var</span> rem = width / <span class="number">10</span>;</span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">'px'</span>;</span><br><span class="line">    flexible.rem = win.rem = rem;</span><br><span class="line">&#125;</span><br><span class="line">win.addEventListener(<span class="string">'resize'</span>, refreshRem);</span><br></pre></td></tr></table></figure><p>REM布局也是目前多屏幕适配的最佳方式。默认情况下我们html标签的font-size为16px,我们利用媒体查询，设置在不同设备下的字体大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pc width &gt; 1100px */</span></span><br><span class="line"><span class="selector-tag">html</span>&#123; <span class="attribute">font-size</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ipad pro */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1024px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FF00FF</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.4rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ipad */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.3rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone6 7 8 plus */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">414px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.25rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphoneX */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0FF000</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.125rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone6 7 8 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0FF000</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone5 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0FF000</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.75rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h3><ol start="4"><li>视口单位<br>css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。各个单位具体的含义如下：</li></ol><table><thead><tr><th>单位</th><th>含义</th></tr></thead><tbody><tr><td>vw</td><td>相对于视窗的宽度，1vw 等于视口宽度的1%，即视窗宽度是100vw</td></tr><tr><td>vh</td><td>相对于视窗的高度，1vh 等于视口高度的1%，即视窗高度是100vh</td></tr><tr><td>vmin</td><td>vw和vh中的较小值</td></tr><tr><td>vmax</td><td>vw和vh中的较大值</td></tr></tbody></table><p>那么vw或者vh很类似百分比单位。vw和%的区别为：</p><table><thead><tr><th>单位</th><th>含义</th></tr></thead><tbody><tr><td>%</td><td>大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等）</td></tr><tr><td>vm/vh</td><td>相对于视窗的尺寸</td></tr></tbody></table><blockquote><p>从对比中我们可以发现，vw单位与百分比类似，单确有区别，前面我们介绍了百分比单位的换算困难，这里的vw更像”理想的百分比单位”。任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一</p></blockquote><p>使用视口单位来实现响应式有两种做法：</p><ol><li>仅使用vw作为CSS单位</li></ol><ul><li>对于设计稿的尺寸转换为为单位，我们使用Sass函数编译<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iPhone 6尺寸作为设计稿基准</span></span><br><span class="line"><span class="variable">$vm_base</span>: <span class="number">375</span>; </span><br><span class="line"><span class="keyword">@function</span> vw(<span class="variable">$px</span>) &#123;</span><br><span class="line">    <span class="keyword">@return</span> (<span class="variable">$px</span> / <span class="number">375</span>) * <span class="number">100vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>无论是文本还是布局宽度、间距等都使用vw作为单位<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mod_nav</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  &amp;_list &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">padding</span>: vm(<span class="number">15</span>) vm(<span class="number">10</span>) vm(<span class="number">10</span>); <span class="comment">// 内间距</span></span><br><span class="line">    &amp;_item &#123;</span><br><span class="line">      <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">text-align</span>: center;</span><br><span class="line">      <span class="attribute">font-size</span>: vm(<span class="number">10</span>); <span class="comment">// 字体大小</span></span><br><span class="line">      &amp;_logo &#123;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">        <span class="attribute">width</span>: vm(<span class="number">40</span>); <span class="comment">// 宽度</span></span><br><span class="line">        <span class="attribute">height</span>: vm(<span class="number">40</span>); <span class="comment">// 高度</span></span><br><span class="line">        <span class="selector-tag">img</span> &#123;</span><br><span class="line">          <span class="attribute">display</span>: block;</span><br><span class="line">          <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">          <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &amp;_name &#123;</span><br><span class="line">        <span class="attribute">margin-top</span>: vm(<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>1物理像素线（也就是普通屏幕下1px,高清屏幕下0.5px的情况）采用transform属性scale实现<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mod_grid</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="comment">// 实现1物理像素的下边框线</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">pointer-events</span>: none;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="number">2</span>) &#123;</span><br><span class="line">      -webkit-<span class="attribute">transform</span>: scaleY(<span class="number">0.5</span>);</span><br><span class="line">      -webkit-<span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对于需要保持宽高比的图，应该用padding-top实现<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mod_banner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding-top</span>: percentage(<span class="number">100</span>/<span class="number">700</span>); <span class="comment">// 使用padding-top</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>搭配vw和rem<br>虽然采用vw适配后的页面效果很好，但是它是利用视口单位实现的布局，依赖视口大小而自动缩放，无论视口过大还是过小，它也随着时候过大或者过小，失去了最大最小宽度的限制，此时我们可以结合rem来实现布局</li></ol><ul><li>给根元素大小设置随着视口变化而变化的vw单位，这样就可以实现动态改变其大小</li><li>限制根元素字体大小的最大最小值，配合body加上最大宽度和最小宽度<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推</span></span><br><span class="line"><span class="variable">$vm_fontsize</span>: <span class="number">75</span>; <span class="comment">// iPhone 6尺寸的根元素大小基准值</span></span><br><span class="line"><span class="keyword">@function</span> rem(<span class="variable">$px</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> (<span class="variable">$px</span> / <span class="variable">$vm_fontsize</span> ) * <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根元素大小使用 vw 单位</span></span><br><span class="line"><span class="variable">$vm_design</span>: <span class="number">750</span>;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: (<span class="variable">$vm_fontsize</span> / (<span class="variable">$vm_design</span> / <span class="number">2</span>)) * <span class="number">100vw</span>; </span><br><span class="line">  <span class="comment">// 同时，通过Media Queries 限制根元素最大最小值</span></span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (max-width: <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">64px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (min-width: <span class="number">540px</span>) &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">108px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">540px</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">320px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片响应式"><a href="#图片响应式" class="headerlink" title="图片响应式"></a>图片响应式</h3></li></ul><ol start="5"><li><p>图片响应式<br>这里的图片响应式包括两个方面:<br>一个就是大小自适应，这样能够保证图片在不同的屏幕分辨率下出现压缩、拉伸的情况；<br>一个就是根据不同的屏幕分辨率和设备像素比来尽可能选择高分辨率的图片，也就是当在小屏幕上不需要高清图或大图，这样我们用小图代替，就可以减少网络带宽了。</p></li><li><p>使用max-width（图片自适应）:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inline-block 元素相对于它周围的内容以内联形式呈现，但与内联不同的是，这种情况下我们可以设置宽度和高度。 max-width保证了图片能够随着容器的进行等宽扩充（即保证所有图片最大显示为其自身的 100%。此时，如果包含图片的元素比图片固有宽度小，图片会缩放占满最大可用空间），而height为auto可以保证图片进行等比缩放而不至于失真。如果是背景图片的话要灵活运用background-size属性。<br>那么为什么不能用width：100%呢？因为这条规则会导致它显示得跟它的容器一样宽。在容器比图片宽得多的情况下，图片会被无谓地拉伸。</p></li><li><p>使用srcset</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">"photo_w350.jpg 1x, photo_w640.jpg 2x"</span> <span class="attr">src</span>=<span class="string">"photo_w350.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果屏幕的dpi = 1的话则加载1倍图，而dpi = 2则加载2倍图，手机和mac基本上dpi都达到了2以上，这样子对于普通屏幕来说不会浪费流量，而对于视网膜屏来说又有高清的体验。<br>如果浏览器不支持srcset，则默认加载src里面的图片。<br>但是你会发现实际情况并不是如此，在Mac上的Chrome它会同时加载srcset里面的那张2x的，还会再去加载src里面的那张，加载两张图片。顺序是先把所有srcset里面的加载完了，再去加载src的。这个策略比较奇怪，它居然会加载两张图片，如果不写src，则不会加载两张，但是兼容性就没那么好。这个可能是因为浏览器认为，既然有srcset就不用写src了，如果写了src，用户可能是有用的。而使用picture就不会加载两张</p></li><li><p>使用background-image</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.banner</span>&#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(/static/large.jpg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">767px</span>)&#123;</span><br><span class="line">  background-image: url(/static/small.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用picture标签<br>picturefill.min.js ：解决IE等浏览器不支持 的问题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"banner_w1000.jpg"</span> <span class="attr">media</span>=<span class="string">"(min-width: 801px)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"banner_w800.jpg"</span> <span class="attr">media</span>=<span class="string">"(max-width: 800px)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"banner_w800.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- picturefill.min.js 解决IE等浏览器不支持 &lt;picture&gt; 的问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/vendor/picturefill.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>picture必须要写img标签，否则无法显示，对picture的操作最后都是在img上面，例如onload事件是在img标签触发的，picture和source是不会进行layout的，它们的宽和高都是0。<br>另外使用source，还可以对图片格式做一些兼容处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">"image/webp"</span> <span class="attr">srcset</span>=<span class="string">"banner.webp"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"banner.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：<br>响应式布局的实现可以通过媒体查询+px,媒体查询+百分比，媒体查询+rem+js,vm/vh,vm/vh +rem这几种方式来实现。</p></li></ol><p>但每一种方式都是有缺点的，媒体查询需要选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配，另外用户体验也不友好，布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。</p><p>通过百分比来适配首先是计算麻烦，第二各个属性中如果使用百分比，其相对的元素的属性并不是唯一的，这样就造成我们使用百分比单位容易使布局问题变得复杂。</p><p>通过采用rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得CSS与JS 耦合了在一起。</p><p>通过利用纯css视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的，但是兼容性还没有完全能结构接受。</p><h3 id="响应式布局的成型方案"><a href="#响应式布局的成型方案" class="headerlink" title="响应式布局的成型方案"></a>响应式布局的成型方案</h3><p>现在的css，UI框架等都已经考虑到了适配不同屏幕分辨率的问题，实际项目中我们可以直接使用这些新特性和框架来实现响应式布局。可以有以下选择方案：</p><blockquote><p>利用上面的方法自己来实现，比如CSS3 Media Query,rem，vw等<br>Flex弹性布局，兼容性较差<br>Grid网格布局，兼容性较差<br>Columns栅格系统，往往需要依赖某个UI库，如Bootstrap   </p></blockquote><h3 id="响应式布局的要点"><a href="#响应式布局的要点" class="headerlink" title="响应式布局的要点"></a>响应式布局的要点</h3><p>在实际项目中，我们可能需要综合上面的方案，比如用rem来做字体的适配，用srcset来做图片的响应式，宽度可以用rem，flex，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：</p><blockquote><p>设置viewport<br>媒体查询<br>字体的适配（字体单位）<br>百分比布局<br>图片的适配（图片的响应式）<br>结合flex，grid，BFC，栅格系统等已经成型的方案   </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够，缺点就是CSS比较重。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="responsive" scheme="https://jambo0624.github.io/tags/responsive/"/>
    
  </entry>
  
  <entry>
    <title>cookie &amp; session &amp; localStorage</title>
    <link href="https://jambo0624.github.io/2019-10-04-cookie-session-localstorage.html"/>
    <id>https://jambo0624.github.io/2019-10-04-cookie-session-localstorage.html</id>
    <published>2019-10-04T02:21:38.000Z</published>
    <updated>2020-10-14T09:28:20.782Z</updated>
    
    <content type="html"><![CDATA[<p><code>cookie</code> 和 <code>session</code> 是为了让 <code>http</code> 协议有状态。 <code>session</code> 是由服务器记录的一次会话，他会把 <code>会话id</code> 返回给客户端，客户端进行记录，就是 <code>cookie</code> 。</p><a id="more"></a><h1 id="cookie-session-localStorage"><a href="#cookie-session-localStorage" class="headerlink" title="cookie-session-localStorage"></a>cookie-session-localStorage</h1><p>经常会疑惑于三者之间的关系，下面就进行简单的梳理</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li>特点</li></ul><ol><li>服务器通过set-Cookie头给客户端一串字符串</li><li>客户端每次访问相同域名的网页时，必须带上这段字符串</li><li>客户端要在一段时间内保存这个Cookie</li><li>一般存储大小在 4k 左右</li><li>cookie在用户关闭页面（会话结束）候就会失效，但是后台代码可以任意设置cookie的过期时间<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">'set-Cookie'</span>,<span class="string">`login_email = <span class="subst">$&#123;email&#125;</span>`</span>)</span><br></pre></td></tr></table></figure></li></ol><p>cookie解决的是，一个网站不用重复登录的问题</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><ul><li>特点</li></ul><ol><li>将sessionID（随机数）通过Cookie发送给客户端</li><li>客户端访问服务器时，服务器读取sessionID</li><li>服务器有一块内存（哈希表）保存了所有的session</li><li>通过sessionID，我们可以得到对应用户的隐私信息，如id，email</li><li>这块内存就是服务器上的所有session<br>下面是单条数据的代码表示<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cookie <span class="comment">// &#123; sessionId: 'random number' &#125;</span></span><br><span class="line">session <span class="comment">// &#123; sessionId: &#123; loginin_email: 'xxxx@gmail.com' &#125; &#125;</span></span><br><span class="line">sessionID <span class="comment">// &#123; loginin_email: 'xxxx@gmail.com' &#125;</span></span><br></pre></td></tr></table></figure>session解决的是，cookie明文可见并且用户可以随意更改cookie带来的安全问题。<br>也可以说通常情况下，session是基于cookie实现的</li></ol><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ul><li>特点</li></ul><ol><li>跟HTTP无关</li><li>HTTP不会带上localStorage的值</li><li>只有相同域名的页面才能读取localStorage（没有同源那么严格）</li><li>每个localStorage最大存储量一般为5M左右（每个浏览器不同）</li><li>常用场景： 记录有没有提示过用户，如更新等（没有用的信息，不能记录密码）</li><li>localStorage永久有效，除非用户主动清理</li></ol><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>1.前面四点同localStorage<br>5.sessionStorage在用户关闭页面（会话结束）候就会失效</p><h3 id="看似cookie和localStorage没关系，为什么被放在一起比较"><a href="#看似cookie和localStorage没关系，为什么被放在一起比较" class="headerlink" title="看似cookie和localStorage没关系，为什么被放在一起比较"></a>看似cookie和localStorage没关系，为什么被放在一起比较</h3><p>因为开始没有localStorage这个API时，只能用cookie做跨页面访问和持久化存储。<br>还有一个忠告就是前端尽量不要操作cookie</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;cookie&lt;/code&gt; 和 &lt;code&gt;session&lt;/code&gt; 是为了让 &lt;code&gt;http&lt;/code&gt; 协议有状态。 &lt;code&gt;session&lt;/code&gt; 是由服务器记录的一次会话，他会把 &lt;code&gt;会话id&lt;/code&gt; 返回给客户端，客户端进行记录，就是 &lt;code&gt;cookie&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="jquery" scheme="https://jambo0624.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>git 命令行清单</title>
    <link href="https://jambo0624.github.io/2019-09-15-git-commandList.html"/>
    <id>https://jambo0624.github.io/2019-09-15-git-commandList.html</id>
    <published>2019-09-15T03:50:24.000Z</published>
    <updated>2020-10-13T13:07:32.244Z</updated>
    
    <content type="html"><![CDATA[<p>昨天梳理了一些 git 的基础知识，但是主要是理论性的，命令行等实用性的东西比较少。<br>今天我们就专门整理了日常使用频率相对较高的command。让我们开始吧。</p><a id="more"></a><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示当前的Git配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑Git配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置提交代码时的用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.name <span class="string">"[name]"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.email <span class="string">"[email address]"</span></span></span><br></pre></td></tr></table></figure><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看信息</span></span></span><br><span class="line">```shell</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">"提交说明"</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天梳理了一些 git 的基础知识，但是主要是理论性的，命令行等实用性的东西比较少。&lt;br&gt;今天我们就专门整理了日常使用频率相对较高的command。让我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://jambo0624.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://jambo0624.github.io/tags/git/"/>
    
      <category term="command" scheme="https://jambo0624.github.io/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>git基础</title>
    <link href="https://jambo0624.github.io/2019-09-14-git-basic.html"/>
    <id>https://jambo0624.github.io/2019-09-14-git-basic.html</id>
    <published>2019-09-14T08:03:56.000Z</published>
    <updated>2020-10-13T12:48:14.734Z</updated>
    
    <content type="html"><![CDATA[<p>虽然工作中一直在使用 git 来管理代码，并在 gitlab 托管项目。但是对于git的知识还不是很系统。<br>下面我就系统的整理一下git的相关知识，我们开始吧。</p><a id="more"></a><h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><p>Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。</p><p>Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。</p><p>而且，编辑旧文件后，试图覆盖较新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖了他人的编辑内容。</p><h3 id="管理历史记录的数据库"><a href="#管理历史记录的数据库" class="headerlink" title="管理历史记录的数据库"></a>管理历史记录的数据库</h3><p>数据库 (Repository) 是记录文件或目录状态的地方，存储着内容修改的历史记录。在数据库的管理下，把文件和目录修改的历史记录放在对应的目录下。</p><p><strong>远程数据库和本地数据库</strong><br>首先，Git的数据库分为远程数据库和本地数据库的两种。</p><blockquote><p>远程数据库: 配有专用的服务器，为了多人共享而建立的数据库。<br>本地数据库: 为了方便用户个人使用，在自己的机器上配置的数据库。</p></blockquote><p>数据库分为远程和本地两种。<br>平时用手头上的机器在本地数据库上操作就可以了。<br>如果想要公开在本地数据库中修改的内容，把内容上传到远程数据库就可以了。<br>另外，通过远程数据库还可以取得其他人修改的内容。</p><h3 id="修改记录的提交"><a href="#修改记录的提交" class="headerlink" title="修改记录的提交"></a>修改记录的提交</h3><p>若要把文件或目录的添加和变更保存到数据库，就需要进行提交。</p><p>执行提交后，数据库中会生成上次提交的状态与当前状态的差异记录（也被称为revision）。</p><p>提交是以时间顺序排列状态被保存到数据库中的。凭借该提交和最新的文件状态，就可以知道过去的修改记录以及内容。</p><p>系统会根据修改的内容计算出没有重复的40位英文及数字来给提交命名。指定这个命名，就可以在数据库中找到对应的提交。</p><p>执行提交时，系统会要求输入提交信息。请务必输入提交信息，因为在空白的状态下执行提交会失败的。</p><h3 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h3><p>在Git管理下，大家实际操作的目录被称为工作树。</p><p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。</p><p>Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要把文件加入到索引区域中。</p><p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。</p><p>下面我们借用一张图，和我们常用的几个命令，来总结 git 基础操作。<br>首先我们先来理解下 Git 工作区、暂存区和版本库概念：</p><ul><li><p>工作区：就是你在电脑里能看到的目录。</p></li><li><p>暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</p></li><li><p>版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。<br><img src="https://s1.ax1x.com/2020/10/13/0hb7ad.jpg" alt="0hb7ad.jpg"></p></li><li><p>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</p></li><li><p>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</p></li><li><p>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</p></li><li><p>当对工作区修改（或新增）的文件执行 <code>git add</code> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p></li><li><p>当执行提交操作（<code>git commit</code>）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p></li><li><p>当执行 <code>git reset HEAD</code> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p></li><li><p>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p></li><li><p>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p></li><li><p>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然工作中一直在使用 git 来管理代码，并在 gitlab 托管项目。但是对于git的知识还不是很系统。&lt;br&gt;下面我就系统的整理一下git的相关知识，我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://jambo0624.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://jambo0624.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>js中的遍历操作</title>
    <link href="https://jambo0624.github.io/2019-08-24-traverse.html"/>
    <id>https://jambo0624.github.io/2019-08-24-traverse.html</id>
    <published>2019-08-24T07:49:32.000Z</published>
    <updated>2020-10-13T12:19:44.014Z</updated>
    
    <content type="html"><![CDATA[<p>最近在逛社区时，看到了一段这样的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(;a&lt;<span class="number">5</span>;a++)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不觉惊讶，但仍然觉得循环遍历的许多细节，包括多个变种还是值得研究的。<br>话不多说，我们开始。</p><a id="more"></a><p>除了for循环外，还有以下一些方式：</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'element1'</span>, <span class="string">'element2'</span>, <span class="string">'element3'</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是以上遍历，没有办法到<strong>某个特定条件退出</strong>。<br>当数组很大，没办法通过提前终止遍历来节省资源。</p><h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for in循环"></a>for in循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'element1'</span>, <span class="string">'element2'</span>, <span class="string">'element3'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for in语句是一种精准的迭代语句，可以枚举对象的所有<strong>可枚举属性</strong>(可以使用<code>Object.getOwnPropertyDescriptor(targetObj, attrName)</code>方法来查看对象的某个属性是否可枚举)。<br>也就是说，可以用它来遍历对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">     a: <span class="number">1</span>,</span><br><span class="line">     b: <span class="number">1</span>,</span><br><span class="line">     c: <span class="number">1</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(attr, obj[attr]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> father = &#123;</span><br><span class="line">    fatherAttr: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以father为原型创建对象实例instance</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="built_in">Object</span>.create(father);</span><br><span class="line"></span><br><span class="line">instance.a = <span class="number">1</span>;</span><br><span class="line">instance.b = <span class="number">1</span>;</span><br><span class="line">instance.c = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> instance) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(attr, instance[attr]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 1</span></span><br><span class="line"><span class="comment">// b 1</span></span><br><span class="line"><span class="comment">// c 1</span></span><br><span class="line"><span class="comment">// fatherAttr 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取instance实例的自有属性名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(instance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["a", "b", "c"]</span></span><br></pre></td></tr></table></figure><p>for in循环会将对象的<strong>原型属性</strong>也一并列举出来。故使用此方法去遍历对象属性的时候，需要加多一层判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(attr)) &#123;</span><br><span class="line">    <span class="comment">// 是对象的自有属性，可以尽情的玩耍了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'a𠮷c'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 无法用言语描述的字符</span></span><br><span class="line"><span class="comment">// 无法用言语描述的字符</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>ES5及之前处理字符串时，是以16位编码单位为基础的。<br>所以对于某些32位进行编码的字符，for in就处理得不是很好。</p><h3 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for of循环"></a>for of循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'a 𠮷 c'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">' '</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(char);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 𠮷</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>但是for of</p><ul><li>运行环境为ES6及以上版本，所以兼容性没有for in循环以及传统的操作好，如果需要考虑兼容上世纪的浏览器，就不能使用这个东西</li><li>只能用于遍历可迭代对象，即存在生成器方法（用于产生迭代器）的对象，如果用于遍历不可迭代对象，分分钟报错没商量。<br>可以通过检测对象的Symbol.iterator方法（相关内容将放在下一篇）是否为函数来判断对象是否可迭代。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断其Symbol.iterator属性是否为函数</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">typeof</span> arr[<span class="built_in">Symbol</span>.iterator]).toUpperCase() === <span class="string">'FUNCTION'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此对象不可迭代'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure></li></ul><p>当然，像Array、Set、Map类型还提供了一些特殊的生成器，可以让搬砖工作者更方便的去处理其想关注的内容：</p><ul><li>entries() 返回一个迭代器，其返回值为键值对数组（Map集合的默认迭代器；对于Set集合，返回值数组的元素相同，即value）</li><li>keys() 返回一个迭代器，其返回值为集合的键名（对于Set集合，此迭代器跟values迭代器返回值相同;对于数组，此迭代器返回值为索引）</li><li>values() 返回一个迭代器，其返回值为集合的值（Array、Set集合的默认迭代器）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(arr);</span><br><span class="line"></span><br><span class="line">for (let item of <span class="keyword">set</span>.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["a", "a"] ["b", "b"] ["c", "c"] ["d", "d"] [0, "a"] [1, "b"] [2, "c"] [3, "d"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c d 0 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c d a b c d</span></span><br></pre></td></tr></table></figure>除了JavaScript的内置对象，一些DOM标准的类型如NodeList也可以使用for of循环进行遍历：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> containers = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> node <span class="keyword">of</span> containers) &#123;</span><br><span class="line">    <span class="comment">// 搞事情专用注释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自定义对象的遍历"><a href="#自定义对象的遍历" class="headerlink" title="自定义对象的遍历"></a>自定义对象的遍历</h3><p><strong>Object.keys()获取键名数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> father = &#123;</span><br><span class="line">    fatherAttr: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以father为原型创建对象实例instance</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(father);</span><br><span class="line"></span><br><span class="line">instance.a = <span class="number">1</span>;</span><br><span class="line">instance.b = <span class="number">1</span>;</span><br><span class="line">instance.c = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(instance, <span class="string">'d'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(instance)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>从上面的例子中可以看出，Object.keys()方法并不会获取对象的原型属性以及自身不可枚举属性，这个是比较符合我们的需求的</p><p><strong>Object.getOwnPropertyNames()获取键名数组</strong><br>此方法跟keys方法表现一样，所不同的是，其返回的数组<strong>包含</strong>了对象的<strong>不可枚举属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.getOwnPropertyNames(instance)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br></pre></td></tr></table></figure><p><strong>Object.entries()获取键值对数组</strong><br>获得键值对数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.entries(instance)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["a", 1]</span></span><br><span class="line"><span class="comment">// ["b", 1]</span></span><br><span class="line"><span class="comment">// ["c", 1]</span></span><br></pre></td></tr></table></figure><p><strong>Object.values()获取对象的属性值数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.entries(instance)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>Object.getOwnPropertySymbols()获取Symbol属性名</strong><br>如果需要遍历对象实例的Symbol类型的属性名，需要使用Object.getOwnPropertySymbols()方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> father = &#123;</span><br><span class="line">    fatherAttr: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(father);</span><br><span class="line"></span><br><span class="line">instance.a = <span class="number">1</span>;</span><br><span class="line">instance.b = <span class="number">1</span>;</span><br><span class="line">instance.c = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">instance[<span class="built_in">Symbol</span>(<span class="string">'I am a handsome boy!'</span>)] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(instance)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.getOwnPropertySymbols(instance)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol(I am a handsome boy!)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在逛社区时，看到了一段这样的代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;a&amp;lt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;a++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然不觉惊讶，但仍然觉得循环遍历的许多细节，包括多个变种还是值得研究的。&lt;br&gt;话不多说，我们开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="for" scheme="https://jambo0624.github.io/tags/for/"/>
    
  </entry>
  
  <entry>
    <title>meta 标签的一些用法</title>
    <link href="https://jambo0624.github.io/2019-08-04-meta-tag.html"/>
    <id>https://jambo0624.github.io/2019-08-04-meta-tag.html</id>
    <published>2019-08-04T13:17:32.000Z</published>
    <updated>2020-10-13T11:14:00.448Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一段 meta 标签的代码，<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>具体用意不太知道。<br>说明还是有每一行代码，每一个细节都是值得进一步了解的，话不多说，咱们开始。</p><a id="more"></a><p>X-UA-Compatible是自从IE8新加的一个设置，对于IE8以下的浏览器是不识别的。<br>通过在meta中设置X-UA-Compatible的值，可以指定网页的兼容性模式设置。</p><p>在网页中指定的模式优先权高于服务器中(通过HTTP Header)所指定的模式。 兼容性模式设置优先级：</p><blockquote><p>meta tag &gt; http header</p></blockquote><p>常用的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7"</span>&gt;</span>  </span><br><span class="line">#以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面。  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=8"</span>&gt;</span>  </span><br><span class="line">#以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面。  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span>  </span><br><span class="line">#以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面。  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7,IE=9"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7,9"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=Edge,chrome=1"</span>&gt;</span></span><br><span class="line">#以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame.</span><br></pre></td></tr></table></figure><p>通过 wiki 发现，google frame 已经是历史了，没必要知之甚祥。</p><p>下面我们将常用的 meta 标签做个总结。<br>meta是html文档在head标签里定义的一个对文档进行描述的功能性标签<br>meta标签有下面的作用：</p><ul><li>1.搜索引擎优化（SEO）</li><li>2.定义页面使用语言</li><li>3.自动刷新并指向新的页面</li><li>4.实现网页转换时的动态效果</li><li>5.控制页面缓冲</li><li>6.网页定级评价</li><li>7.控制网页显示的窗口</li></ul><p>meta标签的组成：<br>meta标签共有两个属性，它们分别是<strong>http-equiv属性</strong>和<strong>name属性</strong>，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</p><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。</p><p>meta标签的name属性语法格式是：<br><code>&lt;meta name=&quot;参数&quot; content=&quot;具体的参数值&quot;&gt;</code></p><p>其中name属性主要有以下几种参数：　<br>A、Keywords(关键字)　<br>说明：keywords用来告诉搜索引擎你网页的关键字是什么。<br><code>&lt;meta name=&quot;keywords&quot; content=&quot;science,education,culture,politics,ecnomics，relationships,entertaiment,human&quot;&gt;</code></p><p>B、description(网站内容描述)<br>说明：description用来告诉搜索引擎你的网站主要内容。<br><code>&lt;meta name=&quot;description&quot; content=&quot;This page is about the meaning of science,education,culture.&quot;&gt;</code></p><p>C、robots(机器人向导)<br>说明：robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。<br>content的参数有all,none,index,noindex,follow,nofollow。默认是all。<br><code>&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt;</code></p><p>D、author(作者)<br>说明：标注网页的作者<br><code>&lt;meta name=&quot;author&quot; content=&quot;root,root@xxxx.com&quot;&gt;</code></p><p>E:renderer(渲染)<br>告诉浏览器你的渲染模式<br><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code></p><p>F：viewport(视图模式）<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;/&gt;</code></p><h3 id="http-equiv属性"><a href="#http-equiv属性" class="headerlink" title="http-equiv属性"></a>http-equiv属性</h3><p>http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。</p><p>meta标签的http-equiv属性语法格式是：<br><code>&lt;meta http-equiv=&quot;参数&quot; content=&quot;参数变量值&quot;&gt;</code></p><p>其中http-equiv属性主要有以下几种参数：<br>常用项：X-UA-Compatible（浏览模式）<br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code></p><p>A、Expires(期限)<br>说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。<br><code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri,01Jan201618:18:18GMT&quot;&gt;</code><br>注意：必须使用GMT的时间格式。</p><p>B、Pragma(cache模式)<br>说明：禁止浏览器从本地计算机的缓存中访问页面内容。<br><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;</code><br>注意：这样设定，访问者将无法脱机浏览。</p><p>C、Refresh(刷新)<br>说明：自动刷新并指向新页面。<br><code>&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2;URL=http://www.xxxx.net&quot;&gt;</code><br>注意：其中的2是指停留2秒钟后自动刷新到URL网址。</p><p>D、Set-Cookie(cookie设定)<br>说明：如果网页过期，那么存盘的cookie将被删除。<br><code>&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt;</code><br>注意：必须使用GMT的时间格式。</p><p>E、Window-target(显示窗口的设定)<br>说明：强制页面在当前窗口以独立页面显示。<br><code>&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_blank&quot;&gt;</code><br>注意：用来防止别人在框架里调用自己的页面。</p><p>F、content-Type(显示字符集的设定)<br>说明：设定页面使用的字符集。<br><code>&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=gb2312&quot;&gt;</code></p><p>G、content-Language（显示语言的设定）<br><code>&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-cn&quot;/&gt;</code></p><p>H、Cache-Control指定请求和响应遵循的缓存机制。<br>Cache-Control指定请求和响应遵循的缓存机制。<br>在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。<br>请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，<br>响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。<br>各个消息中的指令含义如下</p><blockquote><p>Public:指示响应可被任何缓存区缓存<br>Private:指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效<br>no-cache指示请求或响应消息不能缓存<br>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应<br>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应<br>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p></blockquote><p><strong>Meta标签使用技巧：</strong><br>Meta标签是用来描述网页属性的一种语言，标准的Meta标签可以便于搜索引擎排序，提高搜索引擎网站权重排名。要想网站做的更符合搜索引擎标准就必须了解meta标签，下面由Seoer惜缘于大家讲讲meta标签含义与使用方法：<br>1、META标签的keywords<br><code>&lt;meta name=&quot;Keywords&quot; content=&quot;信息参数&quot;/&gt;</code><br>meat标签的Keywords的的信息参数，代表说明网站的关键词是什么。</p><p>2、META标签的Description<br><code>&lt;meta name=&quot;Description&quot; content=&quot;信息参数&quot;/&gt;</code><br>meta标签的Description的信息参数，代表说明网站的主要内容，概况是什么。</p><p>3、META标签的http-equiv=Content-Typecontent=”text/html<br>http-equiv=Content-Type代表的是HTTP的头部协议，提示浏览器网页的信息，<br><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=信息参数&quot;/&gt;</code><br>meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文；<br>meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文；<br>meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码；</p><p>4、META标签的generator<br><code>&lt;meta name=&quot;generator&quot; content=&quot;信息参数&quot;/&gt;</code><br>meta标签的generator的信息参数，代表说明网站的采用的什么软件制作。</p><p>5、META标签的author<br><code>&lt;meta name=&quot;author&quot; content=&quot;信息参数&quot;&gt;</code><br>meta标签的author的信息参数，代表说明网页版权作者信息。</p><p>6、META标签的http-equiv=”Refresh”<br><code>&lt;Meta http-equiv=&quot;Refresh&quot; Content=&quot;时间;Url=网址参数&quot;&gt;</code><br>meta标签的Refresh代表多少时间网页自动刷新，加上Url中的网址参数就代表，多长时间自动链接其他网址。</p><p>7、META标签的http-equiv=”Pragma” CONTENT=”no-cache”<br><code>&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;</code><br>代表禁止浏览器从本地计算机的缓存中访问页面内容,这样设定，访问者将无法脱机浏览。</p><p>8、META标签的COPYRIGHT<br><code>&lt;META NAME=&quot;COPYRIGHT&quot; CONTENT=&quot;信息参数&quot;&gt;</code><br>meta标签的COPYRIGHT的信息参数，代表说明网站版权信息。</p><p>9、META标签的http-equiv=”imagetoolbar”<br><code>&lt;meta http-equiv=&quot;imagetoolbar&quot; content=&quot;false&quot;/&gt;</code><br>指定是否显示图片工具栏，当为false代表不显示，当为true代表显示。</p><p>10、META标签的Content-Script-Type<br><code>&lt;Meta http-equiv=&quot;Content-Script-Type&quot; Content=&quot;text/javascript&quot;&gt;</code><br>W3C网页规范，指明页面中脚本的类型。</p><p>11、META标签的revisit-after<br><code>&lt;META name=&quot;revisit-after&quot; CONTENT=&quot;7days&quot;&gt;</code><br>revisit-after代表网站重访,7days代表7天，依此类推。</p><p>12、META标签的Robots<br><code>&lt;meta name=&quot;Robots&quot; contect=&quot;信息参数&quot;&gt;</code><br>Robots代表告诉搜索引擎机器人抓取哪些页面</p><p>其中的属性说明如下：</p><blockquote><p>信息参数为all：文件将被检索，且页面上的链接可以被查询；<br>信息参数为none：文件将不被检索，且页面上的链接不可以被查询；<br>信息参数为index：文件将被检索；<br>信息参数为follow：页面上的链接可以被查询；<br>信息参数为noindex：文件将不被检索，但页面上的链接可以被查询；<br>信息参数为nofollow：文件将被检索，但页面上的链接不可以被查询；</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到一段 meta 标签的代码，&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;&lt;/code&gt;具体用意不太知道。&lt;br&gt;说明还是有每一行代码，每一个细节都是值得进一步了解的，话不多说，咱们开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jambo0624.github.io/categories/html/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="meta" scheme="https://jambo0624.github.io/tags/meta/"/>
    
      <category term="tag" scheme="https://jambo0624.github.io/tags/tag/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序知识点</title>
    <link href="https://jambo0624.github.io/2019-07-27-minipro.html"/>
    <id>https://jambo0624.github.io/2019-07-27-minipro.html</id>
    <published>2019-07-27T02:04:04.000Z</published>
    <updated>2020-10-13T10:46:44.734Z</updated>
    
    <content type="html"><![CDATA[<p>近期公司在做小程序，虽然暂时没有参与进去，但是学习的热情不能减。<br>下面就把学习过程中的一些笔记进行整理，作如下总结。我们开始吧。</p><a id="more"></a><h3 id="主体目录结构"><a href="#主体目录结构" class="headerlink" title="主体目录结构"></a>主体目录结构</h3><blockquote><p>pages   – 项目所有组件   index.wxml - xml文件(非常严格)<br>app.js   – 入口文件<br>app.json – 项目全配置文件(1)不能加注释 (2)内容严格<br>app.wxss – 全局样式文件   添加二个新功能:(1)单位  rpx (2) @import “x.wxss”</p></blockquote><h3 id="wxml——小程序wxml-是一种xml文件用于描述网页结构"><a href="#wxml——小程序wxml-是一种xml文件用于描述网页结构" class="headerlink" title="wxml——小程序wxml 是一种xml文件用于描述网页结构"></a>wxml——小程序wxml 是一种xml文件用于描述网页结构</h3><p>xml 格式要求非常严格，不是html<br><strong>一个xml文件必须有且只有一个根元素</strong><br><strong>所有标签有开始必须有结束</strong><br><strong>所有属性值必须双引号</strong>   <code>&lt;button name=&quot;btn&quot; &gt;</code><br>wxml常用标签</p><blockquote><p><code>&lt;view&gt;&lt;/view&gt;</code>            相当于  <code>&lt;div&gt;&lt;/div&gt;</code><br><code>&lt;text&gt;&lt;/text&gt;</code>             相当于 <code>&lt;span&gt;&lt;p&gt;</code><br><code>&lt;image&gt;&lt;/image&gt;</code>         相当于 <code>&lt;img src=&quot;&quot; /&gt;</code><br><code>&lt;navigator&gt;&lt;/navigator&gt;</code>    相当于 <code>&lt;a&gt;</code><br><code>&lt;form&gt;&lt;/form&gt;</code></p></blockquote><p><strong>修改显示组件顺序</strong><br>app.json  “pages”:[“pages/index/index”…]<br>哪个组件在第一位则默认显示哪个组件 </p><h3 id="wxss-样式文件"><a href="#wxss-样式文件" class="headerlink" title="wxss [样式文件]"></a>wxss [样式文件]</h3><p>  每一个组件中都有一个样式文件,每一个组件中都有一个js文件。默认样式文件和js文件自动加载wxml。不用手工引入(微信小程序平台自动操作)<br>  小程序对css文件封装操作 wxss—-#rpx     (r响应式)<br>  示例:</p><blockquote><p>iphone 6 设计图宽度(物理像素 750)     2x<br>(逻辑像素  375px) (逻辑像素 750rpx)<br>iphone 6 plus                    3x </p></blockquote><p>  注意:width:height 使用 rpx;font-size:12px; </p><p><strong>样式引入</strong><br>  @import “引入其它样式文件”<br>  小程序样式布局:弹性布局</p><h3 id="js-样式文件"><a href="#js-样式文件" class="headerlink" title="js [样式文件]"></a>js [样式文件]</h3><p>  小程序一个组件对应 .js 默认有一个对象<br>  Page:当前组件对象 <code>Page({data:{},onload:function()...})</code><br>  小程序js程序<br>  (1)ECMAScript<br>    基本数据类型 number;string;boolean;null;undefined<br>    引入         Object;Number;Date;RegExp;…<br>  (2)小程序没有 BOM/BOM概念<br>    widow;document;alert();….<br>  (3)小程序有一个顶级js对象  wx(类似window)</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>  轮播图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">""</span> &gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常见属性:<br>-autoplay 自动播放<br>-interval  间隔时间<br>-indicator-dots 指示点<br>-vertical   方向</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>   生命周期:一个组件从创建到销毁过程<br>   全局生命周期:app.js</p><blockquote><p>-onLaunch 当小程序运行只执行一次</p></blockquote><p>   局部生命周期(组件生命周期)</p><blockquote><p>-onLoad        组件加载时触发一个组件只会调用一次<br>    参数: options  不同组件之间传参数   a?id=10       b:options.id<br>    通常在此事件发送ajax请求,获取参数</p></blockquote><blockquote><p>-onReady  页面初次渲染完成触发,一个页面只会调用一次,代表页面己渲染结束可以进入交互操作<br>-onShow   页面显示或者切换前台时触发<br>-onHide    页面隐藏/切换后台触发<br>-onUnload 页面卸载时触发.通过程序跳转其它组件<br>                redirectTo();navigateBack()触发</p></blockquote><h3 id="组件事件处理函数"><a href="#组件事件处理函数" class="headerlink" title="组件事件处理函数"></a>组件事件处理函数</h3><blockquote><p>-onPullDownRefresh 监听用户下拉操作<br>    #默认小程序禁止用户下拉操作<br>    #在全局配置文件”window”<br>     enablePullDownRefresh:false   </p></blockquote><blockquote><p>-onReachBottom         监听用户上拉触底<br>-onPageScroll({})         监听用户滑动页面事件 </p></blockquote><blockquote><p> scrollTop         页面在垂直方向己经滚动距离</p></blockquote><h3 id="小程序配置"><a href="#小程序配置" class="headerlink" title="小程序配置"></a>小程序配置</h3><p>全局配置项局部配置项 app.json </p><blockquote><p>-pages:  array   页面路径列表,默认显示数组第一个组件内容</p></blockquote><blockquote><p>-window     窗口样式(渲染方式)<br> “navigationBarTextStyle”: “black”/“white”   颜色  “#f00” red 错误</p></blockquote><blockquote><p>-tabBar            兼容性差<br>    exam01/exam01.json 局部(就近原则)</p></blockquote><h3 id="小程序数据表现-wxml-WeiXin-Markup-Language-一套以xml为标准语言"><a href="#小程序数据表现-wxml-WeiXin-Markup-Language-一套以xml为标准语言" class="headerlink" title="小程序数据表现 wxml(WeiXin Markup Language) 一套以xml为标准语言"></a>小程序数据表现 wxml(WeiXin Markup Language) 一套以xml为标准语言</h3><blockquote><p><code>&lt;view&gt;&lt;view&gt;</code>    div<br><code>&lt;text&gt;&lt;/text&gt;</code>    只有text元素才能全选(复制)<br> <code>:selectable</code>     false  文本是否可以选中<br> <code>:decode</code>       false  是否解码</p></blockquote><blockquote><p><code>&lt;image src=&quot;x.jpg&quot; mode=&quot;aspectFill &quot; lazy-load&gt;&lt;/image&gt;</code><br> <code>:mode</code> :二个参数选项 “aspectFill”  “aspectFit” 缩放<br> <code>:lazy-load</code> :支持懒加载</p></blockquote><blockquote><p><code>&lt;navigator url=&quot;当前小程序跳转链接&quot;&gt;&lt;/navigator&gt;</code></p></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件:组件表示层(wxml)与业务逻辑层(js)交互手段<br>事件绑定:<code>&lt;view id=&quot;tapTest&quot; data-idx=&quot;10&quot; bindtap=&quot;函数&quot;&gt;Clike Me&lt;/view&gt;</code><br>事件类型:</p><blockquote><p>tap      :手指触摸后马上离开<br>longtap  :手指触摸后，超过 350ms再离开(长按钮) 旧<br>longpress :手指触摸后, 超过 350ms再离开         新 1.5.0</p></blockquote><p>绑定函数:在相应的Page对象定义事件处理函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  函数名:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 事件对象信息 ：</span></span><br><span class="line"><span class="comment">// -type:"tap"                           触发事件名称</span></span><br><span class="line"><span class="comment">// -target:&#123;id:" tapTest",dataset:&#123;"idx":19&#125;&#125;   触发事件元素</span></span><br><span class="line"><span class="comment">// -currentTarget&#123;&#125;                       当前元素</span></span><br><span class="line"><span class="comment">// -timeStamp:            页面打开到触发事件所经过毫秒数</span></span><br></pre></td></tr></table></figure><p>注意事项:<br>   (1) “longtap” event is deprecated. Please use “longpress” event instead.<br>    过期:不建议再使用，如果一定要用也可以正常使用<br>   (2)如果当前元素指定 longpress并绑定函数tap事件有可能不会触发<br>   事件传播方式分类<br>   (1)冒泡事件:当一个组件上的事件被触发后，该事件会向父节点传递<br>   (2)非冒泡事件:一个组件上的事件被触发后，该事件不向父节点传递<br>   小程序区别事件处理是否使用冒泡方式看前缀<br>   bind  冒泡事件    bindtap<br>   catch 非冒泡事件  catchtap</p><h3 id="获取不同类型参数跳转方式"><a href="#获取不同类型参数跳转方式" class="headerlink" title="获取不同类型参数跳转方式"></a>获取不同类型参数跳转方式</h3><p>   小程序参数:不推荐使用参数传递数值方式来将参数传递函数内<br>   解决方案: 自定义属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=<span class="string">"tapName"</span> data-idx=<span class="string">"39"</span> bindtap=<span class="string">"tapName"</span>&gt;&lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">Page(&#123;</span></span><br><span class="line"><span class="regexp">   tapName:function(event)&#123;</span></span><br><span class="line"><span class="regexp">    console.log(event.target.dataset.idx);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="小程序跳转与参数传递"><a href="#小程序跳转与参数传递" class="headerlink" title="小程序跳转与参数传递"></a>小程序跳转与参数传递</h3><p>   小程序不同组件之间跳转<br>   方式一:标签   <code>&lt;navigator url=&quot;组件路径&quot;&gt;&lt;/navigator&gt;</code> 注意:使用标签方式跳转还可后退<br>   方式二:编程</p><blockquote><p>-wx.navigateTo({});<br>      保留当前组件跳转到应用内容其它组件<br>      #要求:不能跳转 tabbar</p></blockquote><blockquote><p>-wx.navigateBack({url:组件路径})<br>      关闭当前页组件返回上一个组件或其它组件</p></blockquote><p>   新问题:获取参数值不能将数值显示模板<br>   解决问题:<br>   (1)在低版本小程序 this.data.id = id; 正确   2017 &lt;<br>   (2)新版本小程序  使用新方法解决 setData<br>       setData({data属性名:数值})<br>       setData将数据异步更新视图wxml同时改变 this.data值</p><blockquote><p>-wx.redirectTo({url:”组件路径”})<br>      关闭当组件跳转到应用内其它个组件，不允许跳转tabbar<br>      关闭当前组件<br>         1:关闭当前组件<br>         2:卸载组件 在卸载之前触发 onUnload</p></blockquote><blockquote><p>-wx.reLaunch({url:”组件路径”})<br>      关闭所有组件，打开到应用内某个组件<br>-wx.switchTab({url:”组件路径”})<br>      跳转到tabBar组件，并关闭所有非tabbar组件</p></blockquote><p>   小结:<br>    (1)不同组件之间跳转保留优先 wx.navigateTo()<br>    (2)如果当前组件定义tabbar   wx.reLaunch()</p><h3 id="AJAX请求"><a href="#AJAX请求" class="headerlink" title="AJAX请求"></a>AJAX请求</h3><p>小程序中显示数据依赖 AJAX获取服务器上数据,保存当前data属性在模板显示<br><code>wx.request({})</code>  小程序发送异步请求方法<br>常用属性和方法</p><blockquote><p>url            请求服务器程序地址<br>data string/object/array   请求参数<br>method         请求方法<br>header       请求header appliation/json<br>success          请求成功回调函数<br>fail          请求失败回调函数<br>complete     无论成功或失败都执行</p></blockquote><p>常见错误</p><blockquote><p>(1)工具菜单-&gt;项目详细-&gt;[*] 不校验合法域名<br>(2) this.setData is not a function;<br>   在请求处理函数this 指定当前 wx对象 wx没有 setData<br>   将this指定从 wx 修改 Page<br>   解决方案:使用箭头函数 </p></blockquote><blockquote><p>(3)参数传递失败 id;age<br>  解决方案:打开网络控制面板 network</p></blockquote><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><blockquote><p>-wx.showToast({});       显示消息提示框<br>      title:”..”   提示的内容<br>      icon:””    图标:默认值 “success”<br>      duration  延迟时间<br>      注意:title字数为了兼容性少于7个字<br>      注意:icon:”success” “loading” “none”</p></blockquote><blockquote><p>-wx.showModal({});      显示模态对话框<br>      title:””    标题<br>      content:”” 内容<br>      success: (res)=&gt;{<br>      }</p></blockquote><blockquote><p>-wx.showActionSheet({})  显示操作菜单<br>      itemList:[“”,””,””]<br>      itemColor:”#fff”<br>      success:(res)=&gt;{<br>       res.tapIndex 用户选中下标下标<br>      }</p></blockquote><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>局部(当前组件)数据存储<br><code>data:{}</code><br>全局(小程序生命周期)数据存储跨组件  -在app.js 定义全局共享数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  globalData:&#123;<span class="attr">LoginName</span>:<span class="string">""</span>,<span class="attr">list</span>:[]&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>-其它组件操作全局数据<br>(1)加载全局组件,小程序提供方法 getApp()       const app = getApp();<br>(2)读取数据       var uname = app.globalData.LoginName;<br>(3)操作数据       app.globalData.LoginName = “tom”</p><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>  小程序后台播放器播放音乐，对于微信客户端来说，只能同时<br>  有一个后台音乐在播放，当其它小程序占用音乐播放器，原有<br>  小程序音乐停止播放<br>    方法与事件<br>    (1)wx.playBackgroundAudio({})   播放背景音乐<br>     -datalist        音乐链接目前支持音频格式  mp3;wav;aac;m4a<br>     -title           音乐标题<br>     -convertImgUrl  封面<br>    (2)wx.pauseBackgroundAudio({})  暂停背景音乐<br>    (3)wx.stopBackgroundAudio({})   停止背景音乐<br>    (4)wx.onBackgroundAudioPlay    监听音乐播放事件<br>    (5)wx.onBackgroundAudioPause   监听音乐暂停播放事件<br>    (6)wx.onBackgroundAudioStop    监听音乐停止播放事件</p><p>  开发顺序<br>     -将音频文件保存服务器 node.js/public/bg.mp3<br>     -启动服务器<br>     -打开浏览器访问bg.mp3<br>     -index组件</p><p>   常见错误:音乐播放时闪退<br>   原因:音乐文件路径不正确或者服务器出错</p><h3 id="多媒体视频"><a href="#多媒体视频" class="headerlink" title="多媒体视频"></a>多媒体视频</h3><p>   1:通过video组件显示视频<br>    <code>&lt;video src=&quot;视频路径&quot;&gt;&lt;/video&gt;</code><br>    默认视频:300px 宽 225px 高<br>    常见属性 </p><blockquote><p>autoplay  自动播放<br>loop      循环<br>muted    静音<br>poster    广告图片<br>controls   控件 </p></blockquote><p>   2: 通过video组件显示视频(选择视频 相册 照相机)<br>     <code>&lt;video src=&quot;&quot;&gt;&lt;/video&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseVideo(&#123;                  <span class="comment">// 选择视频播放</span></span><br><span class="line">  sourceType:[<span class="string">"album"</span>,<span class="string">"camera"</span>],    <span class="comment">// 相册相机</span></span><br><span class="line">  maxDuration:<span class="number">60</span>,                 <span class="comment">// 视频长度上限</span></span><br><span class="line">  camera:[<span class="string">"front"</span>,<span class="string">"back"</span>],           <span class="comment">// 相册可以用前摄像头后</span></span><br><span class="line">  success:<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    result.tempFilePath;             <span class="comment">// 视频路径 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="tabbar"><a href="#tabbar" class="headerlink" title="tabbar"></a>tabbar</h3><p>小程序主页底层导航条，该导航条是通过配置文件创建<br>app.json<br>pages:[]    组件访问路径<br>windows:{} 组件配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tabBar:&#123;</span><br><span class="line">   <span class="string">"position"</span>:<span class="string">"bottom"</span>,     <span class="comment">// tabbar位置"top","bottom"</span></span><br><span class="line">   <span class="string">"list"</span>:[</span><br><span class="line">      &#123; </span><br><span class="line">      <span class="string">"pagePath"</span>:<span class="string">"pages/home/home"</span>,  <span class="comment">// 访问组件路径</span></span><br><span class="line">      <span class="string">"text"</span>:<span class="string">"首页"</span>,                   <span class="comment">// 当前文本</span></span><br><span class="line">      <span class="string">"iconPath"</span>:<span class="string">"assets/tabs/home.png"</span>, <span class="comment">// 图片路径</span></span><br><span class="line">      <span class="string">"selectedIconPath"</span>:<span class="string">"assets/tabs/home-action.png"</span> <span class="comment">//选中图片</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 注意1:图片本地保存<br> 注意2:最少二个对象</p><p> 1:常见错误:<br> tabBar.list[1].iconPath        文件不存在<br> tabBar.list[1].selectedIconPath 文件不存在<br> 2:常见错误:<br>  -点击某个组件  tabbar 消失<br>  -当前组需要显示tabbar必须将组配置<br>   tabbar:[pagePath]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期公司在做小程序，虽然暂时没有参与进去，但是学习的热情不能减。&lt;br&gt;下面就把学习过程中的一些笔记进行整理，作如下总结。我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="minipro" scheme="https://jambo0624.github.io/categories/minipro/"/>
    
    
      <category term="minipro" scheme="https://jambo0624.github.io/tags/minipro/"/>
    
  </entry>
  
</feed>
