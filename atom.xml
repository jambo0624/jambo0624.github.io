<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You should know</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jambo0624.github.io/"/>
  <updated>2020-05-31T04:12:58.954Z</updated>
  <id>https://jambo0624.github.io/</id>
  
  <author>
    <name>Jambo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>轮播图在切换页面时，显示凌乱的问题</title>
    <link href="https://jambo0624.github.io/2020-05-31-swiperInterval.html"/>
    <id>https://jambo0624.github.io/2020-05-31-swiperInterval.html</id>
    <published>2020-05-31T03:53:14.000Z</published>
    <updated>2020-05-31T04:12:58.954Z</updated>
    
    <content type="html"><![CDATA[<p>轮播图效果在切换页面后，首先会有一段加速过程，之后才会正常播放。这是什么原因呢？</p><p>原因是浏览器本着节省内存的原则，在页面切换到其他页面时，定时器不运动，但是动画依然排列，当切换回来的时候，动画加速运动，出现错误，在轮播图之类的页面经常会发生这样的情况</p><a id="more"></a><p>具体需要三个知识点</p><ul><li>document.onvisibilitychange<br>只要页面发生变化，就会触发这个事件</li></ul><hr><ul><li>document.hidden<br>这个是指当页面不是当前页面时为true，否则为false</li></ul><hr><ul><li>document.visibilityState<br>visible 表示当前网页是可见或者是部分可见的。<br>hidden：当前网页是不可见的<br>prerender 网页内容被预渲染并且用户不可见<br>unloaded 如果文档被卸载，那么这个值将被返回</li></ul><hr><h3 id="解决setInterval在浏览器切换中的问题："><a href="#解决setInterval在浏览器切换中的问题：" class="headerlink" title="解决setInterval在浏览器切换中的问题："></a>解决setInterval在浏览器切换中的问题：</h3><p>思路：如果页面是不可见的，那么我们就会清除定时器，如果页面是可见的，那么我们就重新开启定时器。<br>所以我们需要用<code>document.onvisibilitychange</code>进行监听，然后用<code>document.visibilityState</code>或者是<code>document.hidden</code>进行判断。<br>实际操作:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onvisibilitychange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">document</span>.visibilityState==<span class="string">"visible"</span>)&#123;</span><br><span class="line">      timer=setInterval(slidemove, <span class="number">1000</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jq中animate的解决"><a href="#jq中animate的解决" class="headerlink" title="jq中animate的解决"></a>jq中animate的解决</h3><p>如果用的是jq的animate这个方法，就只需要到这个方法的前面加上<code>stop(true,true)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".slidePanel"</span>).stop(<span class="literal">true</span>,<span class="literal">true</span>).animate(&#123;</span><br><span class="line">  <span class="string">"left"</span>: -iNow*varWidth+<span class="string">"px"</span>,</span><br><span class="line">  <span class="string">"speed"</span>:<span class="number">300</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;轮播图效果在切换页面后，首先会有一段加速过程，之后才会正常播放。这是什么原因呢？&lt;/p&gt;
&lt;p&gt;原因是浏览器本着节省内存的原则，在页面切换到其他页面时，定时器不运动，但是动画依然排列，当切换回来的时候，动画加速运动，出现错误，在轮播图之类的页面经常会发生这样的情况&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="swiper" scheme="https://jambo0624.github.io/tags/swiper/"/>
    
      <category term="interval" scheme="https://jambo0624.github.io/tags/interval/"/>
    
  </entry>
  
  <entry>
    <title>js-timeTrans</title>
    <link href="https://jambo0624.github.io/2020-04-27-js-timeTrans.html"/>
    <id>https://jambo0624.github.io/2020-04-27-js-timeTrans.html</id>
    <published>2020-04-27T07:09:25.000Z</published>
    <updated>2020-04-29T14:22:35.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间问题的汇总"><a href="#时间问题的汇总" class="headerlink" title="时间问题的汇总"></a>时间问题的汇总</h2><p>实际开发过程中，经常会遇到时间的转换问题，但是通常成熟的开发团队经常会在公共区域封装项目的时间转换函数。<br>下面是可能的一些情况：</p><ol><li>时区原因需对时间进行处理，0时区+8小时<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldTimes = <span class="string">'2020-04-20 14:08:09'</span></span><br><span class="line"><span class="keyword">var</span> eosFormatTime = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> date = time.split(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> timeArr = time.split(<span class="string">' '</span>)[<span class="number">1</span>].split(<span class="string">':'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> timeExceptHourStr = timeArr.slice(<span class="number">1</span>,timeArr.length).join(<span class="string">':'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newHour = <span class="built_in">parseInt</span>(timeArr[<span class="number">0</span>]) + <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newH = ((newHour &lt; <span class="number">24</span>) ? newHour :(newHour % <span class="number">24</span>)).toString()</span><br><span class="line">  <span class="keyword">return</span> date + <span class="string">' '</span> + newH + <span class="string">':'</span> + timeExceptHourStr</span><br><span class="line">&#125;</span><br><span class="line">eosFormatTime(oldTimes)</span><br><span class="line"><span class="comment">// 上面的函数只是简单的进行了几个API的组合，基本没有解决问题。因为如果加了8小时之后，满了一天，没有任何的后续操作--玩具代码</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">var</span> Year = nowTime.getFullYear()</span><br><span class="line">  <span class="keyword">var</span> Month = nowTime.getMonth()+<span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> date = nowTime.getDate()</span><br><span class="line">  <span class="keyword">var</span> Week = nowTime.getDay()</span><br><span class="line">  <span class="keyword">var</span> Hour = nowTime.getHours()</span><br><span class="line">  <span class="keyword">var</span> Min = nowTime.getMinutes()</span><br><span class="line">  <span class="keyword">var</span> Sec = nowTime.getSeconds()</span><br><span class="line">  <span class="keyword">var</span> weekArray = [<span class="string">'星期日'</span>,<span class="string">'星期一'</span>,<span class="string">'星期二'</span>,<span class="string">'星期三'</span>,<span class="string">'星期四'</span>,<span class="string">'星期五'</span>,<span class="string">'星期六'</span>]</span><br><span class="line">  <span class="comment">// week的正确格式返回是weekArray[Week]</span></span><br><span class="line">  <span class="keyword">return</span> Year+<span class="string">'-'</span>+Month+<span class="string">'-'</span>+date+<span class="string">' '</span>+ toTenDigit(Hour)+<span class="string">':'</span>+toTenDigit(Min)+<span class="string">':'</span>+toTenDigit(Sec)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toTenDigit</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt; <span class="number">10</span> ? <span class="string">'0'</span>+n : n</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fnTime())</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDateTime</span>(<span class="params">fnTime,timeDif</span>)</span>&#123; </span><br><span class="line">   <span class="keyword">var</span> x = fnTime</span><br><span class="line">  <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(x)</span><br><span class="line">  time.setHours(time.getHours()+timeDif)</span><br><span class="line">  <span class="keyword">return</span> time</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(setDateTime(fnTime(),<span class="number">8</span>))</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;👆的代码是可以直接进行时间转换的。比如，直接加23小时，这样子<br>&nbsp;&nbsp;&nbsp;&nbsp;举一反三的话，也可以直接操作日期。比如👇的代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDateTime</span>(<span class="params">fnTime,dateDif</span>)</span>&#123; </span><br><span class="line">   <span class="keyword">var</span> x = fnTime</span><br><span class="line">  <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(x)</span><br><span class="line">  time.setDate(time.getDate()+timeDif)</span><br><span class="line">  <span class="keyword">return</span> time</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(setDateTime(fnTime(),<span class="number">8</span>))</span><br><span class="line"><span class="comment">// 加的天数由系统自动计算累加</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>getTimezoneOffset() 方法返回协调世界时（UTC）相对于当前时区的时间差值，单位为分钟。</li></ul><ol start="2"><li>时间格式的几个基本操作<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 取得當前時間</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="built_in">Date</span>.now()  <span class="comment">// 获取时间戳</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>()  <span class="comment">// 获取时间物件</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 时间物件和时间戳互相转换</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">const</span> dateObj = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="xml"><span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>)  // 时间戳=&gt;时间物件</span></span><br><span class="line"><span class="xml">dateObj.getTime() // 时间物件=&gt;时间戳 dateObj.valueOf()</span></span><br><span class="line"><span class="xml">Number(dateObj) //timestamp</span></span><br><span class="line"><span class="xml">+dateObj //timestamp</span></span><br><span class="line"><span class="xml">/**</span></span><br><span class="line"><span class="xml">* 通常的用法</span></span><br><span class="line"><span class="xml">**/ </span></span><br><span class="line"><span class="xml">new Date('2020-04-20 08:08:08')</span></span><br><span class="line"><span class="xml">new Date(2020,08,04,23,08,00)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">new Date(2020,08,04,23,08,00).toISOString() //"2020-09-04T15:08:00.000Z"</span></span><br><span class="line"><span class="xml">new Date(2020,08,04,23,08,00).toString() //"Fri Sep 04 2020 23:08:00 GMT+0800 (中国标准时间)"</span></span><br><span class="line"><span class="xml">new Date(2020,08,04,23,08,00).toTimeString() //"23:08:00 GMT+0800 (中国标准时间)"</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>两个常用方法<br>&nbsp;&nbsp;&nbsp;&nbsp;把秒数转换成分钟数和小时数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> totalSeconds = <span class="number">6384053</span></span><br><span class="line"><span class="keyword">var</span> hours = <span class="built_in">Math</span>.floor(totalSeconds/<span class="number">3600</span>)</span><br><span class="line"><span class="keyword">var</span> minutes = <span class="built_in">Math</span>.floor((totalSeconds%<span class="number">3600</span>)/<span class="number">60</span>)</span><br><span class="line"><span class="keyword">var</span> seconds = totalSeconds%<span class="number">3600</span>%<span class="number">60</span></span><br><span class="line"><span class="built_in">console</span>.log(hours,minutes,seconds)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing) <span class="comment">// originalThing 被引用</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;一旦调用了 replaceThing 函数，theThing 就得到一个新的对象，它由一个大数组和一个新的闭包（someMethod）组成。然而 originalThing 被一个由 unused 变量（这是从前一次调用 replaceThing 变量的 Thing 变量）所持有的闭包所引用。需要记住的是一旦为同一个父作用域内的闭包创建作用域，作用域将被共享。<br>&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，someMethod 创建的作用域与 unused 共享。unused 包含一个关于 originalThing 的引用。即使 unused 从未被引用过，someMethod 也可以通过 replaceThing 作用域之外的 theThing 来使用它（例如全局的某个地方）。由于 someMethod 与 unused 共享闭包范围，unused 指向 originalThing 的引用强制它保持活动状态（两个闭包之间的整个共享范围）。这阻止了它们的垃圾收集。<br>&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，为闭包 someMethod 创建的作用域与 unused 共享，而 unused 又引用 originalThing。someMethod 可以通过 replaceThing 范围之外的 theThing 来引用，尽管 unused 从来没有被引用过。事实上，unused 对 originalThing 的引用要求它保持活跃，因为 someMethod 与 unused 的共享封闭范围。<br>&nbsp;&nbsp;&nbsp;&nbsp;所有这些都可能导致大量的内存泄漏。当上面的代码片段一遍又一遍地运行时，您可以预期到内存使用率的上升。当垃圾收集器运行时，其大小不会缩小。一个闭包链被创建（在例子中它的根就是 theThing 变量），并且每个闭包作用域都包含对大数组的间接引用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;时间问题的汇总&quot;&gt;&lt;a href=&quot;#时间问题的汇总&quot; class=&quot;headerlink&quot; title=&quot;时间问题的汇总&quot;&gt;&lt;/a&gt;时间问题的汇总&lt;/h2&gt;&lt;p&gt;实际开发过程中，经常会遇到时间的转换问题，但是通常成熟的开发团队经常会在公共区域封装项目的时间转换函数。&lt;br&gt;下面是可能的一些情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时区原因需对时间进行处理，0时区+8小时&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; oldTimes = &lt;span class=&quot;string&quot;&gt;&#39;2020-04-20 14:08:09&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; eosFormatTime = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;time&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; date = time.split(&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; timeArr = time.split(&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].split(&lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; timeExceptHourStr = timeArr.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,timeArr.length).join(&lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; newHour = &lt;span class=&quot;built_in&quot;&gt;parseInt&lt;/span&gt;(timeArr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) + &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; newH = ((newHour &amp;lt; &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;) ? newHour :(newHour % &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;)).toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; date + &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt; + newH + &lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt; + timeExceptHourStr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;eosFormatTime(oldTimes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 上面的函数只是简单的进行了几个API的组合，基本没有解决问题。因为如果加了8小时之后，满了一天，没有任何的后续操作--玩具代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="timeTrans" scheme="https://jambo0624.github.io/tags/timeTrans/"/>
    
  </entry>
  
  <entry>
    <title>interview-review1</title>
    <link href="https://jambo0624.github.io/2020-04-26-interview-review1.html"/>
    <id>https://jambo0624.github.io/2020-04-26-interview-review1.html</id>
    <published>2020-04-26T14:26:26.868Z</published>
    <updated>2020-04-26T14:26:26.871Z</updated>
    
    <content type="html"><![CDATA[<ol><li>const,let,var</li><li>浏览器兼容</li><li>电梯逻辑</li><li>内存泄漏–垃圾回收机制</li><li>项目部署</li><li>webAssembly</li><li>移动端1px处理</li></ol><hr><ol><li>box-sizing</li><li>垂直居中</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">father</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">手写bind</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> self.apply(context,args.concat(bindArgs))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//终极版本</span></span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断调用者是否是函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 解决fBound作为构造函数new调用时this指向不对的问题</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二版本是fBound.prototype = this.prototype;但是这回导致更改fBound同时更改this，所以引入空函数fNOP</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>硬缓存，软缓存</li><li>sessionStorage,localStorage<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">'a'</span>,<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;))</span><br><span class="line"><span class="built_in">JSON</span>.parse(getItem(<span class="string">'a'</span>))</span><br></pre></td></tr></table></figure></li><li>事件委托</li><li>跨域</li><li>防抖</li><li>rem</li><li>function getAge(){}<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="string">'2015-10-25'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> birthDate = <span class="keyword">new</span> <span class="built_in">Date</span>(params)</span><br><span class="line">  <span class="keyword">let</span> nowDate = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">let</span> milliSecond = nowDate - birthDate</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(milliSecond/<span class="number">1000</span>/<span class="number">3600</span>/<span class="number">24</span>/<span class="number">365</span>)</span><br><span class="line">&#125;</span><br><span class="line">getAge(date)</span><br></pre></td></tr></table></figure></li></ol><hr><ol><li>持久化存储</li><li>css三角形</li><li>== 和 === 的区别</li><li>let var const</li><li>px2rem</li><li>垃圾回收机制（如何判断变量是否被引用）</li><li>开发中遇到的最大问题</li><li>三个空杯，三杯水，最快变成三满三空</li><li>20*20图，黑白黑白，白白为通，判断通路的方法</li><li>手写排序算法</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;const,let,var&lt;/li&gt;
&lt;li&gt;浏览器兼容&lt;/li&gt;
&lt;li&gt;电梯逻辑&lt;/li&gt;
&lt;li&gt;内存泄漏–垃圾回收机制&lt;/li&gt;
&lt;li&gt;项目部署&lt;/li&gt;
&lt;li&gt;webAssembly&lt;/li&gt;
&lt;li&gt;移动端1px处理&lt;/li&gt;
&lt;/ol&gt;
&lt;hr
      
    
    </summary>
    
    
    
      <category term="interview" scheme="https://jambo0624.github.io/tags/interview/"/>
    
      <category term="review" scheme="https://jambo0624.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>object类型赋值的问题</title>
    <link href="https://jambo0624.github.io/2020-04-25-objectAssignment.html"/>
    <id>https://jambo0624.github.io/2020-04-25-objectAssignment.html</id>
    <published>2020-04-25T06:22:00.000Z</published>
    <updated>2020-04-25T13:32:35.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="object类型赋值的问题"><a href="#object类型赋值的问题" class="headerlink" title="object类型赋值的问题"></a>object类型赋值的问题</h3><p>一道代码题目如下，请问输出什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'Lydia'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> members = [person]</span><br><span class="line">person = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(members)  <span class="comment">//[&#123;name: 'Lydia'&#125;]</span></span><br></pre></td></tr></table></figure><p>解析如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>当设置两个对象相等时，他们会通过引用进行交互</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;但是<strong>当你将引用从一个变量分配至另一个变量时，其实只是执行了一个复制操作</strong>（他们的引用并不相同）<br>&nbsp;&nbsp;&nbsp;&nbsp;person为null时,我们并没有修改数组第一个元素的值，而只是修改了变量person的值。因为元素（复制而来）的引用与person不同。<br>&nbsp;&nbsp;&nbsp;&nbsp;members的第一个元素仍然保存着对原始对象的仍然保持着对原始对象的引用。当我们输出members时，第一个元素会将引用的对象打印出来。</p><a id="more"></a><hr><p>反之如果是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'Lydia'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> members = [person]</span><br><span class="line">members[<span class="number">0</span>] = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(members)  <span class="comment">//[null]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;object类型赋值的问题&quot;&gt;&lt;a href=&quot;#object类型赋值的问题&quot; class=&quot;headerlink&quot; title=&quot;object类型赋值的问题&quot;&gt;&lt;/a&gt;object类型赋值的问题&lt;/h3&gt;&lt;p&gt;一道代码题目如下，请问输出什么？&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; person = &amp;#123; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Lydia&#39;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; members = [person]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(members)  &lt;span class=&quot;comment&quot;&gt;//[&amp;#123;name: &#39;Lydia&#39;&amp;#125;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解析如下：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;当设置两个对象相等时，他们会通过引用进行交互&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;但是&lt;strong&gt;当你将引用从一个变量分配至另一个变量时，其实只是执行了一个复制操作&lt;/strong&gt;（他们的引用并不相同）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;person为null时,我们并没有修改数组第一个元素的值，而只是修改了变量person的值。因为元素（复制而来）的引用与person不同。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;members的第一个元素仍然保存着对原始对象的仍然保持着对原始对象的引用。当我们输出members时，第一个元素会将引用的对象打印出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="object" scheme="https://jambo0624.github.io/tags/object/"/>
    
      <category term="heap" scheme="https://jambo0624.github.io/tags/heap/"/>
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>var、let、const 区别</title>
    <link href="https://jambo0624.github.io/2020-04-17-const-let-var.html"/>
    <id>https://jambo0624.github.io/2020-04-17-const-let-var.html</id>
    <published>2020-04-17T13:33:44.000Z</published>
    <updated>2020-04-18T03:19:22.265Z</updated>
    
    <content type="html"><![CDATA[<p>let和const作为新的定义变量的方式，解决了var定义变量存在的一些问题。<br>存在的问题主要是<br>&nbsp;&nbsp;&nbsp;&nbsp;1.变量声明提升<br>&nbsp;&nbsp;&nbsp;&nbsp;2.JS没有块级作用域<br>&nbsp;&nbsp;&nbsp;&nbsp;3.循环内变量过度共享，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台输出了3个3</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>下面依次介绍let和const</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>let声明的变量拥有块级作用域<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'a'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure></li><li>let声明的全局变量不是全局对象的属性<br>&nbsp;&nbsp;&nbsp;&nbsp;这就意味着，你不可以通过window.变量名的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的外层块。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="string">'c'</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">'d'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">//c</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.d) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li><li>形如for (let x…)的循环在每次迭代时都为x创建新的绑定<br>&nbsp;&nbsp;&nbsp;&nbsp;正因为let声明的变量不在全局中，而在一个不可见的作用域中。所以，如果for循环执行多次并且循环保持了一个闭包，那么每个闭包将捕捉一个循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台输出1 2 3</span></span><br></pre></td></tr></table></figure>这种情况适用于现有的三种循环方式：for-of、for-in、以及传统的用分号分隔的类C循环</li><li>用let重定义变量会抛出一个语法错误（SyntaxError）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'b'</span> <span class="comment">// Uncaught SyntaxError:Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>在这些不同之外，let和var几乎很相似了。举个例子，它们都支持使用逗号分隔声明多重变量，它们也都支持解构特性。</strong></p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一句话说明白，const 就是用来定义常量的！任何非主流的写法都是非法的<br>比如这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只声明变量不赋值</span></span><br><span class="line"><span class="keyword">const</span> a  <span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p>这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复声明变量</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'b'</span> <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><p>还有这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给变量重新赋值</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span></span><br><span class="line">a = <span class="string">'b'</span> <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><p>最后是经常容易忽略的特殊情况,看似黑科技</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不过不推荐这么干，实在没啥意思，常量常量，不变的才叫常量嘛~</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="comment">//重新赋值当然是行不通的了</span></span><br><span class="line">a = &#123;<span class="attr">a</span>:<span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="comment">//嘿嘿嘿科技</span></span><br><span class="line">a.a = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>其实不是黑科技</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="string">'a'</span>&#125;;  <span class="comment">// 绑定的是对象指针</span></span><br><span class="line"><span class="comment">//重新赋值当然是行不通的了</span></span><br><span class="line">a = &#123;<span class="attr">a</span>:<span class="string">'b'</span>&#125;;  <span class="comment">// 绑定新对象的指针</span></span><br><span class="line"><span class="comment">//并不是科技</span></span><br><span class="line">a.a = <span class="string">'b'</span> <span class="comment">// 对象指针没变，指针指向的内容可以随意改变。</span></span><br></pre></td></tr></table></figure><p>以上就是暂时碰到一些常见问题的总结。That’s all！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;let和const作为新的定义变量的方式，解决了var定义变量存在的一些问题。&lt;br&gt;存在的问题主要是&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.变量声明提升&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.JS没有块级作用域&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.循环内变量过度共享，代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 控制台输出了3个3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="ES6" scheme="https://jambo0624.github.io/tags/ES6/"/>
    
      <category term="var" scheme="https://jambo0624.github.io/tags/var/"/>
    
      <category term="let" scheme="https://jambo0624.github.io/tags/let/"/>
    
      <category term="const" scheme="https://jambo0624.github.io/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>css一些体会</title>
    <link href="https://jambo0624.github.io/2020-03-30-css-advance.html"/>
    <id>https://jambo0624.github.io/2020-03-30-css-advance.html</id>
    <published>2020-03-30T01:04:56.000Z</published>
    <updated>2020-04-01T09:13:30.031Z</updated>
    
    <content type="html"><![CDATA[<ul><li>css元素之间互相影响的一些案例,即不正交之处<blockquote><p>兄弟元素之间，上下<code>margin</code>会合并，但是加<code>border</code>之后就不会了。包括父子元素，也就是BFC的触发<br><code>li</code>元素的小圆点，会受到<code>display</code>的影响<br><code>position</code>为<code>absolute</code>是，<code>display</code>的值会受影响<br><code>transform:scale()</code>会让<code>position:fixed</code>也被拉伸计算<br><code>float</code>不会影响<code>block</code>，但是会让文字环绕</p></blockquote><a id="more"></a></li></ul><hr><ul><li>垂直居中时，高度不要写死，高度要由内容撑开，或者加<code>padding</code>使得元素居中<h3 id="块级元素内含行内元素的一些问题"><a href="#块级元素内含行内元素的一些问题" class="headerlink" title="块级元素内含行内元素的一些问题"></a>块级元素内含行内元素的一些问题</h3>&nbsp;&nbsp;&nbsp;&nbsp;如果其内部只有行内元素，那么他的高度是由行内元素的行高确定的，通常是字体大小乘以字体建议的行高<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>&amp;nbsp;</code>意思是no break space<br>&nbsp;&nbsp;&nbsp;&nbsp;让姓名和联系方式两端对齐的小技巧,核心是<code>text-align:justify</code>和<code>::after</code><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: justify;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>文本溢出<br>单行<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>多行<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">-webkit-line-camp</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>文字垂直居中<blockquote><p>不要直接写死高度，或者行高<br>要写成<code>line-height</code>和`padding``撑出来的height</p></blockquote></li></ul><hr><h3 id="块级元素内含块级元素的一些问题"><a href="#块级元素内含块级元素的一些问题" class="headerlink" title="块级元素内含块级元素的一些问题"></a>块级元素内含块级元素的一些问题</h3><p>margin合并<br>阻止margin合并的办法就是在中间加元素，就是我们通常做的<code>::before{content:&#39;&#39;;display:table;}</code></p><ul><li>实现一个1:1的盒子<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆叠顺序"><a href="#堆叠顺序" class="headerlink" title="堆叠顺序"></a>堆叠顺序</h3>从上之下为，由底到面<blockquote><p>z-index: 负数<br>background<br>border<br>div<br>float<br>inline/text<br>position/z-index: 0<br>z-index: 正数</p></blockquote></li></ul><hr><h3 id="堆叠上下文"><a href="#堆叠上下文" class="headerlink" title="堆叠上下文"></a>堆叠上下文</h3><p>这里上下文指的是一个块，也就是区域<br>以下情况会触发：<br>&nbsp;&nbsp;&nbsp;&nbsp;根元素 (HTML),<br>&nbsp;&nbsp;&nbsp;&nbsp;z-index 值不为 “auto”的 绝对/相对定位，<br>&nbsp;&nbsp;&nbsp;&nbsp;一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，<br>&nbsp;&nbsp;&nbsp;&nbsp;opacity 属性值小于 1 的元素<br>&nbsp;&nbsp;&nbsp;&nbsp;transform 属性值不为 “none”的元素，<br>&nbsp;&nbsp;&nbsp;&nbsp;mix-blend-mode 属性值不为 “normal”的元素，<br>&nbsp;&nbsp;&nbsp;&nbsp;filter值不为“none”的元素，<br>&nbsp;&nbsp;&nbsp;&nbsp;perspective值不为“none”的元素，<br>&nbsp;&nbsp;&nbsp;&nbsp;isolation 属性被设置为 “isolate”的元素，<br>&nbsp;&nbsp;&nbsp;&nbsp;position: fixed<br>&nbsp;&nbsp;&nbsp;&nbsp;在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值<br>&nbsp;&nbsp;&nbsp;&nbsp;-webkit-overflow-scrolling 属性被设置 “touch”的元素</p><hr><h2 id="移动端的小技巧"><a href="#移动端的小技巧" class="headerlink" title="移动端的小技巧"></a>移动端的小技巧</h2><h3 id="基础差异"><a href="#基础差异" class="headerlink" title="基础差异"></a>基础差异</h3><ol><li>学会 media query</li><li>学会要设计图（没图不做）<br>&nbsp;&nbsp;&nbsp;&nbsp;实在要做也行，丑可别怪我</li><li>学会隐藏元素</li><li>手机端要加一个 meta<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>手机端的交互方式不一样<br>&nbsp;&nbsp;&nbsp;&nbsp;没有 hover<br>&nbsp;&nbsp;&nbsp;&nbsp;有 touch 事件<br>&nbsp;&nbsp;&nbsp;&nbsp;没有 resize<br>&nbsp;&nbsp;&nbsp;&nbsp;没有滚动条</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;css元素之间互相影响的一些案例,即不正交之处&lt;blockquote&gt;
&lt;p&gt;兄弟元素之间，上下&lt;code&gt;margin&lt;/code&gt;会合并，但是加&lt;code&gt;border&lt;/code&gt;之后就不会了。包括父子元素，也就是BFC的触发&lt;br&gt;&lt;code&gt;li&lt;/code&gt;元素的小圆点，会受到&lt;code&gt;display&lt;/code&gt;的影响&lt;br&gt;&lt;code&gt;position&lt;/code&gt;为&lt;code&gt;absolute&lt;/code&gt;是，&lt;code&gt;display&lt;/code&gt;的值会受影响&lt;br&gt;&lt;code&gt;transform:scale()&lt;/code&gt;会让&lt;code&gt;position:fixed&lt;/code&gt;也被拉伸计算&lt;br&gt;&lt;code&gt;float&lt;/code&gt;不会影响&lt;code&gt;block&lt;/code&gt;，但是会让文字环绕&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>面试js部分（二）</title>
    <link href="https://jambo0624.github.io/2020-03-25-interview-js2.html"/>
    <id>https://jambo0624.github.io/2020-03-25-interview-js2.html</id>
    <published>2020-03-25T09:45:53.000Z</published>
    <updated>2020-03-29T07:56:58.064Z</updated>
    
    <content type="html"><![CDATA[<ul><li>JS中使用typeof可以得到哪些值<br>共5种他们分别是undefined,string,number,boolean,object,function<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span> <span class="comment">//string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">//number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">//boolean</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">//function</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li>变量计算–强制类型转换<br>字符串拼接<br>== 运算符(jquery源码中，<code>obj.a==null</code>和<code>obj.a===null || obj.a===undefined</code>一样的效果)<br>if 语句<br>逻辑运算符</li></ul><hr><ul><li>JS中的内置函数<br>Object<br>Array<br>Number<br>String<br>Boolean<br>Function<br>Date<br>RegExp<br>Error</li></ul><hr><ul><li>创建10个a标签，点击的时候弹出来对应的序号<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i,a</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">    a.innerHTML = i + <span class="string">'&lt;br&gt;'</span></span><br><span class="line">    a.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">      e.preventDefault()</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.body.append(a)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>获取 2017-06-10格式的日期<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!date)&#123;</span><br><span class="line">    date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> year = date.getFullYear()</span><br><span class="line">  <span class="keyword">var</span> month = date.getMonth()+<span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> day = date.getDate()</span><br><span class="line">  month = month &lt; <span class="number">10</span> ? <span class="string">'0'</span>+month:month</span><br><span class="line">  day = day &lt; <span class="number">10</span> ? <span class="string">'0'</span>+day:day</span><br><span class="line">  <span class="keyword">return</span> year +<span class="string">'-'</span>+ month+<span class="string">'-'</span> + day</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(format())</span><br></pre></td></tr></table></figure></li><li>获取随机数，要求是长度一致的字符串格式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">random = random + <span class="string">'0000000000'</span></span><br><span class="line">random = random.slice(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(random)</span><br></pre></td></tr></table></figure></li><li>能遍历对象和数组的通用forEach函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">obj,fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> key</span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">    obj.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">      fn(item,index)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">        fn(key,obj[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">forEach(arr,(item,index)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item,index)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>:<span class="string">'100'</span>,<span class="attr">y</span>:<span class="string">'200'</span>&#125;</span><br><span class="line">forEach(obj,(key,val)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key,val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>DOM节点的attribute和property有什么不同<br>Attribute更原生，是对html标签属性的修改<br>Property是对JS对象的属性的修改</li></ul><hr><ul><li>通用事件绑定<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem,type,selector,fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!fn)&#123;</span><br><span class="line">    fn = selector</span><br><span class="line">    selector = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  elem.addEventListener(type,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target</span><br><span class="line">    <span class="keyword">if</span>(selector)&#123;</span><br><span class="line">      target = e.target</span><br><span class="line">      <span class="keyword">if</span>(target.matches(selector))&#123;</span><br><span class="line">        fn.call(target,e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fn(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">bindEvent(a,<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  alert(<span class="string">'clicked'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 事件委托</span></span><br><span class="line">bindEvent(div,<span class="string">'click'</span>,<span class="string">'a'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>require.js(AMD)<br><img src="https://s1.ax1x.com/2020/03/26/Gp77fU.jpg" alt="require.js"></li><li>CommonJS<br><img src="https://s1.ax1x.com/2020/03/26/Gpbtrd.png" alt="COmmonJS"><blockquote><p>要异步，就需要AMD<br>如果使用了npm，建议使用CommonJS</p></blockquote></li></ul><hr><ul><li>上线流程要点</li></ul><ol><li>将测试完的代码提交到git版本库的master分支</li><li>将当前服务器的代码进行打包并记录版本号，备份</li><li>将master分支的代码提交覆盖到线上服务器，生成新的版本号</li></ol><hr><ul><li>回滚流程要点</li></ul><ol><li>将当前服务器的代码打包并记录版本号，备份</li><li>将备份的上一个版本号解压，覆盖到线上服务器，并生成新的版本号</li></ol><hr><ul><li>window.onload和document.DOMContentLoaded<br>window.onload 页面的全部资源加载完才会执行，包括图片，视频等<br>document.DOMContentLoaded DOM渲染完执行</li></ul><hr><ul><li>三栏布局<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* float */</span></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* position */</span></span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* flex */</span></span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* table */</span></span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* grid */</span></span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>延伸问题</li></ul><ol><li>优缺点和兼容性<br>float 需要清除浮动，但是兼容性好<br>position 比较快，但是脱离文档流，实用性差<br>flex 比较好，目前主流<br>table 语义不好，会同时增高，兼容好<br>grid 最新的，最强大</li><li>高度的影响<br>flex和table能用</li></ol><hr><ul><li>JS如何设置获取盒模型的宽和高<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dom</span><span class="selector-class">.style</span><span class="selector-class">.height</span></span><br><span class="line"><span class="selector-tag">dom</span><span class="selector-class">.currentStyle</span><span class="selector-class">.height</span></span><br><span class="line"><span class="selector-tag">window</span><span class="selector-class">.getComputedStyle</span>(<span class="selector-tag">dom</span>)<span class="selector-class">.height</span></span><br><span class="line"><span class="selector-tag">dom</span><span class="selector-class">.getBoundingClientRect</span>()<span class="selector-class">.height</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;JS中使用typeof可以得到哪些值&lt;br&gt;共5种他们分别是undefined,string,number,boolean,object,function&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;abc&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//boolean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &amp;#123;&amp;#125; &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; [] &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log &lt;span class=&quot;comment&quot;&gt;//function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="interview" scheme="https://jambo0624.github.io/categories/interview/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>promise面试题</title>
    <link href="https://jambo0624.github.io/2020-03-18-interview-promise.html"/>
    <id>https://jambo0624.github.io/2020-03-18-interview-promise.html</id>
    <published>2020-03-18T08:27:18.000Z</published>
    <updated>2020-03-18T10:33:06.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><code>event loop</code>它的执行顺序：</p><blockquote><p>一开始整个脚本作为一个宏任务执行<br>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列<br>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完<br>执行浏览器<code>UI线程</code>的渲染工作<br>检查是否有<code>Web Worker</code>任务，有则执行<br>执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空</p></blockquote><a id="more"></a><p>微任务包括：<code>MutationObserver</code>、<code>Promise.then()</code>或<code>reject()</code>、<code>Promise</code>为基础开发的其它技术，比如<code>fetch API</code>、<code>V8的垃圾回收过程</code>、Node独有的<code>process.nextTick</code><br>宏任务包括：<code>script</code> 、<code>setTimeout</code>、<code>setInterval</code> 、<code>setImmediate</code> 、<code>I/O</code>、<code>UI rendering</code>。<br>注意⚠️：在所有任务开始的时候，由于宏任务中包括了<code>script</code>，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如<code>setTimeout</code>)将被放到下一轮宏任务中来执行。</p><h3 id="1-Promise的几道基础题"><a href="#1-Promise的几道基础题" class="headerlink" title="1. Promise的几道基础题"></a>1. Promise的几道基础题</h3><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, promise1)</span><br></pre></td></tr></table></figure>过程分析：<br>&nbsp;&nbsp;&nbsp;&nbsp;从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code><br>&nbsp;&nbsp;&nbsp;&nbsp;然后执行同步代码<code>1</code>，此时<code>promise1</code>没有被<code>resolve</code>或者<code>reject</code>，因此状态还是<code>pending</code><br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure></li><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>过程分析：<br>&nbsp;&nbsp;&nbsp;&nbsp;从上至下，先遇到<code>new Promise</code>，执行其中的同步代码<code>1</code><br>&nbsp;&nbsp;&nbsp;&nbsp;再遇到<code>resolve(&#39;success&#39;)</code>， 将<code>promise</code>的状态改为了<code>resolved</code>并且将值保存下来<br>&nbsp;&nbsp;&nbsp;&nbsp;继续执行同步代码<code>2</code><br>&nbsp;&nbsp;&nbsp;&nbsp;跳出<code>promise</code>，往下执行，碰到<code>promise.then</code>这个微任务，将其加入微任务队列<br>&nbsp;&nbsp;&nbsp;&nbsp;执行同步代码<code>4</code><br>&nbsp;&nbsp;&nbsp;&nbsp;本轮宏任务全部执行完毕，检查微任务队列，发现<code>promise.then</code>这个微任务且状态为<code>resolved</code>，执行它。<br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li>题目三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>过程分析<br>&nbsp;&nbsp;&nbsp;&nbsp;和题目二相似，只不过在<code>promise</code>中并没有<code>resolve</code>或者<code>reject</code><br>&nbsp;&nbsp;&nbsp;&nbsp;因此<code>promise.then</code>并不会执行，它只有在被改变了状态之后才会执行。<br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></li><li>题目四<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve(<span class="string">'resolve1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>,promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>,promise2)</span><br></pre></td></tr></table></figure>过程分析：<br>&nbsp;&nbsp;&nbsp;&nbsp;从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code><br>&nbsp;&nbsp;&nbsp;&nbsp;碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来<br>&nbsp;&nbsp;&nbsp;&nbsp;碰到<code>promise1.then</code>这个微任务，将它放入微任务队列<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code><br>&nbsp;&nbsp;&nbsp;&nbsp;执行同步代码<code>1</code>， 同时打印出<code>promise1</code>的状态是<code>resolved</code><br>&nbsp;&nbsp;&nbsp;&nbsp;执行同步代码<code>2</code>，同时打印出<code>promise2</code>的状态是<code>pending</code><br>&nbsp;&nbsp;&nbsp;&nbsp;宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。<br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">'resolve1'</span>&#125;</span><br><span class="line"><span class="string">'2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'resolve1'</span></span><br></pre></td></tr></table></figure></li><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'success'</span></span><br></pre></td></tr></table></figure></li><li>题目六<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>是的，现在<code>start</code>就在<code>1</code>之前打印出来了，因为<code>fn</code>函数是之后执行的。<br>注意⚠️：之前我们很容易就以为看到<code>new Promise()</code>就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。<br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start"</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure><h3 id="Promise结合setTimeout"><a href="#Promise结合setTimeout" class="headerlink" title="Promise结合setTimeout"></a>Promise结合setTimeout</h3></li><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'time'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>过程分析：<br>&nbsp;&nbsp;&nbsp;&nbsp;刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出<code>start</code>和<code>end</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>setTimout</code>作为一个宏任务被放入宏任务队列(下一个)<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>Promise.then</code>作为一个微任务被放入微任务队列<br>&nbsp;&nbsp;&nbsp;&nbsp;本次宏任务执行完，检查微任务，发现<code>Promise.then</code>，执行它<br>&nbsp;&nbsp;&nbsp;&nbsp;接下来进入下一个宏任务，发现<code>setTimeout</code>，执行。<br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'end'</span></span><br><span class="line"><span class="string">'resolve'</span></span><br><span class="line"><span class="string">'time'</span></span><br></pre></td></tr></table></figure></li><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timerStart"</span>);</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timerEnd"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>过程分析：<br>和题目<code>1.2</code>很像，不过在<code>resolve</code>的外层加了一层<code>setTimeout</code>定时器。<br>&nbsp;&nbsp;&nbsp;&nbsp;从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>1</code><br>&nbsp;&nbsp;&nbsp;&nbsp;然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行<br>&nbsp;&nbsp;&nbsp;&nbsp;执行同步代码<code>2</code><br>&nbsp;&nbsp;&nbsp;&nbsp;跳出<code>promise</code>函数，遇到<code>promise.then</code>，但其状态还是为<code>pending</code>，这里理解为先不执行<br>&nbsp;&nbsp;&nbsp;&nbsp;执行同步代码<code>4</code><br>&nbsp;&nbsp;&nbsp;&nbsp;一轮循环过后，进入第二次宏任务，发现延迟队列中有<code>setTimeout</code>定时器，执行它<br>&nbsp;&nbsp;&nbsp;&nbsp;首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列<br>&nbsp;&nbsp;&nbsp;&nbsp;继续执行同步代码<code>timerEnd</code><br>&nbsp;&nbsp;&nbsp;&nbsp;宏任务全部执行完毕，查找微任务队列，发现<code>promise.then</code>这个微任务，执行它。<br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="string">"timerStart"</span></span><br><span class="line"><span class="string">"timerEnd"</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure></li><li>题目三<br>题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么：<br>(1)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer3'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>(2)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer3'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br></pre></td></tr></table></figure>这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。<br>&nbsp;&nbsp;&nbsp;&nbsp;一个是为定时器<code>timer3</code>，一个是为<code>Promise.then</code><br>&nbsp;&nbsp;&nbsp;&nbsp;但是如果是定时器<code>timer3</code>的话，它会在<code>timer2</code>后执行，而<code>Promise.then</code>却是在<code>timer2</code>之前执行。<br>&nbsp;&nbsp;&nbsp;&nbsp;你可以这样理解，<code>Promise.then</code>是微任务，它会被加入到本轮中的微任务列表，而定时器<code>timer3</code>是宏任务，它会被加入到下一轮的宏任务中。<br>&nbsp;&nbsp;&nbsp;&nbsp;理解完这两个案例，可以来看看下面一道比较难的题目了。</li><li>题目四<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  <span class="keyword">const</span> timer2 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> timer1 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br></pre></td></tr></table></figure>这道题稍微的难一些，在promise中执行定时器，又在定时器中执行promise；<br>并且要注意的是，这里的Promise是直接resolve的，而之前的new Promise不一样。<br>因此过程分析为：<br>&nbsp;&nbsp;&nbsp;&nbsp;刚开始整个脚本作为第一次宏任务来执行，我们将它标记为<strong>宏1</strong>，从上至下执行<br>&nbsp;&nbsp;&nbsp;&nbsp;遇到<code>Promise.resolve().then</code>这个微任务，将<code>then</code>中的内容加入第一次的微任务队列标记为<strong>微1</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;遇到定时器<code>timer1</code>，将它加入下一次宏任务的延迟列表，标记为<strong>宏2</strong>，等待执行(先不管里面是什么内容)<br>&nbsp;&nbsp;&nbsp;&nbsp;执行<strong>宏1</strong>中的同步代码<code>start</code><br>&nbsp;&nbsp;&nbsp;&nbsp;第一次宏任务(<strong>宏1</strong>)执行完毕，检查第一次的微任务队列(<strong>微1</strong>)，发现有一个<code>promise.then</code>这个微任务需要执行<br>&nbsp;&nbsp;&nbsp;&nbsp;执行打印出<strong>微1</strong>中同步代码<code>promise1</code>，然后发现定时器<code>timer2</code>，将它加入<strong>宏2</strong>的后面，标记为<strong>宏3</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;第一次微任务队列(<strong>微1</strong>)执行完毕，执行第二次宏任务(<strong>宏2</strong>)，首先执行同步代码<code>timer1</code><br>&nbsp;&nbsp;&nbsp;&nbsp;然后遇到了<code>promise2</code>这个微任务，将它加入此次循环的微任务队列，标记为<strong>微2</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>宏2</strong>中没有同步代码可执行了，查找本次循环的微任务队列(<strong>微2</strong>)，发现了<code>promise2</code>，执行它<br>&nbsp;&nbsp;&nbsp;&nbsp;第二轮执行完毕，执行<strong>宏3</strong>，打印出<code>timer2</code><br>所以结果为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br></pre></td></tr></table></figure></li><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;从上至下，先执行第一个new Promise中的函数，碰到setTimeout将它加入下一个宏任务列表<br>&nbsp;&nbsp;&nbsp;&nbsp;跳出new Promise，碰到promise1.then这个微任务，但其状态还是为pending，这里理解为先不执行<br>&nbsp;&nbsp;&nbsp;&nbsp;promise2是一个新的状态为pending的Promise<br>&nbsp;&nbsp;&nbsp;&nbsp;执行同步代码console.log(‘promise1’)，且打印出的promise1的状态为pending<br>&nbsp;&nbsp;&nbsp;&nbsp;执行同步代码console.log(‘promise2’)，且打印出的promise2的状态为pending<br>&nbsp;&nbsp;&nbsp;&nbsp;碰到第二个定时器，将其放入下一个宏任务列表<br>&nbsp;&nbsp;&nbsp;&nbsp;第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务<br>&nbsp;&nbsp;&nbsp;&nbsp;先执行第一个定时器里的内容，将promise1的状态改为resolved且保存结果并将之前的promise1.then推入微任务队列<br>&nbsp;&nbsp;&nbsp;&nbsp;该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是promise1.then，它抛出了一个错误，且将promise2的状态设置为了rejected<br>&nbsp;&nbsp;&nbsp;&nbsp;第一个定时器执行完毕，开始执行第二个定时器中的内容<br>&nbsp;&nbsp;&nbsp;&nbsp;打印出’promise1’，且此时promise1的状态为resolved<br>&nbsp;&nbsp;&nbsp;&nbsp;打印出’promise2’，且此时promise2的状态为rejected</p><p>完整的结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line">test5.html:<span class="number">102</span> Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!! at test.html:<span class="number">102</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">"success"</span>&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;rejected&gt;: <span class="built_in">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure><ul><li><p>题目六<br>如果你上面这道题搞懂了之后，我们就可以来做做这道了，你应该能很快就给出答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timer1"</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1里的内容"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error!!!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"timer2"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1里的内容'</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line">test5.html:<span class="number">102</span> Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!! at test.html:<span class="number">102</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">"success"</span>&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;rejected&gt;: <span class="built_in">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise中的then、catch、finally"><a href="#Promise中的then、catch、finally" class="headerlink" title="Promise中的then、catch、finally"></a>Promise中的then、catch、finally</h3><p>总结：</p><blockquote><p>Promise的状态一经改变就不能再改变。(见3.1)<br>.then和.catch都会返回一个新的Promise。(上面的👆1.4证明了)<br>catch不管被连接到哪里，都能捕获上层的错误。(见3.2)<br>在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。<br>Promise 的 .then 或者 .catch 可以被调用多次, 当如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。(见3.5)<br>.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。(见3.6)<br>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。(见3.7)<br>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。(见3.8)<br>.then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。(见3.9)<br>.finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。</p></blockquote></li><li><p>题目一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then: "</span>, res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"then: success1"</span></span><br></pre></td></tr></table></figure><p>构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用 。验证了第一个结论，Promise的状态一经改变就不能再改变。</p></li></ul><hr><ul><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then1: "</span>, res);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then2: "</span>, res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then3: "</span>, res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"catch: "</span> <span class="string">"error"</span></span><br><span class="line"><span class="string">"then3: "</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>验证了第三个结论，catch不管被连接到哪里，都能捕获上层的错误。<br>至于then3也会被执行，那是因为catch()也会返回一个Promise，且由于这个Promise没有返回值，所以打印出来的是undefined。</li></ul><hr><ul><li>题目三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>Promise可以链式调用，不过promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般我们任务的链式调用一样return this。<br>上面的输出结果之所以依次打印出1和2，那是因为resolve(1)之后走的是第一个then方法，并没有走catch里，所以第二个then中的res得到的实际上是第一个then的返回值。<br>且return 2会被包装成resolve(2)。</li></ul><hr><ul><li>题目四<br>如果把3.3中的Promise.resolve(1)改为Promise.reject(1)又会怎么样呢？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>结果打印的当然是 1 和 3啦，因为reject(1)此时走的就是catch，且第二个then中的res得到的就是catch中的返回值。</li></ul><hr><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">      resolve(<span class="string">'success'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'timer'</span></span><br><span class="line">success <span class="number">1001</span></span><br><span class="line">success <span class="number">1002</span></span><br></pre></td></tr></table></figure>当然，如果你足够快的话，也可能两个都是1001。<br>Promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。</li></ul><hr><ul><li>题目六<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then: "</span>, res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>你可能想到的是进入.catch然后被捕获了错误。</li></ul><p>结果并不是这样的，它走的是.then里面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"then: "</span> <span class="string">"Error: error!!!"</span></span><br></pre></td></tr></table></figure><p>这也验证了第4点和第6点，返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的return new Error(‘error!!!’)也被包裹成了return Promise.resolve(new Error(‘error!!!’))。<br>当然如果你抛出一个错误的话，可以用下面👇两的任意一种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>));</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br></pre></td></tr></table></figure><ul><li>题目七<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="built_in">console</span>.err)</span><br></pre></td></tr></table></figure>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。</li></ul><p>因此结果会报错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure><ul><li>题目八<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="number">2</span>)</span><br><span class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>其实你只要记住原则8：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。</li></ul><p>第一个then和第二个then中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将resolve(1) 的值直接传到最后一个then里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>题目九<br>下面来介绍一下.then函数中的两个参数。</li></ul><p>第一个参数是用来处理Promise成功的函数，第二个则是处理失败的函数。</p><p>也就是说Promise.resolve(‘1’)的值会进入成功的函数，Promise.reject(‘2’)的值会进入失败的函数。<br>让我们来看看这个例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err!!!'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'catch'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的执行结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'error'</span> <span class="string">'error!!!'</span></span><br></pre></td></tr></table></figure><p>它进入的是then()中的第二个参数里面，而如果把第二个参数去掉，就进入了catch()中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err!!!'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'catch'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'catch'</span> <span class="string">'error!!!'</span></span><br></pre></td></tr></table></figure><p>但是有一个问题，如果是这个案例呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> <span class="title">success</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail1</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fail1'</span>, err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">fail2</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fail2'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于Promise调用的是resolve()，因此.then()执行的应该是success()函数，可是success()函数抛出的是一个错误，它会被后面的catch()给捕获到，而不是被fail1函数捕获。</p><p>因此执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fail2 <span class="built_in">Error</span>: error!!!</span><br><span class="line">at success</span><br></pre></td></tr></table></figure><ul><li>题目十<br>接着来看看.finally()，这个功能一般不太用在面试中，不过如果碰到了你也应该知道该如何处理。<br>其实你只要记住它三个很重要的知识点就可以了：</li></ul><blockquote><p>.finally()方法不管Promise对象最后的状态如何都会执行<br>.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的<br>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。</p></blockquote><p>来看看这个简单的例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'2'</span>)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally2'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'我是finally2返回的值'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally2后面的then函数'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这两个Promise的.finally都会执行，且就算finally2返回了新的值，它后面的then()函数接收到的结果却还是’2’，因此打印结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="string">'finally2'</span></span><br><span class="line"><span class="string">'finally'</span></span><br><span class="line"><span class="string">'finally2后面的then函数'</span> <span class="string">'2'</span></span><br></pre></td></tr></table></figure><p>至于为什么finally2的打印要在finally前面，请看下一个例子中的解析。</p><p>不过在此之前让我们再来确认一下，finally中要是抛出的是一个异常是怎样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally1'</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'我是finally中抛出的异常'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally后面的then函数'</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获错误'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'finally1'</span></span><br><span class="line"><span class="string">'捕获错误'</span> <span class="built_in">Error</span>: 我是<span class="keyword">finally</span>中抛出的异常</span><br></pre></td></tr></table></figure><p>但是如果改为return new Error(‘我是finally中抛出的异常’)，打印出来的就是’finally后面的then函数 1’</p><p>OK，👌，让我们来看一个比较难的例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve(<span class="string">'1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally1'</span>))</span><br><span class="line"></span><br><span class="line">promise2()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally2'</span>))</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先定义了两个函数promise1和promise2，先不管接着往下看。<br>&nbsp;&nbsp;&nbsp;&nbsp;promise1函数先被调用了，然后执行里面new Promise的同步代码打印出promise1<br>&nbsp;&nbsp;&nbsp;&nbsp;之后遇到了resolve(1)，将p的状态改为了resolved并将结果保存下来。<br>&nbsp;&nbsp;&nbsp;&nbsp;此时promise1内的函数内容已经执行完了，跳出该函数<br>&nbsp;&nbsp;&nbsp;&nbsp;碰到了promise1().then()，由于promise1的状态已经发生了改变且为resolved因此将promise1().then()这条微任务加入本轮的微任务列表(这是第一个微任务)<br>&nbsp;&nbsp;&nbsp;&nbsp;这时候要注意了，代码并不会接着往链式调用的下面走，也就是不会先将.finally加入微任务列表，那是因为.then本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管.finally()<br>&nbsp;&nbsp;&nbsp;&nbsp;再往下走碰到了promise2()函数，其中返回的new Promise中并没有同步代码需要执行，所以执行reject(‘error’)的时候将promise2函数中的Promise的状态变为了rejected<br>&nbsp;&nbsp;&nbsp;&nbsp;跳出promise2函数，遇到了promise2().then()，将其加入当前的微任务队列(这是第二个微任务)，且链式调用后面的内容得等该任务执行完后才执行，和.then()一样。<br>&nbsp;&nbsp;&nbsp;&nbsp;OK， 本轮的宏任务全部执行完了，来看看微任务列表，存在promise1().then()，执行它，打印出1，然后遇到了.finally()这个微任务将它加入微任务列表(这是第三个微任务)等待执行<br>&nbsp;&nbsp;&nbsp;&nbsp;再执行promise2().catch()打印出error，执行完后将finally2加入微任务加入微任务列表(这是第四个微任务)<br>&nbsp;&nbsp;&nbsp;&nbsp;OK， 本轮又全部执行完了，但是微任务列表还有两个新的微任务没有执行完，因此依次执行finally1和finally2。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="string">'error'</span></span><br><span class="line"><span class="string">'finally1'</span></span><br><span class="line"><span class="string">'finally2'</span></span><br></pre></td></tr></table></figure><p>在这道题中其实能拓展的东西挺多的，之前没有提到，那就是你可以理解为链式调用后面的内容需要等前一个调用执行完才会执行。<br>就像是这里的finally()会等promise1().then()执行完才会将finally()加入微任务队列，其实如果这道题中你把finally()换成是then()也是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve(<span class="string">'1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally1'</span>))</span><br><span class="line"></span><br><span class="line">promise2()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally2'</span>))</span><br></pre></td></tr></table></figure><h3 id="Promise中的all和race"><a href="#Promise中的all和race" class="headerlink" title="Promise中的all和race"></a>Promise中的all和race</h3><p>在做下面👇的题目之前，让我们先来了解一下Promise.all()和Promise.race()的用法。<br>通俗来说，.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。<br>.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</p><ul><li>题目一<br>我们知道如果直接在脚本文件中定义一个Promise，它构造函数的第一个参数是会立即执行的，就像这样：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'立即打印'</span>))</span><br></pre></td></tr></table></figure>控制台中会立即打印出 “立即打印”。</li></ul><p>因此为了控制它什么时候执行，我们可以用一个函数包裹着它，在需要它执行的时候，调用这个函数就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runP1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'立即打印'</span>))</span><br><span class="line">  <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runP1() <span class="comment">// 调用此函数时才执行</span></span><br></pre></td></tr></table></figure><p>OK 👌， 让我们回归正题。</p><p>现在来构建这么一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数传入一个值x，然后间隔一秒后打印出这个x。</p><p>如果我用.all()来执行它会怎样呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>先来想想此段代码在浏览器中会如何执行？</p><p>没错，当你打开页面的时候，在间隔一秒后，控制台会同时打印出1, 2, 3，还有一个数组[1, 2, 3]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>所以你现在能理解这句话的意思了吗：有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。<br>.all()后面的.then()里的回调函数接收的就是所有异步操作的结果。<br>而且这个结果中数组的顺序和Promise.all()接收到的数组顺序一致！！！</p><blockquote><p>有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p></blockquote><ul><li>题目二<br>我新增了一个runReject函数，它用来在1000 * x秒后reject一个错误。</li></ul><p>同时.catch()函数能够捕获到.all()里最先的那个异常，并且只执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> rej(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="built_in">console</span>.log(x)), <span class="number">1000</span> * x))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 2s后输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">Error</span>: <span class="number">2</span></span><br><span class="line"><span class="comment">// 4s后输出</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>没错，就像我之前说的，.catch是会捕获最先的那个异常，在这道题目中最先的异常就是runReject(2)的结果。<br>另外，如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。</p><p>哈哈，大家别忘了.then()方法的第二个参数也是可以捕获错误的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), </span><br><span class="line">err =&gt; <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><ul><li>题目三<br>所以使用.race()方法，它只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，不过race已经不管那些任务的结果了。</li></ul><p>来，改造一下4.1这道题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'result: '</span>, res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'result: '</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p></blockquote><ul><li>题目四<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> rej(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="built_in">console</span>.log(x)), <span class="number">1000</span> * x)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([runReject(<span class="number">0</span>), runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"result: "</span>, res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>遇到错误的话，也是一样的，在这道题中，runReject(0)最先执行完，所以进入了catch()中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="string">'Error: 0'</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>总结<br>好的，让我们来总结一下.then()和.race()吧，😄</li></ul><blockquote><p>Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。<br>.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。<br>Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。</p></blockquote><h3 id="async-await的几道题"><a href="#async-await的几道题" class="headerlink" title="async/await的几道题"></a>async/await的几道题</h3><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>答案：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;首先一进来是创建了两个函数的，我们先不看函数的创建位置，而是看它的调用位置<br>&nbsp;&nbsp;&nbsp;&nbsp;发现async1函数被调用了，然后去看看调用的内容<br>&nbsp;&nbsp;&nbsp;&nbsp;执行函数中的同步代码async1 start，之后碰到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1<br>&nbsp;&nbsp;&nbsp;&nbsp;跳出async1函数后，执行同步代码start<br>&nbsp;&nbsp;&nbsp;&nbsp;在一轮宏任务全部执行完之后，再来执行刚刚await后面的内容async1 end。</p><p>在这里，你可以理解为await后面的内容就相当于放到了Promise.then的里面。<br>让我们来看看将await转换为Promise.then的伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="comment">// 原来代码</span></span><br><span class="line">  <span class="comment">// await async2();</span></span><br><span class="line">  <span class="comment">// console.log("async1 end");</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 转换后代码</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async2"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><p>另外关于await和Promise的区别，如果我们把await async2()换成一个new Promise呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><p>此时的执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async start'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'start'</span></span><br></pre></td></tr></table></figure><h2 id="可以看到new-Promise-并不会阻塞后面的同步代码async1-end的执行。"><a href="#可以看到new-Promise-并不会阻塞后面的同步代码async1-end的执行。" class="headerlink" title="可以看到new Promise()并不会阻塞后面的同步代码async1 end的执行。"></a>可以看到new Promise()并不会阻塞后面的同步代码async1 end的执行。</h2><ul><li>题目二<br>现在将async结合定时器看看。<br>给题目一中的 async2函数中加上一个定时器：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure>没错，定时器始终还是最后执行的，它被放到下一条宏任务的延迟队列中。<br>答案：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'timer'</span></span><br></pre></td></tr></table></figure></li><li>题目三<br>来吧，小伙伴们，让我们多加几个定时器看看。😁<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer3'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer3'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br></pre></td></tr></table></figure>复制代码定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是0，所以只要关注谁先被调用的。</li></ul><hr><ul><li>题目四<br>正常情况下，async中的await命令是一个Promise对象，返回该对象的结果。</li></ul><p>但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return await 1234</span></span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt end'</span>)</span><br></pre></td></tr></table></figure>这道题目比较有意思，大家要注意了。<br>在async1中await后面的Promise是没有返回值的，也就是它的状态始终是pending状态，因此相当于一直在await，await，await却始终没有响应…<br>所以在await之后的内容是不会执行的，也包括async1后面的 .then。<br>答案为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br></pre></td></tr></table></figure></li><li>题目六<br>让我们给5.5中的Promise加上resolve：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve(<span class="string">'promise1 resolve'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt end'</span>)</span><br></pre></td></tr></table></figure>现在Promise有了返回值了，因此await后面的内容将会被执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="string">'promise1 resolve'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br></pre></td></tr></table></figure></li><li>题目七<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve(<span class="string">'promise resolve'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>这道题应该也不难，不过有一点需要注意的，在async1中的new Promise它的resovle的值和async1().then()里的值是没有关系的，很多小伙伴可能看到resovle(‘promise resolve’)就会误以为是async1().then()中的返回值。<br>因此这里的执行结果为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br><span class="line"><span class="string">'sync1 end'</span></span><br><span class="line"><span class="string">'timer'</span></span><br></pre></td></tr></table></figure></li><li>题目八<br>我们再来看一道头条曾经的面试题：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'setTimeout'</span></span><br></pre></td></tr></table></figure></li><li>题目九<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testSometing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行testSometing"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"testSometing"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行testAsync"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"hello async"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test start..."</span>);</span><br><span class="line">  <span class="keyword">const</span> v1 = <span class="keyword">await</span> testSometing();</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line">  <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise start..."</span>);</span><br><span class="line">  resolve(<span class="string">"promise"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"test end..."</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'test start...'</span></span><br><span class="line"><span class="string">'执行testSometing'</span></span><br><span class="line"><span class="string">'promise start...'</span></span><br><span class="line"><span class="string">'test end...'</span></span><br><span class="line"><span class="string">'testSometing'</span></span><br><span class="line"><span class="string">'执行testAsync'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'hello async'</span></span><br><span class="line"><span class="string">'testSometing'</span> <span class="string">'hello async'</span></span><br></pre></td></tr></table></figure><h3 id="async处理错误"><a href="#async处理错误" class="headerlink" title="async处理错误"></a>async处理错误</h3></li><li>题目一<br>在async中，如果 await后面的内容是一个异常或者错误的话，会怎样呢？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>例如这道题中，await后面跟着的是一个状态为rejected的promise。</li></ul><p><strong>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</strong></p><p>所以答案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async2'</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) error</span><br></pre></td></tr></table></figure><p>如果改为throw new Error也是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1'</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!!</span><br></pre></td></tr></table></figure><ul><li>题目二<br>如果想要使得错误的地方不影响async函数后续的执行的话，可以使用try catch<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error!!!'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'async1 success'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br></pre></td></tr></table></figure>这里的结果为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'error!!!'</span></span><br><span class="line"><span class="string">'async1'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br></pre></td></tr></table></figure>或者你可以直接在Promise.reject后面跟着一个catch()方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// try &#123;</span></span><br><span class="line">  <span class="comment">//   await Promise.reject('error!!!')</span></span><br><span class="line">  <span class="comment">// &#125; catch(e) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(e)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error!!!'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'async1 success'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br></pre></td></tr></table></figure>运行结果是一样的<h3 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h3></li><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">          resolve(<span class="number">6</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(p)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">  p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(arg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在4之前，所以可以来看看first函数里面的内容了。(这一步有点类似于题目1.5)<br>&nbsp;&nbsp;&nbsp;&nbsp;函数first返回的是一个new Promise()，因此先执行里面的同步代码3<br>&nbsp;&nbsp;&nbsp;&nbsp;接着又遇到了一个new Promise()，直接执行里面的同步代码7<br>&nbsp;&nbsp;&nbsp;&nbsp;执行完7之后，在p中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走<br>&nbsp;&nbsp;&nbsp;&nbsp;碰到了resolve(1)，这里就把p的状态改为了resolved，且返回值为1，不过这里也先不执行<br>&nbsp;&nbsp;&nbsp;&nbsp;跳出p，碰到了resolve(2)，这里的resolve(2)，表示的是把first函数返回的那个Promise的状态改了，也先不管它。<br>&nbsp;&nbsp;&nbsp;&nbsp;然后碰到了p.then，将它加入本次循环的微任务列表，等待执行<br>&nbsp;&nbsp;&nbsp;&nbsp;跳出first函数，遇到了first().then()，将它加入本次循环的微任务列表(p.then的后面执行)<br>&nbsp;&nbsp;&nbsp;&nbsp;然后执行同步代码4<br>&nbsp;&nbsp;&nbsp;&nbsp;本轮的同步代码全部执行完毕，查找微任务列表，发现p.then和first().then()，依次执行，打印出1和2<br>&nbsp;&nbsp;&nbsp;&nbsp;本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码5<br>&nbsp;&nbsp;&nbsp;&nbsp;然后又遇到了一个resolve(6)，它是放在p里的，但是p的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说resolve(6)相当于没任何用处，因此打印出来的p为<code>Promise{&lt;resolved&gt;: 1}</code>。(这一步类似于题目3.1)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async1 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="number">2</span>)</span><br><span class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">.catch(<span class="number">4</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>注意的知识点：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;async函数中await的new Promise要是没有返回值的话则不执行后面的内容(类似题5.5)<br>&nbsp;&nbsp;&nbsp;&nbsp;.then函数中的参数期待的是函数，如果不是函数的话会发生透传(类似题3.8 )<br>&nbsp;&nbsp;&nbsp;&nbsp;注意定时器的延迟时间<br>因此本题答案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br></pre></td></tr></table></figure><ul><li>题目三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'resolve3'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  resolve(<span class="string">'resovle1'</span>);</span><br><span class="line">  resolve(<span class="string">'resolve2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p1)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>注意的知识点：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;Promise的状态一旦改变就无法改变(类似题目3.5)<br>&nbsp;&nbsp;&nbsp;&nbsp;finally不管Promise的状态是resolved还是rejected都会执行，且它的回调函数是接收不到Promise的结果的，所以finally()中的res是一个迷惑项(类似3.10)。<br>&nbsp;&nbsp;&nbsp;&nbsp;最后一个定时器打印出的p1其实是.finally的返回值，我们知道.finally的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值(3.10中也有提到), 而这道题中.finally上一个Promise是.then()，但是这个.then()并没有返回值，所以p1打印出来的Promise的值会是undefined，如果你在定时器的下面加上一个return 1，则值就会变成1(感谢掘友JS丛中过的指出)。</p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'resolve1'</span></span><br><span class="line"><span class="string">'finally'</span> <span class="literal">undefined</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="literal">undefined</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="几道大厂的面试题"><a href="#几道大厂的面试题" class="headerlink" title="几道大厂的面试题"></a>几道大厂的面试题</h3><ul><li>使用Promise实现每隔1秒输出1<br>这道题比较简单的一种做法是可以用Promise配合着reduce不停的在promise后面叠加.then，请看下面的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">p, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(<span class="built_in">console</span>.log(x)), <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure>或者你可以更简单一点写：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">p, x</span>) =&gt;</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(<span class="built_in">console</span>.log(x)), <span class="number">1000</span>))), <span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></li><li>使用Promise实现红绿灯交替重复亮</li></ul><p>红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"red"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"green"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"yellow"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> light = <span class="function"><span class="keyword">function</span> (<span class="params">timer, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      cb()</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> step = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">3000</span>, red)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">2000</span>, green)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">1000</span>, yellow)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> step()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step();</span><br></pre></td></tr></table></figure><ul><li>实现mergePromise函数<br>实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="function">(<span class="params">timer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里写代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"done"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>这道题有点类似于Promise.all()，不过.all()不需要管执行顺序，只需要并发执行就行了。但是这里需要等上一个执行完毕之后才能执行下一个。<br>解题思路：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;定义一个数组data用于保存所有异步操作的结果<br>&nbsp;&nbsp;&nbsp;&nbsp;初始化一个const promise = Promise.resolve()，然后循环遍历数组，在promise后面添加执行ajax任务，同时要将添加的结果重新赋值到promise上。</p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span> (<span class="params">ajaxArray</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放每个ajax的结果</span></span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  ajaxArray.forEach(<span class="function"><span class="params">ajax</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次的then为了用来调用ajax</span></span><br><span class="line">    <span class="comment">// 第二次的then是为了获取ajax的结果</span></span><br><span class="line">    promise = promise.then(ajax).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      data.push(res);</span><br><span class="line">      <span class="keyword">return</span> data; <span class="comment">// 把每次的结果返回</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最后得到的promise它的值就是data</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据promiseA+实现一个自己的promise<br><a href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b#heading-7" target="_blank" rel="noopener">Promise不会？？看这里！！！史上最通俗易懂的Promise</a><br><a href="https://zhuanlan.zhihu.com/p/23312442" target="_blank" rel="noopener">写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h2&gt;&lt;p&gt;&lt;code&gt;event loop&lt;/code&gt;它的执行顺序：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一开始整个脚本作为一个宏任务执行&lt;br&gt;执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列&lt;br&gt;当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完&lt;br&gt;执行浏览器&lt;code&gt;UI线程&lt;/code&gt;的渲染工作&lt;br&gt;检查是否有&lt;code&gt;Web Worker&lt;/code&gt;任务，有则执行&lt;br&gt;执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="interview" scheme="https://jambo0624.github.io/categories/interview/"/>
    
    
      <category term="interview" scheme="https://jambo0624.github.io/tags/interview/"/>
    
      <category term="ES6" scheme="https://jambo0624.github.io/tags/ES6/"/>
    
      <category term="promise" scheme="https://jambo0624.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>前后端联调</title>
    <link href="https://jambo0624.github.io/2020-03-17-frontend-afterend.html"/>
    <id>https://jambo0624.github.io/2020-03-17-frontend-afterend.html</id>
    <published>2020-03-17T09:31:48.000Z</published>
    <updated>2020-03-17T09:43:23.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入浅出：了解前后端分离优势、前后端接口联调以及优化问题"><a href="#深入浅出：了解前后端分离优势、前后端接口联调以及优化问题" class="headerlink" title="深入浅出：了解前后端分离优势、前后端接口联调以及优化问题"></a>深入浅出：了解前后端分离优势、前后端接口联调以及优化问题</h2><p>目录：<br>1.项目有前后端分离和前后端不分离；<br>2.前后端接口联调；<br>3.前端性能优化 ；<br>4.前端安全问题；</p><a id="more"></a><h3 id="一、项目有前后端分离和前后端不分离："><a href="#一、项目有前后端分离和前后端不分离：" class="headerlink" title="一、项目有前后端分离和前后端不分离："></a>一、项目有前后端分离和前后端不分离：</h3><p>　　在前后端不分离架构中，所有的静态资源和业务代码统一部署在同一台服务器上。服务器接收到浏览器的请求后，进行处理得到数据，然后将数据填充到静态页面中，最终返回给浏览器。</p><p>　实现前后端分离后，有了下面几点改变：</p><p>　　1.服务器一分为二，前后端分别部署，静态资源放在前端服务器，业务代码放在后的服务器<br>　　2.前端服务器需要接收Http请求（一般使用node.js）<br>　　3.前端服务器需要进行视图解析（可以使用vue.js、angular.js）<br>　　4.前端服务器需要处理路由（也就是页面之间的跳转逻辑）<br>　　5.后端服务器只需要返回数据</p><ul><li>一、前言</li></ul><p>　　前后端分离已成为互联网项目开发的业界标准使用方式，通过nginx+tomcat的方式（也可以中间加一个nodejs）有效的进行解耦，并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。这个步骤是系统架构从猿进化成人的必经之路。<br>　　核心思想是前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互。</p><p>　　在互联网架构中，名词解释：<br>　　Web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。<br>　　应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。</p><ul><li>二、技术分工（开发人员分离）</li></ul><p>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端，又搞后端。<br>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。 </p><p>1、对于后端java工程师：（负责Model层，业务处理/数据等）<br>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构，弹性计算架构，微服务架构，java性能优化，以及相关的项目管理等等。<br>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</p><p>2、对于前端工程师：（负责View和Controller层。）<br>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。<br>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p><p>术业有专攻，这样你的核心竞争力才会越来越高，正所谓你往生活中投入什么，生活就会反馈给你什么。并且两端的发展都越来越高深，你想什么都会，那你毕竟什么都不精。<br>通过将team分成前后端team，让两边的工程师更加专注各自的领域，独立治理，然后构建出一个全栈式的精益求精的team。</p><ul><li>三、开发模式</li></ul><p>以前老的方式是：<br>&nbsp;&nbsp;&nbsp;&nbsp;产品经理/领导/客户提出需求===》UI做出设计图 ===》前端工程师做html页面===》后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）===》集成出现问题 ===》前端返工 ===》后端返工===》二次集成 ===》集成成功 ==》交付</p><p>新的方式是：<br>&nbsp;&nbsp;&nbsp;&nbsp;产品经历/领导/客户提出需===》UI做出设计图 ===》前后端约定接口&amp;数据&amp;参数 ===》前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）===》前后端集成 ===》前端页面调整 ===》集成成功 ===》交付</p><ul><li>四、请求方式</li></ul><p>以前老的方式是：<br>1、客户端请求<br>2、服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）<br>3、调用service,dao代码完成业务逻辑<br>4、返回jsp<br>5、jsp展现一些动态的代码</p><p>新的方式是：<br>1、浏览器发送请求<br>2、直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）<br>3、html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）<br>4、填充html，展现动态效果，在页面上进行解析并操作DOM。</p><p>总结一下新的方式的请求步骤：<br>大量并发浏览器请求—&gt;web服务器集群(nginx)—&gt;应用服务器集群(tomcat)—&gt;文件/数据库/缓存/消息队列服务器集群同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。</p><ul><li><p>五、前后分离的优势<br>&nbsp;&nbsp;&nbsp;&nbsp;1、可以实现真正的前后端解耦，前端服务器使用nginx。前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。（这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack）<br>&nbsp;&nbsp;&nbsp;&nbsp;2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。双方互不干扰，前端与后端是相亲相爱的一家人。<br>&nbsp;&nbsp;&nbsp;&nbsp;3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。（去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。）<br>&nbsp;&nbsp;&nbsp;&nbsp;4、减少后端服务器的并发/负载压力。除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。且除了第一次页面请求外，浏览器会大量调用本地缓存。<br>&nbsp;&nbsp;&nbsp;&nbsp;5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。<br>&nbsp;&nbsp;&nbsp;&nbsp;6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）<br>&nbsp;&nbsp;&nbsp;&nbsp;7、页面显示的东西再多也不怕，因为是异步加载。<br>&nbsp;&nbsp;&nbsp;&nbsp;8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。<br>&nbsp;&nbsp;&nbsp;&nbsp;9、增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。<br>&nbsp;&nbsp;&nbsp;&nbsp;10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。<br>&nbsp;&nbsp;&nbsp;&nbsp;11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），内网使用http，性能和安全都有保障。<br>&nbsp;&nbsp;&nbsp;&nbsp;12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！</p></li><li><p>六、注意事项<br>&nbsp;&nbsp;&nbsp;&nbsp;1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？<br>&nbsp;&nbsp;&nbsp;&nbsp;2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。<br>&nbsp;&nbsp;&nbsp;&nbsp;4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。<br>&nbsp;&nbsp;&nbsp;&nbsp;5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。<br>&nbsp;&nbsp;&nbsp;&nbsp;6、 以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。<br>&nbsp;&nbsp;&nbsp;&nbsp;7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？<br>&nbsp;&nbsp;&nbsp;&nbsp;8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。<br>&nbsp;&nbsp;&nbsp;&nbsp;9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。类似于数据校验这种，前后端都需要做！<br>&nbsp;&nbsp;&nbsp;&nbsp;10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户</p></li></ul><h3 id="二、前后端接口联调："><a href="#二、前后端接口联调：" class="headerlink" title="二、前后端接口联调："></a>二、前后端接口联调：</h3><p>前言：</p><p>以JC同事为例，他公司为前后端分离架构，前端vue全家桶；前后端人员开会协商数据接口后(主要是定义传输的数据和API接口)，前后端并行开发；因为后台此时无法提供后端数据，所以前端需要用mock模拟假数据，管理API接口，获取数据，到时接口联调时连接后端服务器，访问后端数据即可。</p><p>但是JC同事的ajax的借口写的是与后端叔叔商量好的绝对路径（域名+请求路径+请求参数，跨域问题已解决），因为这是以后真正的请求路径，所以JC同事又不像先写本地相对路径，后期再来修改（万一后台叔叔开发的慢了，鬼知道有多少接口要修改呀）。于是他就迷茫了。。。<br>仔细看看这其实就是前后端分离中的mock数据和联调的问题，就现在来说能解决的方式有很多种。先说mock数据，gulp，webpack， fekit （去哪儿网的一款前端自动化构建工具，据说历史比webpack和gulp都要久远）等等自动化构建工具都有mock数据的功能，这不是问题；再说绝对路径的问题，其实只需要做一个host的映射就行了。</p><ul><li>一、什么是前后端接口联调<br>之前开发写代码的时候，所有的ajax数据都不是后端返回的真实数据，而是我们自己通过接口mock模拟的假数据，当前端的代码编写完毕，后端的接口也已经写好之后，我们就需要把mock数据干掉，尝试使用后端提供的数据，进行前后端的一个调试，这个过程我们就把它称之为前后端的接口联调。</li></ul><p>为什么要联调 本地的mock数据是JC同事自己写的，肯定符合前端需求，但是后端接口首先需要测试通不通，还需要测试数据格式对不对，还有后端有没有填写足够的数据，比如写列表页，前端想分页，如果后端就写了两条测试数据，你咋整？ 所以，Jack需要根据后端对接口的调整，不断地来回切换url，这样岂不是还在受后端的影响，还谈什么毛线的前后端分离，名存实亡嘛！</p><ul><li>二、如何实现前后端接口联调</li></ul><p>首先，我们已经知道，目前的前后端分离的架构应用分为两种情况：<br>前后端完全分离，前后端分别拥有自己的域名和服务器。<br>前后端开发分离，但是部署时是一个域名和一台服务器。</p><p>虽然架构可以采用前后端分离，但是部署有可能就不一样了，这和项目的大小，公司的情况等等都有关系了，一个百八十人用的小系统，还得两台服务器两个域名，你不觉着浪费吗?两种不同的部署情况直接导致了前期在设计联调方案的时候就不同了。</p><p>如果你们公司的项目在部署时是两台服务器对应两个域名，恭喜你，这是最nice的方案，也是联调最舒服的方式。第二种情况，也就是开发时前后端分离，部署时是一个域名和一台服务器。知道这个之后，他就明白接下来该怎么操作了。JC同事之前在项目根目录static文件夹下新建了一个mock文件夹，里面写了一些json文件，当我们做联调的时候，这些mock数据就没用了，我们要把mock数据切换成后端提供给我们的真实的数据。</p><p>当我的朋友Jack把static文件夹下的mock数据删除之后，在运行项目，发现报错了，浏览器告诉他，你访问的mock下面的index.json文件找不到404。</p><p>我们平时本地前端开发环境dev地址大多是 localhost:8080，而后台服务器的访问地址就有很多种情况了，比如 后端程序猿本地IP（127.0.0.1:8889），或者外网域名，当前端与后台进行数据交互时，自然就出现跨域问题（后台服务没做处理情况下）。axios不支持jsonp, 所以我们就要使用http-proxy-middleware中间件做代理。</p><p>现在通过在前端修改 vue-cli 的配置可解决： vue-cli中的 config/index.js 下配置 dev选项的 {proxyTable}:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">  target: <span class="string">'127.0.0.1:8889'</span>, <span class="comment">// 真实请求的地址</span></span><br><span class="line">    changeOrigin: <span class="literal">true</span>, <span class="comment">// 是否跨域</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想在公司的vue项目中实现前后端联调，不需要再使用类似于fiddler charles的抓包代理工具了，你只需要使用proxyTable这个配置项，把你需要请求的后端的服务器地址写在target值里就OK了。</p><p>解决完跨域问题后，接下来Jack该想想怎么在一台服务器一个域名下进行联调的问题了。比较常见的做法是前端在本地修改，本地查看，测试好了以后上传到服务器，看看线上环境可不可以，OK的话一切都好；不行就本地接着改，然后在上传。</p><p>联调完之后，如何将前端打包的项目文件发给后端，这里也需要注意两点：<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）css、js和图片等静态文件<br>这时候的静态文件在开发阶段不需要任何考虑，按照你喜欢的相对路径或者相对于项目的根路径的形式写就行了，因为早晚还得交给后端。但是，需要注意：</p><p>如果你采用 相对项目根路径的书写方式来写你的静态文件路径 时，一定要先和后端商量好，将来项目部署的时候他会把你的前端整个项目放在哪里？如果不是根目录下，你就挂了。比如：你的reset.css的路径是 /exports/styles/common/reset.css ，后端把你前端项目放在了根目录下的 frontEnd 文件夹下， reset.css 文件就报404了。</p><p>如果后端采用的java，你需要特别注意的是， tomcat的根目录 并不是 webapps 文件，而后端项目默认是部署在 webapps/ROOT 文件下的，所以你如果使用了相对项目根路径的书写方式来写你的静态文件路径时，对不起又是404了。<br>&nbsp;&nbsp;&nbsp;&nbsp;（2）ajax后端数据</p><p>因为现在唯一的一台服务器还是在后端程序猿那里，所以此时你还是可以写绝对路径（域名+请求路径），利用hosts文件来改变域名映射实现联调。</p><h3 id="三、前端性能优化"><a href="#三、前端性能优化" class="headerlink" title="三、前端性能优化"></a>三、前端性能优化</h3><ul><li>1.内容优化</li></ul><blockquote><p>(1)减少HTTP请求数<br>(2)避免重定向<br>(3)使用Ajax缓存<br>(4)延迟加载组件,预加载组件<br>(5)减少DOM元素数量<br>(6)避免404</p></blockquote><ul><li>2.服务器优化</li></ul><blockquote><p>(1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。<br>(2)GZIP压缩<br>(3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。<br>(4)提前刷新缓冲区<br>(5)对Ajax请求使用GET方法<br>(6)避免空的图像src</p></blockquote><ul><li>3.Cookie优化</li></ul><blockquote><p>(1)减小Cookie大小<br>(2)针对Web组件使用域名无关的Cookie</p></blockquote><ul><li>4.CSS优化</li></ul><blockquote><p>(1)将CSS代码放在HTML页面的顶部<br>(2)避免使用CSS表达式<br>(3)使用link来代替@import<br>(4)避免使用Filters</p></blockquote><ul><li>5.javascript优化</li></ul><blockquote><p>(1)将JavaScript脚本放在页面的底部。<br>(2)将JavaScript和CSS作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。<br>(3)缩小JavaScript和CSS<br>(4)删除重复的脚本<br>(5)最小化DOM的访问：使用JavaScript访问DOM元素比较慢。<br>(6)开发智能的事件处理程序<br>(7)javascript代码注意：谨慎使用with,避免使用eval Function函数,减少作用域链查找。</p></blockquote><ul><li>6.图像优化<blockquote><p>(1)优化图片大小<br>(2)通过CSS Sprites优化图片<br>(3)不要在HTML中使用缩放图片<br>(4)favicon.ico要小而且可缓存</p></blockquote></li></ul><h3 id="四、前端安全问题"><a href="#四、前端安全问题" class="headerlink" title="四、前端安全问题"></a>四、前端安全问题</h3><p>1.算法加密：</p><blockquote><p>(1)   RSA加密<br>(2)   MD5加密<br>(3)   SHA256加密</p></blockquote><p>推荐一个网址：<a href="https://www.haorooms.com/post/js_my_passwordjm" target="_blank" rel="noopener">https://www.haorooms.com/post/js_my_passwordjm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;深入浅出：了解前后端分离优势、前后端接口联调以及优化问题&quot;&gt;&lt;a href=&quot;#深入浅出：了解前后端分离优势、前后端接口联调以及优化问题&quot; class=&quot;headerlink&quot; title=&quot;深入浅出：了解前后端分离优势、前后端接口联调以及优化问题&quot;&gt;&lt;/a&gt;深入浅出：了解前后端分离优势、前后端接口联调以及优化问题&lt;/h2&gt;&lt;p&gt;目录：&lt;br&gt;1.项目有前后端分离和前后端不分离；&lt;br&gt;2.前后端接口联调；&lt;br&gt;3.前端性能优化 ；&lt;br&gt;4.前端安全问题；&lt;/p&gt;
    
    </summary>
    
    
      <category term="basic" scheme="https://jambo0624.github.io/categories/basic/"/>
    
    
      <category term="前后端联调" scheme="https://jambo0624.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>es6数组新增API</title>
    <link href="https://jambo0624.github.io/2020-03-17-es6-array-api.html"/>
    <id>https://jambo0624.github.io/2020-03-17-es6-array-api.html</id>
    <published>2020-03-17T07:19:39.000Z</published>
    <updated>2020-03-17T07:56:00.287Z</updated>
    
    <content type="html"><![CDATA[<p>ES6新增数组的方法</p><ul><li>Array.from()<br>Array.from 方法用于将两类对象转为真正的数组：<br>&nbsp;&nbsp;&nbsp;&nbsp;类似数组的对象（array-like object）<br>&nbsp;&nbsp;&nbsp;&nbsp;可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）<a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="string">"1"</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="string">"2"</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike)   <span class="comment">//[a, b, c]</span></span><br><span class="line"><span class="comment">//ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike) <span class="comment">//[a, b, c]</span></span><br><span class="line"><span class="comment">// 任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</span></span><br><span class="line"><span class="comment">// 扩展运算符只能对部署 Iterator 接口的类数组转换为真正的数组 </span></span><br><span class="line"><span class="comment">// console.log([...arrayLike]); // 报错 TypeError: Cannot spread non-iterable object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from还可以接受第二个参数，作用类似于数组的map方法</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.from(arrayLike, x =&gt; x + x)</span><br><span class="line"><span class="built_in">console</span>.log(map)  <span class="comment">// [aa,bb,cc]</span></span><br></pre></td></tr></table></figure></li><li>Array.of()<br>Array.of 方法用于将一组值，转换为数组。弥补数组构造函数 Array()的不足。因为参数个数的不同，会导致 Array()的行为有差异<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下代码看出差异</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3,11,8]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3, 11, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.of方法可以用下面的代码模拟实现。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>数组实例的 find() 和 findIndex()<br>=&gt; find()方法找到第一个符合条件的成员,没有符合的则返回 undefined<br>=&gt; findIndex 方法的用法与 find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find()</span></span><br><span class="line"><span class="keyword">var</span> item = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// -5</span></span><br><span class="line"><span class="comment">// find 也支持这种复杂的查找</span></span><br><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">20</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">30</span>, <span class="attr">y</span>: <span class="number">40</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">40</span>, <span class="attr">y</span>: <span class="number">50</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>: <span class="number">60</span> &#125;</span><br><span class="line">];</span><br><span class="line">points.find(<span class="function"><span class="keyword">function</span> <span class="title">macther</span>(<span class="params">point</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point.x % <span class="number">3</span> === <span class="number">0</span> &amp;&amp; point.y % <span class="number">4</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>=&gt; findIndex()返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1<br>=&gt; indexOf(..) 会提供这些，但是无法控制匹配逻辑；它总是使用 === 严格相等。所以 ES6 的 findIndex(..) 才是解决方案<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">20</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">30</span>, <span class="attr">y</span>: <span class="number">40</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">40</span>, <span class="attr">y</span>: <span class="number">50</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>: <span class="number">60</span> &#125;</span><br><span class="line">];</span><br><span class="line">points.findIndex(<span class="function"><span class="keyword">function</span> <span class="title">matcher</span>(<span class="params">point</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point.x % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; point.y % <span class="number">4</span> == <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">// 2</span></span><br><span class="line">points.findIndex(<span class="function"><span class="keyword">function</span> <span class="title">matcher</span>(<span class="params">point</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point.x % <span class="number">6</span> == <span class="number">0</span> &amp;&amp; point.y % <span class="number">7</span> == <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li>数组实例的 fill()<br>=&gt; fill()方法使用给定值， 填充一个数组<br>=&gt; fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fill方法使用给定值， 填充一个数组</span></span><br><span class="line"><span class="keyword">var</span> fillArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>).fill(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fillArray)  <span class="comment">//[1,1,1,1,1,1]</span></span><br><span class="line"><span class="comment">//fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// ['a', 7, 'c']</span></span><br><span class="line"><span class="comment">// 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123;</span><br><span class="line">  name: <span class="string">"Mike"</span></span><br><span class="line">&#125;)</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">'Ben'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;]</span></span><br></pre></td></tr></table></figure></li><li>数组实例的 entries()，keys() 和 values()<br>entries()，keys()和 values()——用于遍历数组,可以用 for…of 循环进行遍历<br>唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">[...a.values()]; <span class="comment">// [1,2,3]</span></span><br><span class="line">[...a.keys()]; <span class="comment">// [0,1,2]</span></span><br><span class="line">[...a.entries()]; <span class="comment">// [ [0,1], [1,2], [2,3] ]</span></span><br></pre></td></tr></table></figure></li><li>includes()方法返回一个布尔值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].includes(<span class="number">4</span>) <span class="comment">// false</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>)].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>includes 方法弥补了 indexOf 方法不够语义化和误判 NaN 的缺点</li></ul><hr><ul><li>数组实例的 flat()，flatMap()<br>=&gt; flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法<strong>返回一个新数组</strong>，对原数据没有影响。传参数代表拉平几层默认是一层<br>=&gt; flatMap()只能展开一层数组。方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法。该方法返回一个新数组，不改变原数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()   <span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)    <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">//flatMap()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])  <span class="comment">//map执行完后是[[2, 4], [3, 6], [4, 8]]</span></span><br><span class="line"><span class="comment">// 然后在执行flat()方法得到下边的结果  // [2, 4, 3, 6, 4, 8]</span></span><br><span class="line"><span class="comment">// flatMap()只能展开一层数组  // 相当于 .flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [ [x * <span class="number">2</span>] ])</span><br><span class="line"><span class="comment">// map执行完后是[[[2]], [[4]], [[6]], [[8]]]</span></span><br><span class="line"><span class="comment">// 然后在执行flat()方法得到如下结果</span></span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><h3 id="字符串API比较少"><a href="#字符串API比较少" class="headerlink" title="字符串API比较少"></a>字符串API比较少</h3></li><li>includes(), startsWith(), endsWith()（常用）</li><li>repeat()</li><li>padStart()， padEnd()   –作用联想padding</li><li>模板字符串</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6新增数组的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Array.from()&lt;br&gt;Array.from 方法用于将两类对象转为真正的数组：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;类似数组的对象（array-like object）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="array" scheme="https://jambo0624.github.io/tags/array/"/>
    
      <category term="api" scheme="https://jambo0624.github.io/tags/api/"/>
    
      <category term="es6" scheme="https://jambo0624.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>scssBasic</title>
    <link href="https://jambo0624.github.io/2020-03-16-scss.html"/>
    <id>https://jambo0624.github.io/2020-03-16-scss.html</id>
    <published>2020-03-16T07:58:51.000Z</published>
    <updated>2020-03-19T01:04:04.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SCSS定制"><a href="#SCSS定制" class="headerlink" title="SCSS定制"></a>SCSS定制</h3><p>ex:css文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$jd_red</span>:<span class="number">#f10215</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.register</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">$jd_red</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">$jd_red</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">$jd_red</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.img</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">$jd_red</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>1.CSS有以下的几个缺点<br>语法不够强大，没有变量和合理的复用机制，使用逻辑上相关的属性值必须重复编写，导致难以维护。<br>动态样式语言为css赋予了动态语言的特性，极大的提高了样式语言的可维护性。<br>常用的动态样式语言：css的预处理器<br>&nbsp;&nbsp;&nbsp;&nbsp;(1)scss/sass 都属于CSS的预处理器（用一种专门的编程语言，进行web页面样式的设计，再通过编译器转化为正常的css文件，以供项目使用）<br>&nbsp;&nbsp;&nbsp;&nbsp;(2)less<br>&nbsp;&nbsp;&nbsp;&nbsp;(3)stylus<br>2.scss<br>&nbsp;&nbsp;&nbsp;&nbsp;scss是一款强化css的辅助工具，他在css语法的基础上增加了变量，嵌套，混合，导入，函数等高级功能，这些拓展相对于css更强大与优雅。<br>&nbsp;&nbsp;&nbsp;&nbsp;scss的作用:有助于更好的管理样式文件，以及更高效的开发项目。<br>3.使用scss<br>在服务器端使用<br>&nbsp;&nbsp;&nbsp;&nbsp;(1)安装NodeJS解释器<br>&nbsp;&nbsp;&nbsp;&nbsp;(2)安装scss编译程序<br>&nbsp;&nbsp;&nbsp;&nbsp;在命令行界面输入：npm install -g node-sass<br>&nbsp;&nbsp;&nbsp;&nbsp;检查scss程序能否正常使用：node-sass -v 如果能查看到版本号，说明sass程序可用<br>&nbsp;&nbsp;&nbsp;&nbsp;(3)编译scss文件<br>&nbsp;&nbsp;&nbsp;&nbsp;1.创建一个scss文件，编写动态样式代码<br>&nbsp;&nbsp;&nbsp;&nbsp;2.通过以下命令行来完成编译</p><blockquote><p>单文件的转换命令：node-sass scss/input.scss  css/output.css<br>多文件的转换命令：node-sass scss文件夹名称 -o css文件夹名称<br>单文件监听命令：node-sass -w scss/input.scss css/output.css<br>多文件监听命令：node-sass -w scss文件夹名称 -o css文件夹名称</p></blockquote><p>4.scss的基础语法</p><ul><li>1.变量<br>使用$符号标识变量。<br>变量命名规范遵循css中选择器的命令规范，不能以数字开头，不能包含特殊字符（可以包含_,-）,尽量见名知意。<br>ex1:<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$jd_red</span>:<span class="number">#f10215</span>; <span class="comment">//颜色变量</span></span><br><span class="line"><span class="variable">$normal_width</span>:<span class="number">100px</span>; <span class="comment">//数值变量</span></span><br><span class="line"><span class="variable">$before_content</span>:<span class="string">"子曰："</span>; <span class="comment">//字符串变量</span></span><br><span class="line"><span class="variable">$border_style</span>:solid;  <span class="comment">//样式变量</span></span><br><span class="line"><span class="variable">$my_border</span>:<span class="number">1px</span> <span class="variable">$border_style</span> <span class="variable">$jd_red</span>; <span class="comment">//声明变量时，变量的值也可以是其它变量。</span></span><br></pre></td></tr></table></figure>注意：<br>&nbsp;&nbsp;&nbsp;&nbsp;(1)声明变量时变量值可以引用其它变量。<br>&nbsp;&nbsp;&nbsp;&nbsp;(2)变量定义在{}规则块外，整个样式表中都可以引用，定义在{}规则内，它只能在规则块中使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;(3)声明重复变量，只有最后一处有效，且他会覆盖前面的值，尽量不要重复。<br>&nbsp;&nbsp;&nbsp;&nbsp;(4)!default规则，如果变量已经声明赋值了，那就用他声明的值，否则就用当前这个默认值。<br>ex2:<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="variable">$my_border</span>;</span><br><span class="line">  <span class="variable">$width</span>:<span class="number">200px</span>;  <span class="comment">//局部变量，只能在当前选择器中使用</span></span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">$width</span>;  <span class="comment">//在此可以调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">$width</span>;  <span class="comment">//不能调用$width</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>2.嵌套规则<br>&nbsp;&nbsp;&nbsp;&nbsp;(1)在选择器中嵌套选择器<br>ex1:<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">div</span><span class="selector-class">.top</span> <span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">div</span><span class="selector-class">.top</span> <span class="selector-tag">p</span>&#123;<span class="attribute">margin</span>:<span class="number">10px</span>;&#125;</span><br><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">div</span><span class="selector-class">.middle</span>&#123;<span class="attribute">background</span>:gray;&#125;</span><br></pre></td></tr></table></figure>将上面的css代码改成scss格式：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.top</span>&#123;</span><br><span class="line">  <span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line">  <span class="selector-tag">p</span>&#123;<span class="attribute">margin</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.middle</span>&#123;<span class="attribute">background</span>:gray;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>ex2:<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">a</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:blue;&#125;</span><br></pre></td></tr></table></figure>改写scss方式：<br>&nbsp;&nbsp;&nbsp;&nbsp;在嵌套规则中，有时候需要使用嵌套外层的父选择器，可用&amp;代表嵌套规则外层的父选择器。<br>&nbsp;&nbsp;&nbsp;&nbsp;不添加&amp;,标签和：之间会一个空格，导致浏览器不读取这个伪类<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="selector-tag">a</span>&#123;<span class="attribute">color</span>:red;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;(2)群组选择器嵌套<br>&nbsp;&nbsp;&nbsp;&nbsp;ex:css的写法<br>&nbsp;&nbsp;&nbsp;&nbsp;nav a,header a,section a{color:blue;}<br>&nbsp;&nbsp;&nbsp;&nbsp;用scss方式写：<br>&nbsp;&nbsp;&nbsp;&nbsp;nav,header,section{a{color:blue;}}<br>&nbsp;&nbsp;&nbsp;&nbsp;(3)属性嵌套<br>&nbsp;&nbsp;&nbsp;&nbsp;在scss中除了选择器，属性也可以嵌套<br>ex:<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border-style</span>:solid;</span><br><span class="line">  <span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>:<span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>用scss的方式写：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:&#123;</span><br><span class="line">    style:solid;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.导入文件<br>&nbsp;&nbsp;&nbsp;&nbsp;在scss中，局部文件名以_开头。<br>&nbsp;&nbsp;&nbsp;&nbsp;在scss编译时就不会编译这些以_开头的文件，而只是把这些文件用作导入，引入局部文件时可以不写文件的全名，即省略下划线，并且局部文件的后缀也可以不写。同一个局部文件可以在不同的主文件中引用。<br>&nbsp;&nbsp;&nbsp;&nbsp;引入局部文件需用 @import<br>ex:<br>=&gt; 定义了一个局部文件_myColors.scss<br>=&gt; 引入该文件： @import “myColors”</li><li>4.混合器——需要复用的样式封装<br>&nbsp;&nbsp;&nbsp;&nbsp;1.普通混合器<br>&nbsp;&nbsp;&nbsp;&nbsp;使用 @minix标识符定义。<br>&nbsp;&nbsp;&nbsp;&nbsp;语法: @minix 混合器名称{样式声明}<br>&nbsp;&nbsp;&nbsp;&nbsp;通过 @include 来使用混合器<br>&nbsp;&nbsp;&nbsp;&nbsp;语法：选择器{ @include 混合器名称}<br>ex:<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> my_box_shadow &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">9px</span> <span class="number">2px</span> gray;</span><br><span class="line">  -moz-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">9px</span> <span class="number">2px</span> gray;</span><br><span class="line">  -ms-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">9px</span> <span class="number">2px</span> gray;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">9px</span> <span class="number">2px</span> gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.info</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:green;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">2px</span> solid <span class="variable">$jd_red</span>;</span><br><span class="line">  <span class="keyword">@include</span> my_box_shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;2.带参混合器<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> 混合器名称(参数<span class="number">1</span>，参数<span class="number">2</span>，...)&#123;</span><br><span class="line">  属性1：参数1；</span><br><span class="line">  属性2：参数2；</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;使用带参混合器<br><code>选择器{ @include 混合器名称(实参1，实参2，...)}</code></li><li>5.继承<br>&nbsp;&nbsp;&nbsp;&nbsp;通过 @extend实现继承<br>&nbsp;&nbsp;&nbsp;&nbsp;继承是说一个选择器可以继承另一个选择器定义的所有样式。<br>ex:<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.round</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">border-radius</span>:<span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.round-shadow</span>&#123;</span><br><span class="line">  <span class="keyword">@extend</span> .round;</span><br><span class="line">  <span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scss运算"><a href="#scss运算" class="headerlink" title="scss运算"></a>scss运算</h3></li><li>1.数字：加减乘除，取整等运算（+,-,*,/,%）,如果必要会在不同单位间转换值（前提是scss能转）<br>ex:<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$my_width</span>:<span class="number">5%</span>;</span><br><span class="line"><span class="variable">$my_max_width</span>:<span class="variable">$my_width</span>*<span class="number">4</span>;</span><br><span class="line"><span class="variable">$other_size</span>:<span class="variable">$my_width</span>+<span class="variable">$my_max_width</span>;</span><br></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;(1)注意加法<br>&nbsp;&nbsp;&nbsp;&nbsp;+也可以用于连接字符串</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">"Microsoft"</span>+yahei;</span><br><span class="line">  <span class="attribute">font-family</span>: A+<span class="string">"rial"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;如果用有引号的字符串去连接无引号的字符串，运算结果是由引号的，相反，无引号的字符串去连接有引号的字符串，运算结果则没有引号。—–（有没有双引号，以前面的为准）<br>&nbsp;&nbsp;&nbsp;&nbsp;(2)除法运算<br>ex:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">10px</span>/<span class="number">80px</span>; <span class="comment">//分隔线</span></span><br><span class="line">  <span class="variable">$width</span>:<span class="number">1000px</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">$width</span>/<span class="number">2</span>;      <span class="comment">//除法</span></span><br><span class="line">  <span class="attribute">height</span>:(<span class="number">500px</span>/<span class="number">2</span>);    <span class="comment">//除法</span></span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">5px</span>+<span class="number">10px</span>/<span class="number">2px</span>; <span class="comment">//除法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;/在css中通常起到分隔数字的用途，同时也赋予除法的功能。<br>以下情况/被视为除法运算：<br>&nbsp;&nbsp;&nbsp;&nbsp;1.如果值，或值的一部分，是变量或者是函数的返回值。<br>&nbsp;&nbsp;&nbsp;&nbsp;2.如果值被圆括号包裹时<br>&nbsp;&nbsp;&nbsp;&nbsp;3.如果值是算术运算的一部分<br>&nbsp;&nbsp;&nbsp;&nbsp;(3)运算表达式与其他连用是，用空格做连接符<br>ex:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">5px</span>+<span class="number">10px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;(4)在有引号的文本字符串中使用#{}插值语句可以添加动态的值。(有点借鉴模板字符串)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">"I am #&#123;5+15&#125; years old"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.颜色：颜色值的运算是分段计算的，也就是分别计算红色，绿色，以及蓝色的值。<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="number">#010203</span>+<span class="number">#040506</span>&#125;;</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;计算：01+04=05  02+05=07  03+06=09<br>&nbsp;&nbsp;&nbsp;&nbsp;结果：color:#050709;<br>&nbsp;&nbsp;&nbsp;&nbsp;值包含alpha(透明度)，必须有相等alpha值才能进行运算，因为算术运算不会作用于alpha。<br>ex:<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgba(125,25,10,<span class="selector-class">.5</span>)+rgba(245,65,90,<span class="selector-class">.5</span>)</span><br></pre></td></tr></table></figure><h3 id="scss函数"><a href="#scss函数" class="headerlink" title="scss函数"></a>scss函数</h3>scss定义了多种函数，有些甚至可以通过普通的css语句调用。<br>ex:rgba(10,30,40,.7);在普通的css中也可以使用<br>&nbsp;&nbsp;&nbsp;&nbsp;1.颜色<br>rgba();<br>hsl(hue,saturation,lightness);<blockquote><p>hue:色调，取值0-360，0-120红色，120-240绿色，240-360蓝色。<br>saturation:饱和度，取值为0%-100%<br>lightness:亮度，取值0%-100%</p></blockquote></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;2.数字函数</p><blockquote><p>round(value) 将数值进行四舍五入，转换成最接近的整数。<br>ceil(value) 向上取整<br>floor(value) 向下取整<br>min(num1,num2…)找出数值之间的最小值<br>max(num1,num2…)找最大值<br>random() 获取随机数</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;3.字符串函数</p><blockquote><p>unquote(string) 删除字符串的引号<br>quote(string)   添加字符串的引号<br>to_upper_case(string) 将字符串小写字母转换为大写字母<br>to_lower_case(string) 将字符串大写字母转换为小写字母</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;4.自定义函数<br>&nbsp;&nbsp;&nbsp;&nbsp;scss支持自定义函数使用关键词 @function定义，并能在任何属性或scss中使用，需要调用 @return输出结果。<br>语法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@function</span> 函数名(<span class="variable">$n</span>)&#123;</span><br><span class="line">  <span class="keyword">@return</span> 运算表达式；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;5.控制指令<br>1.当 @if 的表达式返回值不是false或null时，表示条件成立，执行{}内的代码。<br>ex:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span> &#123;<span class="attribute">border-radius</span>:<span class="number">5px</span>;&#125;</span><br><span class="line">  <span class="keyword">@if</span> <span class="number">5</span>&lt;<span class="number">3</span> &#123;<span class="attribute">border-radius</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">  <span class="keyword">@if</span> null &#123;<span class="attribute">border-radius</span>:<span class="number">20px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.@if 声明后面可以跟多个 @else if 声明，或者一个 @else声明。<br>ex:</p><pre class="line-numbers language-scss"><span class="variable"><code class="language-scss"><span class="variable">$type</span>:abc;<span class="selector-tag">nav</span>{  <span class="keyword">@if</span> <span class="variable">$type</span>==sun{      <span class="attribute">color</span>:yellow;  } <span class="keyword">@else</span> if <span class="variable">$type</span>==mars{      <span class="attribute">color</span>:red;  } <span class="keyword">@else</span> if <span class="variable">$type</span>==moon{      <span class="attribute">color</span>:blue;  } <span class="keyword">@else</span>{      <span class="attribute">color</span>:black;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SCSS定制&quot;&gt;&lt;a href=&quot;#SCSS定制&quot; class=&quot;headerlink&quot; title=&quot;SCSS定制&quot;&gt;&lt;/a&gt;SCSS定制&lt;/h3&gt;&lt;p&gt;ex:css文件&lt;/p&gt;
&lt;figure class=&quot;highlight scss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$jd_red&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;#f10215&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.register&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:&lt;span class=&quot;variable&quot;&gt;$jd_red&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.search&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:&lt;span class=&quot;variable&quot;&gt;$jd_red&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;h1&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:&lt;span class=&quot;variable&quot;&gt;$jd_red&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.img&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:&lt;span class=&quot;variable&quot;&gt;$jd_red&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="scss" scheme="https://jambo0624.github.io/categories/scss/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="scss" scheme="https://jambo0624.github.io/tags/scss/"/>
    
  </entry>
  
  <entry>
    <title>jquery-api</title>
    <link href="https://jambo0624.github.io/2020-03-16-jquery-api.html"/>
    <id>https://jambo0624.github.io/2020-03-16-jquery-api.html</id>
    <published>2020-03-16T06:38:46.000Z</published>
    <updated>2020-03-16T07:57:52.894Z</updated>
    
    <content type="html"><![CDATA[<p>jQuery常用方法归纳总结</p><ul><li>$.grep()<br><code>$.grep( array, function(elementOfArray, indexInArray) [, invert ] )</code><br>功能：查找满足过滤函数的数组元素：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery1.42.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">   $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">     <span class="keyword">var</span> arr = [<span class="number">23</span>,<span class="number">45</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">67</span>,<span class="number">8</span>,<span class="number">100</span>,<span class="number">-2</span>];</span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> arrGrep = $.grep(arr, <span class="function"><span class="keyword">function</span> (<span class="params">element,index</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">       <span class="keyword">return</span> (index&lt;<span class="number">5</span>)&amp;&amp;(element != <span class="number">4</span>);<span class="comment">//整体返回一个数组</span></span></span><br><span class="line">     &#125;)</span><br><span class="line"><span class="actionscript">     alert(arrGrep);<span class="comment">//23,45,5,1</span></span></span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li>$.map()<br><code>$.map( array, callback(elementOfArray, indexInArray) )</code><br>功能：将一个数组中的所有元素转换到另一个数组中。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">67</span>,<span class="number">8</span>,<span class="number">100</span>,<span class="number">-2</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> arrMap = $.map(arr, <span class="function"><span class="keyword">function</span> (<span class="params">element,index</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//  return (index&lt;3)&amp;&amp;(element != 4);这里按布尔值返回</span></span></span><br><span class="line">      if(index&lt;3 &amp;&amp; element&lt; 4)&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> element;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    alert(arrMap);<span class="comment">//1</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>mouseover()/mouserout()<br>当鼠标进入/离开某个元素或它的后代元素时触发mouseover/mouseout事件。<br>mouseover事件大多数时候会与 mouseout 事件一起使用。<br>mouseover/mouserout事件由于<strong>冒泡</strong>机制，经常在不需要的时候不小心触发，从而导致一些脚本问题。</li></ul><hr><ul><li>mouseenter()/mouseleave()<br>mouseenter/mouseleave当且仅当鼠标进入被选元素时才触发，当鼠标穿过任何子元素时不会触发。它不关心目标元素是否有子元素。</li></ul><hr><ul><li>focusin()和focusout()<br>.focusin()：一个元素或它的子元素得到焦点时触发此事件<br>.focusout()：一个元素或它的子元素失去焦点时触发此事件</li></ul><p>与 focus() 方法不同的是，focusin() 方法在任意子元素获得焦点时也会触发。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>focusin fire<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>focusin fire<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $( <span class="string">"p"</span> ).focusin(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      $( <span class="keyword">this</span> ).find( <span class="string">"span"</span> ).css( <span class="string">"display"</span>, <span class="string">"inline"</span> ).fadeOut( <span class="number">1000</span> );</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>eq()和get()<br>.get()： 通过jQuery对象获取一个对应的DOM元素。<br>.eq()：从集合的一个元素中构造新的jQuery对象</li></ul><p>eq返回的是一个jQuery对象，get返回的是一个DOM对象。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$( <span class="string">"li"</span> ).get( <span class="number">0</span> ).css(<span class="string">"color"</span>, <span class="string">"red"</span>); <span class="comment">//错误</span></span><br><span class="line">$( <span class="string">"li"</span> ).eq( <span class="number">0</span> ).css(<span class="string">"color"</span>, <span class="string">"red"</span>); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>那么，什么是DOM对象，什么又是jQuery对象呢？</p><p>DOM对象就是用js获得的对象，而juqery对象是用jQuery类库的选择器获得的对象。</p><p>如：<code>var $obj = $(&quot;div&quot;);</code>//jQuery对象</p><p>get方法本质上是把jQuery对象转换成DOM对象，但是css属于jQuery构造器的，DOM是不存在这个方法的，如果需要用jQuery的方法，我们必须这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> li = $(<span class="string">"li"</span>).get(<span class="number">0</span>);</span><br><span class="line">$(li).css(<span class="string">"color"</span>,<span class="string">"black"</span>);<span class="comment">//用$包装</span></span><br></pre></td></tr></table></figure><ul><li>filter()<br><code>filter()</code>方法:筛选出与指定表达式匹配的元素集合。<br>这个方法用于缩小匹配的范围。用逗号分隔多个表达式。</li></ul><p>filter(expression)：（字符串|函数）如果参数是字符串，则制定jQuery选择器，用于从包装集里删除所有与选择器不匹配的元素，最后留下与选择器匹配的元素；如果参数是函数，则用于确定筛选条件。为包装集里的每一个元素各调用一次该函数，函数调用返回值为false的任何元素都会从包装集里删除。</p><p>以下代码意为：保留第一个以及带有select类的元素</p><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello Again<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"selected"</span>&gt;</span>And Again<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jQuery 代码:</p><p>  <code>$(&quot;p&quot;).filter(&quot;.selected, :first&quot;)</code><br>结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"selected"</span>&gt;</span>And Again<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再看一个function的例子，一个函数用来作为测试元素的集合。它接受一个参数index，这是元素在jQuery集合的索引。在函数， this指的是当前的DOM元素。</p><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>How are you?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jQuery 代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $(<span class="string">"ol"</span>, <span class="keyword">this</span>).length == <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果:</p><p><code>&lt;p&gt;How are you?&lt;/p&gt;</code></p><ul><li>.bind()、.live()和.delegate()方法<br>.bind()：绑定事件处理函数的最基本方式是使用.bind()方法。它和live()方法一样，接受两个参数：</li></ul><p>.bind(event type, event handler)<br>两种绑定事件处理函数的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'.mydiv'</span>).bind(<span class="string">'click'</span>,test);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"￼Hello World!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事件处理函数也可以使用匿名函数，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#mydiv"</span>).bind(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"￼Hello World!"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>.live()：live方法和bind方法的唯一区别在于.live()不仅作用于DOM中当前存在的元素，还作用于将来可能存在（动态生成）的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'.box'</span>).live(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).clone().appendTo(<span class="string">'.container'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用live方法绑定事件的缺点在于它无法使用链式调用，那有没有既可以像live方法那样绑定事件，又可以支持链式调用的方法呢？答案就是下面的delegate方法。</p><p>delegate()方法：为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，</p><p>并规定当这些事件发生时运行的函数。从jQuery 1.7开始，<code>.delegate()</code>已经被<code>.on()</code>方法取代。<br>语法：</p><p> <code>$(selector).delegate(childSelector,event type,function)</code><br>参数说明：</p><p><code>childSelector</code> 必需。规定要附加事件处理程序的一个或多个子元素。</p><p><code>event</code> 必需。规定附加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。</p><p><code>function</code> 必需。规定当事件发生时运行的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'.container'</span>).delegate(<span class="string">'.box'</span>,<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).clone().appendTo(<span class="string">'.container'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>delegate()会在以下两个情况下使用到：</p><p>1、如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下：<br>2、当元素在当前页面中不可用时，可以使用delegate()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"ul"</span>).delegate(<span class="string">"li"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><ul><li>end()方法<br><code>end()</code>方法：在jquery命令链内调用，以便退回到前一个包装集。<br>每次过滤方法都会被压入栈中。当我们需要返回到前一个状态时，我们可以使用end() 进行出栈操作，来返回栈中的前一个状态。</li></ul><p>end() 方法结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">'ul.one'</span>).find(<span class="string">".two"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>).find(<span class="string">'.three'</span>).css(<span class="string">"background"</span>,<span class="string">"blue"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的代码例子中，我们只会看到item 1的字体颜色改变了，而背景颜色没有改变。这是因为<br>第二个find()方法之前的状态返回的是红色字体的class值为two的对象，因此，第二次find()只会查找<code>&lt;ul class=&quot;one&quot;&gt;</code>中的.two，使用end()方法修改该链式操作的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">'ul.one'</span>).find(<span class="string">".two"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>).end().find(<span class="string">'.three'</span>).css(<span class="string">"background"</span>,<span class="string">"blue"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>end()方法在这里是 返回调用 find() 之前的状态，也就是$(‘ul.one’)</p><hr><ul><li>toggleClass()<br><code>toggleClass()方法：</code>如果在元素中指定类名称不存在，则添加指定类名称；如果元素已经拥有指定类名称，则从元素中删除指定类名称。<br><code>css(name,value)</code>方法：设定指定的值到每个已匹配元素的指定的css样式属性</li></ul><hr><ul><li>wrap()和wrapInner()<br><code>wrap()和wrapInner()：</code>前者把所有匹配的元素用其他元素的结构化标记包裹起来；后者将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来。<br>看下面一个wrap()的例子：<br>用原先div的内容作为新div的class，并将每一个元素包裹起来</li></ul><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>Goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jQuery 代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.inner'</span>).wrap(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;div class="'</span> + $(<span class="keyword">this</span>).text() + <span class="string">'" /&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"Hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"Goodbye"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>Goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着再看下面一个wrapInner()的例子:</p><p>用原先div的内容作为新div的class，并将每一个元素包裹起来</p><p>HTML 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>Goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jQuery 代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.inner'</span>).wrapInner(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;div class="'</span> + $(<span class="keyword">this</span>).text() + <span class="string">'" /&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"Hello"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"Goodbye"</span>&gt;</span>Goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>detach、empty和remove方法<br><code>.detach( [selector ] )：</code>从DOM中去掉所有匹配的元素。当需要移走一个元素，不久又将该元素插入DOM时，就需要用到detach方法。</li></ul><p><code>.empty()：</code>这个方法不仅移除子元素（和其他后代元素），同样移除元素里的文本。因为，根据说明，元素里任何文本字符串都被看做是该元素的子节点。</p><p><code>.remove( [selector ] )：</code>将元素从DOM中移除，同时移除元素上的事件及 jQuery 数据</p><p>empty()的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">".two"</span>).empty();<span class="comment">//item 1 文本节点被移除，li的小圆点还在，证明li没有被移除</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看下面一个remove()例子：</p><p>描述：从DOM中把所有段落删除</p><p>HTML 代码:<br><code>&lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;</code><br>jQuery 代码:<br><code>$(&quot;p&quot;).remove();</code><br>结果:<br><code>how are</code></p><hr><ul><li>val()方法<br>val()：获得匹配元素的当前值。<br>描述:获取文本框中的值</li></ul><p>jQuery 代码:<br><code>$(&quot;input&quot;).val();</code></p><p>jQuery 代码:<br><code>$(&quot;input&quot;).val(&quot;hello world!&quot;);</code></p><hr><ul><li>each()和map()<br>each()和map()方法：each返回的是原来的数组，并不会新创建一个数组。而map方法会返回一个新的数组。如果在没有必要的情况下使用map，则有可能造成内存浪费。<br>each方法：</li></ul><p>定义一个空数组，通过each方法，往数组添加ID值；最后将数组转换成字符串后，alert这个值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  $(<span class="string">":checkbox"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">    arr.push(<span class="keyword">this</span>.id);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> str = arr.join(<span class="string">","</span>);</span><br><span class="line">  alert(str);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>map方法:</p><p>将每个:checkbox执行return this.id；并将这些返回值，自动的保存为jQuery对象，然后用get方法将其转换成原生Javascript数组，再使用join方法转换成字符串，最后alert这个值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = $(<span class="string">":checkbox"</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">  &#125;).get().join();    </span><br><span class="line">  alert(str);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当有需一个数组的值的时候，用map方法，很方便。</p><hr><ul><li>$.each()<br>jQuery的$(selector).each()函数可以遍历循环选中的子元素，而jQuery的$.each()函数则可以遍历任何集合，包括对象和数组，它接收要遍历的集合以及一个回调函数，回调函数每次传递一个数组的下标和这个下标所对应的数组的值。</li></ul><p><code>$.each(array,callback);</code></p><p><code>$.each(object,callback);</code></p><p>=&gt; 数组实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.each( [ <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> i, l </span>)</span>&#123;</span><br><span class="line">  alert( <span class="string">"index #"</span> + i + <span class="string">": "</span> + l );</span><br><span class="line">&#125;);</span><br><span class="line">callback(索引,索引值)</span><br></pre></td></tr></table></figure><p>DEMO：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index <span class="number">0</span>: one</span><br><span class="line">index <span class="number">1</span>: two;</span><br><span class="line">index <span class="number">2</span>: three</span><br></pre></td></tr></table></figure><p>=&gt; 对象实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.each(&#123; <span class="attr">name</span>: <span class="string">"trigkit4"</span>, <span class="attr">lang</span>: <span class="string">"JS"</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> k, v </span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Key: "</span> + k + <span class="string">", Value: "</span> + v );</span><br><span class="line">&#125;);</span><br><span class="line">callback(键,值)</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key: name, <span class="attr">Value</span>: trigkit4</span><br><span class="line">Key: lang, <span class="attr">Value</span>: JS</span><br></pre></td></tr></table></figure><ul><li>.trigger()<br>描述: 根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为。</li></ul><p>当相应的事件发生时，任何通过.on()、.bind()或一个快捷方法绑定的事件处理程序将被触发。但是，它们可以用.trigger()方法手动触发</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="built_in">document</span>).bind(<span class="string">'abc'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  $(<span class="built_in">document</span>).trigger(<span class="string">'abc'</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">//Output  'hello';</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>.attr()和.prop()<br>.attr()：获取匹配的元素集合中的第一个元素的属性的值 或 设置每一个匹配元素的一个或多个属性。</li></ul><p>.prop()：同上<br>jQuery 1.6之前 ，.attr()方法在取某些 attribute 的值时，会返回 property 的值，这就导致了结果的不一致。从 jQuery 1.6 开始， .prop()方法 方法返回 property 的值,而 .attr() 方法返回 attributes 的值。</p><p>例如, selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, 和 defaultSelected 应使用.prop()方法进行取值或赋值。<br>他们没有相应的属性（attributes），只有特性(property)。</p><hr><ul><li>.after()和.insertAfter()</li></ul><p>1.after()<br>描述:<br>在所有段落中后插入一个jQuery对象(类似于一个DOM元素数组)。</p><p>HTML 代码:<br><code>&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</code><br>jQuery 代码:<br><code>$(&quot;p&quot;).after( $(&quot;b&quot;) );</code><br>结果:<br><code>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</code></p><p>2.insertAfter()<br>描述:<br>把所有段落插入到一个元素之后。与 $(“#foo”).after(“p”)相同</p><p>HTML 代码:<br><code>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id=&quot;foo&quot;&gt;Hello&lt;/div&gt;</code><br>jQuery 代码:</p><p><code>$(&quot;p&quot;).insertAfter(&quot;#foo&quot;);</code><br>结果:<br><code>&lt;div id=&quot;foo&quot;&gt;Hello&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</code></p><hr><ul><li>.before()和.insertBefore()</li></ul><p>3.before()<br>描述:<br>在所有段落中前插入一个jQuery对象(类似于一个DOM元素数组)。</p><p>HTML 代码:</p><p><code>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</code><br>jQuery 代码:</p><p><code>$(&quot;p&quot;).before( $(&quot;b&quot;) );</code><br>结果:</p><p><code>&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</code></p><ul><li>.append()和.appendTo()</li></ul><p>4.append()<br>描述：向所有段落中追加一些HTML标记。</p><p>HTML 代码:</p><p><code>&lt;p&gt;I would like to say: &lt;/p&gt;</code><br>jQuery 代码:</p><p><code>$(&quot;p&quot;).append(&quot;&lt;b&gt;Hello&lt;/b&gt;&quot;);</code><br>结果:</p><p><code>&lt;p&gt;I would like to say: &lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;</code></p><p>5.appendTo()<br>描述：新建段落追加div中并加上一个class</p><p>HTML 代码:</p><p><code>&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</code><br>jQuery 代码:<br><code>$(&quot;&lt;p/&gt;&quot;).appendTo(&quot;div&quot;).addClass(&quot;test&quot;).end().addClass(&quot;test2&quot;);</code><br>结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"test test2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>.prepend()和.prependTo()</li></ul><p>6.prepend()<br>描述：向所有段落中前置一个jQuery对象(类似于一个DOM元素数组)。</p><p>HTML 代码:</p><p><code>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</code></p><p>jQuery 代码:</p><p><code>$(&quot;p&quot;).prepend( $(&quot;b&quot;) );</code><br>结果:</p><p><code>&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;</code></p><p>7.prependTo()<br>描述：把所有段落追加到ID值为foo的元素中。</p><p>HTML 代码:</p><p><code>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</code><br>jQuery 代码:</p><p><code>$(&quot;p&quot;).prependTo(&quot;#foo&quot;);</code><br>结果:</p><p><code>&lt;div id=&quot;foo&quot;&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt;</code></p><p>总结</p><ol><li>.insertAfter()和.after()：在现存元素的外部，从后面插入元素  </li></ol><ol start="2"><li>.insertBefore()和.before()：在现存元素的外部，从前面插入元素  </li></ol><ol start="3"><li>.appendTo()和.append()：在现存元素的内部，从后面插入元素  </li></ol><ol start="4"><li>.prependTo()和.prepend()  ：在现存元素的内部，从前面插入元素</li></ol><hr><ul><li>.data( key, value )<br>.data() 方法允许我们在DOM元素上绑定任意类型的数据,<br><code>$(&quot;div&quot;).data(&quot;test&quot;, { first: 16, last: &quot;pizza!&quot; });</code></li></ul><hr><ul><li>.promise( [type ] [, target ] )<br>在 Javascript 中，有外一种异步处理模式被叫做 Promises， CommonJS 标准委员会于是发布了一个规范，就把这个 API 叫做 Promises 了。</li></ul><p>Promise 背后的概念非常简单，有两部分:</p><p>=&gt; Deferreds，定义工作单元，<br>=&gt; Promises，从 Deferreds 返回的数据。<br>Promise 不同于回调的很重要的一个点是，你可以在 Promise 状态变成执行(resolved)之后追加处理句柄。这就允许你传输数据，而忽略它是否已经被应用获取，然后缓存它，等等之类的操作，因此你可以对数据执行操作，而不管它是否已经或者即将可用。</p><p>你可以给一个 promise 追加多个处理(then())。Promise API 好玩的地方在于允许链式处理:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lang: js</span></span><br><span class="line">promise</span><br><span class="line">  .then(doSomething)</span><br><span class="line">  .then(doSomethingElse)</span><br><span class="line">  .then(doSomethingMore)</span><br><span class="line">  .catch(logError);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jQuery常用方法归纳总结&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$.grep()&lt;br&gt;&lt;code&gt;$.grep( array, function(elementOfArray, indexInArray) [, invert ] )&lt;/code&gt;&lt;br&gt;功能：查找满足过滤函数的数组元素：&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;js/jquery1.42.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;   $(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;67&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arrGrep = $.grep(arr, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;element,index&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (index&amp;lt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&amp;amp;&amp;amp;(element != &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//整体返回一个数组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;     alert(arrGrep);&lt;span class=&quot;comment&quot;&gt;//23,45,5,1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="jquery" scheme="https://jambo0624.github.io/categories/jquery/"/>
    
    
      <category term="api" scheme="https://jambo0624.github.io/tags/api/"/>
    
      <category term="jquery" scheme="https://jambo0624.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>js数组api</title>
    <link href="https://jambo0624.github.io/2020-03-16-array-api.html"/>
    <id>https://jambo0624.github.io/2020-03-16-array-api.html</id>
    <published>2020-03-16T03:45:10.000Z</published>
    <updated>2020-03-16T03:53:01.470Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript数组API汇总</p><ul><li>01、push()：将value添加到数组的最后，返回新数组的长度(改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.push(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)    <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(a)         <span class="comment">// [1, 2, 3, 4, 5, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">result = a.push(<span class="string">'a'</span>, <span class="string">'b'</span>)      <span class="comment">// 可一次添加多个值</span></span><br><span class="line"><span class="built_in">console</span>.log(result)            <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(a)                 <span class="comment">// [1, 2, 3, 4, 5, 1, 'a', 'b']</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li>02、unshift()：添加元素到数组的开头，返回新数组的长度(改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.unshift(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)        <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(a)             <span class="comment">// [1, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">result = a.unshift(<span class="string">'a'</span>, <span class="string">'b'</span>)  <span class="comment">// 可一次添加多个值</span></span><br><span class="line"><span class="built_in">console</span>.log(result)           <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(a)                <span class="comment">// ['a', 'b', 1, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li>03、pop()：删除数组中最后一个元素，返回被删除的元素(改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.pop()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">result = a.pop()     <span class="comment">// 数组为空数组后，执行pop()方法，返回undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// []</span></span><br></pre></td></tr></table></figure></li><li>04、shift()：删除数组第一个元素，返回被删除的元素(改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.shift()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">result = a.shift()     <span class="comment">// 数组为空数组后，执行pop()方法，返回undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(result)    <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a)         <span class="comment">// []</span></span><br></pre></td></tr></table></figure></li><li>05、join(value)：将数组用value连接为字符串，返回被连接后的字符串(不改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.join()</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">result = a.join(<span class="string">''</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// 12345</span></span><br><span class="line">result = a.join(<span class="string">','</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">result = a.join(<span class="string">'&amp;'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// 1&amp;2&amp;3&amp;4&amp;5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用了toString()方法！'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  toValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用了toValue()方法！'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'b'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">result = a.join(obj)  <span class="comment">// 使用对象时会调用对象自身的toString方法，我们这里重写了toString</span></span><br><span class="line"><span class="comment">// 调用了toString()方法</span></span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 1a2a3a4a5</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中的join()方法相对的一个方法是字符串的split()方法</span></span><br><span class="line"><span class="built_in">console</span>.log(result.split(<span class="string">'a'</span>))  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li>06、reverse()：反转数组，返回反转后的新数组(改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, ,<span class="number">3</span>, ,<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">//  [5, 4 ,3 ,2 ,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)        <span class="comment">//  [5, 4 ,3 ,2 ,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">result = a.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// [[4, 5], [2, 3], 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)        <span class="comment">// [[4, 5], [2, 3], 1]</span></span><br><span class="line"><span class="comment">// 可以看到这里的反转只是基于数组的第一层，属于浅反转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的深反转需要使用递归实现</span></span><br><span class="line"><span class="keyword">const</span> deepReverse = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = array.reverse()</span><br><span class="line">  temp.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(v) === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">      deepReverse(v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line">a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">result = deepReverse(a)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [[5, 4], [3, 2], 1]</span></span><br></pre></td></tr></table></figure></li><li>07、slice(start, end)：获取子数组，包含原数组索引start的值到索引end的值，不包含end，返回获取的子数组(不改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.slice(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">1</span>))       <span class="comment">// [2, 3, 4, 5]  只有一个参数且不小于0时，则从此索引开始截取到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">-1</span>))      <span class="comment">// [5]  只有一个参数且小于0时，则从倒数|start|位截取到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">-1</span>, <span class="number">1</span>))   <span class="comment">// []   反向截取，不合法，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">1</span>, <span class="number">-1</span>))   <span class="comment">// [2, 3, 4]  从第1位截取到倒数第1位</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">-1</span>, <span class="number">-2</span>))  <span class="comment">// []   反向截取，不合法，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">-2</span>, <span class="number">-1</span>))  <span class="comment">// [4]  倒数第2位截取到倒数第1位</span></span><br></pre></td></tr></table></figure></li><li>08、splice(index, count, value1, value2….)：从索引位index处删除count个元素，插入value1, value2等元素，返回被删除的元素组成的新数组(改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 0, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">-2</span>))  <span class="comment">// [4, 5]  当参数为单个且小于0时，将截取从倒数|index|位到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a)             <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">-1</span>))  <span class="comment">// [5]  当参数为单个且小于0时，将截取从倒数|index|位到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a)             <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">0</span>))  <span class="comment">// [1, 2, 3, 4, 5] 当参数为单个且不小于0时，将截取从index位到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a)            <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">1</span>))  <span class="comment">// [2, 3, 4, 5]  当参数为单个且不小于0时，将截取从index位到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a)            <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">-1</span>, <span class="number">2</span>))   <span class="comment">// [5]  从倒数第1位开始截取两个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(a)                 <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>))  <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// ['a', 'b', 'c', 3, 4, 5]  截取后将value值依次填充到截取位置处，旧值被向后顺移</span></span><br></pre></td></tr></table></figure></li><li>09、sort()：对数组元素进行排序，返回排序后的新数组(改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">31</span>, <span class="number">22</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.sort()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [1, 22, 27, 31, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 22, 27, 31, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">a = [<span class="string">'c'</span>, <span class="string">'ac'</span>, <span class="string">'ab'</span>, <span class="string">'A1'</span>, <span class="string">'1c'</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="string">'13'</span>, <span class="string">'12'</span>, <span class="string">'3'</span>, <span class="string">'2'</span>, <span class="string">'1b'</span>, <span class="string">'1a'</span>, <span class="number">1</span>, <span class="string">'aa'</span>, <span class="string">'a'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [1, 12, "12", 13, "13", "1a", "1b", "1c", "2", 2, "3", 3, "A1", "a", "aa", "ab", "ac", "b", "c"]</span></span><br><span class="line"><span class="comment">// 可以看出sort排序是根据每个字符对应的ASCII码值进行排序的，而非值的大小。</span></span><br><span class="line"><span class="comment">// 先比较第一位的ASCII码值，如果第一位的ASCII码值相同，则开始比较第二位的ASCII码值，以此类推</span></span><br><span class="line"><span class="comment">// ASCII码表(http://tool.oschina.net/commons?type=4 + K)</span></span><br><span class="line">a = [<span class="number">31</span>, <span class="number">22</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br><span class="line">a.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 9, 22, 27, 31]  按数值大小正序排列</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">31</span>, <span class="number">22</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br><span class="line">a.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> b - a</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [31, 27, 22, 9, 1]  按数值大小倒序排列</span></span><br></pre></td></tr></table></figure></li><li>10、toString()：将数组中的元素用逗号拼接成字符串，返回拼接后的字符串(不改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.toString()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 1,2,3,4,5</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了toString()方法之外，String()方法也可以将数组转换成字符串</span></span><br><span class="line">result = <span class="built_in">String</span>(a)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure></li><li>11、indexOf(value)：从索引为0开始，检查数组中是否包含有value，有则返回匹配到的第一个索引，没有则返回-1(不改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.indexOf(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">result = a.indexOf(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li>12、lastIndexOf(value)：从最后的索引开始，检查数组找那个是否包含value，有则返回匹配到的第一个索引，没有返回-1(不改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.lastIndexOf(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">result = a.lastIndexOf(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li>13、concat(value)：将数组和(或)值连接成新数组，返回新数组(不改变原数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>], b = [<span class="number">3</span>, <span class="number">4</span>], c = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> result = a.concat(b, c)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">b = [<span class="number">3</span>, [<span class="number">4</span>]]</span><br><span class="line">result = a.concat(b, c) </span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [1, 2, 3, [4], 5]  concat对于嵌套数组无法拉平</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure></li><li>14、forEach()：对数组进行遍历循环，对数组中每一项运行给定函数，参数都是function类型，默认有传参，参数分别为：遍历数组内容、对应的数组索引、数组本身。没有返回值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item + <span class="string">'|'</span> + index + <span class="string">'|'</span> + (a === <span class="literal">true</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// 1|0|true</span></span><br><span class="line"><span class="comment">// 2|1|true</span></span><br><span class="line"><span class="comment">// 3|2|true</span></span><br><span class="line"><span class="comment">// 4|3|true</span></span><br><span class="line"><span class="comment">// 5|4|true</span></span><br></pre></td></tr></table></figure></li><li>15、map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的新数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * item</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></li><li>16、filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> index % <span class="number">3</span> === <span class="number">0</span> || item &gt;= <span class="number">8</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// [1, 4, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure></li><li>17、every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>18、some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>19、 reduce():接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值</li></ul><p><strong>语法：</strong><code>array.reduce(function(previousValue, currentValue, currentIndex, arr), initialValue)</code><br>如果initialValue省略，则previousValue和currentValue分别为数组中的第一项元素和第二项元素；如果initialValue存在，则previousValue为initialValue，而currentValue为数组中的第一项<br><strong>注意:</strong> reduce() 对于空数组是不会执行回调函数的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = arr.reduce(<span class="function">(<span class="params">previousValue, currentValue, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue</span><br><span class="line">&#125;，<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result1:'</span>, result1) <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = arr.reduce(<span class="function">(<span class="params">previousValue, currentValue, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result2:'</span>, result2) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>综上可知，改变原数组的API如下：<br>push()、unshift()、pop()、shift()、reverse()、splice()、sort()</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript数组API汇总&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;01、push()：将value添加到数组的最后，返回新数组的长度(改变原数组)&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Base&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = a.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(result)    &lt;span class=&quot;comment&quot;&gt;// 6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a)         &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, 4, 5, 1]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// More&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;result = a.push(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;)      &lt;span class=&quot;comment&quot;&gt;// 可一次添加多个值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(result)            &lt;span class=&quot;comment&quot;&gt;// 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a)                 &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, 4, 5, 1, &#39;a&#39;, &#39;b&#39;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="array" scheme="https://jambo0624.github.io/tags/array/"/>
    
      <category term="api" scheme="https://jambo0624.github.io/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>c3-animation</title>
    <link href="https://jambo0624.github.io/2020-03-16-c3-animation.html"/>
    <id>https://jambo0624.github.io/2020-03-16-c3-animation.html</id>
    <published>2020-03-16T03:31:40.000Z</published>
    <updated>2020-03-16T03:37:55.466Z</updated>
    
    <content type="html"><![CDATA[<ul><li>动画是使元素从一种样式逐渐变化为另一种样式的效果，可以改变任意多的样式任意多的次数，通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。<a id="more"></a>动画的基本格式<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.box</span>&#123;</span></span><br><span class="line">        animation:（动画的属性）动画的值</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="keyword">@keyframes</span> run&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">from</span>&#123;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">to</span>&#123;&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">``` </span><br><span class="line">动画的执行方式</span><br><span class="line">``` css</span><br><span class="line">  @keyframes run&#123;</span><br><span class="line">    from&#123;&#125;</span><br><span class="line">    to&#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>或者<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> run&#123;</span><br><span class="line">  0%&#123;&#125;</span><br><span class="line">  100%&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>动画的各种参数<blockquote><p>1.设置动画的序列名称 <code>animation-name</code><br>2.设置动画执行一次所需要的时间 <code>animation-duration</code><br>3.设置动画延迟执行的时间 <code>animation-delay</code><br>4.设置动画执行的次数 <code>animation-iteration-count</code><br>5.设置动画执行方向 <code>animation-direction</code><br>&nbsp;&nbsp;&nbsp;&nbsp;相反方向    alternate<br>&nbsp;&nbsp;&nbsp;&nbsp;常顺序    normal<br>6.设置动画执行完毕时保持的状态 <code>animation-fill-mode</code><br>7.设置动画执行的速度 <code>animation-timing-function</code><br>8.设置动画是否执行 <code>animation-play-state</code><br>&nbsp;&nbsp;&nbsp;&nbsp;开始动画    running<br>&nbsp;&nbsp;&nbsp;&nbsp;停止动画    paused</p></blockquote></li></ul><p>帧动画</p><ul><li>帧动画是将animation中设置steps的值所生成的动画<br>下面是帧动画的程序<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.div1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:400px</span> ;</span></span><br><span class="line">        height: 400px;</span><br><span class="line">        border: 3px solid black;</span><br><span class="line"><span class="css">        <span class="selector-tag">border-radius</span><span class="selector-pseudo">:50</span>% ;</span></span><br><span class="line">        margin: 100px auto;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.div2</span>&#123;</span></span><br><span class="line">        width: 5px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:black</span> ;</span></span><br><span class="line">        border-radius: 50% 50% 0 0/ 50% 50% 0 0;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 200px;</span><br><span class="line">        top: 0px;</span><br><span class="line">        animation: name 60s steps(60) infinite;</span><br><span class="line">        transform-origin:  center bottom; </span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="keyword">@keyframes</span> name&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">from</span>&#123;&#125;</span></span><br><span class="line">        to&#123;</span><br><span class="line">          transform: rotate(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;动画是使元素从一种样式逐渐变化为另一种样式的效果，可以改变任意多的样式任意多的次数，通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="animation" scheme="https://jambo0624.github.io/tags/animation/"/>
    
      <category term="keyframe" scheme="https://jambo0624.github.io/tags/keyframe/"/>
    
  </entry>
  
  <entry>
    <title>js笔记</title>
    <link href="https://jambo0624.github.io/2020-03-16-js-note.html"/>
    <id>https://jambo0624.github.io/2020-03-16-js-note.html</id>
    <published>2020-03-16T01:55:44.000Z</published>
    <updated>2020-03-16T02:20:16.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="03变量交换"><a href="#03变量交换" class="headerlink" title="03变量交换"></a>03变量交换</h3><ul><li>1、运算符的优先级问题<br>&nbsp;&nbsp;&nbsp;&nbsp;一是是括号<br>&nbsp;&nbsp;&nbsp;&nbsp;二是一元运算符（-,!,++,–）<br>&nbsp;&nbsp;&nbsp;&nbsp;三是二元运算符（+,-,<em>,/）<br>&nbsp;&nbsp;&nbsp;&nbsp;四是一级逻辑运算符（&gt;,&lt;,&gt;=,&lt;=）<br>&nbsp;&nbsp;&nbsp;&nbsp;五是二级逻辑运算符（==,===,!==,!===）<br>&nbsp;&nbsp;&nbsp;&nbsp;六是三级逻辑运算符（&amp;&amp;优先于||）<br>&nbsp;&nbsp;&nbsp;&nbsp;七是三元运算符（?）<br>&nbsp;&nbsp;&nbsp;&nbsp;八是赋值运算符（=,+=,-=,</em>=,/=,%=）<a id="more"></a></li><li>2、a++和++a的区别<br>&nbsp;&nbsp;&nbsp;&nbsp;a++是先赋值再计算<br>&nbsp;&nbsp;&nbsp;&nbsp;++a是先计算再赋值<h3 id="09for循环求斐波那契数列中第n项的值"><a href="#09for循环求斐波那契数列中第n项的值" class="headerlink" title="09for循环求斐波那契数列中第n项的值"></a>09for循环求斐波那契数列中第n项的值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibon</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n==<span class="number">1</span> || n==<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp =b;</span><br><span class="line">    b=a+b;</span><br><span class="line">    a=temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fibon(<span class="number">12</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="12打印"><a href="#12打印" class="headerlink" title="12打印"></a>12打印</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、打印9*9★（外循环控制行，内循环控制列）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"☆"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、打印直角三角形</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;=i;j++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"☆"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、打印99乘法表 ("\n")表示空格  unicode编码字符转义</span></span><br><span class="line"><span class="comment">//4、利用table标签打印99乘法表</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;table border='1px' cellpadding='0' cellspacing='0'&gt;"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"&lt;tr&gt;"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;td&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(j+<span class="string">"*"</span>+i+<span class="string">"="</span>+i*j);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;/table&gt;"</span>);</span><br></pre></td></tr></table></figure><h3 id="15数组的遍历"><a href="#15数组的遍历" class="headerlink" title="15数组的遍历"></a>15数组的遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素到新数组（1-100之间所有的奇数，放在数组中）</span></span><br><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i%<span class="number">2</span> !==<span class="number">0</span>) &#123;</span><br><span class="line">    arr[arr.length] =i;  <span class="comment">//arr.length可以作为新数组的索引值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><h3 id="16数组案例"><a href="#16数组案例" class="headerlink" title="16数组案例"></a>16数组案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、数组中所有值的和及平均值</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">  sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> avg=sum/(i<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br><span class="line"><span class="built_in">console</span>.log(avg);</span><br><span class="line"><span class="comment">//2、数组中的最大值</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">653</span>,<span class="number">23</span>,<span class="number">99</span>];</span><br><span class="line"><span class="keyword">var</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i]&gt;max) &#123;</span><br><span class="line">    max =arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max);</span><br><span class="line"><span class="comment">//3、求数组中的最大值和最小值以及其位置</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">32</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">653</span>,<span class="number">23</span>,<span class="number">99</span>];</span><br><span class="line"><span class="keyword">var</span> maxValue=arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> minValue=arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> maxIndex=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> minIndex=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i]&gt;maxValue) &#123;</span><br><span class="line">    maxValue =arr[i];</span><br><span class="line">    maxIndex=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[i]&lt;minValue) &#123;</span><br><span class="line">    minValue=arr[i];</span><br><span class="line">    minIndex=i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxValue);</span><br><span class="line"><span class="built_in">console</span>.log(maxIndex);</span><br><span class="line"><span class="built_in">console</span>.log(minValue);</span><br><span class="line"><span class="built_in">console</span>.log(minIndex);</span><br><span class="line"><span class="comment">//4、将数组用特殊字符隔开</span></span><br><span class="line"><span class="comment">//第一种做法：浪费内存</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str=arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> separator=<span class="string">"|"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">  str += separator + arr[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">//第二种方法：用API中的join方法</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1=arr.join(<span class="string">"|"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">//第三种方法：用API中的map方法(实现效果不严谨，不使用。这里仅仅作为复习)</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1=arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">ele,index,array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ele+<span class="string">"|"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">//5、将数组中值为0的去掉，不为0的存入一个新数组</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> newArr=[];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] !==<span class="number">0</span>) &#123;</span><br><span class="line">    newArr[newArr.length]= arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">//6、翻转数组</span></span><br><span class="line"><span class="comment">//第一种方法：创建新数组</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> newArr=[];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=arr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">  newArr[newArr.length] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">//第二种方法：翻转自身</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length/<span class="number">2</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">  arr[i] = arr[arr.length<span class="number">-1</span>-i];</span><br><span class="line">  arr[arr.length<span class="number">-1</span>-i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//7、冒泡排序</span></span><br><span class="line"><span class="keyword">var</span> arr= [<span class="number">2</span>,<span class="number">74</span>,<span class="number">56</span>,<span class="number">34</span>,<span class="number">-98</span>,<span class="number">-23</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">87</span>,<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> flag=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">      arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">      flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag===<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><h3 id="18、函数返回值案例"><a href="#18、函数返回值案例" class="headerlink" title="18、函数返回值案例"></a>18、函数返回值案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、求和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    sum +=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">100</span>));</span><br><span class="line"><span class="comment">//2、圆的周长和面积</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerimeter</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> perimeter =<span class="number">2</span>*<span class="built_in">Math</span>.PI*r;</span><br><span class="line">  <span class="keyword">return</span> perimeter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> area =<span class="built_in">Math</span>.PI*<span class="built_in">Math</span>.pow(r,<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getPerimeter(<span class="number">0.5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//3、两个和三个数中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxTwo</span>(<span class="params">n1,n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max=n1&gt;n2?n1:n2;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxThree</span>(<span class="params">n1,n2,n3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max=(n1&gt;n2?n1:n2)&gt;n3?(n1&gt;n2?n1:n2):n3;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getMaxTwo(<span class="number">2</span>,<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(getMaxThree(<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>));</span><br><span class="line"><span class="comment">//4、一个数组中的最大值和最小值</span></span><br><span class="line"><span class="keyword">var</span>  arr = [<span class="number">58</span>,<span class="number">0</span>,<span class="number">108</span>,<span class="number">22</span>,<span class="number">-4</span>,<span class="number">7</span>,<span class="number">-24</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMax</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max=array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i]&gt;max) &#123;</span><br><span class="line">      max =array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMin</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> min=array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i]&lt;min) &#123;</span><br><span class="line">      min =array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getMax(arr));</span><br><span class="line"><span class="built_in">console</span>.log(getMin(arr));</span><br><span class="line"><span class="comment">//5、两种方法翻转数组</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse1</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArray=[];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=array.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    newArray[newArray.length] =array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse2</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array.length/<span class="number">2</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp=array[i];</span><br><span class="line">    array[i] =array[array.length<span class="number">-1</span>-i];</span><br><span class="line">    array[array.length<span class="number">-1</span>-i] =temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(reverse1(arr));</span><br><span class="line"><span class="built_in">console</span>.log(reverse2(arr));</span><br><span class="line"><span class="comment">//6、冒泡排序</span></span><br><span class="line"><span class="keyword">var</span>  arr1 = [<span class="number">58</span>,<span class="number">0</span>,<span class="number">108</span>,<span class="number">22</span>,<span class="number">-4</span>,<span class="number">7</span>,<span class="number">-24</span>];</span><br><span class="line"><span class="keyword">var</span>  arr2 = [<span class="number">2</span>,<span class="number">74</span>,<span class="number">56</span>,<span class="number">34</span>,<span class="number">-98</span>,<span class="number">-23</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">87</span>,<span class="number">64</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array.length<span class="number">-1</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;array.length<span class="number">-1</span>-i;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j]&gt;array[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp=array[j];</span><br><span class="line">        array[j] =array[j+<span class="number">1</span>];</span><br><span class="line">        array[j+<span class="number">1</span>] =temp;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag===<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// alert(bubble(arr1));  //个人觉得这里undefined是因为，没有出现if里面的flag===1的情况。所以没有返回值</span></span><br><span class="line"><span class="comment">// alert(bubble(arr2));</span></span><br><span class="line"><span class="comment">//7、求阶乘的和1!+2!+3!+...+n!(函数嵌套)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorialSum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    sum += factorial(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> product =<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    product *=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(factorialSum(<span class="number">3</span>));</span><br><span class="line"><span class="comment">//8、判断一个数是否是素数（质数）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;<span class="built_in">Math</span>.sqrt(n);i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n%i === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isPrime(<span class="number">7</span>));</span><br><span class="line"><span class="comment">//9、得到n之内所有的质数</span></span><br><span class="line">getPrime(<span class="number">100</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10、求斐波那契数列中第n项的值</span></span><br><span class="line"><span class="comment">//1 1 2 3 5 8 13 21 34 55 89 144</span></span><br><span class="line"><span class="built_in">console</span>.log(getFibon(<span class="number">4</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFibon</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a1=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> a2=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp =a2;</span><br><span class="line">    a2 =a1+a2;</span><br><span class="line">    arr1 =temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//11、输入某年某月某日，判断这一天是这一年的第几天？（四年一闰，百年不闰，四百年再闰）</span></span><br><span class="line"><span class="comment">//思路：</span></span><br><span class="line"><span class="comment">// 先是判断年份，如果是闰年且超过2月，直接加1</span></span><br><span class="line"><span class="comment">// 之后将每月天数放入一个数组内部，然后判断月份。根据月份数，对天数进行累加。</span></span><br><span class="line"><span class="comment">// 2019,3,28</span></span><br><span class="line"><span class="comment">// console.log(getDays(2019,3,28));</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRN</span>(<span class="params">year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (year%<span class="number">4</span>==<span class="number">0</span> &amp; year%<span class="number">100</span>!==<span class="number">0</span> || year%<span class="number">400</span>==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDays</span>(<span class="params">year,month,day</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr=[<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;month<span class="number">-1</span>;i++) &#123;</span><br><span class="line">    day += arr[i] ;</span><br><span class="line">    <span class="keyword">if</span> (isRN(year)) &#123;</span><br><span class="line">      day +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22、变量和作用域"><a href="#22、变量和作用域" class="headerlink" title="22、变量和作用域"></a>22、变量和作用域</h3><p>全局变量：<br>&nbsp;&nbsp;&nbsp;&nbsp;函数外部(num)或者进入javascript立即定义的变量(num3)或者函数内部不带var的变量(num2)<br>局部变量：<br>&nbsp;&nbsp;&nbsp;&nbsp;函数内部用var定义的变量(num1)。这里和num2的区别就是，就算调用函数，但是引用num1也是无效的<br>函数加载的时候，只加载函数名，不加载函数体。(不调用不执行)意思就是说比如，想引用num2。必须先调用函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num3 = <span class="number">333</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">111</span>;</span><br><span class="line">  num2 = <span class="number">222</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预解析：js解析器在页面加载的时候，首先检查页面上的语法错误。把变量声明提升起来。变量只提升变量名。不提升变量值。而用function直接定义的方法是整体提升。<br>&nbsp;&nbsp;&nbsp;&nbsp;1、查看语法错误<br>&nbsp;&nbsp;&nbsp;&nbsp;2、变量声明提升和函数整体提升<br>&nbsp;&nbsp;&nbsp;&nbsp;3、变量声明提升在函数范围内照样适用</p><h3 id="25、递归和递归案例"><a href="#25、递归和递归案例" class="headerlink" title="25、递归和递归案例"></a>25、递归和递归案例</h3><p>递归就是函数自己调用自己。<br>递归注意事项：<br>&nbsp;&nbsp;&nbsp;&nbsp;递归必须有跳出条件，否则就是死循环。（★★★控制条件来调用它，这样表述更好，意思是条件在前）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、用递归求1-100的和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n&lt;<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n+getSum(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//2、用递归方法求出斐波那契数列第n项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibon</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n==<span class="number">1</span> ||n==<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibon(n<span class="number">-1</span>)+fibon(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fibon(<span class="number">12</span>));</span><br></pre></td></tr></table></figure><h3 id="26、回调函数"><a href="#26、回调函数" class="headerlink" title="26、回调函数"></a>26、回调函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;什么情况下需要使用回调函数呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;通常需要定义一种规则的时候就会使用回调函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;规则的传递只能通过函数来实现，不能通过变量来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">10</span>,<span class="number">5</span>,test1));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06、构造函数法自定义变量"><a href="#06、构造函数法自定义变量" class="headerlink" title="06、构造函数法自定义变量"></a>06、构造函数法自定义变量</h3><p>this<br>&nbsp;&nbsp;&nbsp;&nbsp;1、this只出现在函数中<br>&nbsp;&nbsp;&nbsp;&nbsp;2、谁调用函数，this指的就是谁<br>&nbsp;&nbsp;&nbsp;&nbsp;3、new People();    People中的this代指被创建的对象实例。<br>new<br>&nbsp;&nbsp;&nbsp;&nbsp;1、开辟内存空间，储存新创建的对象（new Object()）<br>&nbsp;&nbsp;&nbsp;&nbsp;2、把this设置成当前对象<br>&nbsp;&nbsp;&nbsp;&nbsp;3、执行内部代码，设置对象属性和方法<br>&nbsp;&nbsp;&nbsp;&nbsp;4、返回新创建的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name+<span class="string">"说：你好！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu= <span class="keyword">new</span> Student(<span class="string">"李志"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu);</span><br><span class="line"><span class="built_in">console</span>.log(stu.name);</span><br><span class="line">stu.sayHi();</span><br></pre></td></tr></table></figure><h3 id="07、对象的属性绑定"><a href="#07、对象的属性绑定" class="headerlink" title="07、对象的属性绑定"></a>07、对象的属性绑定</h3><p>第一种方法：对象+.+属性名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu= <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">stu.name =<span class="string">"李志"</span>;</span><br></pre></td></tr></table></figure><p>第二种方法：对象+[数值]  对象+[字符串]  对象+[变量]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aaa=<span class="string">"age"</span>;</span><br><span class="line">stu[aaa]=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stu);</span><br></pre></td></tr></table></figure><h3 id="08、进制转换"><a href="#08、进制转换" class="headerlink" title="08、进制转换"></a>08、进制转换</h3><p>任意进制转换成十进制<br><code>console.log(parseInt(111,2));</code><br>十进制转换成任意进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="09、对象字面量"><a href="#09、对象字面量" class="headerlink" title="09、对象字面量"></a>09、对象字面量</h3><p>对象的字面量就是一个大括号。而里面的属性和方法是以冒号（:）形式对应表现的。（键值对）key:value,<br>还是object，但是省去了object。类似于在控制台看到的那种状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 =&#123;<span class="attr">aaa</span>:obj1,<span class="attr">name</span>:<span class="string">"张三"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="attr">sayHi</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name+<span class="string">"说：大家好！"</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="10、JSON（javascript-object-notation）—js的对象表现形式"><a href="#10、JSON（javascript-object-notation）—js的对象表现形式" class="headerlink" title="10、JSON（javascript object notation）—js的对象表现形式"></a>10、JSON（javascript object notation）—js的对象表现形式</h3><p>JSON和对象字面量的区别<br>JSON的属性必须用双引号引起来，对象字面量可以省略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json=&#123;<span class="string">"name"</span>:<span class="string">"mijac"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"arr"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="comment">//对象本身没有Length，所以不能用for循环遍历</span></span><br><span class="line"><span class="comment">// console.log(json.length);  //这里的显示结果为undefined.数组有长度，json没有长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;json.length;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(json[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、用for（in）完成对JSON的遍历"><a href="#11、用for（in）完成对JSON的遍历" class="headerlink" title="11、用for（in）完成对JSON的遍历"></a>11、用for（in）完成对JSON的遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json=&#123;<span class="string">"name"</span>:<span class="string">"mijac"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"arr"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> json) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k);</span><br><span class="line">  <span class="built_in">console</span>.log(json[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将10-100放进json中</span></span><br><span class="line"><span class="keyword">var</span> json=&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++ ) &#123;</span><br><span class="line">  json[i] =i*<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(json);</span><br></pre></td></tr></table></figure><h3 id="13、简单和复杂数据类型存储和传递问题-简单数据类型传值，复杂数据类型传址"><a href="#13、简单和复杂数据类型存储和传递问题-简单数据类型传值，复杂数据类型传址" class="headerlink" title="13、简单和复杂数据类型存储和传递问题(简单数据类型传值，复杂数据类型传址)"></a>13、简单和复杂数据类型存储和传递问题(简单数据类型传值，复杂数据类型传址)</h3><p>参数赋值的时候，简单数据类型传数值<br>参数赋值的时候，复杂数据类型传地址（修改的是同一片内存空间）<br>注意：当你想修改成员变量中的简单数据类型时，不要通过参数传递，要在函数中直接修改。</p><h3 id="14、内置对象"><a href="#14、内置对象" class="headerlink" title="14、内置对象"></a>14、内置对象</h3><p>内置对象：js本身已经帮我们写好的对象.我们创建出来以后，直接使用就可以，不用定义了。<br>&nbsp;&nbsp;&nbsp;&nbsp;例如：Date,Array,Math,RegExp(正则表达式),Error,String…<br>学习内置对象，主要学习API。(application programming interface应用程序接口)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的两种定义方法</span></span><br><span class="line"><span class="keyword">var</span> arr1 =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 =<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);   <span class="comment">//如果只有一个值，那就是length属性的值</span></span><br><span class="line"><span class="comment">//检测数组</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1 <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line"><span class="comment">// instanceof还能instanceof string。但是必须是new出来的string对象。简单数据类型里面string不行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr1));</span><br><span class="line"><span class="comment">//把数组转换成字符串（toString）</span></span><br><span class="line"><span class="comment">//join方法把数组用特殊字符链接起来。默认转换成字符串，没有变量，默认用逗号隔开。无缝链接要用空字符串。</span></span><br></pre></td></tr></table></figure><h3 id="15、伪数组，以arguments为代表"><a href="#15、伪数组，以arguments为代表" class="headerlink" title="15、伪数组，以arguments为代表"></a>15、伪数组，以arguments为代表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//可以修改元素</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//不是数组类型</span></span><br><span class="line">  <span class="built_in">console</span>.log(fn.length); <span class="comment">//形参个数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">//实参个数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee); <span class="comment">//整个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16、数组的添加和删除-push-pop和shift-unshift"><a href="#16、数组的添加和删除-push-pop和shift-unshift" class="headerlink" title="16、数组的添加和删除(push/pop和shift/unshift)"></a>16、数组的添加和删除(push/pop和shift/unshift)</h3><p>push（增加）和pop（减少）都是栈操作。增加和减少都是最后一个。增加返回的是新数组的长度，减少时返回减少的值。<br>shift（增加）和unshift（减少）都是队列操作。增加和减少都是第一个。增加返回的是新数组的长度，减少时返回减少的值。</p><h3 id="17、数组的翻转和排序-reverse-sort"><a href="#17、数组的翻转和排序-reverse-sort" class="headerlink" title="17、数组的翻转和排序(reverse/sort)"></a>17、数组的翻转和排序(reverse/sort)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组翻转</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> arr1=arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">//数组排序</span></span><br><span class="line"><span class="keyword">var</span> arr2=arr.sort();  <span class="comment">//能对数字和字母进行排序，但是只按照第一位数字。解决方法：通过回调函数。</span></span><br><span class="line"><span class="comment">//回调函数解决（包括底层解决，只不过sort本身是比较？unicode编码？的）</span></span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="number">7</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> aaa = sort(arr2,<span class="function"><span class="keyword">function</span> <span class="title">bubble</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr,bubble</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++) &#123;</span><br><span class="line">    <span class="comment">// var flag=1;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bubble(arr[j],arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        <span class="comment">// flag=0;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag===<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;   <span class="comment">//因为要在for循环之外retur arr，所以在这里输出是不合适的。但是没时间研究这个放在哪里。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aaa);</span><br></pre></td></tr></table></figure><h3 id="18、数组的链接、截取和替换-concat-slice-splice"><a href="#18、数组的链接、截取和替换-concat-slice-splice" class="headerlink" title="18、数组的链接、截取和替换(concat/slice/splice)"></a>18、数组的链接、截取和替换(concat/slice/splice)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链接用concat方法 var arr3=arr1.concat(arr2);</span></span><br><span class="line"><span class="comment">// 截取用slice</span></span><br><span class="line"><span class="keyword">var</span> arr3=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</span><br><span class="line"><span class="comment">// var arr4=arr3.slice(2); //去除从0开始的2个数，并返回剩下的值</span></span><br><span class="line"><span class="comment">// var arr4=arr3.slice(-2); //截取从末尾开始的2个数，并返回这两个数</span></span><br><span class="line"><span class="comment">// var arr4=arr3.slice(4,2); //返回一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr4=arr3.slice(<span class="number">2</span>,<span class="number">4</span>);  <span class="comment">//索引值包左不包右</span></span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br><span class="line"><span class="comment">// 截取（和slice一样）和替换用splice。（a,b,arr）第三个参数就是用arr去替换指定索引值的。</span></span><br><span class="line"><span class="comment">// index和lastrindex分别是从前往后和从后往前查元素的索引值，找到立刻返回，没有的话返回值是-1</span></span><br></pre></td></tr></table></figure><h3 id="20、数组的API遍历（every-some-filter-foreach-map）"><a href="#20、数组的API遍历（every-some-filter-foreach-map）" class="headerlink" title="20、数组的API遍历（every/some/filter/foreach/map）"></a>20、数组的API遍历（every/some/filter/foreach/map）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// every和some有点类似。类似于且（&amp;&amp;）和或（||）的关系。他们的返回值类型都是布尔类型</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">"关羽"</span>,<span class="string">"张飞"</span>,<span class="string">"赵子龙"</span>,<span class="string">"刘备"</span>,<span class="string">"阿童木"</span>];</span><br><span class="line"><span class="keyword">var</span> bool=arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">ele,index,array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// arr[index] ="aaa";</span></span><br><span class="line">  <span class="comment">// console.log(array);</span></span><br><span class="line">  <span class="keyword">if</span> (array.length&gt;<span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bool);</span><br><span class="line"><span class="comment">// filter和他的名字一样，是一个过滤器。返回的是值为true的元素组成的新数组。</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">"关羽"</span>,<span class="string">"张飞"</span>,<span class="string">"赵子龙"</span>,<span class="string">"刘备"</span>,<span class="string">"阿童木"</span>];</span><br><span class="line"><span class="keyword">var</span> arr1=arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">ele,index,array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ele.length&gt;<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">//foreach没有返回值，纯粹用来操作数组。例如添加数组元素进入字符串</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">"关羽"</span>,<span class="string">"张飞"</span>,<span class="string">"赵子龙"</span>,<span class="string">"刘备"</span>,<span class="string">"阿童木"</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele,index,array</span>) </span>&#123;</span><br><span class="line">  str +=ele;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">//map之前复习过，类似于智障版的join。有返回值，返回什么都加入到新数组中。</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">"关羽"</span>,<span class="string">"张飞"</span>,<span class="string">"赵子龙"</span>,<span class="string">"刘备"</span>,<span class="string">"阿童木"</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">ele,index,array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ele+<span class="string">"nihao"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></table></figure><h3 id="21、清空数组"><a href="#21、清空数组" class="headerlink" title="21、清空数组"></a>21、清空数组</h3><p>第一种方法，用splice(0)或者splice(0,arr.length)。道理是一样的<br>第二种方法，arr.length=0;但是伪数组(arguments)不能用<br>第三种方法，开辟新空间。var arr=[];或者var arr=new Array();</p><h3 id="22、数组API案例"><a href="#22、数组API案例" class="headerlink" title="22、数组API案例"></a>22、数组API案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">"张飞"</span>,<span class="string">"刘备"</span>,<span class="string">"宋江"</span>,<span class="string">"阮小七"</span>,<span class="string">"马汉"</span>];</span><br><span class="line"><span class="comment">//需求：两种方法数组用|分割</span></span><br><span class="line"><span class="comment">//第一种，用for</span></span><br><span class="line"><span class="keyword">var</span> str=arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> separator =<span class="string">"|"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">  str += separator +arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">//第二种，用API(join)---因为返回值是字符串，所以可以用</span></span><br><span class="line"><span class="keyword">var</span> arr1=arr.join(<span class="string">"|"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// 需求：翻转数组（reverse以及reverse的底层实现）</span></span><br><span class="line"><span class="keyword">var</span> arr2=arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="comment">//实际底层实现，因为reverse实际修改了原数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse1</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array.length/<span class="number">2</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp=array[i];</span><br><span class="line">    array[i] =array[array.length<span class="number">-1</span>-i];</span><br><span class="line">    array[array.length<span class="number">-1</span>-i] =temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一种底层实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse2</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr=[];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=arr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    newArr[newArr.length] =array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需求：找到数组中每个字母出现的次数["c","a","z","a","a"]</span></span><br><span class="line"><span class="comment">// 复习属性绑定</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"aaa"</span>;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.str=<span class="string">"bbb"</span>;    <span class="comment">//直接将.后面的内容作为属性值。所以是str:"bbb";</span></span><br><span class="line">obj[str]=<span class="string">"ccc"</span>;   <span class="comment">//中括号里面的默认是变量，他会去找变量。所以是aaa:"ccc";</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// ★★★这里在写代码的时候还是没有理解和记忆json[属性]的用法。</span></span><br><span class="line"><span class="comment">// 一个是中括号，二个是中括号里面的内容，三是json[属性]整个表达的意思没弄懂。</span></span><br><span class="line"><span class="keyword">var</span> letter=[<span class="string">"c"</span>,<span class="string">"a"</span>,<span class="string">"z"</span>,<span class="string">"a"</span>,<span class="string">"a"</span>];</span><br><span class="line"><span class="keyword">var</span> json=&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;letter.length;i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> k=letter[i];</span><br><span class="line">  <span class="keyword">if</span> (json[k] !==<span class="literal">undefined</span>) &#123;</span><br><span class="line">    json[k] +=<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    json[k] =<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(json);</span><br><span class="line"><span class="comment">//需求：工资数组[1500,1200,2000,2100,1800]。超过2000的删除</span></span><br><span class="line"><span class="keyword">var</span> money=[<span class="number">1500</span>,<span class="number">1200</span>,<span class="number">2000</span>,<span class="number">2100</span>,<span class="number">1800</span>];</span><br><span class="line"><span class="keyword">var</span> littleMoney=money.filter(<span class="function"><span class="keyword">function</span> (<span class="params">ele,index,array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ele&lt;<span class="number">2000</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(money);</span><br><span class="line"><span class="built_in">console</span>.log(littleMoney);</span><br><span class="line"><span class="comment">//需求：编写一个方法，去掉数组中的重复元素</span></span><br><span class="line"><span class="comment">//这个案例还是需要重新写一遍</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr=[];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;newArr.length;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newArr[j]==array[i]) &#123;</span><br><span class="line">          flag=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag===<span class="number">1</span>) &#123;</span><br><span class="line">      newArr[newArr.length] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(arr));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;03变量交换&quot;&gt;&lt;a href=&quot;#03变量交换&quot; class=&quot;headerlink&quot; title=&quot;03变量交换&quot;&gt;&lt;/a&gt;03变量交换&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1、运算符的优先级问题&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一是是括号&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;二是一元运算符（-,!,++,–）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;三是二元运算符（+,-,&lt;em&gt;,/）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;四是一级逻辑运算符（&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;五是二级逻辑运算符（==,===,!==,!===）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;六是三级逻辑运算符（&amp;amp;&amp;amp;优先于||）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;七是三元运算符（?）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;八是赋值运算符（=,+=,-=,&lt;/em&gt;=,/=,%=）
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="note" scheme="https://jambo0624.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>vue路由懒加载</title>
    <link href="https://jambo0624.github.io/2020-03-15-vue-router-lazyload.html"/>
    <id>https://jambo0624.github.io/2020-03-15-vue-router-lazyload.html</id>
    <published>2020-03-15T15:51:45.000Z</published>
    <updated>2020-03-16T01:52:05.014Z</updated>
    
    <content type="html"><![CDATA[<p>vue路由懒加载<br>&nbsp;&nbsp;&nbsp;&nbsp;路由懒加载能够提高页面的加载速度，不过使用也得看场合。有时候需要懒加载，提升首页加载速度，一般是页面层级较为复杂的时候。大家看一下不加代码分割浏览器加载的文件。</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">manifest</span><span class="selector-class">.xxxxx</span><span class="selector-class">.js</span></span><br><span class="line"><span class="selector-tag">vendor</span><span class="selector-class">.xxxxx</span><span class="selector-class">.js</span></span><br><span class="line"><span class="selector-tag">app</span><span class="selector-class">.xxxxx</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这里前两项是webpack自动分割出来的，当修改业务js时候manifest和vendor是不会改变的，浏览器直接在缓存中提取。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;会变的是app.js。如果不采用路由分割会是什么效果呢。所有的代码都打包到app.js中，如果项目巨大，那么首页加载会是灾难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;那么vue的官方脚手架采用的是webpack打包的一套配置，那么要理解路由懒加载就要从webpack的代码分割的打包模式说起啦。</p><ul><li><p>webpack代码分割<br>&nbsp;&nbsp;&nbsp;&nbsp;webpack 可以帮助我们将代码分成不同的逻辑块，在需要的时候加载这些代码。使用 require.ensure() 来拆分代码<br>&nbsp;&nbsp;&nbsp;&nbsp;require.ensure() 是一种使用 CommonJS 的形式来异步加载模块的策略。在代码中通过 <code>require.ensure([&lt;fileurl&gt;])</code>引用模块<code>require.ensure(dependencies: String[], callback: function(require), chunkName: String)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;第一个参数指定依赖的模块，第二个参数是一个函数，在这个函数里面你可以使用 require 来加载其他的模块，webpack 会收集 ensure 中的依赖，将其打包在一个单独的文件中，在后续用到的时候使用 jsonp 异步地加载进去。</p></li><li><p>js懒加载<br>直接上代代码吧，看着直接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'./a'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">require</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">  <span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上代码，a 和 b 会被打包在一起，在代码中执行到这段代码的时候，会异步地去加载，加载完成后执行函数里面的逻辑。<br>&nbsp;&nbsp;&nbsp;&nbsp;那就是说a和b合并成一个文件，代码走到这里的时候才会去下载这个文件。当然这里是不是要加一个转圈呢啥的，毕竟是异步加载嘛。</p></li><li><p>webpack代码分割<br>&nbsp;&nbsp;&nbsp;&nbsp;还记得webpack中的chunkFilename吗？不知道没关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: utils.assetsPath(<span class="string">'js/[name].[chunkhash].js'</span>),</span><br><span class="line">    chunkFilename: utils.assetsPath(<span class="string">'js/[id].[chunkhash].js'</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>扣了一小段代码。这个是vue脚手架里面的。在<code>build/webpack.prod.conf.js</code>文件中，这个是走<code>npm run build</code>才会进来的。<br>那怎么配合chunkFilename做代码分割呢。上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'./c'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">require</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;,<span class="string">'d'</span>);</span><br><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'./c'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">require</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;,<span class="string">'d'</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;简单介绍下以上代码，这儿‘d’就是最终打包成的chunkFilename 中的name。<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>chunkFilename: utils.assetsPath(&#39;js/[name].[chunkhash].js&#39;)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;name最终a，b，c会被打包到一个叫d.hash.js的文件中去。</p></li><li><p>讲讲vue路由懒加载<br>直接上代码啦。代码结构是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tvProgram = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/page/tvProgram'</span>], resolve);</span><br><span class="line"><span class="keyword">const</span> game = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/page/gameIndex'</span>], resolve);</span><br><span class="line"><span class="keyword">const</span> gameItem = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/page/gameItem'</span>], resolve);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;熟不熟悉。这里采用的是AMD模式。那这里没有指定chunkFileName啊，其实不用担心。<code>chunkFilename:utils.assetsPath(&#39;js/[id].[chunkhash].js&#39;)</code><br>这里用的是id。这是最简单的写法啦。<br>首页是这样的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">manifest</span><span class="selector-class">.xxxxx</span><span class="selector-class">.js</span></span><br><span class="line"><span class="selector-tag">vendor</span><span class="selector-class">.xxxxx</span><span class="selector-class">.js</span></span><br><span class="line"><span class="selector-tag">app</span><span class="selector-class">.xxxxx</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p>然后第二个界面是这样的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1<span class="selector-class">.xxxxx</span><span class="selector-class">.js</span></span><br><span class="line">0<span class="selector-class">.xxxxx</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;那么问题来了什么是 require.ensure什么是require([],function)</p></li><li><p>require-ensure和require-amd的区别：<br>require-amd<br>&nbsp;&nbsp;&nbsp;&nbsp;说明: 同AMD规范的require函数，使用时传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数<br>&nbsp;&nbsp;&nbsp;&nbsp;语法: <code>require(dependencies: String[], [callback: function(...)])</code><br>&nbsp;&nbsp;&nbsp;&nbsp;参数<br>&nbsp;&nbsp;&nbsp;&nbsp;dependencies: 模块依赖数组<br>&nbsp;&nbsp;&nbsp;&nbsp;callback: 回调函数</p></li></ul><p>require-ensure<br>&nbsp;&nbsp;&nbsp;&nbsp;说明: require.ensure在需要的时候才下载依赖的模块，当参数指定的模块都下载下来了（下载下来的模块还没执行），便执行参数指定的回调函数。require.ensure会创建一个chunk，且可以指定该chunk的名称，如果这个chunk名已经存在了，则将本次依赖的模块合并到已经存在的chunk中，最后这个chunk在webpack构建的时候会单独生成一个文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;语法: require.ensure(dependencies: String[], callback: function([require]), [chunkName: String])<br>&nbsp;&nbsp;&nbsp;&nbsp;dependencies: 依赖的模块数组<br>&nbsp;&nbsp;&nbsp;&nbsp;callback: 回调函数，该函数调用时会传一个require参数<br>&nbsp;&nbsp;&nbsp;&nbsp;chunkName: 模块名，用于构建时生成文件时命名使用<br>&nbsp;&nbsp;&nbsp;&nbsp;注意点：require.ensure的模块只会被下载下来，不会被执行，只有在回调函数使用require(模块名)后，这个模块才会被执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue路由懒加载&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;路由懒加载能够提高页面的加载速度，不过使用也得看场合。有时候需要懒加载，提升首页加载速度，一般是页面层级较为复杂的时候。大家看一下不加代码分割浏览器加载的文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://jambo0624.github.io/categories/vue/"/>
    
    
      <category term="vue-router" scheme="https://jambo0624.github.io/tags/vue-router/"/>
    
      <category term="lazyload" scheme="https://jambo0624.github.io/tags/lazyload/"/>
    
  </entry>
  
  <entry>
    <title>vue路由的hash和history模式</title>
    <link href="https://jambo0624.github.io/2020-03-15-vue-router-hash-history.html"/>
    <id>https://jambo0624.github.io/2020-03-15-vue-router-hash-history.html</id>
    <published>2020-03-15T15:48:15.000Z</published>
    <updated>2020-03-16T01:52:20.052Z</updated>
    
    <content type="html"><![CDATA[<p>vue-router两种模式:hash模式和history模式<br>为了构建SPA，vue引入了前端路由系统vue-router。<br>vue-route有两种模式：history模式和hash模式。</p><ol><li>hash模式（vue-router默认hash模式）<br>hash模式背后的原理是onhashchange事件。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hash=location.hash.slice(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.style.color=hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>&nbsp;&nbsp;&nbsp;&nbsp;（localtion是js里管理地址栏的内置对象，是window对象的一部分，可通过window.localtion访问)<br>&nbsp;&nbsp;&nbsp;&nbsp;由于hash发生变化的url都会被浏览器记录下来，使得浏览器的前进后退都可以使用了，尽管浏览器没有亲求服务器，但是页面状态和url关联起来。后来人们称其为前端路由，成为单页应用标配。<br>比如<code>http://www.abc.com/#/index</code>，hash值为#/index。hash模式的特点在于hash出现在url中，但是不会被包括在HTTP请求中，对后端没有影响，不会重新加载页面。</li><li>history模式<br>&nbsp;&nbsp;&nbsp;&nbsp;history模式利用了<code>HTML5 History Interface</code>中新增的<code>pushState()</code>和<code>replaceState()</code>方法。MDN相关介绍（需要特定浏览器支持）。这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。<br>&nbsp;&nbsp;&nbsp;&nbsp;当使用history模式时，url就像正常的url,例如<code>http://abc.com/user/id</code>相比hash模式更加好看。特别注意，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。<br>&nbsp;&nbsp;&nbsp;&nbsp;通过history api，我们丢弃了丑陋的#，但是有一个缺点，当刷新时，如果服务器中没有相应的相应或者资源，会分分钟刷出一个404来（刷新需要请求服务器）。所以history模式不怕前进，不怕后退，就怕刷新。</li><li>hash模式和history模式对比<br>&nbsp;&nbsp;&nbsp;&nbsp;pushState()设置新的url可以是和当前url<strong>同源的任意url;hash只可修改#后面的部分，只能设置当前url同文档</strong>的url。<br>&nbsp;&nbsp;&nbsp;&nbsp;pushState()设置的新url可与当前url一致，这样也会把记录添加到栈中；hash必须设置与当前url不同的url的，才会触发动作将记录添加到栈中。<br>&nbsp;&nbsp;&nbsp;&nbsp;pushState()通过stateObject参数可以添加任意类型的数据到记录中；hash只可添加短字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;pushState()可额外设置title属性供后续使用。<br>不过，hash模式也有比history模式优势的地方。<br>&nbsp;&nbsp;&nbsp;&nbsp;hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误。<br>&nbsp;&nbsp;&nbsp;&nbsp;history模式下，前端的url必须和实际向后端发起请求的url一致，如<code>http://abc.com/user/id</code>,后端如果没有对user/id的路由处理，将返回404错误。</li><li>应用场景<br>&nbsp;&nbsp;&nbsp;&nbsp;对于一般的Vue+Vue-router+Webpack+XXX形式1的Web开发场景，用history模式即可，后端用Apach或Nginx进行路由的简单配置，同时搭配前端路由的404页面支持。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue-router两种模式:hash模式和history模式&lt;br&gt;为了构建SPA，vue引入了前端路由系统vue-router。&lt;br&gt;vue-route有两种模式：history模式和hash模式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;hash模式（vue-router默认hash模式）&lt;br&gt;hash模式背后的原理是onhashchange事件。&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.onhashchange=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; hash=location.hash.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.body.style.color=hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://jambo0624.github.io/categories/vue/"/>
    
    
      <category term="vue-router" scheme="https://jambo0624.github.io/tags/vue-router/"/>
    
      <category term="hash" scheme="https://jambo0624.github.io/tags/hash/"/>
    
      <category term="history" scheme="https://jambo0624.github.io/tags/history/"/>
    
  </entry>
  
  <entry>
    <title>vim命令</title>
    <link href="https://jambo0624.github.io/2020-03-14-vim-command.html"/>
    <id>https://jambo0624.github.io/2020-03-14-vim-command.html</id>
    <published>2020-03-14T04:52:51.000Z</published>
    <updated>2020-03-14T05:06:22.389Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">Vim命令合集</a><br>退出方式</p><blockquote><p>:w 保存文件但不退出vi<br>:w file 将修改另外保存到file中，不退出vi<br>:w! 强制保存，不推出vi<br>:wq 保存文件并退出vi<br>:wq! 强制保存文件，并退出vi<br>q: 不保存文件，退出vi<br>:q! 不保存文件，强制退出vi<br>:e! 放弃所有修改，从上次保存文件开始再编辑</p></blockquote><a id="more"></a><p>命令历史</p><blockquote><p>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。<br>文件命令<br>打开单个文件  vim file<br>同时打开多个文件 vim file1 file2 file3 …<br>在vim窗口中打开一个新文件   :open file<br>在新窗口中打开文件  :split file<br>切换到下一个文件 :bn<br>切换到上一个文件 :bp<br>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来&nbsp;&nbsp;&nbsp;&nbsp;:args<br>打开远程文件，比如ftp或者share folder<br>&nbsp;&nbsp;&nbsp;&nbsp;:e <a href="ftp://192.168.10.76/abc.txt" target="_blank" rel="noopener">ftp://192.168.10.76/abc.txt</a><br>&nbsp;&nbsp;&nbsp;&nbsp;:e \qadrive\test\1.txt<br>vim的模式<br>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空<br>插入模式（按i键进入） 左下角显示–INSERT–<br>可视模式（不知道如何进入） 左下角显示–VISUAL–<br>导航命令<br>% 括号匹配<br>插入命令<br>i 在当前位置生前插入<br>I 在当前行首插入<br>a 在当前位置后插入<br>A 在当前行尾插入<br>o 在当前行之后插入一行<br>O 在当前行之前插入一行<br>查找命令<br>/text　　查找text，按n健查找下一个，按N健查找前一个。<br>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。<br>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$<br>:set ignorecase　　忽略大小写的查找<br>:set noignorecase　　不忽略大小写的查找<br>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。<br>:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。<br>:set nohlsearch　　关闭高亮搜索显示<br>:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。<br>:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。<br>:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。<br>替换命令<br>ra 将当前字符替换为a，当期字符即光标所在字符。<br>s/old/new/ 用old替换new，替换当前行的第一个匹配<br>s/old/new/g 用old替换new，替换当前行的所有匹配<br>%s/old/new/ 用old替换new，替换所有行的第一个匹配<br>%s/old/new/g 用old替换new，替换整个文件的所有匹配<br>:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。<br>ddp 交换光标所在行和其下紧邻的一行。<br>移动命令<br>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符</p></blockquote><p>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<Esc>，这里的Esc是必须的，否则命令不生效。</p><blockquote><p>w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。<br>b 向后移动一个单词 2b 向后移动2个单词<br>e，同w，只不过是光标停在单词尾部<br>ge，同b，光标停在单词尾部。<br>^ 移动到本行第一个非空白字符上。<br>0（数字0）移动到本行第一个字符上，<br><HOME> 移动到本行第一个字符。同0健。<br>$ 移动到行尾 3$ 移动到下面3行的行尾<br>gg 移动到文件头。 = [[<br>G（shift + g） 移动到文件尾。 = ]]<br>f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。<br>F 同f，反向查找。<br>跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。<br>Ctrl + e 向下滚动一行<br>Ctrl + y 向上滚动一行<br>Ctrl + d 向下滚动半屏<br>Ctrl + u 向上滚动半屏<br>Ctrl + f 向下滚动一屏<br>Ctrl + b 向上滚动一屏<br>撤销和重做<br>u 撤销（Undo）<br>U 撤销对整行的操作<br>Ctrl + r 重做（Redo），即撤销的撤销。<br>删除命令<br>x 删除当前字符<br>3x 删除当前光标开始向后三个字符<br>X 删除当前字符的前一个字符。X=dh<br>dl 删除当前字符， dl=x<br>dh 删除前一个字符<br>dd 删除当前行<br>dj 删除上一行<br>dk 删除下一行<br>10d 删除当前行开始的10行。<br>D 删除当前字符至行尾。D=d$<br>d$ 删除当前字符之后的所有字符（本行）<br>kdgg 删除当前行之前所有行（不包括当前行）<br>jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）<br>:1,10d 删除1-10行<br>:11,$d 删除11行及以后所有的行<br>:1,$d 删除所有行<br>J(shift + j)　　删除两行之间的空行，实际上是合并两行。<br>拷贝和粘贴<br>yy 拷贝当前行<br>nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。<br>p  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。<br>shift+p 在当前行前粘贴<br>:1,10 co 20 将1-10行插入到第20行之后。<br>:1,$ co $ 将整个文件复制一份并添加到文件尾部。<br>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制<br>ddp交换当前行和其下一行<br>xp交换当前字符和其后一个字符<br>剪切命令<br>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切<br>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴<br>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。<br>:1, 10 m 20 将第1-10行移动到第20行之后。<br>退出命令<br>:wq 保存并退出<br>ZZ 保存并退出<br>:q! 强制退出并忽略所有更改<br>:e! 放弃所有修改，并打开原来文件。<br>窗口命令<br>:split或new 打开一个新窗口，光标停在顶层的窗口上<br>:split file或:new file 用新窗口打开文件<br>split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。<br>Ctrl+ww 移动到下一个窗口<br>Ctrl+wj 移动到下方的窗口<br>Ctrl+wk 移动到上方的窗口<br>关闭窗口<br>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。<br>:q 如果是最后一个被关闭的窗口，那么将退出vim。<br>ZZ 保存并退出。<br>关闭所有窗口，只保留当前窗口 :only<br>录制宏<br>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。<br>执行shell命令<br>:!command<br>:!ls 列出当前目录下文件<br>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。<br>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。<br>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。<br>注释命令<br>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#<br>3,5 s/^/#/g 注释第3-5行<br>3,5 s/^#//g 解除3-5行的注释<br>1,$ s/^/#/g 注释整个文档。<br>:%s/^/#/g 注释整个文档，此法更快。<br>帮助命令<br>:help or F1 显示整个帮助<br>:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。<br>:help ‘number’ Vim选项的帮助用单引号括起<br>:help <Esc> 特殊键的帮助用&lt;&gt;扩起<br>:help -t Vim启动参数的帮助用-<br>：help i_<Esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回<br>其他非编辑命令<br>. 重复前一次命令<br>:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看<br>:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。<br>:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。<br>Vim教程<br>在Unix系统上<br>$ vimtutor<br>在Windows系统上<br>:help tutor</p></blockquote><blockquote><p>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vim命令合集&lt;/a&gt;&lt;br&gt;退出方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;:w 保存文件但不退出vi&lt;br&gt;:w file 将修改另外保存到file中，不退出vi&lt;br&gt;:w! 强制保存，不推出vi&lt;br&gt;:wq 保存文件并退出vi&lt;br&gt;:wq! 强制保存文件，并退出vi&lt;br&gt;q: 不保存文件，退出vi&lt;br&gt;:q! 不保存文件，强制退出vi&lt;br&gt;:e! 放弃所有修改，从上次保存文件开始再编辑&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/categories/vim/"/>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/tags/vim/"/>
    
      <category term="command" scheme="https://jambo0624.github.io/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>vimtutor教程</title>
    <link href="https://jambo0624.github.io/2020-03-14-vimtutor.html"/>
    <id>https://jambo0624.github.io/2020-03-14-vimtutor.html</id>
    <published>2020-03-14T03:13:38.000Z</published>
    <updated>2020-03-14T05:06:54.973Z</updated>
    
    <content type="html"><![CDATA[<p>vim 是一个具有很多命令的功能非常强大的编辑器。限于篇幅，在本教程当中就不详细介绍了。本教程的设计目标是讲述一些必要的基本命令，而掌握好这些命令，您就能够很容易将vim当作一个通用的万能编辑器来使用了。<br>完成本教程的内容大约需要25-30分钟，取决于您训练的时间。<br>每一节的命令操作将会更改本文。推荐您复制本文的一个副本，然后在副本上进行训练(如果您是通过”vimtutor”来启动教程的，那么本文就已经是副本了)。<br>切记一点∶本教程的设计思路是在使用中进行学习的。也就是说，您需要通过执行命令来学习它们本身的正确用法。如果您只是阅读而不操作，那么您可能会很快遗忘这些命令的！<br>好了，现在请确定您的Shift-Lock(大小写锁定键)还没有按下，然后按键盘上的字母键 j 足够多的次数来移动光标，直到第一节的内容能够完全充满屏幕。</p><a id="more"></a><h2 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h2><h3 id="第一节∶移动光标"><a href="#第一节∶移动光标" class="headerlink" title="第一节∶移动光标"></a>第一节∶移动光标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  ※※ 要移动光标，请依照说明分别按下 h、j、k、l 键。 ※※</span><br><span class="line"></span><br><span class="line">      ^</span><br><span class="line">      k      提示∶ h 的键位于左边，每次按下就会向左移动。</span><br><span class="line"> &lt; h     l &gt;      l 的键位于右边，每次按下就会向右移动。</span><br><span class="line">      j           j 键看起来很象一支尖端方向朝下的箭头。</span><br><span class="line">      v</span><br><span class="line"></span><br><span class="line">  1\. 请随意在屏幕内移动光标，直至您觉得舒服为止。</span><br><span class="line"></span><br><span class="line">  2\. 按下下行键(j)，直到出现光标重复下行。     ---&gt; 现在您应该已经学会如何移动到下一讲吧。</span><br><span class="line"></span><br><span class="line">  3\. 现在请使用下行键，将光标移动到第二讲。</span><br><span class="line"></span><br><span class="line">提示∶如果您不敢确定您所按下的字母，请按下&lt;ESC&gt;键回到正常(Normal)模式。</span><br><span class="line">      然后再次从键盘输入您想要的命令。</span><br><span class="line"></span><br><span class="line">提示∶光标键应当也能正常工作的。但是使用hjkl键，在习惯之后您就能够快速</span><br><span class="line">      地在屏幕内四处移动光标了。</span><br></pre></td></tr></table></figure><h3 id="第二节∶VIM的进入和退出"><a href="#第二节∶VIM的进入和退出" class="headerlink" title="第二节∶VIM的进入和退出"></a>第二节∶VIM的进入和退出</h3><p>!! 特别提示∶敬请阅读完整本一节的内容，然后才能执行以下所讲解的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 请按&lt;ESC&gt;键(这是为了确保您处在正常模式)。</span><br><span class="line"></span><br><span class="line">2. 然后输入∶ :q! &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">---&gt; 这种方式的退出编辑器绝不会保存您进入编辑器以来所做的改动。</span><br><span class="line">如果您想保存更改再退出，请输入∶</span><br><span class="line">:wq &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">3. 如果您看到了命令行提示符，请输入能够带您回到本教程的命令，那就是∶</span><br><span class="line"></span><br><span class="line">vimtutor &lt;回车&gt;</span><br><span class="line"></span><br><span class="line"> 通常情况下您也可以用这种方式∶</span><br><span class="line">vim tutor &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">---&gt; 这里的 &#39;vim&#39; 表示进入vim编辑器，而 &#39;tutor&#39;则是您准备要编辑的文件。</span><br><span class="line"></span><br><span class="line">4. 如果您自信已经牢牢记住了这些步骤的话，请从步骤1执行到步骤3退出，然后再次进入编辑器。接着将光标移动到第一讲第三节来继续我们的教程讲解。</span><br></pre></td></tr></table></figure><h3 id="第三节∶文本编辑之删除"><a href="#第三节∶文本编辑之删除" class="headerlink" title="第三节∶文本编辑之删除"></a>第三节∶文本编辑之删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  ** 在正常(Normal)模式下，可以按下 x 键来删除光标所在位置的字符。**</span><br><span class="line"></span><br><span class="line">  1\. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line"></span><br><span class="line">  2\. 为了修正输入错误，请将光标移至准备删除的字符的位置处。</span><br><span class="line"></span><br><span class="line">  3\. 然后按下 x 键将错误字符删除掉。</span><br><span class="line"></span><br><span class="line">  4\. 重复步骤2到步骤4，直到句子修正为止。</span><br><span class="line"></span><br><span class="line">---&gt; The ccow jumpedd ovverr thhe mooon.</span><br><span class="line"></span><br><span class="line">  5\. 好了，该行已经修正了，下一节内容是第一讲第四节。</span><br><span class="line"></span><br><span class="line">特别提示∶在您浏览本教程时，不要强行记忆。记住一点∶在使用中学习。</span><br></pre></td></tr></table></figure><h3 id="第四节∶文本编辑之插入"><a href="#第四节∶文本编辑之插入" class="headerlink" title="第四节∶文本编辑之插入"></a>第四节∶文本编辑之插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">** 在正常模式下，可以按下 i 键来插入文本。**</span><br><span class="line"></span><br><span class="line">1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span><br><span class="line"></span><br><span class="line">2. 为了使得第一行内容雷同于第二行，请将光标移至文本第一个字符准备插入</span><br><span class="line">的位置。</span><br><span class="line"></span><br><span class="line">3. 然后按下 i 键，接着输入必要的文本字符。</span><br><span class="line"></span><br><span class="line">4. 所有文本都修正完毕，请按下 &lt;ESC&gt; 键返回正常模式。</span><br><span class="line">重复步骤2至步骤4以便修正句子。</span><br><span class="line"></span><br><span class="line">---&gt; There is text misng this .</span><br><span class="line">---&gt; There is some text missing from this line.</span><br><span class="line"></span><br><span class="line">5. 如果您对文本插入操作已经很满意，请接着阅读下面的小结。</span><br></pre></td></tr></table></figure><h3 id="第一讲小结"><a href="#第一讲小结" class="headerlink" title="第一讲小结"></a>第一讲小结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  1\. 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。</span><br><span class="line">    h (左移) j (下行)       k (上行)     l (右移)</span><br><span class="line"></span><br><span class="line">  2\. 欲进入vim编辑器(从命令行提示符)，请输入∶vim 文件名 &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">  3\. 欲退出vim编辑器，请输入以下命令放弃所有修改∶</span><br><span class="line"></span><br><span class="line">    &lt;ESC&gt;   :q!  &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">      或者输入以下命令保存所有修改∶</span><br><span class="line"></span><br><span class="line">    &lt;ESC&gt;   :wq  &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">  4\. 在正常模式下删除光标所在位置的字符，请按∶ x</span><br><span class="line"></span><br><span class="line">  5\. 在正常模式下要在光标所在位置开始插入文本，请按∶</span><br><span class="line"></span><br><span class="line">  i     输入必要文本 &lt;ESC&gt;</span><br><span class="line"></span><br><span class="line">特别提示∶按下 &lt;ESC&gt; 键会带您回到正常模式或者取消一个不期望或者部分完成的命令。</span><br></pre></td></tr></table></figure><p>好了，第一讲到此结束。下面接下来继续第二讲的内容。</p><h2 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h2><h3 id="第一节∶删除类命令"><a href="#第一节∶删除类命令" class="headerlink" title="第一节∶删除类命令"></a>第一节∶删除类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> ** 输入 dw 可以从光标处删除至一个单字&#x2F;单词的末尾。**</span><br><span class="line">1. 请按下 &lt;ESC&gt; 键确保您处于正常模式。</span><br><span class="line"></span><br><span class="line">2. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line"></span><br><span class="line">3. 请将光标移至准备要删除的单词的开始。</span><br><span class="line"></span><br><span class="line">4. 接着输入 dw 删除掉该单词。</span><br><span class="line"></span><br><span class="line">特别提示∶您所输入的 dw 会在您输入的同时出现在屏幕的最后一行。如果您输入有误，请按下 &lt;ESC&gt; 键取消，然后重新再来。</span><br><span class="line"></span><br><span class="line">---&gt; There are a some words fun that don&#39;t belong paper in this sentence.</span><br><span class="line"></span><br><span class="line">5. 重复步骤3至步骤4，直至句子修正完毕。接着继续第二讲第二节内容。</span><br></pre></td></tr></table></figure><h3 id="第二节∶其他删除类命令"><a href="#第二节∶其他删除类命令" class="headerlink" title="第二节∶其他删除类命令"></a>第二节∶其他删除类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ** 输入 d$ 从当前光标删除到行末。**</span><br><span class="line"></span><br><span class="line">  1\. 请按下 &lt;ESC&gt; 键确保您处于正常模式。</span><br><span class="line"></span><br><span class="line">  2\. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line"></span><br><span class="line">  3\. 请将光标移动到该行的尾部(也就是在第一个点号‘.’后面)。</span><br><span class="line"></span><br><span class="line">  4\. 然后输入 d$ 从光标处删至当前行尾部。</span><br><span class="line"></span><br><span class="line">---&gt; Somebody typed the end of this line twice. end of this line twice.</span><br><span class="line"></span><br><span class="line">  5\. 请继续学习第二讲第三节就知道是怎么回事了。</span><br></pre></td></tr></table></figure><h3 id="第三节∶关于命令和对象"><a href="#第三节∶关于命令和对象" class="headerlink" title="第三节∶关于命令和对象"></a>第三节∶关于命令和对象</h3><p>删除命令 d 的格式如下∶</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[number] d object 或者 d [number] object</span><br><span class="line"></span><br><span class="line">其意如下∶</span><br><span class="line">number - 代表执行命令的次数(可选项，缺省设置为 1 )。</span><br><span class="line">d - 代表删除。</span><br><span class="line">object - 代表命令所要操作的对象(下面有相关介绍)。</span><br><span class="line"></span><br><span class="line">一个简短的对象列表∶</span><br><span class="line">w - 从当前光标当前位置直到单字&#x2F;单词末尾，包括空格。</span><br><span class="line">e - 从当前光标当前位置直到单字&#x2F;单词末尾，但是 不 包括空格。</span><br><span class="line">$ - 从当前光标当前位置直到当前行末。</span><br><span class="line"></span><br><span class="line">特别提示∶</span><br><span class="line">对于勇于探索者，请在正常模式下面仅按代表相应对象的键而不使用命令，则将看到光标的移动正如上面的对象列表所代表的一样。</span><br></pre></td></tr></table></figure><h3 id="第四节∶对象命令的特殊情况"><a href="#第四节∶对象命令的特殊情况" class="headerlink" title="第四节∶对象命令的特殊情况"></a>第四节∶对象命令的特殊情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">** 输入 dd 可以删除整一个当前行。 **</span><br><span class="line"></span><br><span class="line">鉴于整行删除的高频度，VIM 的设计者决定要简化整行删除，仅需要在同一行上</span><br><span class="line">击打两次 d 就可以删除掉光标所在的整行了。</span><br><span class="line"></span><br><span class="line">1\. 请将光标移动到本节中下面的短句段落中的第二行。</span><br><span class="line">2\. 输入 dd 删除该行。</span><br><span class="line">3\. 然后移动到第四行。</span><br><span class="line">4\. 接着输入 2dd (还记得前面讲过的 number-command-object 吗？) 删除两行。</span><br><span class="line"></span><br><span class="line">    1)  Roses are red,</span><br><span class="line">    2)  Mud is fun,</span><br><span class="line">    3)  Violets are blue,</span><br><span class="line">    4)  I have a car,</span><br><span class="line">    5)  Clocks tell time,</span><br><span class="line">    6)  Sugar is sweet</span><br><span class="line">    7)  And so are you.</span><br></pre></td></tr></table></figure><h3 id="第五节∶撤消类命令"><a href="#第五节∶撤消类命令" class="headerlink" title="第五节∶撤消类命令"></a>第五节∶撤消类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">** 输入 u 来撤消最后执行的命令，输入 U 来修正整行。**</span><br><span class="line"></span><br><span class="line">1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行，并将其置于第一个错误处。</span><br><span class="line">2. 输入 x 删除第一个不想保留的字母。</span><br><span class="line">3. 然后输入 u 撤消最后执行的(一次)命令。</span><br><span class="line">4. 这次要使用 x 修正本行的所有错误。</span><br><span class="line">5. 现在输入一个大写的 U ，恢复到该行的原始状态。</span><br><span class="line">6. 接着多次输入 u 以撤消 U 以及更前的命令。</span><br><span class="line">7. 然后多次输入 CTRL-R (先按下 CTRL 键不放开，接着输入 R 键) ，这样就可以执行恢复命令，也就是撤消掉撤消命令。</span><br><span class="line"></span><br><span class="line">---&gt; Fiix the errors oon thhis line and reeplace them witth undo.</span><br><span class="line"></span><br><span class="line">8. 这些都是非常有用的命令。下面是第二讲的小结了。</span><br></pre></td></tr></table></figure><h3 id="第二讲小结"><a href="#第二讲小结" class="headerlink" title="第二讲小结"></a>第二讲小结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1\. 欲从当前光标删除至单字&#x2F;单词末尾，请输入∶dw</span><br><span class="line"></span><br><span class="line">2\. 欲从当前光标删除至当前行末尾，请输入∶d$</span><br><span class="line"></span><br><span class="line">3\. 欲删除整行，请输入∶dd</span><br><span class="line"></span><br><span class="line">4\. 在正常模式下一个命令的格式是∶</span><br><span class="line"></span><br><span class="line">     [number]   command   object     或者     command [number]   object</span><br><span class="line">   其意是∶</span><br><span class="line">     number - 代表的是命令执行的次数</span><br><span class="line">     command - 代表要做的事情，比如 d 代表删除</span><br><span class="line">     object - 代表要操作的对象，比如 w 代表单字&#x2F;单词，$ 代表到行末等等。</span><br><span class="line">$ (to the end of line), etc.</span><br><span class="line"></span><br><span class="line">5\. 欲撤消以前的操作，请输入∶u (小写的u)</span><br><span class="line">   欲撤消在一行中所做的改动，请输入∶U (大写的U)</span><br><span class="line">   欲撤消以前的撤消命令，恢复以前的操作结果，请输入∶CTRL-R</span><br></pre></td></tr></table></figure><h2 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h2><h3 id="第一节∶置入类命令"><a href="#第一节∶置入类命令" class="headerlink" title="第一节∶置入类命令"></a>第一节∶置入类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">** 输入 p 将最后一次删除的内容置入光标之后 **</span><br><span class="line">1. 请将光标移动到本节中下面示范段落的首行。</span><br><span class="line"></span><br><span class="line">2. 输入 dd 将该行删除，这样会将该行保存到vim的缓冲区中。</span><br><span class="line"></span><br><span class="line">3. 接着将光标移动到准备置入的位置的上方。记住∶是上方哦。</span><br><span class="line"></span><br><span class="line">4. 然后在正常模式下(&lt;ESC&gt;键进入)，输入 p 将该行粘贴置入。</span><br><span class="line"></span><br><span class="line">5. 重复步骤2至步骤4，将所有的行依序放置到正确的位置上。</span><br><span class="line"></span><br><span class="line"> d) Can you learn too?</span><br><span class="line"> b) Violets are blue,</span><br><span class="line"> c) Intelligence is learned,</span><br><span class="line"> a) Roses are red,</span><br></pre></td></tr></table></figure><h3 id="第二节∶替换类命令"><a href="#第二节∶替换类命令" class="headerlink" title="第二节∶替换类命令"></a>第二节∶替换类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  ** 输入 r 和一个字符替换光标所在位置的字符。**</span><br><span class="line"></span><br><span class="line">  1\. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span><br><span class="line"></span><br><span class="line">  2\. 请移动光标到第一个错误的适当位置。</span><br><span class="line"></span><br><span class="line">  3\. 接着输入 r ，这样就能将错误替换掉了。</span><br><span class="line"></span><br><span class="line">  4\. 重复步骤2和步骤3，直到第一行已经修改完毕。</span><br><span class="line"></span><br><span class="line">---&gt;  Whan this lime was tuoed in, someone presswd some wrojg keys!</span><br><span class="line">---&gt;  When this line was typed in, someone pressed some wrong keys!</span><br><span class="line"></span><br><span class="line">  5\. 然后我们继续学校第三讲第三节。</span><br><span class="line"></span><br><span class="line">特别提示∶切记您要在使用中学习，而不是在记忆中学习。</span><br></pre></td></tr></table></figure><h3 id="第三节∶更改类命令"><a href="#第三节∶更改类命令" class="headerlink" title="第三节∶更改类命令"></a>第三节∶更改类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">** 要改变一个单字&#x2F;单词的部分或者全部，请输入 cw **</span><br><span class="line">1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span><br><span class="line"></span><br><span class="line">2. 接着把光标放在单词 lubw 的字母 u 的位置那里。</span><br><span class="line"></span><br><span class="line">3. 然后输入 cw 就可以修正该单词了(在本例这里是输入 ine 。)</span><br><span class="line"></span><br><span class="line">4. 最后按 &lt;ESC&gt; 键，然后光标定位到下一个错误第一个准备更改的字母处。</span><br><span class="line"></span><br><span class="line">5. 重复步骤3和步骤4，直到第一个句子完全雷同第二个句子。</span><br><span class="line"></span><br><span class="line">---&gt; This lubw has a few wptfd that mrrf changing usf the change command.</span><br><span class="line">---&gt; This line has a few words that need changing using the change command.</span><br><span class="line"></span><br><span class="line">提示∶请注意 cw 命令不仅仅是替换了一个单词，也让您进入文本插入状态了。</span><br></pre></td></tr></table></figure><h3 id="第四节∶使用c指令的其他更改类命令"><a href="#第四节∶使用c指令的其他更改类命令" class="headerlink" title="第四节∶使用c指令的其他更改类命令"></a>第四节∶使用c指令的其他更改类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  ** 更改类指令可以使用同删除类命令所使用的对象参数。**</span><br><span class="line"></span><br><span class="line">  1\. 更改类指令的工作方式跟删除类命令是一致的。操作格式是∶</span><br><span class="line"></span><br><span class="line">       [number]   c   object    或者     c [number]   object</span><br><span class="line"></span><br><span class="line">  2\. 对象参数也是一样的，比如 w 代表单字&#x2F;单词，$代表行末等等。</span><br><span class="line"></span><br><span class="line">  3\. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span><br><span class="line"></span><br><span class="line">  4\. 接着将光标移动到第一个错误处。</span><br><span class="line"></span><br><span class="line">  5\. 然后输入 c$ 使得该行剩下的部分更正得同第二行一样。最后按 &lt;ESC&gt; 键。</span><br><span class="line"></span><br><span class="line">---&gt; The end of this line needs some help to make it like the second.</span><br><span class="line">---&gt; The end of this line needs to be corrected using the  c$  command.</span><br></pre></td></tr></table></figure><h3 id="第三讲小结"><a href="#第三讲小结" class="headerlink" title="第三讲小结"></a>第三讲小结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 要重新置入已经删除的文本内容，请输入小写字母 p。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。</span><br><span class="line"></span><br><span class="line">2. 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。</span><br><span class="line"></span><br><span class="line">3. 更改类命令允许您改变指定的对象，从当前光标所在位置直到对象的末尾。比如输入 cw 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。</span><br><span class="line"></span><br><span class="line">4. 更改类命令的格式是∶</span><br><span class="line"></span><br><span class="line">[number] c object 或者 c [number] object</span><br></pre></td></tr></table></figure><p>下面我们继续学习下一讲。</p><h2 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h2><h3 id="第一节∶定位及文件状态"><a href="#第一节∶定位及文件状态" class="headerlink" title="第一节∶定位及文件状态"></a>第一节∶定位及文件状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">** 输入 CTRL-g 显示当前编辑文件中当前光标所在行位置以及文件状态信息。</span><br><span class="line">   输入 SHIFT-G 则直接跳转到文件中的某一指定行。**</span><br><span class="line"></span><br><span class="line">提示∶切记要先通读本节内容，之后才可以执行以下步骤!!!</span><br><span class="line"></span><br><span class="line">1\. 按下 CTRL 键不放开然后按 g 键。然后就会看到页面最底部出现一个状态信息行，显示的内容是当前编辑的文件名和文件的总行数。请记住步骤3的行号。</span><br><span class="line"></span><br><span class="line">2\. 按下 SHIFT-G 键可以使得当前光标直接跳转到文件最后一行。</span><br><span class="line"></span><br><span class="line">3\. 输入您曾停留的行号，然后按下 SHIFT-G。这样就可以返回到您第一次按下CTRL-g 时所在的行好了。注意∶输入行号时，行号是不会在屏幕上显示出来的。</span><br><span class="line"></span><br><span class="line">4\. 如果愿意，您可以继续执行步骤1至步骤三。</span><br></pre></td></tr></table></figure><h3 id="第二节∶搜索类命令"><a href="#第二节∶搜索类命令" class="headerlink" title="第二节∶搜索类命令"></a>第二节∶搜索类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> ** 输入 &#x2F; 以及尾随的字符串可以用以在当前文件中查找该字符串。**</span><br><span class="line">1. 在正常模式下输入 &#x2F; 字符。您此时会注意到该字符和光标都会出现在屏幕底部，这跟 : 命令是一样的。</span><br><span class="line"></span><br><span class="line">2. 接着输入 errroor &lt;回车&gt;。那个errroor就是您要查找的字符串。</span><br><span class="line"></span><br><span class="line">3. 要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字符串，请输入 Shift-N 即可。</span><br><span class="line"></span><br><span class="line">4. 如果您想逆向查找字符串，请使用 ? 代替 &#x2F; 进行。</span><br><span class="line"></span><br><span class="line">---&gt; When the search reaches the end of the file it will continue at the start.</span><br><span class="line"></span><br><span class="line">&quot;errroor&quot; is not the way to spell error; errroor is an error.</span><br><span class="line"></span><br><span class="line">提示∶如果查找已经到达文件末尾，查找会自动从文件头部继续查找。</span><br></pre></td></tr></table></figure><h3 id="第三节∶配对括号的查找"><a href="#第三节∶配对括号的查找" class="headerlink" title="第三节∶配对括号的查找"></a>第三节∶配对括号的查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ** 按 % 可以查找配对的括号 )、]、&#125;。**</span><br><span class="line"></span><br><span class="line">  1\. 把光标放在本节下面标记有 --&gt; 那一行中的任何一个 (、[ 或 &#123; 处。</span><br><span class="line"></span><br><span class="line">  2\. 接着按 % 字符。</span><br><span class="line"></span><br><span class="line">  3\. 此时光标的位置应当是在配对的括号处。</span><br><span class="line"></span><br><span class="line">  4\. 再次按 % 就可以跳回配对的第一个括号处。</span><br><span class="line"></span><br><span class="line">---&gt; This ( is a test line with (&#39;s, [&#39;s ] and &#123;&#39;s &#125; in it. ))</span><br><span class="line"></span><br><span class="line">提示∶在程序调试时，这个功能用来查找不配对的括号是很有用的。</span><br></pre></td></tr></table></figure><h3 id="第四节∶修正错误的方法之一"><a href="#第四节∶修正错误的方法之一" class="headerlink" title="第四节∶修正错误的方法之一"></a>第四节∶修正错误的方法之一</h3><p>** 输入 :s/old/new/g 可以替换 old 为 new。**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line"></span><br><span class="line">2. 输入 :s&#x2F;thee&#x2F;the &lt;回车&gt; 。请注意该命令只改变光标所在行的第一个匹配</span><br><span class="line">串。</span><br><span class="line"></span><br><span class="line">3. 输入 :s&#x2F;thee&#x2F;the&#x2F;g 则是替换全行的匹配串。</span><br><span class="line"></span><br><span class="line">---&gt; the best time to see thee flowers is in thee spring.</span><br><span class="line"></span><br><span class="line">4. 要替换两行之间出现的每个匹配串，请输入 :#,#s&#x2F;old&#x2F;new&#x2F;g (#,#代表的是</span><br><span class="line">两行的行号)。输入 :%s&#x2F;old&#x2F;new&#x2F;g 则是替换整个文件中的每个匹配串。</span><br></pre></td></tr></table></figure><h3 id="第四讲小结"><a href="#第四讲小结" class="headerlink" title="第四讲小结"></a>第四讲小结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1\. Ctrl-g 用于显示当前光标所在位置和文件状态信息。Shift-G 用于将光标跳转至文件最后一行。先敲入一个行号然后按 Shift-G 则是将光标移动至该行号代表的行。</span><br><span class="line"></span><br><span class="line">2\. 输入 &#x2F; 然后紧随一个字符串是则是在当前所编辑的文档中向后查找该字符串。输入问号 ? 然后紧随一个字符串是则是在当前所编辑的文档中向前查找该字符串。完成一次查找之后按 n 键则是重复上一次的命令，可在同一方向上查找下一个字符串所在；或者按 Shift-N 向相反方向查找下该字符串所在。</span><br><span class="line"></span><br><span class="line">3\. 如果光标当前位置是括号(、)、[、]、&#123;、&#125;，按 % 可以将光标移动到配对的括号上。</span><br><span class="line"></span><br><span class="line">4\. 在一行内替换头一个字符串 old 为新的字符串 new，请输入  :s&#x2F;old&#x2F;new</span><br><span class="line">   在一行内替换所有的字符串 old 为新的字符串 new，请输入  :s&#x2F;old&#x2F;new&#x2F;g</span><br><span class="line">   在两行内替换所有的字符串 old 为新的字符串 new，请输入  :#,#s&#x2F;old&#x2F;new&#x2F;g</span><br><span class="line">   在文件内替换所有的字符串 old 为新的字符串 new，请输入  :%s&#x2F;old&#x2F;new&#x2F;g</span><br><span class="line">   进行全文替换时询问用户确认每个替换需添加 c 选项，请输入 :%s&#x2F;old&#x2F;new&#x2F;gc</span><br></pre></td></tr></table></figure><h2 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h2><h3 id="第一节∶在-VIM-内执行外部命令的方法"><a href="#第一节∶在-VIM-内执行外部命令的方法" class="headerlink" title="第一节∶在 VIM 内执行外部命令的方法"></a>第一节∶在 VIM 内执行外部命令的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">** 输入 :! 然后紧随著输入一个外部命令可以执行该外部命令。**</span><br><span class="line">1. 按下我们所熟悉的 : 命令设置光标到屏幕底部。这样就可以让您输入命令了。</span><br><span class="line"></span><br><span class="line">2. 接着输入感叹号 ! 这个字符，这样就允许您执行外部的 shell 命令了。</span><br><span class="line"></span><br><span class="line">3. 我们以 ls 命令为例。输入 !ls &lt;回车&gt; 。该命令就会列举出您当前目录的内容，就如同您在命令行提示符下输入 ls 命令的结果一样。如果 !ls 没起作用，您可以试试 :!dir 看看。</span><br><span class="line"></span><br><span class="line">---&gt; 提示∶ 所有的外部命令都可以以这种方式执行。</span><br><span class="line"></span><br><span class="line">---&gt; 提示∶ 所有的 : 命令都必须以 &lt;回车&gt; 告终。</span><br></pre></td></tr></table></figure><h3 id="第二节∶关于保存文件的更多信息"><a href="#第二节∶关于保存文件的更多信息" class="headerlink" title="第二节∶关于保存文件的更多信息"></a>第二节∶关于保存文件的更多信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  ** 要将对文件的改动保存到文件中，请输入 :w FILENAME 。**</span><br><span class="line"></span><br><span class="line">  1\. 输入 :!dir 或者 :!ls 获知当前目录的内容。您应当已知道最后还得敲</span><br><span class="line">     &lt;回车&gt; 吧。</span><br><span class="line"></span><br><span class="line">  2\. 选择一个尚未存在文件名，比如 TEST 。</span><br><span class="line"></span><br><span class="line">  3\. 接着输入 :w TEST  (此处 TEST 是您所选择的文件名。)</span><br><span class="line"></span><br><span class="line">  4\. 该命令会以 TEST 为文件名保存整个文件 (VIM 教程)。为了确保正确保存，</span><br><span class="line">     请再次输入 :!dir 查看您的目录列表内容。</span><br><span class="line"></span><br><span class="line">---&gt; 请注意∶如果您退出 VIM 然后在以文件名 TEST 为参数进入，那么该文件内容应该同您保存时的文件内容是完全一样的。</span><br><span class="line"></span><br><span class="line">  5\. 现在您可以通过输入 :!rm TEST 来删除 TEST 文件了。</span><br></pre></td></tr></table></figure><h3 id="第三节∶一个具有选择性的保存命令"><a href="#第三节∶一个具有选择性的保存命令" class="headerlink" title="第三节∶一个具有选择性的保存命令"></a>第三节∶一个具有选择性的保存命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">** 要保存文件的部分内容，请输入 :#,# w FILENAME **</span><br><span class="line"></span><br><span class="line">1. 再来执行一次 :!dir 或者 :!ls 获知当前目录的内容，然后选择一个合适的不重名的文件名，比如 TEST 。</span><br><span class="line"></span><br><span class="line">2. 接着将光标移动至本页的最顶端，然后按 CTRL-g 找到该行的行号。别忘了行号哦。</span><br><span class="line"></span><br><span class="line">3. 接着把光标移动至本页的最底端，再按一次 CTRL-g 。也别忘了这个行好哦。</span><br><span class="line"></span><br><span class="line">4. 为了只保存文章的某个部分，请输入 :#,# w TEST 。这里的 #,# 就是上面要求您记住的行号(顶端行号,底端行号)，而 TEST 就是选定的文件名。</span><br><span class="line"></span><br><span class="line">5. 最后，用 :!dir 确认文件是否正确保存。但是这次先别删除掉。</span><br></pre></td></tr></table></figure><h3 id="第四节∶提取和合并文件"><a href="#第四节∶提取和合并文件" class="headerlink" title="第四节∶提取和合并文件"></a>第四节∶提取和合并文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  ** 要向当前文件中插入另外的文件的内容，请输入 :r FILENAME **</span><br><span class="line"></span><br><span class="line">  1\. 请键入 :!dir 确认您前面创建的 TEST 文件还在。</span><br><span class="line"></span><br><span class="line">  2\. 然后将光标移动至当前页面的顶端。</span><br><span class="line"></span><br><span class="line">特别提示∶ 执行步骤3之后您将看到第五讲第三节，请届时再往下移动回到这里来。</span><br><span class="line"></span><br><span class="line">  3\. 接着通过 :r TEST 将前面创建的名为 TEST 的文件提取进来。</span><br><span class="line"></span><br><span class="line">特别提示∶您所提取进来的文件将从光标所在位置处开始置入。</span><br><span class="line"></span><br><span class="line">  4\. 为了确认文件已经提取成功，移动光标回到原来的位置就可以注意有两份第</span><br><span class="line">     五讲第三节，一份是原本，另外一份是来自文件的副本。</span><br></pre></td></tr></table></figure><h3 id="第五讲小结"><a href="#第五讲小结" class="headerlink" title="第五讲小结"></a>第五讲小结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. :!command 用于执行一个外部命令 command。</span><br><span class="line"></span><br><span class="line"> 请看一些实际例子∶</span><br><span class="line">:!dir - 用于显示当前目录的内容。</span><br><span class="line">:!rm FILENAME - 用于删除名为 FILENAME 的文件。</span><br><span class="line"></span><br><span class="line">2. :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。</span><br><span class="line"></span><br><span class="line">3. :#,#w FILENAME 可将当前编辑文件第 # 行至第 # 行的内容保存到文件FILENAME 中。</span><br><span class="line"></span><br><span class="line">4. :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。</span><br></pre></td></tr></table></figure><h2 id="第六讲"><a href="#第六讲" class="headerlink" title="第六讲"></a>第六讲</h2><h3 id="第一节∶打开类命令"><a href="#第一节∶打开类命令" class="headerlink" title="第一节∶打开类命令"></a>第一节∶打开类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  ** 输入 o 将在光标的下方打开新的一行并进入插入模式。**</span><br><span class="line"></span><br><span class="line">  1\. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line"></span><br><span class="line">  2\. 接着输入小写的 o 在光标 *下方* 打开新的一行并进入插入模式。</span><br><span class="line"></span><br><span class="line">  3\. 然后复制标记有 ---&gt; 的行并按 &lt;ESC&gt; 键退出插入模式而进入正常模式。</span><br><span class="line"></span><br><span class="line">---&gt; After typing  o  the cursor is placed on the open line in Insert mode.</span><br><span class="line"></span><br><span class="line">  4\. 为了在光标 *上方* 打开新的一行，只需要输入大写的 O 而不是小写的 o</span><br><span class="line">     就可以了。请在下行测试一下吧。当光标处在在该行上时，按 Shift-O可以</span><br><span class="line">     在该行上方新开一行。</span><br><span class="line"></span><br><span class="line">Open up a line above this by typing Shift-O while the cursor is on this line.</span><br></pre></td></tr></table></figure><h3 id="第二节∶光标后插入类命令"><a href="#第二节∶光标后插入类命令" class="headerlink" title="第二节∶光标后插入类命令"></a>第二节∶光标后插入类命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   ** 输入 a 将可在光标之后插入文本。 **</span><br><span class="line">1. 请在正常模式下通过输入 $ 将光标移动到本节中下面标记有 ---&gt; 的第一行的末尾。</span><br><span class="line"></span><br><span class="line">2. 接着输入小写的 a 则可在光标之后插入文本了。大写的 A 则可以直接在行末插入文本。</span><br><span class="line"></span><br><span class="line">提示∶输入大写 A 的操作方法可以在行末插入文本，避免了输入 i，光标定位到最后一个字符，输入的文本，&lt;ESC&gt; 回复正常模式，箭头右键移动光标以及x 删除当前光标所在位置字符等等诸多繁杂的操作。</span><br><span class="line"></span><br><span class="line">3. 操作之后第一行就可以补充完整了。请注意光标后插入文本与插入模式是基本完全一致的，只是文本插入的位置定位稍有不同罢了。</span><br><span class="line"></span><br><span class="line">---&gt; This line will allow you to practice</span><br><span class="line">---&gt; This line will allow you to practice appending text to the end of a line.</span><br></pre></td></tr></table></figure><h3 id="第三节∶另外一个置换类命令的版本"><a href="#第三节∶另外一个置换类命令的版本" class="headerlink" title="第三节∶另外一个置换类命令的版本"></a>第三节∶另外一个置换类命令的版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  ** 输入大写的 R 可连续替换多个字符。**</span><br><span class="line"></span><br><span class="line">  1\. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span><br><span class="line"></span><br><span class="line">  2\. 移动光标到第一行中不同于标有 ---&gt; 的第二行的第一个单词的开始，即单词 last 处。</span><br><span class="line"></span><br><span class="line">  3\. 然后输入大写的 R 开始把第一行中的不同于第二行的剩余字符逐一输入，就可以全部替换掉原有的字符而使得第一行完全雷同第二行了。</span><br><span class="line"></span><br><span class="line">---&gt; To make the first line the same as the last on this page use the keys.</span><br><span class="line">---&gt; To make the first line the same as the second, type R and the new text.</span><br><span class="line"></span><br><span class="line">  4\. 请注意∶如果您按 &lt;ESC&gt; 退出置换模式回复正常模式，尚未替换的文本将仍然保持原状。</span><br></pre></td></tr></table></figure><h3 id="第四节∶设置类命令的选项"><a href="#第四节∶设置类命令的选项" class="headerlink" title="第四节∶设置类命令的选项"></a>第四节∶设置类命令的选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">** 设置可使查找或者替换可忽略大小写的选项 **</span><br><span class="line">1. 要查找单词 ignore 可在正常模式下输入 &#x2F;ignore 。要重复查找该词，可以重复按 n 键。</span><br><span class="line"></span><br><span class="line">2. 然后设置 ic 选项(ic就是英文忽略大小写Ignore Case的首字母缩写词)，即输入∶</span><br><span class="line">  :set ic</span><br><span class="line"></span><br><span class="line">3. 现在可以通过键入 n 键再次查找单词 ignore。重复查找可以重复键入 n 键。</span><br><span class="line"></span><br><span class="line">4. 然后设置 hlsearch 和 incsearch 这两个选项，输入以下内容∶</span><br><span class="line">  :set hls is</span><br><span class="line"></span><br><span class="line">5. 现在可以再次输入查找命令，看看会有什么效果∶</span><br><span class="line">  &#x2F;ignore</span><br></pre></td></tr></table></figure><h3 id="第六讲小结"><a href="#第六讲小结" class="headerlink" title="第六讲小结"></a>第六讲小结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1\. 输入小写的 o 可以在光标下方打开新的一行并将光标置于新开的行首，进入插入模式。</span><br><span class="line">   输入大写的 O 可以在光标上方打开新的一行并将光标置于新开的行首，进入插入模式。</span><br><span class="line"></span><br><span class="line">2\. 输入小写的 a 可以在光标所在位置之后插入文本。</span><br><span class="line">   输入大写的 A 可以在光标所在行的行末之后插入文本。</span><br><span class="line"></span><br><span class="line">3\. 输入大写的 R 将进入替换模式，直至按 &lt;ESC&gt; 键退出替换模式而进入正常模式。</span><br><span class="line"></span><br><span class="line">4\. 输入 :set xxx 可以设置 xxx 选项。</span><br></pre></td></tr></table></figure><h3 id="第七讲∶在线帮助命令"><a href="#第七讲∶在线帮助命令" class="headerlink" title="第七讲∶在线帮助命令"></a>第七讲∶在线帮助命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">** 使用在线帮助系统 **</span><br><span class="line">Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方</span><br><span class="line">法之一∶</span><br><span class="line"></span><br><span class="line">按下 &lt;HELP&gt; 键 (如果键盘上有的话)</span><br><span class="line">按下 &lt;F1&gt; 键 (如果键盘上有的话)</span><br><span class="line">输入 :help &lt;回车&gt;</span><br><span class="line">输入 :q &lt;回车&gt; 可以关闭帮助窗口。</span><br><span class="line"></span><br><span class="line">提供一个正确的参数给&quot;:help&quot;命令，您可以找到关于该主题的帮助。请试验以</span><br><span class="line">下参数(可别忘了按回车键哦。:)∶</span><br><span class="line"></span><br><span class="line">:help w &lt;回车&gt;</span><br><span class="line">:help c_&lt;T &lt;回车&gt;</span><br><span class="line">:help insert-index &lt;回车&gt;</span><br><span class="line">:help user-manual &lt;回车&gt;</span><br></pre></td></tr></table></figure><h3 id="第八讲∶创建一个启动脚本"><a href="#第八讲∶创建一个启动脚本" class="headerlink" title="第八讲∶创建一个启动脚本"></a>第八讲∶创建一个启动脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">** 启用vim的功能 **</span><br><span class="line"></span><br><span class="line">Vim的功能特性要比vi多得多，但大部分功能都没有缺省激活。为了启动更多的</span><br><span class="line">功能，您得创建一个vimrc文件。</span><br><span class="line"></span><br><span class="line">1\. 开始编辑vimrc文件，这取决于您所使用的操作系统∶</span><br><span class="line"></span><br><span class="line">   :edit ~&#x2F;.vimrc  这是Unix系统所使用的命令</span><br><span class="line">   :edit $VIM&#x2F;_vimrc  这是Windows系统所使用的命令</span><br><span class="line"></span><br><span class="line">2\. 接着导入vimrc范例文件∶</span><br><span class="line"></span><br><span class="line">   :read $VIMRUNTIME&#x2F;vimrc_example.vim</span><br><span class="line"></span><br><span class="line">3\. 保存文件，命令为∶</span><br><span class="line"></span><br><span class="line">   :write</span><br><span class="line"></span><br><span class="line">在下次您启动vim的时候，编辑器就会有了语法高亮的功能。您可以继续把您喜欢的其它功能设置添加到这个vimrc文件中。</span><br></pre></td></tr></table></figure><p>vim 教程到此结束。本教程只是为了简明地介绍一下vim编辑器，但已足以让您很容易学会使用本编辑器了。毋庸质疑，vim还有很多很多的命令，本教程所介绍的还差得远著呢。所以您要精通的话，还望继续努力哦。下一步您可以阅读vim手册，使用的命令是∶<br>  :help user-manual<br>这是第一本完全讲解vim的书籍。对于初学者特别有用。其中还包含有大量实例和图示。欲知详情，请访问 <a href="http://iccf-holland.org/click5.html" target="_blank" rel="noopener">http://iccf-holland.org/click5.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vim 是一个具有很多命令的功能非常强大的编辑器。限于篇幅，在本教程当中就不详细介绍了。本教程的设计目标是讲述一些必要的基本命令，而掌握好这些命令，您就能够很容易将vim当作一个通用的万能编辑器来使用了。&lt;br&gt;完成本教程的内容大约需要25-30分钟，取决于您训练的时间。&lt;br&gt;每一节的命令操作将会更改本文。推荐您复制本文的一个副本，然后在副本上进行训练(如果您是通过”vimtutor”来启动教程的，那么本文就已经是副本了)。&lt;br&gt;切记一点∶本教程的设计思路是在使用中进行学习的。也就是说，您需要通过执行命令来学习它们本身的正确用法。如果您只是阅读而不操作，那么您可能会很快遗忘这些命令的！&lt;br&gt;好了，现在请确定您的Shift-Lock(大小写锁定键)还没有按下，然后按键盘上的字母键 j 足够多的次数来移动光标，直到第一节的内容能够完全充满屏幕。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/categories/vim/"/>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>面试network部分</title>
    <link href="https://jambo0624.github.io/2020-03-12-interview-network.html"/>
    <id>https://jambo0624.github.io/2020-03-12-interview-network.html</id>
    <published>2020-03-12T06:20:09.000Z</published>
    <updated>2020-03-19T01:50:31.626Z</updated>
    
    <content type="html"><![CDATA[<ul><li>304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销<br>&nbsp;&nbsp;&nbsp;&nbsp;1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）<br>&nbsp;&nbsp;&nbsp;&nbsp;2.304是    HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件<br>&nbsp;&nbsp;&nbsp;&nbsp;3.流程：客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。<br>=&gt; 有了Last-Modified，为什么还要用ETag？<br>&nbsp;&nbsp;&nbsp;&nbsp;1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）<br>&nbsp;&nbsp;&nbsp;&nbsp;2、某些服务器不能精确的得到文件的最后修改时间<br>&nbsp;&nbsp;&nbsp;&nbsp;3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get<br>=&gt; 有了ETag，为什么还要用Last-Modified？<br>&nbsp;&nbsp;&nbsp;&nbsp;1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改<br>&nbsp;&nbsp;&nbsp;&nbsp;2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）<br>&nbsp;&nbsp;&nbsp;&nbsp;3、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。<a id="more"></a></li></ul><hr><ul><li>TCP的三次握手和四次挥手<br>三次握手<br>&nbsp;&nbsp;&nbsp;&nbsp;第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；<br>&nbsp;&nbsp;&nbsp;&nbsp;第二次握手：服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接<br>&nbsp;&nbsp;&nbsp;&nbsp;第三次握手：客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；<br>四次挥手<br>&nbsp;&nbsp;&nbsp;&nbsp;第一次挥手：客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；<br>&nbsp;&nbsp;&nbsp;&nbsp;第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成<br>&nbsp;&nbsp;&nbsp;&nbsp;第三次挥手：服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕<br>&nbsp;&nbsp;&nbsp;&nbsp;第四次挥手：客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</li></ul><hr><ul><li>为什么建立连接是三次握手，而断开连接是四次挥手呢?<br>&nbsp;&nbsp;&nbsp;&nbsp;建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>&nbsp;&nbsp;&nbsp;&nbsp;而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</li></ul><hr><ul><li>http协议的理解<br>&nbsp;&nbsp;&nbsp;&nbsp;1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议<br>&nbsp;&nbsp;&nbsp;&nbsp;2.基于TCP/IP通信协议来传递数据（HTML，图片资源）<br>&nbsp;&nbsp;&nbsp;&nbsp;3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统<br>&nbsp;&nbsp;&nbsp;&nbsp;4.http请求信息request：<br>&nbsp;&nbsp;&nbsp;&nbsp;请求行（request line）、请求头部（header）,空行和请求数据四部分构成<blockquote><p>请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.<br>请求头部，用来说明服务器要使用的附加信息<br>空行，请求头部后面的空行是必须的<br>请求数据也叫主体，可以添加任意的其他数据。</p></blockquote></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;5.http相应信息Response<br>&nbsp;&nbsp;&nbsp;&nbsp;状态行、消息报头、空行和响应正文</p><blockquote><p>状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成<br>消息报头，用来说明客户端要使用的一些附加信息<br>空行，消息报头后面的空行是必须的<br>响应正文，服务器返回给客户端的文本信息。</p></blockquote><ul><li>http和https<br>https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密<br>http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少</li></ul><hr><ul><li>web缓存</li></ul><p>1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本<br>2.缓存的好处<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）减少不必要的请求<br>&nbsp;&nbsp;&nbsp;&nbsp;（2）降低服务器的压力，减少服务器的消耗<br>&nbsp;&nbsp;&nbsp;&nbsp;（3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）</p><hr><ul><li>CDN（内容分发网络）</li></ul><p>1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。<br>2.关键技术：内容存储和分发技术中<br>3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术<br>将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）</p><hr><ul><li>从输入url到获取页面的完整过程 </li></ul><p>1.查询浏览器缓存，系统缓存，路由器缓存<br>2.查询NDS(域名解析)，获取域名对应的IP地址<br>3.浏览器与服务器建立tcp链接（三次握手）<br>4.浏览器向服务器发送http请求(请求和传输数据）<br>5.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器<br>6.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤<br>7.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来</p><hr><ul><li>浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print<br>流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树<br>概念：<br>&nbsp;&nbsp;&nbsp;&nbsp;1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树<br>&nbsp;&nbsp;&nbsp;&nbsp;2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）<br>&nbsp;&nbsp;&nbsp;&nbsp;3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置<br>&nbsp;&nbsp;&nbsp;&nbsp;4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点<br>重绘：<br>&nbsp;&nbsp;&nbsp;&nbsp;当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上<br>&nbsp;&nbsp;&nbsp;&nbsp;触发重绘的条件：改变元素外观属性。如：color，background-color等<br>&nbsp;&nbsp;&nbsp;&nbsp;重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观<br>&nbsp;&nbsp;&nbsp;&nbsp;注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局<br>重排（重构/回流/reflow）<br>&nbsp;&nbsp;&nbsp;&nbsp;当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。<br>&nbsp;&nbsp;&nbsp;&nbsp;每个页面都需要一次回流，就是页面第一次渲染的时候<br>重排一定会影响重绘，但是重绘不一定会影响重排</li></ul><hr><ul><li>为什么css放在顶部而js写在后面<br>&nbsp;&nbsp;&nbsp;&nbsp;1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了<br>&nbsp;&nbsp;&nbsp;&nbsp;2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。<br>&nbsp;&nbsp;&nbsp;&nbsp;3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验<br>&nbsp;&nbsp;&nbsp;&nbsp;但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理</li></ul><hr><ul><li>存储方式与传输方式<br>&nbsp;&nbsp;&nbsp;&nbsp;1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m<br>&nbsp;&nbsp;&nbsp;&nbsp;2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响<br>&nbsp;&nbsp;&nbsp;&nbsp;3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）<br>&nbsp;&nbsp;&nbsp;&nbsp;4.localStroage: h5的本地存储，数据永久保存在客服端</li></ul><hr><ul><li>token、cookie、session三者的理解？？？！！！<br>&nbsp;&nbsp;&nbsp;&nbsp;1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的用户身份的验证方式)<br>&nbsp;&nbsp;&nbsp;&nbsp;2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名。服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）<br>&nbsp;&nbsp;&nbsp;&nbsp;3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）。cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。</li></ul><hr><ul><li>基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前时间戳 + sign签名）<br>&nbsp;&nbsp;&nbsp;&nbsp;1、用户通过用户名和密码发送请求<br>&nbsp;&nbsp;&nbsp;&nbsp;2、服务器端验证<br>&nbsp;&nbsp;&nbsp;&nbsp;3、服务器端返回一个带签名的token，给客户端<br>&nbsp;&nbsp;&nbsp;&nbsp;4、客户端储存token，并且每次用于发送请求<br>&nbsp;&nbsp;&nbsp;&nbsp;5、服务器验证token并且返回数据<br>每一次请求都需要token</li></ul><hr><ul><li>cookie与session区别<br>&nbsp;&nbsp;&nbsp;&nbsp;1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>&nbsp;&nbsp;&nbsp;&nbsp;2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。<br>&nbsp;&nbsp;&nbsp;&nbsp;3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。<br>&nbsp;&nbsp;&nbsp;&nbsp;4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li></ul><hr><ul><li>session与token区别<br>&nbsp;&nbsp;&nbsp;&nbsp;1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App<br>&nbsp;&nbsp;&nbsp;&nbsp;2、token是Auth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，token不能转移到其他的App，也不能转到其他用户上。（适用于App）<br>&nbsp;&nbsp;&nbsp;&nbsp;3、session的状态是存在服务器端的，客户端只存在session id，Token状态是存储在客户端的</li></ul><hr><ul><li>HTTP 缓存有哪几种？<br>&nbsp;&nbsp;&nbsp;&nbsp;ETag 是通过对比浏览器和服务器资源的特征值（如MD5）来决定是否要发送文件内容，如果一样就只发送 304（not modified）<br>&nbsp;&nbsp;&nbsp;&nbsp;Expires 是设置过期时间（绝对时间），但是如果用户的本地时间错乱了，可能会有问题<br>&nbsp;&nbsp;&nbsp;&nbsp;CacheControl: max-age=3600 是设置过期时长（相对时间），跟本地时间无关。</li></ul><hr><ul><li>RESTful常用的方法和介绍<br>rest请求方法有4种，包括get,post,put,delete.分别对应获取资源，添加资源，更新资源及删除资源</li></ul><hr><ul><li>csrf跨站攻击怎么解决<br>CSRF, 跨站请求伪造,它可以在用户毫不知情的情况下以用户名义伪造请求发送给受攻击站点，从而对用户或者网站造成攻击. 预防措施如下:<br>=&gt; 服务器端验证HTTP Referer字段, Referer记录了该HTTP请求的来源地址<br>=&gt; 在请求地址中添加token并验证<br>=&gt; 在HTTP头中自定义属性并验证</li></ul><hr><ul><li>对web安全的理解<br>=&gt; CSRF 攻击和防范<br>跨站请求伪造,可以理解为攻击者盗用了用户的身份，以用户的名义发送恶意请求，造成用户隐私及财产损失<br>过程:<br>&nbsp;&nbsp;&nbsp;&nbsp;1.登录受信任网站并在本地生成cookie;<br>&nbsp;&nbsp;&nbsp;&nbsp;2.在不登出 网站 的情况下访问危险网站 </li></ul><p><strong>防范:</strong> 关键操作只接受POST请求, 使用验证码, 检测Referer, 使用token(或者JWT)</p><p>=&gt; XSS 攻击和防范<br>全称Cross-site script，跨站脚本攻击，是Web程序中常见的漏洞。<br>原理是攻击者向有XSS漏洞的网站中输入恶意的脚本，当其它用户浏览该网站时候，该脚本会自动执行，从而达到攻击的目的(盗取Cookie，破坏页面结构，重定向到钓鱼网站等)。<br>区分: 分为持久型XSS和非持久性XSS. 持久型XSS是将攻击的脚本植入到服务器，从而导致每个访问的用户都会遭到此XSS脚本的攻击。非持久型XSS是将恶意脚本包装在页面的URL参数中，通过URL链接骗取用户访问，从而进行攻击.<br><strong>防范:</strong> 对用户输入进行HTML转义, 对敏感信息进行过滤</p><p>=&gt; SQL 注入与防范<br>通过把SQL命令插入到表单中并提交或页面请求的参数中，最终使得服务器执行恶意的SQL命令.<br><strong>防范:</strong> 对用户的输入进行校验或限制长度；对特殊字符进行转换, 不要使用动态拼装SQL，为每个应用使用单独的权限有限的数据库连接。对隐私信息进行加密</p><p>=&gt; DDOS 攻击<br>分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。</p><hr><ul><li>base64为什么能提升性能以及它的缺点是什么<br>优点:<br>• 无额外请求<br>• 适用于很小或者很简单的图片<br>• 可像单独图片一样使用，比如背景图片等<br>• 没有跨域问题，不需要考虑缓存、文件头或者cookies问题<br>缺点:<br>• CSS 文件体积的增大, 造成CRP(关键渲染路径)阻塞<br>• 页面解析CSS生成的CSSOM时间增加</li></ul><hr><ul><li>介绍webp图片文件格式<br>WebP是一种支持有损压缩和无损压缩的图片文件格式，根据Google的测试，无损压缩后的WebP比PNG 文件少了45％的文件大小，即使这些PNG文件经过其他压缩工具压缩之后，WebP 还是可以减少28％的文件大小。<br>•优点<br>更小的文件尺寸<br>更高的质量——与其他相同大小不同格式的压缩图像比较<br>•缺点<br>编码和解码速度比较慢,存在一定兼容性</li></ul><hr><ul><li>说说H5手机端的适配的几种方案 </li></ul><ol><li>js实现一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">    resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span><br><span class="line">    recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span><br><span class="line">      <span class="keyword">var</span> fontSize = <span class="number">20</span>;</span><br><span class="line">      docEl.style.fontSize = fontSize + <span class="string">'px'</span>;</span><br><span class="line">      <span class="keyword">var</span> docStyles = getComputedStyle(docEl);</span><br><span class="line">      <span class="keyword">var</span> realFontSize = <span class="built_in">parseFloat</span>(docStyles.fontSize);</span><br><span class="line">      <span class="keyword">var</span> scale = realFontSize / fontSize;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"realFontSize: "</span> + realFontSize + <span class="string">", scale: "</span> + scale);</span><br><span class="line">      fontSize = clientWidth / <span class="number">750</span> * <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">if</span>(isIphoneX()) fontSize = <span class="number">19</span>;</span><br><span class="line">      fontSize = fontSize / scale;</span><br><span class="line">      docEl.style.fontSize = fontSize + <span class="string">'px'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">// Abort if browser does not support addEventListener</span></span><br><span class="line">  <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line">  win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">  doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// iphoneX判断</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isIphoneX</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/iphone/gi</span>.test(navigator.userAgent) &amp;&amp; (screen.height == <span class="number">812</span> &amp;&amp; screen.width == <span class="number">375</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></li><li>js实现二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _base = base|| <span class="number">75</span>;</span><br><span class="line">  <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">  <span class="keyword">var</span> matches = ua.match(<span class="regexp">/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i</span>);</span><br><span class="line">  <span class="keyword">var</span> isIos = navigator.appVersion.match(<span class="regexp">/(iphone|ipad|ipod)/gi</span>);</span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(!isIos &amp;&amp; !(matches &amp;&amp; matches[<span class="number">1</span>] &gt; <span class="number">534</span>)) &#123;</span><br><span class="line">  <span class="comment">// 如果非iOS, 非Android4.3以上, dpr设为1;</span></span><br><span class="line">    dpr = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> scale = <span class="number">1</span>/ dpr;</span><br><span class="line">  <span class="keyword">var</span> metaEl = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span><br><span class="line">  <span class="keyword">if</span>(!metaEl) &#123;</span><br><span class="line">    metaEl = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>);</span><br><span class="line">    metaEl.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>);</span><br><span class="line">    <span class="built_in">window</span>.document.head.appendChild(metaEl);</span><br><span class="line">  &#125;</span><br><span class="line">  metaEl.setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width,user-scalable=no,initial-scale='</span>+ scale + <span class="string">',maximum-scale='</span>+ scale + <span class="string">',minimum-scale='</span>+ scale);</span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.fontSize = <span class="built_in">document</span>.documentElement.clientWidth / (<span class="number">750</span>/ _base) + <span class="string">'px'</span>;</span><br><span class="line">&#125;)(<span class="number">75</span>);</span><br></pre></td></tr></table></figure></li><li>css @media媒介查询(苏宁易购实现方式)</li><li>手淘的lib-flexible实现方式</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.304是    HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.流程：客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。&lt;br&gt;=&amp;gt; 有了Last-Modified，为什么还要用ETag？&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、某些服务器不能精确的得到文件的最后修改时间&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get&lt;br&gt;=&amp;gt; 有了ETag，为什么还要用Last-Modified？&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
    
    </summary>
    
    
      <category term="interview" scheme="https://jambo0624.github.io/categories/interview/"/>
    
    
      <category term="面试，network" scheme="https://jambo0624.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8Cnetwork/"/>
    
  </entry>
  
</feed>
