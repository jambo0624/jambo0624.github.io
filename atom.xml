<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You should know</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jambo0624.github.io/"/>
  <updated>2020-10-19T12:44:34.839Z</updated>
  <id>https://jambo0624.github.io/</id>
  
  <author>
    <name>Jambo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『question 系列』writeDown</title>
    <link href="https://jambo0624.github.io/2020-08-07-writedown-question.html"/>
    <id>https://jambo0624.github.io/2020-08-07-writedown-question.html</id>
    <published>2020-08-07T15:01:04.000Z</published>
    <updated>2020-10-19T12:44:34.839Z</updated>
    
    <content type="html"><![CDATA[<p>『question 系列』的 js 部分，有一个很关键的部分就是<strong>手写</strong>的实现。<br>今天我们就把上出现的手写题目，进行梳理。下面我们开始吧。        </p><a id="more"></a><h2 id="面试手写部分"><a href="#面试手写部分" class="headerlink" title="面试手写部分"></a>面试手写部分</h2><ul><li><strong>AJAX手写</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = xhr.responseText</span><br><span class="line">    resolve(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(method,url,isAsyn)</span><br><span class="line">xhr.send()  <span class="comment">// xhr.send(body)</span></span><br></pre></td></tr></table></figure></li></ul><p>对于这种状态在ajax中分为5中状态：      </p><blockquote><p>0: (未初始化)还没有调用send()方法。<br>1: (载入)已经调用send()方法，正在派发请求。<br>2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。<br>3: (交互)正在解析响应内容。<br>4: (完成)响应内容已经解析完成，用户可以调用。</p></blockquote><p>AJAX状态码说明      </p><blockquote><p>1** ：请求收到，继续处理<br>2** ：操作成功收到，分析、接受<br>3** ：完成此请求必须进一步处理<br>4** ：请求包含一个错误语法或不能完成<br>5** ：服务器执行一个完全有效请求失败      </p></blockquote><ul><li><strong>Promise用法</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(data)   <span class="comment">//成功时调用</span></span><br><span class="line">    reject(err)  <span class="comment">//失败时调用</span></span><br><span class="line">  &#125;)  </span><br><span class="line">&#125;</span><br><span class="line">fn.then(success,fail).then(success2,fail2)</span><br></pre></td></tr></table></figure></li></ul><p>Promise.all 用法–promise1和promise2都成功才会调用success<br><code>Promise.all([promise1,promise2]).then(success,fail)</code><br>Promise.race 用法–promise1和promise2只要有一个成功就会调用success<br><code>Promise.race([promise1,promise2]).then(success,fail)</code>      </p><ul><li><strong>JavaScript常见的六种继承方式</strong></li></ul><blockquote><p>方式一、原型链继承  </p></blockquote><p><code>Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象</code><br>核心： 将父类的实例作为子类的原型<br>缺点：<br>  来自原型对象的所有属性被所有实例共享<br>  创建子类实例时，无法向父类构造函数传参<br>  要想为子类新增属性和方法，必须要在Student.prototype = new Person() 之后执行，不能放到构造器中     </p><blockquote><p>方式二:    </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 相当于: this.Person(name, age)</span></span><br><span class="line">  <span class="comment">/*this.name = name</span></span><br><span class="line"><span class="comment">  this.age = age*/</span></span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类<br>缺点：<br>  实例并不是父类的实例，只是子类的实例<br>  只能继承父类的实例属性和方法，<strong>不能继承原型属性和方法</strong><br>  无法实现函数复用，每个子类都有父类实例函数的副本，影响性能      </p><blockquote><p>方式三: 原型链+借用构造函数的组合继承</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 相当于: this.Person(name, age)</span></span><br><span class="line">  <span class="comment">/*this.name = name</span></span><br><span class="line"><span class="comment">  this.age = age*/</span></span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//组合继承也是需要修复构造函数指向的</span></span><br></pre></td></tr></table></figure><p>缺点：<br>  调用了两次父类构造函数，生成了两份实例      </p><blockquote><p>方式四: 组合继承优化1</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = Person.prototype</span><br></pre></td></tr></table></figure><p>缺点：<br>  没办法辨别是实例是子类还是父类创造的，子类和父类的构造函数指向是同一个   </p><blockquote><p>方式五: 组合继承优化2</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype)<span class="comment">//核心代码</span></span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//核心代码</span></span><br></pre></td></tr></table></figure><blockquote><p>方式六：ES6中class 的继承</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, salary) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age)<span class="comment">//通过super调用父类的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.salary = salary</span><br><span class="line">  &#125;</span><br><span class="line">  showName() &#123;<span class="comment">//在子类自身定义方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调用子类的方法"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>五和六分别是ES5和ES6的标准方法</p></blockquote><ul><li><strong>数组去重</strong>        </li></ul><blockquote><p>1.哈希表思想</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = []</span><br><span class="line">  <span class="keyword">var</span> hash = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hash[item]) &#123;</span><br><span class="line">      result.push(item)</span><br><span class="line">      hash[item] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.遍历数组，用indexOf() / includes()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//indexOf()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(arr[i])===<span class="number">-1</span>) &#123;</span><br><span class="line">      result.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//includes()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    !result.includes(item) &amp;&amp; result.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.数组下标判断法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.indexOf(arr[i])===i) &#123;</span><br><span class="line">      result.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序查找的ES6写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>4.排序，去除相邻的重复值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.sort()</span><br><span class="line">  <span class="keyword">var</span> result = [arr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    arr[i] !== arr[i<span class="number">-1</span>] &amp;&amp; result.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>5.双层循环遍历</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>,len=arr.length;i&lt;len;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;len;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i]===arr[j]) &#123;</span><br><span class="line">        arr.splice(j,<span class="number">1</span>)</span><br><span class="line">        len--</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>6.ES6的Set结构（高性能）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line">  <span class="keyword">return</span> [...result]</span><br><span class="line">  <span class="comment">//👆两行合并 return Array.from(new Set(arr))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数节流（throttle）</strong><br>核心的事情是能不能，开始是能。调用完，马上不能。一段时间之后才可以                   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canUse = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canUse) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">      canUse = <span class="literal">false</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>canUse = <span class="literal">true</span>, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>函数防抖（debounce）</strong><br><a href="https://juejin.im/post/5b8de829f265da43623c4261" target="_blank" rel="noopener">防抖和节流的区别</a><br>核心的事情是重新定时，所以开始定义timer为null。返回的函数也是先清timer。进去timer之后，先执行fn。之后赶紧清timer  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存在问题版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timerId = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span>(timerId)&#123;<span class="built_in">window</span>.clearTimeout(timerId)&#125;</span><br><span class="line">    <span class="comment">// 问题主要是箭头函数导致this指向，和arguments传递的问题</span></span><br><span class="line">    timerId = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      fn.apply(context, <span class="built_in">arguments</span>)</span><br><span class="line">      timerId = <span class="literal">null</span></span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面有助于理解arguments的传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFun = debounce(doSomething,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">newFun(<span class="number">1234</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>手动写一个node服务器</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url == <span class="string">'/'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> indexFile = fs.createReadStream(<span class="string">'./index.html'</span>)</span><br><span class="line">    req.writeHead(<span class="number">200</span>,&#123;<span class="string">'context-Type'</span>:<span class="string">'text/html;charset = utf8'</span>&#125;)</span><br><span class="line">    indexFile.pipe(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>如何用正则实现 trim()</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> string.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong><a href="https://juejin.im/post/5e16eb2df265da3e0640b290" target="_blank" rel="noopener">手写Promise</a></strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  _this.state = PENDING</span><br><span class="line">  _this.value = <span class="literal">undefined</span></span><br><span class="line">  _this.onFulfilledFunc=[]</span><br><span class="line">  _this.onRejectedFunc=[]</span><br><span class="line">  executor(resolve,rejected)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_this.state===PENDING)&#123;</span><br><span class="line">      _this.value = value</span><br><span class="line">      _this.state = RESOLVED</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_this.state===PENDING)&#123;</span><br><span class="line">      _this.value = value</span><br><span class="line">      _this.state = REJECTED</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.state === RESOLVED)&#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.value)</span><br><span class="line">          resolvePromise(promise,x,resolve,reject)</span><br><span class="line">        &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.state === REJECTED)&#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.value)</span><br><span class="line">          resolvePromise(promise,x,resolve,reject)</span><br><span class="line">        &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.state === PENDING)&#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      self.onFulfilledFunc.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(self.value)</span><br><span class="line">            resolvePromise(promise,x,resolve,reject)</span><br><span class="line">          &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      self.onRejectedFunc.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.value)</span><br><span class="line">            resolvePromise(promise,x,resolve,reject)</span><br><span class="line">          &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise,x,solve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(promise === x &amp;&amp; x !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'发生了循环引用'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'function'</span> || <span class="keyword">typeof</span> x === <span class="string">'object'</span>))&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> then ===<span class="string">'function'</span>)&#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          resolvePromise(promise,y,solve,reject)</span><br><span class="line">        &#125;, e =&gt; &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>用js如何去除url中的#号</strong><br>• 情景一: 单纯将hash路由改变成history路由即可去除hash的#号,此时需要服务器做路由重定向,比如nginx, node重定向<br>• 情景二: 单纯去除#       <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dropHash</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = url.indexOf(<span class="string">'#'</span>)</span><br><span class="line">  <span class="keyword">return</span> i &gt; <span class="number">-1</span> ? url.replace(<span class="regexp">/#/g</span>, <span class="string">''</span>) : url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>手动实现 Array.prototype.map 方法</strong><br>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">arr, mapCallback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || !arr.length || <span class="keyword">typeof</span> mapCallback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 每次调用此函数时，我们都会创建一个 result 数组</span></span><br><span class="line">    <span class="comment">// 因为我们不想改变原始数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      result.push(mapCallback(arr[i], i, arr));</span><br><span class="line">      <span class="comment">// 将 mapCallback 返回的结果 push 到 result 数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>手动实现Array.prototype.filter方法</strong><br>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">arr, filterCallback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || !arr.length || <span class="keyword">typeof</span> filterCallback !== <span class="string">'function'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 每次调用此函数时，我们都会创建一个 result 数组</span></span><br><span class="line">    <span class="comment">// 因为我们不想改变原始数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 检查 filterCallback 的返回值是否是真值</span></span><br><span class="line">      <span class="keyword">if</span> (filterCallback(arr[i], i, arr)) &#123;</span><br><span class="line">      <span class="comment">// 如果条件为真，则将数组元素 push 到 result 中</span></span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// return the result array</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>手动实现Array.prototype.reduce方法</strong><br>reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">arr, reduceCallback, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || !arr.length || <span class="keyword">typeof</span> reduceCallback !== <span class="string">'function'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span></span><br><span class="line">    <span class="keyword">let</span> hasInitialValue = initialValue !== <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">let</span> value = hasInitialValue ? initialValue : arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = hasInitialValue ? <span class="number">0</span> : <span class="number">1</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      value = reduceCallback(value, arr[i], i, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>编写一个可以执行如下操作的函数。</strong>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addSix = createBase(<span class="number">6</span>);</span><br><span class="line">addSix(<span class="number">10</span>); <span class="comment">// 返回 16</span></span><br><span class="line">addSix(<span class="number">21</span>); <span class="comment">// 返回 27</span></span><br></pre></td></tr></table></figure>可以创建一个闭包来存放传递给函数 createBase 的值。被返回的内部函数是在外部函数中创建的，内部函数就成了一个闭包，它可以访问外部函数中的变量，在本例中是变量 baseNumber。     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBase</span>(<span class="params">baseNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">N</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我们在这里访问 baseNumber，即使它是在这个函数之外声明的。</span></span><br><span class="line">    <span class="comment">// JavaScript 中的闭包允许我们这么做。</span></span><br><span class="line">    <span class="keyword">return</span> baseNumber + N;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addSix = createBase(<span class="number">6</span>);</span><br><span class="line">addSix(<span class="number">10</span>);</span><br><span class="line">addSix(<span class="number">21</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>请写出下面代码的运行结果：</strong>        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'settimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>答案<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// settimeout</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组</strong>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>判断一个给定的字符串是否是同构的。</strong><br>paper 和 title 将返回 true。<br>egg 和 sad 将返回 false。<br>dgg 和 add 将返回 true。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIsomorphic</span>(<span class="params">firstString, secondString</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查长度是否相等，如果不相等, 它们不可能是同构的</span></span><br><span class="line">  <span class="keyword">if</span> (firstString.length !== secondString.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> letterMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; firstString.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> letterA = firstString[i],</span><br><span class="line">        letterB = secondString[i];</span><br><span class="line">    <span class="comment">// 如果 letterA 不存在, 创建一个 map，并将 letterB 赋值给它</span></span><br><span class="line">    <span class="keyword">if</span> (letterMap[letterA] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      letterMap[letterA] = letterB;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (letterMap[letterA] !== letterB) &#123;</span><br><span class="line">      <span class="comment">// 如果 letterA 在 map 中已存在, 但不是与 letterB 对应，</span></span><br><span class="line">      <span class="comment">// 那么这意味着 letterA 与多个字符相对应。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 迭代完毕，如果满足条件，那么返回 true。</span></span><br><span class="line">  <span class="comment">// 它们是同构的。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『question 系列』的 js 部分，有一个很关键的部分就是&lt;strong&gt;手写&lt;/strong&gt;的实现。&lt;br&gt;今天我们就把上出现的手写题目，进行梳理。下面我们开始吧。        &lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
      <category term="write-down" scheme="https://jambo0624.github.io/tags/write-down/"/>
    
  </entry>
  
  <entry>
    <title>读《程序是怎么跑起来的》</title>
    <link href="https://jambo0624.github.io/2020-07-26-how-program-works.html"/>
    <id>https://jambo0624.github.io/2020-07-26-how-program-works.html</id>
    <published>2020-07-26T07:47:59.000Z</published>
    <updated>2020-09-26T02:38:56.990Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是《程序是怎么跑起来的》读书笔记。<br>在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。<br>下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: </p><a id="more"></a><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>程序是由指令和数据构成的。<br>CPU所负责的就是解释和运行最终转换成机器语言的程序内容。<br>从功能方面来看， CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。<br><strong>寄存器</strong> 可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。<br><strong>控制器</strong> 负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。<br><strong>运算器</strong> 负责运算从内存读入寄存器的数据。<br><strong>时钟</strong> 负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。</p><p>汇编语言 (assembly) 采用助记符 (memonic) 来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符，助记符通常为指令功能的英语单词的简写。<br>通常我们将汇编语言编写的程序转化成机器语言的过程称为 <strong>汇编</strong> ；反之，机器语言程序转化成汇编语言程序的过程则称为 <strong>反汇编</strong> 。  </p><p>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器 (基址，变址，通用) 一般有多个。<br>CPU每执行一个指令，程序计数器的值就会自动加1。也就是说，<strong>程序计数器</strong> 决定着程序的流程。<br><strong>标志寄存器</strong> 实现了对程序的流程控制。<br>函数调用处理是通过把程序计数器的值设定成函数的<strong>存储地址</strong>来实现的。<br>函数调用使用的是call指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call指令会把 <strong>调用函数后要执行的指令地址</strong> 存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行<code>return</code>命令。<code>return</code>命令的功能是把保存在栈中的地址设定到程序计数器中。  </p><p>第一张结束了，通过第一章。我们要知道几个基本的知识:</p><ol><li>程序就是数据和指令</li><li><code>高级编程语言</code>-&gt;<code>汇编语言</code>-&gt;<code>机器语言</code></li></ol><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>因为 IC 的所有引脚，只有直流电压 0V 或 5V 两个状态。所以，决定了计算机的信息数据只能用二进制数来处理。<br>计算机处理信息的最小单位——位，就相当于二进制中的一位。位的英文 <code>bit</code> 是二进制数位<code>(binary digit)</code>的缩写。<br>8位二进制数被称为一个 <strong>字节</strong> 。字节是最基本的信息计量单位。位是最小单位，字节是基本单位。   </p><p>二进制数的值转换成十进制数的值，只需将二进制数的各数位的值和 <strong>位权</strong> 相乘，然后将相乘的结果相加即可。<br><strong>移位运算</strong> 指的是将二进制数值的各数位进行左右移位 (shift=移位) 的运算。移位有左移 &lt;&lt; (向高位方向) 和右移 &gt;&gt; (向低位方向) 两种。      </p><p>为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加1。<strong>将二进制数的值取反后加1的结果，和原来的值相加，结果为 0</strong><br>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为<strong>逻辑右移</strong>。<br>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值 (0或1) 。这就称为<strong>算术右移</strong>。如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2、1/4、1/8等的数值运算。如果是正数，只需在最高位补0即可。<br>只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式 (逻辑左移) 还是相乘运算 (算术左移) ，都只需在空出来的低位补 0 即可。   </p><p><strong>符号扩充</strong>就是指在保持值不变的前提下将其转换成16位和32位的二进制数。也就是说，不管是正数还是用补数表示的负数，都只需用符号位的值 (0或者1) 填充高位即可。     </p><p>计算机能处理的运算，大体可分为<strong>算术运算</strong>和<strong>逻辑运算</strong>。算术运算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算，包括逻辑非（NOT运算）、逻辑与（AND运算）、逻辑或（OR运算）和逻辑异或（XOR运算）四种。  </p><h3 id="计算机中进行小数计算时出错的原因"><a href="#计算机中进行小数计算时出错的原因" class="headerlink" title="计算机中进行小数计算时出错的原因"></a>计算机中进行小数计算时出错的原因</h3><p>经典面试题目: 0.1 + 0.2 = ?<br>是因为 <strong>“有一些十进制数的小数无法转换成二进制数”</strong>    </p><p><strong>双精度浮点数</strong> 类型用64位、<strong>单精度浮点数</strong> 类型用32位来表示全体小数<br><strong>浮点数</strong> 是指用符号、尾数、基数和指数这四部分来表示的小数<br>64: 1位符号，11位指数，52位尾数<br>32: 1位符号，8位指数，23位尾数</p><p>如何避免计算机计算出错  </p><blockquote><p>首先是回避策略，即无视这些错误。根据程序目的的不同，有时一些微小的偏差并不会造成什么问题。<br>把小数转换成整数来计算。计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题。</p></blockquote><p>在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD方法，以确保最终得到准确的数值。BCD (Binary Coded Decimal) 是一种使用二进制表示十进制的方法。  </p><p>在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。因此，在实际程序中，也经常会用十六进制数来代替二进制数。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><strong>内存</strong> 实际上是一种名为内存IC的电子元件。内存IC中有<code>电源</code>、<code>地址信号</code>、<code>数据信号</code>、<code>控制信号</code>等用于输入输出的大量引脚（IC的引脚），通过为其指定地址（address），来进行数据的读写。  </p><p>编程语言中的<strong>数据类型</strong>表示存储的是何种类型的数据。<br>从内存来看，就是占用的内存大小的意思。<br>即使是物理上以1个字节为单位来逐一读写数据的内存，在程序中，通过指定其类型（变量的数据类型等），也能实现以特定字节数为单位来进行读写。      </p><p><strong>指针</strong>也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写。   </p><p>数组是高效实用内存的基础。<br><strong>数组</strong>是指多个同样数据类型的数据在内存中连续排列的形式。<br>作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引<code>(index)</code>。<br>指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由<strong>编译器</strong>自动实现的。<br>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。  </p><p><strong>栈</strong>用的是<code>LIFO</code>（Last Input First Out，后入先出）方式，而队列用的则是<code>FIFO</code>（First Input First Out，先入先出）方式。<br><strong>队列</strong>一般是以<code>环状缓冲区</code>（ring buffer）的方式来实现的  </p><p>在数组的各个元素中，除了数据的值之外，通过为其附带上下一个元素的索引，即可实现<strong>链表</strong>。使用<strong>链表</strong>来追加或删除数据则毫不费事。   </p><h3 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h3><blockquote><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。即使CPU可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低。总之，存储在磁盘中的程序需要读入到内存后才能运行。</p></blockquote><p>磁盘缓存 (disk cache) 指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。使用磁盘缓存可以大大改善磁盘数据的访问速度<br>虚拟内存 (virtual memory) 是指把磁盘的一部分作为假想的内存来使用。<br>虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的。也就是说，为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。    </p><p>节约内存的编程方法<br>(1) 通过DLL文件实现函数共有<br>DLL（Dynamic Link Library）文件，顾名思义，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。此外，还有一个需要大家注意的地方，那就是多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。<br>Windows的操作系统本身也是多个DLL文件的集合体。有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。<br>(2) 通过调用_stdcall来减小程序文件的大小<br><strong>栈清理处理</strong>是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。<br>该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。<br>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。这时所使用的就是_stdcall。<br>在函数前加上_stdcall，就可以把栈清理处理变为在被调用函数一方进行。</p><p>磁盘的物理结构<br>扇区是对磁盘进行物理读写的最小单位。<br>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用1簇的空间。这样一来，所有的文件都会占用1簇的整数倍的磁盘空间。<br>以簇为单位进行读写时，1簇中没有填满的区域会保持不被使用的状态。虽然这看起来是有点浪费，不过该机制就是如此规定的，所以我们也没有什么好办法。另外，如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。由于在磁盘表面上，表示扇区区分的领域是必要的，因此，如果簇的容量过小，磁盘的整体容量也会减少。扇区和簇的大小，是由处理速度和存储容量的平衡来决定的。   </p><h3 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h3><p>RLE算法: 把文件内容用<code>数据×重复次数</code>的形式来表示的压缩方法称为RLE (Run Length Encoding，行程长度编码) 算法。<br>在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE算法可以发挥不错的效果，但它并不适合文本文件的压缩。   </p><p><strong>莫尔斯编码</strong>是根据日常文本中各字符的出现频率来决定表示各字符的编码的数据长度的。<br>使用<strong>哈夫曼树</strong>后，出现频率越高的数据所占用的数据位数就越少，而且数据的区分也可以很清晰地实现。   </p><h3 id="程序是在何种环境中运行的"><a href="#程序是在何种环境中运行的" class="headerlink" title="程序是在何种环境中运行的"></a>程序是在何种环境中运行的</h3><p>应用的运行环境，是指<code>操作系统</code>和<code>计算机本身(硬件)</code>的种类   </p><p>机器语言的程序称为<strong>本地代码</strong> (native code)<br>程序员用C语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为<strong>源代码</strong>。    </p><p>应用程序向操作系统传递指令的途径称为API (ApplicationProgramming Interface)<br>BIOS (BasicInput/Output System)。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。<br><strong>引导程序</strong>是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。   </p><h3 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h3><p>源代码完成后，就可以编译生成可执行文件了。负责实现该功能的是编译器。<br><code>Dump</code> 是指把文件的内容，每个字节用2位十六进制数来表示的方式。</p><p>能够把C语言等高级编程语言编写的源代码转换成本地代码的程序称为<strong>编译器</strong>。<br>但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p><p>编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理。<br>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行连接的程序就称为<strong>链接器</strong>（linkage editor或连结器）  </p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ilink32 -Tpe -c -x -aa c0w32.obj Sample1.obj, Sample1.exe, ,</span><br><span class="line">import32.lib cw32.lib</span><br></pre></td></tr></table></figure><p>c0w32.obj这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的<strong>启动</strong>。<br>因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来。     </p><p>像import32.lib及cw32.lib这样的文件称为库文件。<br><strong>库文件</strong>指的是把多个目标文件集成保存到一个文件中的形式。<br><strong>链接器</strong>指定<strong>库文件</strong>后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件。    </p><p><code>sprintf()</code>等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为<code>标准函数</code>。<br>之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这一过程。   </p><p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL（Dynamic Link Library）文件的特殊库文件中。<br>就如Dynamic这一名称所表示的那样，DLL文件是程序运行时动态结合的文件。  </p><p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为<strong>静态链接库</strong>。<br>静态（static=静态的）同动态（dynamic=动态的）是相反的意思。存储着<code>sprintf()</code>的目标文件的cw32lib就是静态链接库。<br><code>sprintf()</code>提供了通过指定格式把数值转换成字符串的功能。   </p><p>那就是EXE文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在EXE文件的开头，追加转换内存地址所需的必要信息。这个信息称为<strong>再配置信息</strong>。<br>EXE文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离。   </p><p>EXE文件的内容分为再配置信息、变量组和函数组<br>当程序加载到内存后，除此之外还会额外生成两个组，那就是栈和堆。<br><strong>栈</strong>是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域。<br><strong>堆</strong>是用来存储程序运行时的任意数据及对象的内存领域<br>EXE文件中并不存在栈及堆的组。栈和堆需要的内存空间是在EXE文件加载到内存后开始运行时得到分配的。<br>因而，内存中的程序，就是由<code>用于变量的内存空间</code>、<code>用于函数的内存空间</code>、<code>用于栈的内存空间</code>、<code>用于堆的内存空间</code>这4部分构成的。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。不过，在内存的使用方法上，二者存在些许不同。栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。与此相对，堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。<br><strong>栈</strong>中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。<br>与此相对，<strong>堆</strong>的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。<br>如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为<strong>内存泄露</strong>（memory leak）   </p><blockquote><p>Q：编译器和解释器有什么不同？<br>A：<strong>编译器</strong>是在运行前对所有源代码进行解释处理的。而<strong>解释器</strong>则是在运行时对源代码的内容一行一行地进行解释处理的。<br>Q：“分割编译”指的是什么？<br>A：将整个程序分为多个源代码来编写，然后分别进行编译，最后链接成一个EXE文件。这样每个源代码都相对变短，便于程序管理。<br>Q：“Build”指的是什么？<br>A：根据开发工具种类的不同，有的编译器可以通过选择“Build”菜单来生成EXE文件。这种情况下，<strong><code>Build</code>指的是连续执行编译和链接</strong>。<br>Q：使用DLL文件的好处是什么？<br>A: DLL文件中的函数可以被多个程序共用。因此，借助该功能可以节约内存和磁盘。此外，在对函数的内容进行修正时，还不需要重新链接（静态链接）使用这个函数的程序。<br>Q：不链接导入库的话就无法调用DLL文件中的函数吗？<br>A：通过使用LoadLibrary()及GetProcAddress()这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。不过使用导入库更简单一些。<br>Q：“叠加链接”这个术语指的是什么？<br>A：将不会同时执行的函数，交替加载到同一个地址中运行。通过使用“叠加链接器”这一特殊的链接器即可实现。在计算机中配置的内存容量不多的MS-DOS时代，经常使用叠加链接。</p></blockquote><p>IDE: Integrated Development Environment，即继承了变成所需的各种工具的开发软件。<br>CPU: Central Processing Unit (中央处理器)<br>IC: Integrated Circuit (集成电路)<br>DLL: Dynamic Link Library</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是《程序是怎么跑起来的》读书笔记。&lt;br&gt;在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。&lt;br&gt;下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: &lt;/p&gt;
    
    </summary>
    
    
      <category term="program" scheme="https://jambo0624.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://jambo0624.github.io/tags/program/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>CodeStandard</title>
    <link href="https://jambo0624.github.io/2020-07-19-code-standard.html"/>
    <id>https://jambo0624.github.io/2020-07-19-code-standard.html</id>
    <published>2020-07-19T03:16:16.000Z</published>
    <updated>2020-08-12T14:31:54.468Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：</p><ul><li>谨记代码是给人看的，它们只是恰巧能跑而已<a id="more"></a></li></ul><h4 id="能愿动词说明"><a href="#能愿动词说明" class="headerlink" title="能愿动词说明"></a>能愿动词说明</h4><p> 本文统一采用以下几个能愿动词作为规范的约束强度。</p><ul><li><code>必须（Must）</code>：只能这样做，请无条件遵守</li><li><code>绝不（Must Not）</code>：严令禁止，在任何情况下都不能这么做</li><li><code>应该（Should）</code>：强烈建议这样做，但是并不强求</li><li><code>不应该（Should Not）</code>：强烈建议不这样做，但是并不强求</li><li><code>可以（May）</code>：你可以按照自己的喜好去做</li></ul><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><p>下面几个词组指代四种命名风格。</p><ul><li><code>camelCase</code>：小驼峰</li><li><code>PascalCase</code>：大驼峰</li><li><code>kebab-case</code>：小写 + 中划线</li><li><code>kebab_ase</code>：小写 + 下划线</li></ul><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h3 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h3><h4 id="lang属性"><a href="#lang属性" class="headerlink" title="lang属性"></a>lang属性</h4><p>html 标签 <strong>必须</strong> 设置 lang 属性，此属性值 <strong>应该</strong> 与目标用户的第一语言保持一致。<br>当使用i18n等工具进行页面语言的切换时，此属性值也 <strong>应该</strong> 一并切换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh_CN"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="img-标签的-alt-属性"><a href="#img-标签的-alt-属性" class="headerlink" title="img 标签的 alt 属性"></a>img 标签的 alt 属性</h4><p>每一个 img 标签都 <strong>应该</strong> 有一个 alt 属性， 且它的内容 <strong>应该</strong> 尽可能详尽地描述这张图片的作用。<br>它除了能提供信息以及更好的 seo 之外，还能帮助视障人士。</p><h4 id="中文和西文之间的空格"><a href="#中文和西文之间的空格" class="headerlink" title="中文和西文之间的空格"></a>中文和西文之间的空格</h4><p>页面上的中文和西文（数字）之间 <strong>必须</strong> 有一个空格。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia是混成词，分别取自于网站核心技术Wiki以及英文中百科全书之意的encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia 是混成词，分别取自于网站核心技术 Wiki 以及英文中百科全书之意的 encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>皇后乐队是英国摇滚乐乐队，成立于 1970 年。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><h4 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h4><p><strong>必须</strong> 在所有样式文件前引入 <a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a> 用于消除各个浏览器之间的差异。<br>对于不同的项目，<strong>应该</strong> 根据需求设立 reset 样式集，并在 Normalize.css 之后引入。 Reset 样式集应该秉承最小化原则。</p><h4 id="简化版的CSS-BEM"><a href="#简化版的CSS-BEM" class="headerlink" title="简化版的CSS BEM"></a>简化版的CSS BEM</h4><p><a href="http://getbem.com/introduction/" target="_blank" rel="noopener">CSS BEM</a>是一种可以有效降低样式冲突概率的 css 选择器方法，但这种风格的代码对绝大部分项目来说是 too heavy 的。<br>这里提出一种简化的方案，只有”层级”和”断字”的概念。使用中划线 <code>-</code> 表示层级，使用下划线 <code>_</code> 表示断字。项目 <strong>必须</strong> 严格遵守该规范。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-img"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-login"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-sign_up"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>如果项目要使用 Css 预处理器， <strong>应该</strong>优先使用 Sass，且 <strong>必须</strong> 使用 Scss 语法。使用 Scss 语法对上方的 html 代码进行选择会变得非常简单易行。<br>每一个 Scss 选择器后面 <strong>必须</strong> 有一个空行。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  &amp;-logo &#123;</span><br><span class="line">    &amp;-<span class="selector-tag">img</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    &amp;-text &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &amp;-navbar &#123;</span><br><span class="line">    &amp;-item &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &amp;-login &#123;&#125;</span><br><span class="line">    &amp;-sign_up &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择器命名"><a href="#选择器命名" class="headerlink" title="选择器命名"></a>选择器命名</h4><p>选择器命名的第一要务是见名知意。</p><ul><li>对于一些常见的、约定俗成的单词简写，<strong>可以</strong> 使用简写形式。如：<code>description</code>-&gt;<code>desc</code></li><li><strong>绝不</strong> 使用简写后有多种释义，或是简写后无法辨别含义的单词简写。如：<code>description</code>-&gt;<code>des</code>,<code>fc</code></li><li>嵌套层级 <strong>不应该</strong> 过深，当出现三到四层嵌套后，可以使用全新的选择器名称。如：<code>.page-header-logo{ .title ...}</code></li></ul><h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>所有项目都 <strong>应该</strong> 使用 Babel 进行转义，而源码都 <strong>应该</strong> 拥抱已经发布的 ECMAScript 特性。</p><h4 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h4><p>所有项目都 <strong>应该</strong> 使用 ESLint 进行代码格式检查。</p><h4 id="const-let-和-var"><a href="#const-let-和-var" class="headerlink" title="const, let 和 var"></a>const, let 和 var</h4><p><code>const</code> <strong>必须</strong> 是第一公民，次之是 <code>let</code>。被 Babel (或其他转义工具)转义的项目中 <strong>绝不</strong> 出现 <code>var</code>。</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>变量命名的第一要务是见名知意。</p><ul><li>布尔型的变量 <strong>应该</strong> 以 <code>is</code> 或 <code>flag</code> 开头。如：<code>isVisible</code></li><li>数值类型的变量 <strong>必须</strong> 采用复数形式的名词。如：<code>users</code>,<code>categories</code></li><li>对于单复同行的数值型变量，<strong>应该</strong> 添加其他的单词进行辅助释义。如：<code>newsList</code></li><li>对象类型的变量 <strong>必须</strong> 采用单数形式的名词。如:<code>user</code></li><li>函数 (方法) 命名 <strong>必须</strong> 是以动词开头的 camelCase 风格。如: <code>createUser</code>, <code>validateForm</code></li><li>对于项目中约定的常量 (如配置项等)，<strong>应该</strong> 使用 PASCAL_CASE 风格。如: <code>HEADER_MENU</code>, <code>PRIMARY_COLOR</code></li><li>类( Class )的名称 <strong>必须</strong> 采用 PascalCase 形式，且 <strong>应该</strong> 拟人化。如: <code>Permission</code>, <code>FormValidator</code></li><li>任何变量的命名都 <strong>不应该</strong> 过于生僻和抽象</li></ul><h4 id="一些推荐使用的函数首部动词"><a href="#一些推荐使用的函数首部动词" class="headerlink" title="一些推荐使用的函数首部动词"></a>一些推荐使用的函数首部动词</h4><ul><li><code>do</code>/<code>deal</code>：做某些事情</li><li><code>go</code>：跳转、前往</li><li><code>get</code>/<code>fetch</code>：获取某些事物</li><li><code>set</code>：设置某些事物</li><li><code>make</code>/<code>create</code>：创建</li><li><code>edit</code>/<code>update</code>：编辑</li><li><code>delete</code>/<code>destory</code>：删除</li><li><code>handle</code>：被其他操作触发了</li></ul><h4 id="Restful-Actions"><a href="#Restful-Actions" class="headerlink" title="Restful Actions"></a>Restful Actions</h4><p>对于项目中的接口，<strong>应该</strong> 将 ajax 请求拆分为请求函数以实现复用以及提高项目的可维护性。<br>如果接口使用 Restful API，那么前端对应的方法名 <strong>可以</strong> 按照下面的规范来进行命名。</p><ul><li><code>get</code> <code>/books</code>=&gt;<code>reqFetchBooks</code></li><li><code>get</code> <code>/books/:id</code>=&gt;<code>reqShowBooks</code></li><li><code>post</code> <code>/books</code>=&gt;<code>reqCreateBooks</code></li><li><code>post,put,patch</code> <code>/books/:id</code>=&gt;<code>reqUpdateBooks</code></li><li><code>delete</code> <code>/books/:id</code>=&gt;<code>reqDestoryBooks</code></li></ul><h4 id="数组的循环"><a href="#数组的循环" class="headerlink" title="数组的循环"></a>数组的循环</h4><p>在使用循环时， <strong>不应该</strong> 使用<code>item</code>作为数组的元素名，而 <strong>应该</strong> 使用数组的单数形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">books.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; &#125;);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">books.map(<span class="function"><span class="params">book</span> =&gt;</span> &#123; &#125;);</span><br><span class="line">newsList.map(<span class="function"><span class="params">news</span> =&gt;</span> &#123; &#125;)</span><br></pre></td></tr></table></figure><h4 id="if的处理"><a href="#if的处理" class="headerlink" title="if的处理"></a>if的处理</h4><p>每一个<code>if</code>都 <strong>必须</strong> 囊括所有情况，也就是说每一种逻辑都可以被 if 处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125; <span class="keyword">else</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>部分<code>if else</code>逻辑 <strong>可以</strong> 通过及时 <code>return</code> 减少嵌套层数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// correct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (a !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br></pre></td></tr></table></figure><p>过多的<code>!a || b</code> <strong>应该</strong> 被转换为<code>!(a &amp;&amp; b)</code>，这种逻辑更符合直觉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not bad</span></span><br><span class="line"><span class="keyword">if</span> (!a || !b) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (!(a &amp;&amp; b)) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>注释本身 <strong>不应该</strong> 对变量或方法本身是做什么的进行解释。这要求变量命名尽可能得见名知意。</li></ul><h3 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h3><p><strong>NOTICE HERE</strong>： Vue 的相关规范全部基于官方的<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">风格指南</a>， 并在此基础上进行了一些修改和约束。</p><h4 id="组件文件命名"><a href="#组件文件命名" class="headerlink" title="组件文件命名"></a>组件文件命名</h4><ul><li>页面、路由相关的组件 <strong>应该</strong> 使用一个单词命名</li><li>非页面、路由相关的组件 <strong>应该</strong> 使用<code>PascalCase</code>风格命名</li><li>组件 <strong>应该</strong> 拟人化。如：<code>UserCreator</code>,<code>Selector</code></li></ul><h4 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h4><p>如果文件夹内拥有<code>index.vue</code>，那么引入时 <strong>应该</strong> 省略 index 字样， 并在末尾添加 <code>/</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/'</span></span><br></pre></td></tr></table></figure><p>引入组件时，模块名 <strong>必须</strong> 为 <code>PascalCase</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="根标签书写规范"><a href="#根标签书写规范" class="headerlink" title="根标签书写规范"></a>根标签书写规范</h4><p>vue 文件中的标签书写顺序 <strong>必须</strong> 为：</p><ol><li><code>&lt;template&gt;&lt;/template&gt;</code></li><li><code>&lt;script&gt;&lt;/script&gt;</code></li><li><code>&lt;style&gt;&lt;/style&gt;</code></li></ol><h3 id="lt-template-gt-lt-template-gt-根标签"><a href="#lt-template-gt-lt-template-gt-根标签" class="headerlink" title="&lt;template&gt;&lt;/template&gt;根标签"></a><code>&lt;template&gt;&lt;/template&gt;</code>根标签</h3><p>每一个根标签下的顶级元素都 <strong>必须</strong> 有一个与当前文件名对应的 css 选择器。在本规范中， <strong>应该</strong> 使用<code>文件名</code>的<code>kebab_case</code>结构作为该 css 选择器。如：<code>SelectorGender</code>-&gt;<code>selector_gender</code><br>如果为了进一步降低组件间的样式冲突的可能性， <strong>可以</strong> 使用 <code>文件夹层级</code> + <code>文件名</code> 共同组装成根组件的根选择器。假定有以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- common &lt;dir&gt;</span><br><span class="line">|  |-- selectors &lt;dir&gt;</span><br><span class="line">|  |  |-- SelectorGender &lt;file&gt;</span><br></pre></td></tr></table></figure><p>那么其对应的唯一 css 选择器名应该为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;common-selectors-selector_gender&quot;&gt;</span><br><span class="line">     &lt;!--    --&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-script-gt-lt-script-gt-根标签"><a href="#lt-script-gt-lt-script-gt-根标签" class="headerlink" title="&lt;script&gt;&lt;/script&gt;根标签"></a><code>&lt;script&gt;&lt;/script&gt;</code>根标签</h3><p>实例选项顺序<br>组件实例中的选项顺序 <strong>必须</strong> 按照 vue 风格指南的要求进行排版</p><ol><li><code>el</code></li><li><code>name</code></li><li><code>parent</code></li><li><code>functional</code></li><li><code>delemiters</code></li><li><code>comments</code></li><li><code>components</code></li><li><code>directives</code></li><li><code>filters</code></li><li><code>extends</code></li><li><code>mixins</code></li><li><code>inheritAttrs</code></li><li><code>model</code></li><li><code>props/prosData</code></li><li><code>data</code></li><li><code>computed</code></li><li><code>watch</code></li><li><code>beforeCreated</code></li><li><code>created</code></li><li><code>beforeMounted</code></li><li><code>mounted</code></li><li><code>beforeUpdate</code></li><li><code>updated</code></li><li><code>activated</code></li><li><code>deactivated</code></li><li><code>beforeDestory</code></li><li><code>destoryed</code></li><li><code>methods</code></li><li><code>template/render</code></li><li><code>renderError</code></li></ol><h4 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h4><p>各个选项间 <strong>必须</strong> 间隔一个空行，而内部的值或方法不空行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Demo'</span>,</span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tableData: <span class="string">''</span>,</span><br><span class="line">      userInfo: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    getTableData () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getUserInfo () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：name"><a href="#实例选项：name" class="headerlink" title="实例选项：name"></a>实例选项：<code>name</code></h4><p>每一个组件 <strong>必须</strong> 有一个 <code>name</code> 实例选项，其值 <strong>必须</strong> 为被其他组件引入时的模块名。如果你的组件命名完全符合本规范，那么一般情况下，此属性的值应与组件的文件名保持一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file name: MyComponent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// worst</span></span><br><span class="line">  <span class="comment">// no name</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'my-component'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'myComponent'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  name: <span class="string">'MyComponent'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * use this component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'../common/MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="实例选项：props"><a href="#实例选项：props" class="headerlink" title="实例选项：props"></a>实例选项：<code>props</code></h4><p>组件需要的参数，都 <strong>应该</strong> 拥有完善的验证规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    demo:&#123;</span><br><span class="line">      type: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="params">val</span> =&gt;</span> [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'first'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="string">'second'</span>].includes(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：data"><a href="#实例选项：data" class="headerlink" title="实例选项：data"></a>实例选项：<code>data</code></h4><ul><li><strong>不应该</strong> 使用 <code>Vue.set()</code> 方式为组件扩展响应式的 data</li><li><strong>应该</strong> 将一些同属于某一块页面元素的 data 合并为对象的形式，避免 data 的扁平化</li><li>每一个 data 都 <strong>必须</strong> 是被使用到的</li></ul><h4 id="实例选项-生命周期函数"><a href="#实例选项-生命周期函数" class="headerlink" title="实例选项: 生命周期函数"></a>实例选项: 生命周期函数</h4><p>生命周期函数内 <strong>不应该</strong> 直接书写过多的业务逻辑。如果逻辑过多，<strong>应该</strong> 在 methods 中定义独立的函数并在生命周期函数中进行调用。</p><h3 id="lt-style-gt-lt-style-gt-根标签"><a href="#lt-style-gt-lt-style-gt-根标签" class="headerlink" title="&lt;style&gt;&lt;/style&gt;根标签"></a><code>&lt;style&gt;&lt;/style&gt;</code>根标签</h3><ul><li><strong>必须</strong> 添加 scoped 属性</li><li><strong>必须</strong> 使用 sass 预处理器，并且使用 scss 语法</li><li>所有的组件内样式 <strong>必须</strong> 被该组件的唯一 css 选择器包裹<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"selector_gender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.selector_gender</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* ... */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="关于命名的（最佳）实践"><a href="#关于命名的（最佳）实践" class="headerlink" title="关于命名的（最佳）实践"></a>关于命名的（最佳）实践</h3><ul><li>在 Dom 上绑定的事件回调方法 <strong>应该</strong> 使用<code>on</code>+<code>动词</code>+<code>名词</code>形式。如：<code>@click=&quot;onCreateUser&quot;</code></li><li>子组件 emit 的事件名称 <strong>应该</strong> 使用 <code>动词的一般现在时</code>。如：<code>@click</code>,<code>@submit</code></li><li>子组件 emit 的事件回调方法 <strong>应该</strong> 使用<code>handle</code>+<code>名词</code>+<code>动词过去式</code>形式。如：<code>@submit=&quot;handleUserCreated&quot;</code></li><li><strong>应该</strong> 正确使用<code>or</code>和<code>and</code>。详见下方示例<br>一个完整的例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"users"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onCreateUser"</span>&gt;</span>Create User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onEditUser(scope.row)"</span>&gt;</span>Edit User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">:loading</span>=<span class="string">"isDeletingUser"</span> @<span class="attr">click</span>=<span class="string">"onDeleteUser(scope.row)"</span>&gt;</span>Delete User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">user-creator-and-editor</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ref</span>=<span class="string">"userCreatorAndEditor"</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">submit</span>=<span class="string">"handleUserCreatedOrEdited"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user-creator-and-editor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> UserCreatorAndEditor <span class="keyword">from</span> <span class="string">'./UserCreatorAndEditor'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; reqDestoryUser &#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'Users'</span>,</span></span><br><span class="line"></span><br><span class="line">    components: &#123; UserCreatorAndEditor &#125;,</span><br><span class="line"></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        isDeletingUser: <span class="literal">false</span>,</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">      onCreateUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'create'</span> &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      onEditUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'edit'</span>, userId: id &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      handleUserCreatedOrEdited(result) &#123;</span><br><span class="line">        if(result) &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line">        &#125;     </span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="keyword">async</span> onDeleteUser(&#123; id &#125;) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">await</span> reqDestoryUser(id);</span></span><br><span class="line"><span class="actionscript">           <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">finally</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">false</span></span></span><br><span class="line">        &#125;   </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>每个方法和变量都见名知意，并且永不重复！</li></ul><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><p><strong>不应该</strong> 使用路由大量传递参数,请尽可能地保证<code>clean and beautiful</code>。</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p><strong>应该</strong> 使用<code>module</code>组织 vuex，而非全部注册在顶级。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>绝不</strong> 给 Vue 挂载大体量的插件或扩展， <strong>应该</strong> 在需要用到的页面进行按需引入</li><li><strong>不应该</strong> 直接选取某个 dom 元素进行直接的 dom 操作( Echarts 等插件除外)</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>项目的技术文档 <strong>必须</strong> 使用 Markdown 格式编写。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><ul><li>英文文档 <strong>必须</strong> 使用半角标点符号</li><li>中文文档中以下标点符号 <strong>必须</strong> 使用半角，并在其后添加一个空格<ul><li>引号: <code>&quot;&quot;</code></li><li>冒号: <code>:</code></li><li>感叹号: <code>!</code></li><li>问号: <code>?</code></li><li>所有的括号: <code>() [] {}</code></li></ul></li><li>中文文档中以下标点符号 <strong>必须</strong> 使用全角，其后不需要添加空格<ul><li>逗号: <code>，</code></li><li>句号: <code>。</code></li><li>省略号: <code>……</code></li></ul></li></ul><h3 id="Markdown-语法约束"><a href="#Markdown-语法约束" class="headerlink" title="Markdown 语法约束"></a>Markdown 语法约束</h3><ul><li><strong>必须</strong> 有且仅有一个一级标题</li><li>标题的层级最多 <strong>不应该</strong> 超过三级</li><li>句子的末尾 <strong>必须</strong> 有句号</li><li>无序列表和有序列表的末尾 <strong>不应该</strong> 添加句号</li><li><strong>应该</strong> 优先选用无需列表而非有序列表</li><li>用于表明格式的关键字符 <strong>必须</strong> 前后各留一个空格</li><li>标题与段落之间 <strong>必须</strong> 前后各留一个空行</li></ul><h3 id="的，得，地"><a href="#的，得，地" class="headerlink" title="的，得，地"></a>的，得，地</h3><p><strong>必须</strong> 正确使用<code>的</code>，<code>得</code>，<code>地</code>。</p><h3 id="项目版本"><a href="#项目版本" class="headerlink" title="项目版本"></a>项目版本</h3><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>项目开发过程中的版本迭代 <strong>应该</strong> 遵循类似 npm 的版本定义方法。即:</p><ul><li><code>1.1.1</code> -&gt; <code>1.1.2</code>: 向下兼容的问题修复</li><li><code>1.1.1</code> -&gt; <code>1.2.1</code>: 向下兼容的功能迭代</li><li><code>1.1.1</code> -&gt; <code>2.1.1</code>: 发生了非向下兼容的功能迭代</li></ul><h4 id="版本迭代及分支管理"><a href="#版本迭代及分支管理" class="headerlink" title="版本迭代及分支管理"></a>版本迭代及分支管理</h4><ul><li><code>master</code>分支 <strong>必须</strong> 对应线上代码</li><li>对于开发告一段落，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><ul><li>安装依赖时 <strong>必须</strong> 按照功能严格区分生产环境依赖和开发环境依赖</li><li><strong>绝不</strong> 遗留未被使用的依赖。如果不使用某个依赖时， <strong>必须</strong> 第一时间进行卸载</li><li><strong>绝不</strong> 在未获得其他开发人员同意的情况下升级依赖版本</li><li><strong>应该</strong> 优先使用使用量大、受众面广的依赖</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="使用If"><a href="#使用If" class="headerlink" title="使用If"></a>使用If</h4><p>Windows 下的 Git 默认使用<code>crlf</code>作为换行符，甚至会将<code>lf</code>转换为<code>crlf</code>。本规范要求所有的换行都 <strong>必须</strong> 使用<code>lf</code>风格。</p><p>Q: 安装 Git 时，忘记去勾了 crlf 自动替换的选项，怎么办？<br>A: 执行以下命令:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.eol lf</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><ul><li>开发分支 <strong>必须</strong> 是<code>develop</code></li><li>功能分支 <strong>必须</strong> 以<code>feature/</code>开头。如: <code>feature/user_system</code></li><li>开发完毕，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h4 id="Merge-Request-Pull-Request"><a href="#Merge-Request-Pull-Request" class="headerlink" title="Merge Request(Pull Request)"></a>Merge Request(Pull Request)</h4><p>每一次分支合并都 <strong>必须</strong> 发起一个<code>Merge Request</code>，并且交由他人评审。</p><h3 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h3><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><ul><li><code>src</code><ul><li><code>api</code>: 存放 API 资源</li><li><code>assets</code>: 存放需要被 Webpack 处理的静态资源</li><li><code>components</code>: 存放于项目无关的公共组件。理论上这些组件可以被任何项目直接使用</li><li><code>config</code>: 存放一些项目配置文件</li><li><code>models</code>: 存放前端的数据模型。如果项目使用了 Typescript， 理论上不需要设置改目录</li><li><code>router</code>: Vue 路由</li><li><code>store</code>: Vuex。 <strong>应该</strong> 只包含<code>modules</code>和<code>index.js</code>，保证 vuex 所有功能都尽可能按照模块划分<ul><li><code>modules</code>: Vuex 的模块</li><li><code>index.js</code></li></ul></li><li><code>styles</code>: 存放全局样式。样式文件 <strong>必须</strong> 使用 Scss 进行组织; 作为子文件的样式文件 <strong>必须</strong> 使用 <code>_</code>开头<ul><li><code>_common.scss</code>: 公共样式文件</li><li><code>_hack.scss</code>: 对各种组件库或其他样式进行加强修改。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>_mixins.scss</code>: 提供全局的 Scss Mixins</li><li><code>_reset.scss</code>: 对页面样式进行重置。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>main.scss</code>: 按照一定的顺序注册全部样式文件。被<code>main.js</code>引入</li><li><code>resource.scss</code>: 被<code>scss-loader</code>处理，注册全局可用的 Scss 资源</li></ul></li><li><code>utils</code>: 各种工具<ul><li><code>http.js</code>: 请求层。<strong>必须</strong> 优先使用<code>axios</code></li></ul></li><li><code>views</code>: 视图层</li><li><code>App.vue</code></li><li><code>main.js</code>: 文件内容 <strong>必须</strong> 尽可能短小且清晰</li></ul></li><li><code>.editorconfig</code></li><li><code>.prettierignore</code></li><li><code>.prettierrc.js</code></li><li><code>.prettierrc.js</code></li><li><code>CHANGELOG.md</code>: 项目更新日志。在每一次上线前都 <strong>必须</strong> 进行补全</li><li><code>README.md</code>: 用来说明项目，以及帮助其他人快速上手项目</li></ul><h4 id="main-scss-组织"><a href="#main-scss-组织" class="headerlink" title="main.scss 组织"></a>main.scss 组织</h4><p>由于样式存在后者覆盖前者的问题，因此 main.scss <strong>必须</strong> 按照一定的顺序进行组织。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络资源 (network resources)</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">"https://fonts.googleapis.com/css?family=Nunito"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地资源 (local resources)。如: 变量，mixin，图标</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"iconfont"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式重置 (reset)。推荐优先使用 normalize.css，自己书写的 reset 文件的内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~normalize.css/normalize.css"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"reset"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方库 (libraries)</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~element-ui/packages/theme-chalk/src/index"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~swiper/css/swiper"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共样式 (common)。如果有需要的话，给公共样式加入一个前缀以作区分，如 ` g-container `</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"common"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图 (views)。对于一个 vue 项目，可能不需要引入视图内的样式</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/layout/home"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/widgets/header"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强行重置某些样式 (hack)。内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"hack"</span>;</span><br></pre></td></tr></table></figure><h4 id="Scss全局资源"><a href="#Scss全局资源" class="headerlink" title="Scss全局资源"></a>Scss全局资源</h4><blockquote><p>参考官方文档: <a href="https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项</a></p></blockquote><p>在<code>src/styles/</code>目录下创建<code>resources.scss</code>文件，用于存放全局可以使用的样式资源，如变量，mixin 等。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br></pre></td></tr></table></figure><p>在<code>vue.config.js</code>中进行了配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: <span class="string">`@import "@/styles/resources.scss";`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Editorconfig"><a href="#Editorconfig" class="headerlink" title="Editorconfig"></a>Editorconfig</h3><p>每一个项目都 <strong>必须</strong> 添加<code>Editorconfig</code>文件，并且每一个开发人员的编辑器都 <strong>必须</strong> 安装该插件。<br>下面是一份推荐使用的 editorconfig 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset = utf<span class="number">-8</span></span><br><span class="line">end_of_line = lf</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = <span class="number">2</span></span><br><span class="line">tab_width = <span class="number">2</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p>所有项目都 <strong>必须</strong> 使用<code>Prettier</code>进行代码的格式化。<br>下面是一份推荐使用的 prettier 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line">modules.export = &#123;</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: <span class="string">"*.&#123;js,ts,jsx,tsx,vue&#125;"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        singleQuote: <span class="literal">true</span>,</span><br><span class="line">        printWidth: <span class="number">100</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谨记代码是给人看的，它们只是恰巧能跑而已
    
    </summary>
    
    
      <category term="standard" scheme="https://jambo0624.github.io/categories/standard/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="standard" scheme="https://jambo0624.github.io/tags/standard/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』network&amp;performance questions</title>
    <link href="https://jambo0624.github.io/2020-06-14-network-question.html"/>
    <id>https://jambo0624.github.io/2020-06-14-network-question.html</id>
    <published>2020-06-14T05:20:34.000Z</published>
    <updated>2020-10-19T09:00:26.245Z</updated>
    
    <content type="html"><![CDATA[<p>今天是『question 系列』的 http 和 performance 部分， js 部分我们放在最后。<br>下面我们开始吧。        </p><a id="more"></a><h2 id="network部分"><a href="#network部分" class="headerlink" title="network部分"></a>network部分</h2><ul><li>304的缓存原理（添加Etag标签.last-modified）<br>304 网页上次请求没有更新，节省带宽和开销            </li></ul><ol><li>服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）        </li><li>304是    HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件                 </li><li>流程：客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。    </li></ol><p>=&gt; 有了Last-Modified，为什么还要用ETag？          </p><ol><li>因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）       </li><li>某些服务器不能精确的得到文件的最后修改时间                                     </li><li>一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get    </li></ol><p>=&gt; 有了ETag，为什么还要用Last-Modified？    </p><ol><li>两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改      </li><li>如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）      </li><li>ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。      </li></ol><ul><li>TCP的三次握手和四次挥手<br>三次握手<br>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；<br>第二次握手：服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接<br>第三次握手：客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；<br>四次挥手<br>第一次挥手：客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；<br>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成<br>第三次挥手：服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕<br>第四次挥手：客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；       </li></ul><ul><li>为什么建立连接是三次握手，而断开连接是四次挥手呢?<br>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。       </li></ul><ul><li>http协议的理解    </li></ul><ol><li><p>超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议    </p></li><li><p>基于TCP/IP通信协议来传递数据（HTML，图片资源）    </p></li><li><p>基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统    </p></li><li><p>http请求信息request：<br>请求行（request line）、请求头部（header）,空行和请求数据四部分构成    </p><blockquote><p>请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.<br>请求头部，用来说明服务器要使用的附加信息<br>空行，请求头部后面的空行是必须的<br>请求数据也叫主体，可以添加任意的其他数据。    </p></blockquote></li></ol><p>5.http相应信息Response<br>状态行、消息报头、空行和响应正文    </p><blockquote><p>状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成<br>消息报头，用来说明客户端要使用的一些附加信息<br>空行，消息报头后面的空行是必须的<br>响应正文，服务器返回给客户端的文本信息。     </p></blockquote><ul><li>http和https<br>https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密<br>http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少    </li></ul><ul><li>web缓存    </li></ul><ol><li>web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本    </li><li>缓存的好处<br>（1）减少不必要的请求<br>（2）降低服务器的压力，减少服务器的消耗<br>（3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）    </li></ol><ul><li>CDN（内容分发网络）    </li></ul><ol><li>尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。       </li><li>关键技术：内容存储和分发技术中       </li><li>基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术<br>将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）      </li></ol><ul><li>从输入url到获取页面的完整过程     </li></ul><ol><li>查询浏览器缓存，系统缓存，路由器缓存    </li><li>查询NDS(域名解析)，获取域名对应的IP地址     </li><li>浏览器与服务器建立tcp链接（三次握手）    </li><li>浏览器向服务器发送http请求(请求和传输数据）    </li><li>服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器    </li><li>浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤    </li><li>浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来    </li></ol><ul><li>浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print<br>流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树<br>概念：    </li></ul><p>1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树<br>2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）<br>3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置<br>4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点    </p><p>重绘：<br>当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上<br>触发重绘的条件：改变元素外观属性。如：color，background-color等<br>重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观<br><strong>注意</strong>：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局    </p><p>重排（重构/回流/reflow）<br>当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。<br>每个页面都需要一次回流，就是页面第一次渲染的时候<br>重排一定会影响重绘，但是重绘不一定会影响重排    </p><ul><li>为什么css放在顶部而js写在后面    </li></ul><ol><li>浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了    </li><li>其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。    </li><li>js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验<br>但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理    </li></ol><ul><li>存储方式与传输方式    </li></ul><ol><li>indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m    </li><li>Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响    </li><li>Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）    </li><li>localStroage: h5的本地存储，数据永久保存在客服端    </li></ol><ul><li>token、cookie、session三者的理解？？？！！！    </li></ul><ol><li>token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的用户身份的验证方式)      </li><li>cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名。服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）    </li><li>session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）。cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。    </li></ol><ul><li>基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前时间戳 + sign签名）    </li></ul><ol><li>用户通过用户名和密码发送请求    </li><li>服务器端验证    </li><li>服务器端返回一个带签名的token，给客户端    </li><li>客户端储存token，并且每次用于发送请求    </li><li>服务器验证token并且返回数据<br>每一次请求都需要token    </li></ol><ul><li>cookie与session区别    </li></ul><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。    </li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。    </li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。    </li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。    </li></ol><ul><li>session与token区别    </li></ul><ol><li>session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App    </li><li>token是Auth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，token不能转移到其他的App，也不能转到其他用户上。（适用于App）    </li><li>session的状态是存在服务器端的，客户端只存在session id，Token状态是存储在客户端的    </li></ol><ul><li>HTTP 缓存有哪几种？<br>ETag 是通过对比浏览器和服务器资源的特征值（如MD5）来决定是否要发送文件内容，如果一样就只发送 304（not modified）<br>Expires 是设置过期时间（绝对时间），但是如果用户的本地时间错乱了，可能会有问题<br>CacheControl: max-age=3600 是设置过期时长（相对时间），跟本地时间无关。    </li></ul><ul><li>RESTful常用的方法和介绍<br>rest请求方法有4种，包括get,post,put,delete.分别对应获取资源，添加资源，更新资源及删除资源    </li></ul><ul><li>csrf跨站攻击怎么解决<br>CSRF, 跨站请求伪造,它可以在用户毫不知情的情况下以用户名义伪造请求发送给受攻击站点，从而对用户或者网站造成攻击. 预防措施如下:<br>=&gt; 服务器端验证HTTP Referer字段, Referer记录了该HTTP请求的来源地址<br>=&gt; 在请求地址中添加token并验证<br>=&gt; 在HTTP头中自定义属性并验证    </li></ul><ul><li>对web安全的理解<br>=&gt; CSRF 攻击和防范<br>跨站请求伪造,可以理解为攻击者盗用了用户的身份，以用户的名义发送恶意请求，造成用户隐私及财产损失<br>过程:     </li></ul><ol><li>登录受信任网站并在本地生成cookie;     </li><li>在不登出 网站 的情况下访问危险网站     </li></ol><p><strong>防范:</strong> 关键操作只接受POST请求, 使用验证码, 检测Referer, 使用token(或者JWT)    </p><p>=&gt; XSS 攻击和防范<br>全称Cross-site script，跨站脚本攻击，是Web程序中常见的漏洞。<br>原理是攻击者向有XSS漏洞的网站中输入恶意的脚本，当其它用户浏览该网站时候，该脚本会自动执行，从而达到攻击的目的(盗取Cookie，破坏页面结构，重定向到钓鱼网站等)。<br>区分: 分为持久型XSS和非持久性XSS. 持久型XSS是将攻击的脚本植入到服务器，从而导致每个访问的用户都会遭到此XSS脚本的攻击。非持久型XSS是将恶意脚本包装在页面的URL参数中，通过URL链接骗取用户访问，从而进行攻击.<br><strong>防范:</strong> 对用户输入进行HTML转义, 对敏感信息进行过滤    </p><p>=&gt; SQL 注入与防范<br>通过把SQL命令插入到表单中并提交或页面请求的参数中，最终使得服务器执行恶意的SQL命令.<br><strong>防范:</strong> 对用户的输入进行校验或限制长度；对特殊字符进行转换, 不要使用动态拼装SQL，为每个应用使用单独的权限有限的数据库连接。对隐私信息进行加密    </p><p>=&gt; DDOS 攻击<br>分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。    </p><ul><li>base64为什么能提升性能以及它的缺点是什么<br>优点:<br>• 无额外请求<br>• 适用于很小或者很简单的图片<br>• 可像单独图片一样使用，比如背景图片等<br>• 没有跨域问题，不需要考虑缓存、文件头或者cookies问题<br>缺点:<br>• CSS 文件体积的增大, 造成CRP(关键渲染路径)阻塞<br>• 页面解析CSS生成的CSSOM时间增加    </li></ul><ul><li>介绍webp图片文件格式<br>WebP是一种支持有损压缩和无损压缩的图片文件格式，根据Google的测试，无损压缩后的WebP比PNG 文件少了45％的文件大小，即使这些PNG文件经过其他压缩工具压缩之后，WebP 还是可以减少28％的文件大小。<br>•优点<br>更小的文件尺寸<br>更高的质量——与其他相同大小不同格式的压缩图像比较<br>•缺点<br>编码和解码速度比较慢,存在一定兼容性    </li></ul><ul><li>说说H5手机端的适配的几种方案 </li></ul><ol><li><p>js实现一</p><pre class="line-numbers language-js">(<span class="function"><span class="keyword">function</span> (<span class="params"><code class="language-js">(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>{  <span class="keyword">var</span> docEl = doc.documentElement,    resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,    recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{      <span class="keyword">var</span> clientWidth = docEl.clientWidth;      <span class="keyword">var</span> fontSize = <span class="number">20</span>;      docEl.style.fontSize = fontSize + <span class="string">'px'</span>;      <span class="keyword">var</span> docStyles = getComputedStyle(docEl);      <span class="keyword">var</span> realFontSize = <span class="built_in">parseFloat</span>(docStyles.fontSize);      <span class="keyword">var</span> scale = realFontSize / fontSize;      <span class="built_in">console</span>.log(<span class="string">"realFontSize: "</span> + realFontSize + <span class="string">", scale: "</span> + scale);      fontSize = clientWidth / <span class="number">750</span> * <span class="number">20</span>;      <span class="keyword">if</span>(isIphoneX()) fontSize = <span class="number">19</span>;      fontSize = fontSize / scale;      docEl.style.fontSize = fontSize + <span class="string">'px'</span>;    };  <span class="comment">// Abort if browser does not support addEventListener</span>  <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;  win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);  doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);  <span class="comment">// iphoneX判断</span>  <span class="function"><span class="keyword">function</span> <span class="title">isIphoneX</span>(<span class="params"></span>)</span>{    <span class="keyword">return</span> <span class="regexp">/iphone/gi</span>.test(navigator.userAgent) && (screen.height == <span class="number">812</span> && screen.width == <span class="number">375</span>)  }})(<span class="built_in">document</span>, <span class="built_in">window</span>);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>js实现二</p><pre class="line-numbers language-js">(<span class="function"><span class="keyword">function</span>(<span class="params"><code class="language-js">(<span class="function"><span class="keyword">function</span>(<span class="params">base</span>) </span>{  <span class="keyword">var</span> _base = base|| <span class="number">75</span>;  <span class="keyword">var</span> ua = navigator.userAgent;  <span class="keyword">var</span> matches = ua.match(<span class="regexp">/Android[\S\s]+AppleWebkit\/(\d{3})/i</span>);  <span class="keyword">var</span> isIos = navigator.appVersion.match(<span class="regexp">/(iphone|ipad|ipod)/gi</span>);  <span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>;  <span class="keyword">if</span>(!isIos && !(matches && matches[<span class="number">1</span>] > <span class="number">534</span>)) {  <span class="comment">// 如果非iOS, 非Android4.3以上, dpr设为1;</span>    dpr = <span class="number">1</span>;  }  <span class="keyword">var</span> scale = <span class="number">1</span>/ dpr;  <span class="keyword">var</span> metaEl = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>);  <span class="keyword">if</span>(!metaEl) {    metaEl = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>);    metaEl.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>);    <span class="built_in">window</span>.document.head.appendChild(metaEl);  }  metaEl.setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width,user-scalable=no,initial-scale='</span>+ scale + <span class="string">',maximum-scale='</span>+ scale + <span class="string">',minimum-scale='</span>+ scale);  <span class="built_in">document</span>.documentElement.style.fontSize = <span class="built_in">document</span>.documentElement.clientWidth / (<span class="number">750</span>/ _base) + <span class="string">'px'</span>;})(<span class="number">75</span>);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>3.css @media媒介查询(苏宁易购实现方式)</p><p>4.手淘的lib-flexible实现方式</p><h2 id="性能优化部分"><a href="#性能优化部分" class="headerlink" title="性能优化部分"></a>性能优化部分</h2><h3 id="关于webpack的面试题总结"><a href="#关于webpack的面试题总结" class="headerlink" title="关于webpack的面试题总结"></a><a href="https://zhuanlan.zhihu.com/p/44438844" target="_blank" rel="noopener">关于webpack的面试题总结</a></h3><ul><li>webpack打包文件体积过大？（最终打包为一个js文件）    </li></ul><ol><li>异步加载模块    </li><li>提取第三库    </li><li>代码压缩    </li><li>去除不必要的插件    </li></ol><ul><li>如何优化webpack构建的性能<br>一、减少代码体积     </li></ul><ol><li>使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积    </li><li>把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理    </li><li>对一些组件库采用按需加载，避免无用的代码<br>二、减少目录检索范围<br>在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度<br>三、减少检索路经<br>resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路径，可以对其配置alias    </li></ol><ul><li>移动端的性能优化    </li></ul><ol><li>首屏加载和按需加载，懒加载    </li><li>资源预加载    </li><li>图片压缩处理，使用base64内嵌图片    </li><li>合理缓存dom对象    </li><li>使用touchstart代替click（click 300毫秒的延迟）    </li><li>利用transform:translateZ(0)，开启硬件GUP加速    </li><li>不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明    </li><li>使用viewport固定屏幕渲染，加速页面渲染内容    </li><li>尽量使用事件代理，避免直接事件绑定    </li></ol><ul><li>Vue的SPA 如何优化加载速度    </li></ul><ol><li>减少入口文件体积    </li><li>静态资源本地缓存    </li><li>开启Gzip压缩    </li><li>使用SSR,nuxt.js    </li></ol><ul><li>有哪些常见 loader 和 plugin，你用过哪些<br>loader:让webpack能够处理非js文件(自身职能理解js)，然后你就可以利用 webpack 的打包能力，对它们进行处理。<br>例如：css-loader、style-loader、postcss-loader、sass-loader<br>plugins:从打包优化和压缩，一直到重新定义环境中的变量.<br>例如：uglify-webpack-plugin、clean-webpack-plugin、babel-polyfill                                     </li></ul><ul><li>如何优化网站的SEO    </li></ul><ol><li>网站结构布局优化：尽量简单, 提倡扁平化结构. 一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。     </li><li>img标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。    </li><li>把重要内容HTML代码放在最前搜索引擎抓取HTML内容是从上到下，利用这一特点，可以让主要代码优先读取，广告等不重要代码放在下边。    </li><li>控制页面的大小，减少http请求，提高网站的加载速度。    </li><li>合理的设计title、description和keywords<br>• title标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的title标题中不要设置相同的内容。<br>• meta keywords页面/网站的关键字。<br>• meta description网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。    </li><li>语义化书写HTML代码，符合W3C标准尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事。让阅读源码者和“蜘蛛”都一目了然。    </li><li>a标签：页面链接，要加 “title” 属性说明，链接到其他网站则需要加上 el=”nofollow” 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。    </li><li>图标使用IconFont替换    </li><li>使用CDN网络缓存，加快用户访问速度，减轻服务器压力    </li><li>启用GZIP压缩，浏览速度变快，搜索引擎的蜘蛛抓取信息量也会增大    </li><li>SSR技术    </li><li>预渲染技术    </li></ol><ul><li>如何优化用户体验<br>• 页面渲染前使用骨架屏或者加载动画,避免大块白屏<br>• 使用预渲染或者ssr技术提高首屏加载时间<br>• 动画使用css3硬件加速,避免用户操作动画卡顿<br>• 计算密集型业务使用web worker或者js分片处理,避免js线程阻塞<br>• 页面状态监控,给用户提供反馈机制<br>• 静态资源走CDN缓存或者oss服务,提高用户访问速度<br>• 避免用户操作报错,提供404页面或则错误提示页面    </li></ul><ul><li>webpack和gulp的优缺点  </li></ul><table><thead><tr><th></th><th>gulp</th><th>webpack</th></tr></thead><tbody><tr><td>定位</td><td>基于任务流的自动化打包工具</td><td>模块化打包工具</td></tr><tr><td>优点</td><td>易于学习和理解, 适合多页面应用开发</td><td>可以模块化的打包任何资源,适配任何模块系统,适合SPA单页应用的开发</td></tr><tr><td>缺点</td><td>不太适合单页或者自定义模块的开发</td><td>学习成本低,配置复杂,通过babel编译后的js代码打包后体积过大</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是『question 系列』的 http 和 performance 部分， js 部分我们放在最后。&lt;br&gt;下面我们开始吧。        &lt;/p&gt;
    
    </summary>
    
    
      <category term="network" scheme="https://jambo0624.github.io/categories/network/"/>
    
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
      <category term="performance" scheme="https://jambo0624.github.io/tags/performance/"/>
    
      <category term="network" scheme="https://jambo0624.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』 css questions (part 3)</title>
    <link href="https://jambo0624.github.io/2020-05-31-css-question3.html"/>
    <id>https://jambo0624.github.io/2020-05-31-css-question3.html</id>
    <published>2020-05-31T06:18:24.000Z</published>
    <updated>2020-10-19T08:58:01.169Z</updated>
    
    <content type="html"><![CDATA[<p>现在把整理的 css 在面试中可能会被问到的问题剩下部分记录一下。<br>我们开始吧。</p><a id="more"></a><ul><li><strong>position:fixed;在 android 下无效怎么处理？</strong><blockquote><p>因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。</p></blockquote></li></ul><blockquote><p>如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：</p></blockquote><p><code>&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt;</code></p><ul><li><p><strong>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</strong></p><blockquote><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms</p></blockquote></li><li><p><strong>如何让去除 inline-block 元素间间距？</strong></p><blockquote><p>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p></blockquote></li><li><p><strong>overflow:scroll 时不能平滑滚动的问题怎么处理？</strong><br>以下代码可解决这种卡顿的问题：<code>-webkit-overflow-scrolling:touch</code>;是因为这行代码启用了硬件加速特性，所以滑动很流畅。</p></li><li><p><strong>有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</strong></p><blockquote><p>（1）外层div使用<code>position：relative</code>；高度要求自适应的div使用<code>position:absolute;top:100px;bottom:0;left:0;right:0</code>;</p><p>（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。</p></blockquote></li><li><p><strong>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</strong></p></li></ul><p>我了解到的一共有七种常见的图片的格式。</p><blockquote><p>（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。</p></blockquote><blockquote><p>（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。</p></blockquote><blockquote><p>（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。</p></blockquote><blockquote><p>（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。</p></blockquote><blockquote><p>（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。</p></blockquote><blockquote><p>（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合于用来制作一些网站logo或者图标之类的图片。</p></blockquote><blockquote><p>（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。</p></blockquote><ul><li><p><strong>浏览器如何判断是否支持 webp 格式图片</strong></p><blockquote><p>（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。</p><p>（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。</p></blockquote></li><li><p><strong>什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</strong></p><blockquote><p>网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。</p><p>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开，静态资源放CDN。</p><p>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</p><p>同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的http请求的解析速度。</p></blockquote></li><li><p><strong>style 标签写在 body 后与 body 前有什么区别？</strong></p><blockquote><p>页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）</p></blockquote></li><li><p><strong>什么是 CSS 预处理器/后处理器？</strong></p><blockquote><p>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。</p></blockquote></li></ul><blockquote><p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p></blockquote><blockquote><p>CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。</p></blockquote><blockquote><p>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p></blockquote><ul><li><strong>阐述一下 CSSSprites</strong><br>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites能减少图片的字节。</li></ul><p>优点：</p><blockquote><p>减少HTTP请求数，极大地提高页面加载速度<br>增加图片信息重复度，提高压缩比，减少图片大小<br>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</p></blockquote><p>缺点：</p><blockquote><p>图片合并麻烦<br>维护麻烦，修改一个图片可能需要重新布局整个图片，样式</p></blockquote><ul><li><strong>使用 rem 布局的优缺点？</strong><br>优点：<blockquote><p>在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。<br>而且现在浏览器基本都已经支持rem了，兼容性也非常的好。</p></blockquote></li></ul><p>缺点：</p><blockquote><p>（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。<br>（2）使用iframe引用也会出现问题。<br>（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。</p></blockquote><ul><li><p>画一条 0.5px 的线</p><blockquote><p>采用meta viewport的方式</p><p>采用border-image的方式</p><p>采用transform:scale()的方式</p></blockquote></li><li><p><strong>transition 和 animation 的区别</strong></p><blockquote><p>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。</p><p>animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</p></blockquote></li><li><p><strong>什么是首选最小宽度？</strong><br>“首选最小宽度”，指的是元素最适合的最小宽度。</p></li></ul><blockquote><p>东亚文字（如中文）最小宽度为每个汉字的宽度。</p><p>西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。</p><p>如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</p></blockquote><ul><li><p><strong>为什么 height:100%会无效？</strong></p><blockquote><p>对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</p><p>原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，<br>所以无法参与计算。</p><p>使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。 </p></blockquote></li><li><p><strong>min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</strong></p><blockquote><p>（1）max-width会覆盖width，即使width是行类样式或者设置了!important。</p><p>（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。</p></blockquote></li><li><p><strong>内联盒模型基本概念</strong></p><blockquote><p>（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。</p><p>（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。</p><p>（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</p><p>（4）包含块（containing box），由一行一行的“行框盒子”组成。</p></blockquote></li><li><p><strong>什么是幽灵空白节点？</strong></p><blockquote><p>“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</p></blockquote></li><li><p><strong>什么是替换元素？</strong><br>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，<code>&lt;img&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;iframe&gt;</code>或者表单元素<code>&lt;textarea&gt;</code>和<code>&lt;input&gt;</code>和<code>&lt;select&gt;</code>都是典型的替换元素。</p></li></ul><p>替换元素除了内容可替换这一特性以外，还有以下一些特性。</p><blockquote><p>（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口，</p><p>（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如<code>&lt;video&gt;</code>、<code>&lt;iframe&gt;</code>或者<code>&lt;canvas&gt;</code>等，也有少部分替换元素为0像素，如<code>&lt;img&gt;</code>图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。</p><p>（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是<code>vertical-align</code>属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</p><p>（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</p></blockquote><ul><li><strong>替换元素的计算规则？</strong><br>替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</li></ul><blockquote><p>（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</p><p>（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括<code>&lt;img&gt;</code>的width和height属性、<code>&lt;input&gt;</code>的size属性、<code>&lt;textarea&gt;</code>的cols和rows属性等。</p><p>（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</p></blockquote><p>这3层结构的计算规则具体如下</p><blockquote><p>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</p><p>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</p><p>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。</p><p>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</p><p>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</p><p>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p></blockquote><ul><li><strong>content 与替换元素的关系？</strong><br>content属性生成的对象称为“匿名替换元素”。</li></ul><blockquote><p>（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。</p><p>（2）content生成的内容不能左右:empty伪类。</p><p>（3）content动态生成值无法获取。 </p></blockquote><ul><li><strong>margin:auto 的填充规则？</strong><br>margin的’auto’可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。</li></ul><blockquote><p>（1）如果一侧定值，一侧auto，则auto为剩余空间大小。<br>（2）如果两侧均是auto，则平分剩余空间。</p></blockquote><ul><li><p><strong>margin 无效的情形</strong></p><blockquote><p>（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有margin合并的问题。</p><p>（2）表格中的<tr>和<td>元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。</p><p>（3）绝对定位元素非定位方位的margin值“无效”。</p><p>（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。</p></blockquote></li><li><p><strong>border 的特殊性？</strong></p><blockquote><p>（1）border-width却不支持百分比。</p><p>（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-color没有边框显示的原因。</p><p>（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。</p><p>（4）border-color默认颜色就是color色值。</p><p>（5）默认background背景图片是相对于padding box定位的。</p></blockquote></li><li><p><strong>什么是基线和 x-height？</strong></p><blockquote><p>字母x的下边缘（线）就是我们的基线。</p><p>x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。</p><p>ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</p></blockquote></li><li><p><strong>line-height 的特殊性？</strong></p><blockquote><p>（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</p><p>（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</p><p>（3）行距=line-height-font-size。</p><p>（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。</p><p>（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</p><p>（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。</p><p>（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</p><p>（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。</p><p>（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</p><p>（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</p></blockquote></li><li><p><strong>vertical-align 的特殊性？</strong></p><blockquote><p>（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。</p><p>（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display计算值是table-cell的元素，我们不妨脑补成<td>元素，则和<tr>元素上边缘对齐。</p><p>（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。</p><p>（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。</p><p>（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。</p><p>（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。</p><p>（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。</p></blockquote></li><li><p><strong>overflow 的特殊性？</strong></p><blockquote><p>（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。</p><p>（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素<code>&lt;html&gt;</code>，另一个是文本域<code>&lt;textarea&gt;</code>。</p><p>（3）滚动条会占用容器的可用宽度或高度。</p><p>（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</p></blockquote></li><li><p><strong>无依赖绝对定位是什么？</strong></p><blockquote><p>没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。</p><p>无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。</p></blockquote></li><li><p><strong>absolute 与 overflow 的关系？</strong></p><blockquote><p>（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素进行剪裁。</p><p>（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也都不会出现滚动条。</p><p>（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。</p></blockquote></li><li><p><strong>clip 裁剪是什么？</strong></p><blockquote><p>所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。</p><p>clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</p></blockquote></li><li><p><strong>relative 的特殊性？</strong></p><blockquote><p>（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</p><p>（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。</p><p>（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。</p></blockquote></li><li><p><strong>什么是层叠上下文？</strong><br>层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p></li></ul><p>层叠上下文元素有如下特性：</p><blockquote><p>（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。<br>（2）层叠上下文可以阻断元素的混合模式。<br>（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。<br>（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。<br>（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</p></blockquote><p>层叠上下文的创建：</p><blockquote><p>（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是<html>元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。</p><p>（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。</p><p>（3）其他一些CSS3属性，比如元素的opacity值不是1。</p></blockquote><ul><li><p><strong>什么是层叠水平？</strong></p><blockquote><p>层叠水平，英文称作stacking level，决定了同一个层叠上下文中元素在z轴上的显示顺序。</p><p>显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。</p></blockquote></li><li><p><strong>元素的层叠顺序？</strong><br>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。</p></li><li><p><strong>层叠准则？</strong></p><blockquote><p>（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</p><p>（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</p></blockquote></li><li><p><strong>font-weight 的特殊性？</strong></p><blockquote><p>如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。</p></blockquote></li><li><p><strong>text-indent 的特殊性？</strong></p><blockquote><p>（1）text-indent仅对第一行内联盒子内容有效。</p><p>（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inline-table则会生效。</p><p>（3）<code>&lt;input&gt;</code>标签按钮text-indent值无效。</p><p>（4）<code>&lt;button&gt;</code>标签按钮text-indent值有效。</p><p>（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</p></blockquote></li><li><p><strong>letter-spacing 与字符间距？</strong><br>letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。</p></li></ul><p>letter-spacing具有以下一些特性。</p><blockquote><p>（1）继承性。<br>（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。<br>（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。<br>（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。<br>（5）支持小数值，即使0.1px也是支持的。<br>（6）暂不支持百分比值。</p></blockquote><ul><li><strong>word-spacing 与单词间距？</strong><blockquote><p>letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。</p></blockquote></li><li><strong>white-space 与换行和空格的控制？</strong><br>white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否生效）等。</li></ul><p>其属性值包括下面这些。</p><blockquote><p>•normal：合并空白字符和换行符。<br>•pre：空白字符不合并，并且内容只在有换行符的地方换行。<br>•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。<br>•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。<br>•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。</p></blockquote><ul><li><strong>隐藏元素的 background-image 到底加不加载？</strong></li></ul><blockquote><p>（1）元素的背景图片</p></blockquote><p>-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求 -:hover 样式下，触发时请求</p><blockquote><p>（2）img 标签图片任何情况下都会请求图片</p></blockquote><ul><li><p><strong>如何实现单行／多行文本溢出的省略（…）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="comment">/*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'...'</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>常见的元素隐藏方式？</strong></p><blockquote><p>（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</p><p>（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</p><p>（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</p><p>（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</p><p>（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</p><p>（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p><p>（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p></blockquote></li></ul><ul><li><strong>css 实现上下固定中间自适应布局</strong><br>利用绝对定位实现<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>利用flex布局实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>css 两栏布局的实现</strong><br>相关资料：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*/</span></span><br><span class="line"><span class="comment">/*以左边宽度固定为200px为例*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: auto;</span><br><span class="line">  <span class="comment">/*11auto*/</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为</span></span><br><span class="line"><span class="comment">200px。将右边元素的margin-left的值设置为200px。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。</p><p>以左边宽度固定为 200px 为例</p><blockquote><p>（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。</p><p>（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。</p><p>（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。</p><p>（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。</p></blockquote><ul><li><strong>css 三栏布局的实现</strong><br>相关资料：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里以左边宽度固定为100px，右边宽度固定为200px为例。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">00100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">00200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元</span></span><br><span class="line"><span class="comment">素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</p><p>这里以左边宽度固定为100px，右边宽度固定为200px为例。</p><blockquote><p>（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</p><p>（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。</p><p>（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。</p><p>（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。双飞翼布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。</p><p>（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</p></blockquote><ul><li><strong>实现一个宽高自适应的正方形</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.第一种方式是利用vw来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.第三种方式是利用子元素的margin-top的值来实现的*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>实现一个三角形</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*三角形的实现原理是利用了元素边框连接处的等分原理。*/</span></span><br><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: tomato transparent transparent transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>一个自适应矩形，水平垂直居中，且宽高比为 2:1</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现原理参考自适应正方形和水平居中方式*/</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在把整理的 css 在面试中可能会被问到的问题剩下部分记录一下。&lt;br&gt;我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』 css questions (part 2)</title>
    <link href="https://jambo0624.github.io/2020-05-05-css-question2.html"/>
    <id>https://jambo0624.github.io/2020-05-05-css-question2.html</id>
    <published>2020-05-05T11:28:04.000Z</published>
    <updated>2020-10-19T08:58:01.176Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jambo0624.github.io/2020-05-03-css-question.html">前一篇文章</a>整理了 css 在面试中可能会被问到的问题，现在把整理的第二部分记录下来。<br>我们开始吧。</p><a id="more"></a><ul><li><strong>::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。</strong></li></ul><blockquote><p>在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。<br>但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。<br>伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。</p></blockquote><ul><li><p><strong>伪类与伪元素的区别</strong></p><blockquote><p>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p><p>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。</p><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p></blockquote></li><li><p><strong>CSS 中哪些属性可以继承？</strong><br>有继承性的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）字体系列属性 font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）文本系列属性 text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）表格布局属性 caption-side border-collapse empty-cells</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）列表属性 list-style-type、list-style-image、list-style-position、list-style</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）光标属性 cursor</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）元素可见性 visibility</span><br><span class="line"></span><br><span class="line">（<span class="number">7</span>）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性</span><br><span class="line"></span><br><span class="line">注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>CSS 优先级算法如何计算？</strong><br>相关知识点：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CSS的优先级是根据样式声明的特殊性值来判断的。</span><br><span class="line"></span><br><span class="line">选择器的特殊性值分为四个等级，如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）标签内选择符x,0,0,0</span></span><br><span class="line"><span class="comment">//（2）ID选择符0,x,0,0</span></span><br><span class="line"><span class="comment">//（3）class选择符/属性选择符/伪类选择符0,0,x,0</span></span><br><span class="line"><span class="comment">//（4）元素和伪元素选择符0,0,0,x</span></span><br><span class="line"></span><br><span class="line">计算方法：</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）每个等级的初始值为0</span></span><br><span class="line"><span class="comment">//（2）每个等级的叠加为选择器出现的次数相加</span></span><br><span class="line"><span class="comment">//（3）不可进位，比如0,99,99,99</span></span><br><span class="line"><span class="comment">//（4）依次表示为：0,0,0,0</span></span><br><span class="line"><span class="comment">//（5）每个等级计数之间没关联</span></span><br><span class="line"><span class="comment">//（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值</span></span><br><span class="line"><span class="comment">//（7）如果两个优先级相同，则最后出现的优先级高，!important也适用</span></span><br><span class="line"><span class="comment">//（8）通配符选择器的特殊性值为：0,0,0,0</span></span><br><span class="line"><span class="comment">//（9）继承样式优先级最低，通配符样式优先级高于继承样式</span></span><br><span class="line"><span class="comment">//（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>关于伪类 LVHA 的解释?</strong><br>a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</li></ul><p>当链接未访问过时：</p><blockquote><p>（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；<br>（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。</p></blockquote><p>当链接访问过时，情况基本同上，只不过需要将:link换成:visited。</p><p>这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。</p><ul><li><p><strong>display 有哪些值？说明他们的作用。</strong></p><blockquote><p>block    块类型。默认宽度为父元素宽度，可设置宽高，换行显示。<br>none    元素不显示，并从文档流中移除。<br>inline    行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。<br>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。<br>list-item    像块类型元素一样显示，并添加样式列表标记。<br>table    此元素会作为块级表格来显示。<br>inherit    规定应该从父元素继承display属性的值。</p></blockquote></li><li><p><strong>CSS3 有哪些新特性？</strong></p><blockquote><p>新增各种CSS选择器    （:not(.input)：所有class不是“input”的节点）<br>圆角        （border-radius:8px）<br>多列布局    （multi-column layout）<br>阴影和反射    （Shadow\Reflect）<br>文字特效        （text-shadow）<br>文字渲染        （Text-decoration）<br>线性渐变        （gradient）<br>旋转            （transform）<br>缩放，定位，倾斜，动画，多背景<br>例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</p></blockquote></li></ul><ul><li><strong>一个满屏品字布局如何设计?</strong><br>简单的方式：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的div宽100%，               </span></span><br><span class="line"><span class="comment">// 下面的两个div分别宽50%，            </span></span><br><span class="line"><span class="comment">// 然后用float或者inline使其不换行即可</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>CSS 多列等高如何实现？</strong><blockquote><p>（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p><p>（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。</p><p>（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度的特性，来实现多列等高。</p></blockquote></li></ul><ul><li><strong>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</strong><blockquote><p>（1）png24位的图片在iE6浏览器上出现背景。解决方案：做成PNG8，也可以引用一段脚本处理。</p></blockquote></li></ul><blockquote><p>（2）浏览器默认的margin和padding不同。解决方案：加一个全局的*{margin:0;padding:0;}来统一。</p></blockquote><blockquote><p>（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">10px</span>;<span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;&#125;</span><br></pre></td></tr></table></figure><p>这种情况之下IE会产生20px的距离<br>解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p><blockquote><p>（4）渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用”\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用”+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bb</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f1ee18</span>;<span class="comment">/*所有识别*/</span></span><br><span class="line">  <span class="selector-class">.background-color</span>: <span class="number">#00deff</span>\<span class="number">9</span>;<span class="comment">/*IE6、7、8识别*/</span></span><br><span class="line">  +<span class="attribute">background-color</span>: <span class="number">#a200ff</span>;<span class="comment">/*IE6、7识别*/</span></span><br><span class="line">  _background-<span class="attribute">color</span>: <span class="number">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义<br>属性；Firefox下，只能使用getAttribute()获取自定义属性<br>解决方法：统一通过getAttribute()获取自定义属性。</p></blockquote><blockquote><p>（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有<br>pageX、pageY属性，但是没有x、y属性。<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p></blockquote><blockquote><p>（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示<br>解决方法：</p></blockquote><p>1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome更新到27版本之后就不可以用了。</p><p>2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/…；</p><blockquote><p>（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了 解决方法：改变CSS属性的排列顺序L-V-H-A</p></blockquote><blockquote><p>（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</p></blockquote><ul><li>li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？<br>浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个<li>放在一行，这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</li></ul><p>解决办法：</p><blockquote><p>（1）为<code>&lt;li&gt;</code>设置<code>float:left</code>。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p><p>（2）将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</p><p>（3）将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即<code>font-size:0</code>。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p><p>（4）消除<code>&lt;ul&gt;</code>的字符间隔<code>letter-spacing:-8px</code>，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符间隔设为默认<code>letter-spacing:normal</code>。</p></blockquote><ul><li><strong>为什么要初始化 CSS 样式？</strong></li></ul><p>-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p><p>-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p><p>最简单的初始化方法：<code>*{padding:0;margin:0;}</code>（强烈不建议）</p><p>淘宝的样式初始化代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">hr</span>,<span class="selector-tag">p</span>,<span class="selector-tag">blockquote</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dt</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">li</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">form</span>,<span class="selector-tag">fieldset</span>,<span class="selector-tag">legend</span></span><br><span class="line">,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">th</span>,<span class="selector-tag">td</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">select</span>,<span class="selector-tag">textarea</span>&#123;<span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma,arial,\<span class="number">5</span>b8b\<span class="number">4</span>f53;&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;<span class="attribute">font-size</span>:<span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-tag">address</span>,<span class="selector-tag">cite</span>,<span class="selector-tag">dfn</span>,<span class="selector-tag">em</span>,<span class="selector-tag">var</span>&#123;<span class="attribute">font-style</span>:normal;&#125;</span><br><span class="line"><span class="selector-tag">code</span>,<span class="selector-tag">kbd</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">samp</span>&#123;<span class="attribute">font-family</span>:couriernew,courier,monospace;&#125;</span><br><span class="line"><span class="selector-tag">small</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br><span class="line"><span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>&#123;<span class="attribute">list-style</span>:none;&#125;</span><br><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">text-decoration</span>:none;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">text-decoration</span>:underline;&#125;</span><br><span class="line"><span class="selector-tag">sup</span>&#123;<span class="attribute">vertical-align</span>:text-top;&#125;</span><br><span class="line"><span class="selector-tag">sub</span>&#123;<span class="attribute">vertical-align</span>:text-bottom;&#125;</span><br><span class="line"><span class="selector-tag">legend</span>&#123;<span class="attribute">color</span>:<span class="number">#000</span>;&#125;</span><br><span class="line"><span class="selector-tag">fieldset</span>,<span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">select</span>,<span class="selector-tag">textarea</span>&#123;<span class="attribute">font-size</span>:<span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-tag">table</span>&#123;<span class="attribute">border-collapse</span>:collapse;<span class="attribute">border-spacing</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>什么是包含块，对于包含块的理解?</strong><br>包含块（containing block）就是元素用来计算和定位的一个框。</li></ul><blockquote><p>（1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</p><p>（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box边界形成。</p><p>（3）如果元素position:fixed，则“包含块”是“初始包含块”。</p><p>（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：</p></blockquote><p>如果该祖先元素是纯inline元素，则规则略复杂：</p><blockquote><p>假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包含块”；<br>如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的padding box边界形成。</p></blockquote><p>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</p><ul><li><strong>CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</strong><br>（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。</li></ul><p>（2）但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。</p><p>在不同浏览器下的区别：</p><p>在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。</p><p>在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</p><ul><li><strong>width:auto 和 width:100%的区别</strong><br>一般而言</li></ul><blockquote><p>width:100%会使元素box的宽度等于父元素的content box的宽度。</p><p>width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。</p></blockquote><ul><li><strong>绝对定位元素与非绝对定位元素的百分比计算的区别</strong><blockquote><p>绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。</p><p>非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。</p></blockquote></li><li><strong>简单介绍使用图片 base64 编码的优点和缺点。</strong><br>base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url属性。</li></ul><p>使用base64的优点是：</p><blockquote><p>（1）减少一个图片的HTTP请求</p></blockquote><p>使用base64的缺点是：</p><blockquote><p>（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</p></blockquote><blockquote><p>（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要差很多。</p></blockquote><blockquote><p>（3）兼容性的问题，ie8以前的浏览器不支持。</p></blockquote><p>一般一些网站的小图标可以使用base64图片来引入。</p><ul><li><strong>‘display’、’position’和’float’的相互关系？</strong><blockquote><p>（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p></blockquote></li></ul><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；<br>其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；<br>最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><ul><li><strong>margin 重叠问题的理解。</strong><br>相关知识点：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生折叠的必备条件：margin必须是**邻接的**!</span></span><br></pre></td></tr></table></figure></li></ul><p>margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。</p><p>一般来说可以分为四种情形：</p><blockquote><p>第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC来解决。</p><p>第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC来解决。</p><p>第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。</p><p>第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、padding或者高度来解决这个问题。</p></blockquote><ul><li>对 BFC 规范（块级格式化上下文：block formatting context）的理解？</li></ul><blockquote><p>BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。</p><p>一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。</p></blockquote><ul><li><strong>IFC 是什么？</strong><br>IFC指的是行级格式化上下文，它有这样的一些布局规则：</li></ul><blockquote><p>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。<br>（2）当一行不够的时候会自动切换到下一行。<br>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</p></blockquote><ul><li><p><strong>移动端的布局用过媒体查询吗？</strong></p><blockquote><p>假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</p><p>当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。</p><p>包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。</p></blockquote></li><li><p><strong>CSS 优化、提高性能的方法有哪些？</strong><br>加载性能：</p></li></ul><blockquote><p>（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。<br>（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。<br>（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p></blockquote><p>选择器性能：</p><blockquote><p>（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p><p>（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</p><p>（3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</p><p>（4）尽量少的去对标签进行选择，而是用class。</p><p>（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p><p>（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p></blockquote><p>渲染性能：</p><blockquote><p>（1）慎重使用高性能属性：浮动、定位。</p><p>（2）尽量减少页面重排、重绘。</p><p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</p><p>（4）属性值为0时，不加单位。</p><p>（5）属性值为浮动小数0.**，可以省略小数点之前的0。</p><p>（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</p><p>（7）不使用@import前缀，它会影响css的加载速度。</p><p>（8）选择器优化嵌套，尽量避免层级过深。</p><p>（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</p><p>（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p><p>（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</p></blockquote><p>可维护性、健壮性：</p><blockquote><p>（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。<br>（2）样式与内容分离：将css代码定义到外部css中。</p></blockquote><ul><li><p><strong>浏览器是怎样解析 CSS 选择器的？</strong></p><blockquote><p>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。</p><p>试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</p></blockquote></li><li><p><strong>在网页中应该使用奇数还是偶数的字体？为什么呢？</strong></p><blockquote><p>（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。<br>（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。<br>（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</p></blockquote></li><li><p><strong>margin 和 padding 分别适合什么场景使用？</strong></p><blockquote><p>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。<br>margin用于布局分开元素使元素与元素互不相干。<br>padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</p></blockquote></li></ul><p>何时应当使用margin：</p><blockquote><p>•需要在border外侧添加空白时。<br>•空白处不需要背景（色）时。<br>•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</p></blockquote><p>何时应当时用padding：</p><blockquote><p>•需要在border内测添加空白时。<br>•空白处需要背景（色）时。<br>•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</p></blockquote><ul><li><p><strong>抽离样式模块怎么写，说出思路，有无实践经验？</strong><br>我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。</p></li><li><p><strong>简单说一下 css3 的 all 属性。</strong></p><blockquote><p>all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</p><p>initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始值。</p><p>inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。</p><p>unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。</p></blockquote></li></ul><ul><li><strong>为什么不建议使用统配符初始化 css 样式。</strong><br>采用*{padding:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。</li></ul><p>出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即可，并不需使用通配符*来初始化。</p><ul><li><p><strong>absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</strong></p><blockquote><p>（1）内联元素也可以作为“包含块”所在的元素；</p><p>（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</p><p>（3）边界是padding box而不是content box。</p></blockquote></li><li><p><strong>对于 hasLayout 的理解？</strong></p><blockquote><p>hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。</p></blockquote></li><li><p><strong>元素竖向的百分比设定是相对于容器的高度吗？</strong></p><blockquote><p>如果是height的话，是相对于包含块的高度。</p><p>如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。</p></blockquote></li><li><p><strong>怎么让 Chrome 支持小于 12px 的文字？</strong><br>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p></li></ul><p>解决办法：</p><blockquote><p>（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</p><p>（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</p><p>（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</p></blockquote><ul><li><strong>让页面里的字体变清晰，变细用 CSS 怎么做？</strong><blockquote><p>webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</p></blockquote></li></ul><blockquote><p>在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。</p></blockquote><ul><li><p><strong>设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</strong></p><blockquote><p>设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</p><p>css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。</p><p>dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。</p><p>ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</p></blockquote></li><li><p><strong>layout viewport、visual viewport 和 ideal viewport 的区别？</strong><br>移动端一共需要理解三个viewport的概念的理解。</p></li></ul><blockquote><p>第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。</p></blockquote><blockquote><p>第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visual viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。</p></blockquote><blockquote><p>第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://jambo0624.github.io/2020-05-03-css-question.html&quot;&gt;前一篇文章&lt;/a&gt;整理了 css 在面试中可能会被问到的问题，现在把整理的第二部分记录下来。&lt;br&gt;我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』 css questions</title>
    <link href="https://jambo0624.github.io/2020-05-03-css-question.html"/>
    <id>https://jambo0624.github.io/2020-05-03-css-question.html</id>
    <published>2020-05-03T04:13:14.000Z</published>
    <updated>2020-10-19T08:55:11.002Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章总结了 html 部分针对面试的一些沉淀<br>今天主要是 css 部分内容，下面开始。 </p><a id="more"></a><ul><li><p>两种盒模型分别说一下<br>box-sizing：content-box（外加）<br>box-sizing：border-box（内减）        </p></li><li><p>水平居中<br>行内元素：text-align:center<br>块级元素：margin: 0 auto<br>绝对定位和移动：position:absolute; transform:translate()<br>绝对定位和负边距：position:absolute; margin:<br>flex布局：display:flex; justify-content:center;        </p></li><li><p>如何垂直居中        </p></li></ul><ol><li>不定高度,<code>padding:10px</code>        </li><li>定高度        <blockquote><p>1.table<br>2.伪装display:table<br>3.加上100%的before和after，并且display:inline-block<br>4.子绝父相，top和left为0，margin:auto<br>5.子绝父相，top和left为50%，margin调整<br>6.子绝父相，top和left为50%，translate调整<br>7.flex          </p></blockquote></li></ol><ul><li><p>BFC 是什么<br>块格式化上下文（Block Formatting Context，BFC）是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域<br>浮动元素、绝对定位元素、行内块元素、弹性元素、overflow 值不为 visible 的块元素会触发BFC        </p><blockquote><p>其中上外边距塌陷，解决方法如下        </p></blockquote><pre class="line-numbers language-css"><span class="selector-class">.selector</span><span class="selector-pseudo"><code class="language-css"><span class="selector-class">.selector</span><span class="selector-pseudo">::before</span>{          <span class="attribute">content</span>: <span class="string">""</span>;          <span class="attribute">display</span>:table;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>CSS 选择器优先级<br>越具体优先级越高<br>同样优先级写在后面的覆盖写在前面的<br>!important 优先级最高，但是要少用        </p></li></ul><ul><li><p>如何清除浮动        </p><pre class="line-numbers language-css"><span class="selector-class">.clearfix</span><span class="selector-pseudo"><code class="language-css"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> {          <span class="attribute">content</span>: <span class="string">''</span>;          <span class="attribute">display</span>: block; <span class="comment">/*或者 table*/</span>          <span class="attribute">clear</span>: both;        }        <span class="selector-class">.clearfix</span> {          <span class="attribute">zoom</span>: <span class="number">1</span>; <span class="comment">/* IE 兼容*/</span>        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>CSS 加载方式有几种<br>行内，内联，外链，import        </p></li><li><p>简述 src 和 href 的区别<br>href 时指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。<br>src 时指向外部的资源位置，指向的内容将会嵌入到文档中当前标签所在位置        </p></li><li><p>css选择器(e代表元素) <a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener">相关文章</a></p></li></ul><table><thead><tr><th>阐述</th><th>写法</th></tr></thead><tbody><tr><td>通用</td><td>*</td></tr><tr><td>元素</td><td>e</td></tr><tr><td>类</td><td>.class</td></tr><tr><td>id</td><td>#id</td></tr><tr><td>群组</td><td>e1,e2</td></tr><tr><td>后代</td><td>e1 e2</td></tr><tr><td>子代</td><td>e1&gt;e2</td></tr><tr><td>相邻兄弟</td><td>e1+e2</td></tr><tr><td>通用兄弟</td><td>e1~e2</td></tr><tr><td>属性</td><td>[attr] elem[attr] [attr1][attr2] [attr=value]</td></tr><tr><td>属性相关</td><td>[attr^=value] [attr$=value] [attr*=value] [attr~=value]</td></tr><tr><td>伪类– 链接伪类</td><td>:link  :visited</td></tr><tr><td>伪类– 动态伪类</td><td>:hover  :active  :focus</td></tr><tr><td>伪类– 结构伪类</td><td>:first-child :last-child :nth-child(n) :empty :only-child</td></tr><tr><td>伪类– 目标伪类</td><td>:target</td></tr><tr><td>伪类– 否定伪类</td><td>:not</td></tr><tr><td>伪元素</td><td>:first-letter :first-line ::selection</td></tr><tr><td>伪元素–内容生成</td><td>:before或::before :after或::after 必须要有content属性</td></tr></tbody></table><ul><li><p><a href="https://www.jianshu.com/p/d5cc4e169dfa" target="_blank" rel="noopener">CSS 继承，哪些属性能继承，哪些不能</a>        </p></li><li><p><a href="https://www.jianshu.com/p/82f02af17e78" target="_blank" rel="noopener">px、em、rem、%、vw、vh、vm这些单位的区别</a>        </p></li><li><p>line-height: 2和line-height: 200%的区别<br>两个属性设置给具体的某一个元素时是没有区别的<br>区别就是他们设置两种不同的属性后其子元素表现样式上的区别！2是子元素自身，200%是父元素，也就是固定值        </p></li><li><p>行内元素的“框属性”是 line-height 控制<br>对于行内元素来说，上下的 margin padding 不生效，只有左右的 margin padding 生效！        </p></li></ul><ul><li>inline-block 在实际工作中有什么作用<br>如果看到页面上有一排并列的按钮，如果不用浮动，就可以用 inline-block        </li></ul><ul><li><p>让一个元素“看不见”的几种方式        </p><blockquote><p>将元素设置为display:none后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。<br>visibility:hidden适用于那些元素隐藏后不希望页面布局会发生变化的场景.<br>opacity:0<br>设置height，width等盒模型属性为0<br>设置元素的position与left，top，bottom，right等，将元素移出至屏幕外<br>设置元素的position与z-index，将z-index设置成尽量小的负数<br>——能不能点击<br>display,visibility不能，opacity可以，height看情况<br>——能不能动画<br>display立即消失，没有动画<br>visibility按时消失，没有动画<br>opacity和height正常        </p></blockquote></li><li><p>css实现文本溢出显示省略号<br>单行文本        </p><pre class="line-numbers language-css"><span class="selector-tag"><code class="language-css"><span class="selector-tag">p</span> {          <span class="attribute">width</span>: <span class="number">300px</span>;          <span class="attribute">overflow</span>: hidden;          <span class="comment">/*文本不会换行*/</span>          <span class="attribute">white-space</span>: nowrap;          <span class="comment">/*当文本溢出包含元素时，以省略号表示超出的文本*/</span>          <span class="attribute">text-overflow</span>: ellipsis;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多行文本看链接<a href="https://www.jianshu.com/p/50bbd21c0c0f" target="_blank" rel="noopener">css多行文本溢出显示省略号</a>        </p></li></ul><ul><li>三栏布局        <blockquote><p>1.flex布局:容器flex，两边固定px，中间flex1<br>2.绝对定位布局：容器相对，两边绝对，中间margin固定<br>3.圣杯模式： 中间100%，fll，然后左边fll+负向ml再定位调整，右边同理<br>关键在于理解负边距的作用，left的margin-left:-100%使它上移一行        </p></blockquote><pre class="line-numbers language-css"><span class="selector-class"><code class="language-css"><span class="selector-class">.wrapper</span> {          <span class="attribute">overflow</span>: hidden;          <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;            }            <span class="selector-class">.middle</span> {          <span class="attribute">position</span>:relative;                      <span class="attribute">width</span>: <span class="number">100%</span>;          <span class="attribute">float</span>: left;          <span class="attribute">height</span>: <span class="number">80px</span>;          <span class="attribute">background</span>: green;            }        <span class="selector-class">.left</span> {          <span class="attribute">position</span>: relative;          <span class="attribute">float</span>: left;          <span class="attribute">width</span>: <span class="number">100px</span>;          <span class="attribute">background</span>: yellow;          <span class="attribute">height</span>: <span class="number">80px</span>;          <span class="attribute">left</span>: -<span class="number">100px</span>;          <span class="attribute">margin-left</span>: -<span class="number">100%</span>;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>4.双飞翼布局： 中间容器wrapper浮动，width100%，main的ml和mr固定，左右浮动和ml、mr<br>跟圣杯布局没多大区别，就是middle的实现不一样，圣杯布局是middle+padding，双飞翼采用子元素+margin，最主要的还是负边距的使用        </p></blockquote><ul><li>列举你了解的 HTML5、CSS3 新特性<br><a href="https://juejin.im/post/5cbffe386fb9a0322564c0e5" target="_blank" rel="noopener">CSS3 和 HTML5 新特性一览</a><br>CSS3:<br>选择器，边框，背景，渐变，转换，过渡，动画，盒模型，flex，媒体查询<br>HTML5:<br>语义标签，增强型表单，音频视频，canvas， svg，地理位置，webWorker，webStorage，webSocket（全双工通讯）        </li></ul><ul><li>flex：1代表什么意思<br><code>flex: flex-grow flex-shrink flex-basis</code></li></ul><table><thead><tr><th>取值</th><th>结果</th></tr></thead><tbody><tr><td>默认</td><td><code>0 1 auto</code></td></tr><tr><td>none</td><td><code>0 0 auto</code></td></tr><tr><td>auto</td><td><code>1 1 auto</code></td></tr><tr><td>非负数</td><td><code>非负数 1 0%</code></td></tr><tr><td>长度或百分比</td><td><code>1 1 长度或百分比</code></td></tr><tr><td>非负数 非负数</td><td><code>非负数 非负数 0%</code></td></tr><tr><td>非负数 长度或百分比</td><td><code>非负数 1 长度或百分比</code></td></tr></tbody></table><p>flex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。这里主要讨论以下 flex-basis 的取值情况：<br>auto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。<br>content：指根据该子元素的内容自动布局。有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto。<br>百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。        </p><p><img src="https://www.w3.org/html/ig/zh/css-flex-1/rel-vs-abs-flex.svg" alt="flex:0 和 flex:auto的区别"><br>👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆一个显示「绝对」伸缩（以零为基准值开始）与「相对」伸缩（以项目的内容大小为基准值开始）差异的图解。这三个项目的伸缩比例分别是「1」、「1」、「2」。        </p><ul><li>Canvas 和 SVG 有什么区别<br>SVG 矢量图优点：不失真，放大缩小图像都很清晰学习成本低，也是一种 DOM 结构使用方便，设计软件可以直接导出<br>Canvas 像素图优点（在元素特别多的情况 1000+）：性能高，可以自己控制绘制过程，还能使用 WebGL可控性高，像素级控制内存占用恒定，就是像素点个数<br>SVG 的应用范围更广一些。        </li></ul><ul><li>渐进增强和优雅降级分别是什么意思<br>渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br>优雅降级（graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。        </li></ul><ul><li>css reset 是什么？css 预编译器是什么？ 后编译器(post css)是什么？<br>css reset 即重置浏览器标签的样式表        <blockquote><p>现在所使用的主流浏览器对一些标签的默认属性上并没有做到统一，所以我们偶尔会发现，某个页面在chrome浏览器上很正常，到了firefox上面却有意想不到的偏差。当然编程人员不喜欢这样的兼容性问题的，而reset.css就是解决默认样式不兼容问题的办法之一。</p></blockquote></li></ul><p>预编译器        </p><blockquote><p>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。<br>CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。</p></blockquote><p>后编译器(post css)        </p><blockquote><p>PostCSS是一个使用JavaScript插件来转换CSS的工具。它将CSS转换成抽象语法树(AST)，也就是JavaScript可以操作的一种数据形式。基于JavaScript的PostCSS插件可以执行不同的代码操作。PostCSS本身并没有改变你的CSS，它请允许插件执行和转换你的代码。<br>实际上，对于CSS的操作，PostCSS插件并没有任何限制。只要你有想得到的，你都可以写一个PostCSS插件来实现。        </p></blockquote><ul><li>浅谈css预处理器，Sass、Less和Stylus<br>下面从特性上比较三者异同：        </li></ul><ol><li><p>变量：        </p><blockquote><p>Sass声明变量必须是『$』开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号：分隔开。<br>Less 声明变量用『@』开头，其余等同 Sass。<br>Stylus 中声明变量没有任何限定，结尾的分号可有可无，但变量名和变量值之间必须要有『等号』。但需要注意的是，如果用“@”符号来声明变量，Stylus会进行编译，但不会赋值给变量。就是说，Stylus 不要使用『@』声明变量。Stylus 调用变量的方法和Less、Sass完全相同。        </p></blockquote></li><li><p>作用域：<br>css 预编译器把变量赋予作用域，也就是存在生命周期。就像 js 一样，它会先从局部作用域查找变量，依次向上级作用域查找。        </p><blockquote><p>Sass：三者最差，不存在全局变量的概念。也就是说在 Sass 中定义了相同名字的变量时你就要小心蛋疼了。<br>Less：我认为跟 JS 一样，逐级查找，向上冒泡。<br>Stylus：完全等同 Less。Stylus 和 Sass 则更倾向于指令式。        </p></blockquote></li><li><p>嵌套：<br>十分真诚的说，三种 css 预编译器的「选择器嵌套」在使用上来说没有任何区别（也可能是我没发现）。Sass 除了常规的采用『&amp;』替代父级选择器之外，还提供了「奇葩的属性嵌套」：        </p></li></ol><pre class="line-numbers language-scss"><span class="selector-class"><code class="language-scss"><span class="selector-class">.footer</span> {          <span class="attribute">font</span>: {            family:  微软雅黑;            size: <span class="number">5rem</span>;            weight: bolder;          }        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了少打几个字，感觉没啥用啊。<br>4. 继承：<br>css 属性的继承是一个非常重要的特性，好消息是三种预编译器都对此做出了改善。        </p><blockquote><p>Sass和Stylus的继承非常像，能把一个选择器的所有样式继承到另一个选择器上。使用『@extend』开始，后面接被继承的选择器。        </p></blockquote><pre class="line-numbers language-scss"><span class="selector-class"><code class="language-scss"><span class="selector-class">.shit</span> {          <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span>;          <span class="attribute">padding</span>: <span class="number">2px</span>;        }        <span class="selector-tag">p</span> {          <span class="keyword">@extend</span> .shit;<span class="comment">/*继承.block*/</span>          <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#aaa</span>;        }         <span class="selector-tag">ul</span>,<span class="selector-tag">li</span> {          <span class="keyword">@extend</span> .shit; <span class="comment">/*继承.block*/</span>          <span class="attribute">color</span>: <span class="number">#aaa</span>;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将被编译成标准 css：        </p><pre class="line-numbers language-scss"><span class="selector-class">.shit</span>,<span class="selector-tag">p</span>,<span class="selector-tag">ul</span>,<span class="selector-tag"><code class="language-scss"><span class="selector-class">.shit</span>,<span class="selector-tag">p</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">ol</span> {          <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span>;          <span class="attribute">padding</span>:<span class="number">2px</span>;        }          <span class="selector-tag">p</span> {          <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#aaa</span>        }           ul,li {          color:<span class="number">#aaa</span>;        }        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Less 继承：与前两者继承方式有所区别，它不是在选择器上继承，而是将Mixins中的样式嵌套到每个选择器里面。然而这样会带来一个明显的缺点：每个选择器中会出现重复的样式。        </p></blockquote><ol start="5"><li>导入@Import：<br>CSS中，不建议用@import导入css，因为会增加http请求。但 CSS 预处理器中的导入和CSS的有很大区别，它是将不同 css 是在语义上导入，最终编译结果会生成一个CSS文件。        </li></ol><p>值得注意的是，如果不同文件相互引入的时候，出现相同变量名时可能会引起错误。所以我的建议是单独有一个 var.sass/less/styl 文件来记录所有你定义的变量。        </p><p>Less 为@Import 扩展了语法，而 Sass 和 Stylus 并没有。具体扩展的 import 语法请见：Less 的 Import 扩展        </p><p>总结        </p><blockquote><p>Sass和Less语法严谨、Stylus相对自由。因为Less长得更像 css，所以它可能学习起来更容易。<br>Sass 和 Compass、Stylus 和 Nib 都是好基友。<br>Sass 和 Stylus 都具有类语言的逻辑方式处理：条件、循环等，而 Less 需要通过When等关键词模拟这些功能，这方面 Less 比不上 Sass 和 Stylus。<br>Less 在丰富性以及特色上都不及 Sass 和 Stylus，若不是因为 Bootstrap 引入了 Less，可能它不会像现在这样被广泛应用        </p></blockquote><ul><li>CSS中 link 和@import 的区别<br>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载<br>import只在IE5以上才能识别，而link是HTML标签，无兼容问题<br>link方式的样式的权重 高于@import的权重        </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇文章总结了 html 部分针对面试的一些沉淀&lt;br&gt;今天主要是 css 部分内容，下面开始。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jambo0624.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』 html questions (part 2)</title>
    <link href="https://jambo0624.github.io/2020-04-12-html-question2.html"/>
    <id>https://jambo0624.github.io/2020-04-12-html-question2.html</id>
    <published>2020-04-12T03:16:23.000Z</published>
    <updated>2020-10-19T08:56:12.733Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jambo0624.github.io/2020-04-10-html-question.html">前一篇文章</a>整理了 html 在面试中可能会被问到的问题，现在把整理的第二部分记录下来。<br>我们开始吧。</p><a id="more"></a><ul><li>为什么操作 DOM 慢？（浏览器绘制过程）<blockquote><p>一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</p></blockquote></li><li>DOMContentLoaded 事件和 Load 事件的区别？<blockquote><p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。</p></blockquote></li></ul><blockquote><p>Load 事件是当所有资源加载完成后触发的。</p></blockquote><ul><li><p>HTML5 有哪些新特性、移除了那些元素？<br>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p><p>新增的有：</p></li></ul><blockquote><p>绘画 canvas;<br>用于媒介回放的 video 和 audio 元素;<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;<br>sessionStorage 的数据在浏览器关闭后自动删除;<br>语意化更好的内容元素，比如 article、footer、header、nav、section;<br>表单控件，calendar、date、time、email、url、search;<br>新的技术 webworker, websocket;<br>新的文档属性 document.visibilityState</p></blockquote><p> 移除的元素有：</p><blockquote><p>纯表现的元素：basefont，big，center，font, s，strike，tt，u;<br>对可用性产生负面影响的元素：frame，frameset，noframes；</p></blockquote><ul><li>如何处理 HTML5 新标签的浏览器兼容问题？<blockquote><p>（1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。</p></blockquote></li></ul><blockquote><p>（2） 当然也可以直接使用成熟的框架，比如 html5shim ;</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!--[<span class="keyword">if</span> lt IE <span class="number">9</span>]&gt;</span><br><span class="line"> &lt;script src=<span class="string">"http://html5shim.googlecode.com/svn/trunk/html5.js"</span>&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"> &lt;![endif]--&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。</span></span><br></pre></td></tr></table></figure><ul><li>简述一下你对 HTML 语义化的理解？</li></ul><blockquote><p>（1） 用正确的标签做正确的事情。<br>（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;<br>（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;<br>（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p></blockquote><p>回答：</p><blockquote><p>我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。<br>html 的本质作用其实就是定义网页文档的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。<br>这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读。<br>比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。<br>对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。<br>如果用户使用的是屏幕阅读器来访问网页的话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。<br>如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO 。<br>从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、footer 这些语义标签，删除了 big 、font 这些没有语义的标签。</p></blockquote><ul><li>b 与 strong 的区别和 i 与 em 的区别？<blockquote><p>从页面显示效果来看，被 <code>&lt;b&gt;</code> 和 <code>&lt;strong&gt;</code> 包围的文字将会被加粗，而被 <code>&lt;i&gt;</code> 和 <code>&lt;em&gt;</code> 包围的文字将以斜体的形式呈现。</p></blockquote></li></ul><blockquote><p>但是 <code>&lt;b&gt;</code> <code>&lt;i&gt;</code> 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 <code>{ font-weight: bolder}</code>，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。</p></blockquote><blockquote><p>而 <code>&lt;em&gt;</code> 和 <code>&lt;strong&gt;</code> 是语义样式标签。 <code>&lt;em&gt;</code> 表示一般的强调文本，而 <code>&lt;strong&gt;</code> 表示比 <code>&lt;em&gt;</code> 语义更强的强调文本。</p></blockquote><blockquote><p>使用阅读设备阅读网页时：<code>&lt;strong&gt;</code> 会重读，而 <code>&lt;b&gt;</code> 是展示强调内容。</p></blockquote><ul><li><p>前端需要注意哪些 SEO ？</p><blockquote><p>（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。</p><p>（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。</p><p>（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。</p><p>（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p><p>（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容</p><p>（6）非装饰性图片必须加 alt</p><p>（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</p></blockquote></li><li><p>HTML5 的离线储存怎么使用，工作原理能不能解释一下？<br>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p><p>原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>如何使用：</p></li></ul><p>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。 <code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></p><p>（2）在如下 cache.manifest 文件的编写离线存储的资源。</p><blockquote><p><code>CACHE MANIFEST</code><br><code>#v0.11</code><br><code>CACHE:</code><br><code>js/app.js</code><br><code>css/style.css</code><br><code>NETWORK:</code><br><code>resourse/logo.png</code><br><code>FALLBACK:</code><br><code>/ /offline.html</code></p><p>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</p><p>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</p><p>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</p></blockquote><p> （3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</p><p> 如何更新缓存：</p><blockquote><p>（1）更新 manifest 文件<br>（2）通过 javascript 操作<br>（3）清除浏览器缓存</p></blockquote><p> 注意事项：</p><blockquote><p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。<br>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。<br>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。<br>（4）FALLBACK 中的资源必须和 manifest 文件同源。<br>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。<br>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。<br>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p></blockquote><ul><li><p>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</p><blockquote><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p></blockquote><blockquote><p>离线的情况下，浏览器就直接使用离线存储的资源。</p></blockquote></li><li><p>常见的浏览器端的存储技术有哪些？</p><blockquote><p>浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。</p></blockquote><blockquote><p>还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。</p></blockquote><blockquote><p>IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。</p></blockquote></li><li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？<br>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储大小：</span><br><span class="line">  cookie 数据大小不能超过<span class="number">4</span> k 。</span><br><span class="line">  sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 <span class="number">5</span>M 或更大。</span><br><span class="line"></span><br><span class="line">有期时间：</span><br><span class="line">  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。</span><br><span class="line">  sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会</span><br><span class="line">                    保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。</span><br><span class="line">  cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</span><br><span class="line"> </span><br><span class="line">作用域：</span><br><span class="line">    sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。</span><br><span class="line">    localStorage    在所有同源窗口中都是共享的。</span><br><span class="line">    cookie          在所有同源窗口中都是共享的。</span><br></pre></td></tr></table></figure></li></ul><p>回答：</p><blockquote><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p></blockquote><blockquote><p>cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</p></blockquote><blockquote><p>sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</p></blockquote><blockquote><p>localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</p></blockquote><blockquote><p>上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p></blockquote><ul><li><p>iframe 有那些缺点？<br>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><p>主要缺点有：</p><blockquote><p>（1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。<br>（2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。<br>（3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。<br>（4） 浏览器的后退按钮失效。<br>（5） 小型的移动设备无法完全显示框架。</p></blockquote></li><li><p>Label 的作用是什么？是怎么用的？<br>label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"Name"</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">“text“</span> <span class="attr">name</span>=<span class="string">"Name"</span> <span class="attr">id</span>=<span class="string">"Name"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>HTML5 的 form 的自动完成功能是什么？</p><blockquote><p>autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。</p><p>自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。</p><p>autocomplete 属性适用于 <code>&lt;form&gt;</code>，以及下面的 <code>&lt;input&gt;</code> 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。</p></blockquote></li><li><p>如何实现浏览器内多个标签页之间的通信?<br>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）如果我们能够获得对应标签页的引用，通过 <span class="string">`postMessage`</span> 方法也是可以实现多个标签页通信的。</span><br></pre></td></tr></table></figure></li></ul><p>回答：</p><blockquote><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。</p><p>第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</p><p>第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</p><p>第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</p><p>还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。</p></blockquote><ul><li><p>webSocket 如何兼容低版本浏览器？</p><blockquote><p>Adobe Flash Socket 、<br>ActiveX HTMLFile (IE) 、<br>基于 multipart 编码发送 XHR 、<br>基于长轮询的 XHR</p></blockquote></li><li><p>页面可见性（Page Visibility API） 可以有哪些用途？<br>这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。</p><blockquote><p>（1）对服务器的轮询<br>（2）网页动画<br>（3）正在播放的音频或视频</p></blockquote></li><li><p>如何在页面上实现一个圆形的可点击区域？</p><blockquote><p>（1）纯 html 实现，使用 <area> 来给 <img> 图像标记热点区域的方式，<map> 标签用来定义一个客户端图像映射，<area> 标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击的圆形区域。</p><p>（2）纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。</p><p>（3）纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内。</p></blockquote></li><li><p>实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。<br><code>&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></p></li><li><p>title 与 h1 的区别？</p><blockquote><p>title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。</p></blockquote></li><li><p><img> 的 title 和 alt 有什么区别？<br>title 通常当鼠标滑动到元素上的时候显示</p><p>alt 是 <img> 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</p></li><li><p>Canvas 和 SVG 有什么区别？</p><blockquote><p>Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。</p><p>SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。</p></blockquote></li><li><p>网页验证码是干嘛的，是为了解决什么安全问题？</p><blockquote><p>（1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水<br>（2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</p></blockquote></li><li><p>渐进增强和优雅降级的定义</p><blockquote><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p>优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。</p></blockquote></li><li><p>attribute 和 property 的区别是什么？</p><blockquote><p>attribute 是 dom 元素在文档中作为 html 标签拥有的属性；<br>property 就是 dom 元素在 js 中作为对象拥有的属性。<br>对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，<br>但是对于自定义的属性来说，他们是不同步的。</p></blockquote></li><li><p>对 web 标准、可用性、可访问性的理解</p><blockquote><p>可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</p><p>可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性</p><p>可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</p></blockquote></li><li><p>IE 各版本和 Chrome 可以并行下载多少个资源？</p><blockquote><p>（1）  IE6 2 个并发<br>（2）  iE7 升级之后的 6 个并发，之后版本也是 6 个<br>（3）  Firefox，chrome 也是6个</p></blockquote></li><li><p>Flash、Ajax 各自的优缺点，在使用中如何取舍？</p><blockquote><p>Flash：（1） Flash 适合处理多媒体、矢量图形、访问机器（2） 对 CSS、处理文本上不足，不容易被搜索</p><p>Ajax：（1） Ajax 对 CSS、文本支持很好，支持搜索（2） 多媒体、矢量图形、机器访问不足</p></blockquote><p>共同点：</p><blockquote><p>（1） 与服务器的无刷新传递消息<br>（2） 可以检测用户离线和在线状态<br>（3） 操作 DOM</p></blockquote></li><li><p>怎么重构页面？</p><blockquote><p>（1） 编写 CSS<br>（2） 让页面结构更合理化，提升用户体验<br>（3） 实现良好的页面效果和提升性能</p></blockquote></li><li><p>浏览器架构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* 用户界面</span><br><span class="line">  * 主进程</span><br><span class="line">  * 内核</span><br><span class="line">      * 渲染引擎</span><br><span class="line">      * JS 引擎</span><br><span class="line">          * 执行栈</span><br><span class="line">      * 事件触发线程</span><br><span class="line">          * 消息队列</span><br><span class="line">              * 微任务</span><br><span class="line">              * 宏任务</span><br><span class="line">      * 网络异步线程</span><br><span class="line">      * 定时器线程</span><br></pre></td></tr></table></figure></li><li><p>常用的 meta 标签<br><code>&lt;meta&gt;</code> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。<br><code>&lt;meta&gt;</code> 标签位于文档的头部，不包含任何内容。<code>&lt;meta&gt;</code> 标签的属性定义了与文档相关联的名称/值对。</p></li></ul><blockquote><p><code>&lt;!DOCTYPE html&gt;</code>  H5标准声明，使用 HTML5 doctype，不区分大小写<br><code>&lt;head lang=”en”&gt;</code> 标准的 lang 属性写法<br><code>&lt;meta charset=’utf-8′&gt;</code>    声明文档使用的字符编码<br><code>&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt;</code>   优先使用 IE 最新版本和 Chrome<br><code>&lt;meta name=”description” content=”不超过150个字符”/&gt;</code>       页面描述<br><code>&lt;meta name=”keywords” content=””/&gt;</code>      页面关键词者<br><code>&lt;meta name=”author” content=”name, email@gmail.com”/&gt;</code>    网页作<br><code>&lt;meta name=”robots” content=”index,follow”/&gt;</code>      搜索引擎抓取<br><code>&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt;</code> 为移动设备添加 viewport<br><code>&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt;</code> iOS 设备 begin<br><code>&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;</code>  添加到主屏后的标题（iOS 6 新增）<br><code>&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;</code> 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏<br><code>&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;</code> 添加智能 App 广告条 Smart App Banner(iOS 6+ Safari)<br><code>&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;</code>  设置苹果工具栏颜色<br><code>&lt;meta name=”renderer” content=”webkit”&gt;</code>  启用360浏览器的极速模式(webkit)<br><code>&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;</code>     避免IE使用兼容模式<br><code>&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;</code>    不让百度转码<br><code>&lt;meta name=”HandheldFriendly” content=”true”&gt;</code>     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓<br><code>&lt;meta name=”MobileOptimized” content=”320″&gt;</code>   微软的老式浏览器<br><code>&lt;meta name=”screen-orientation” content=”portrait”&gt;</code>   uc强制竖屏<br><code>&lt;meta name=”x5-orientation” content=”portrait”&gt;</code>    QQ强制竖屏<br><code>&lt;meta name=”full-screen” content=”yes”&gt;</code>              UC强制全屏<br><code>&lt;meta name=”x5-fullscreen” content=”true”&gt;</code>       QQ强制全屏<br><code>&lt;meta name=”browsermode” content=”application”&gt;</code>   UC应用模式<br><code>&lt;meta name=”x5-page-mode” content=”app”&gt;</code>    QQ应用模式<br><code>&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;</code>    windows phone 点击无高光<br><code>&lt;meta http-equiv=”pragma” content=”no-cache”&gt;</code>   设置页面不缓存<br><code>&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;</code>    设置页面不缓存<br><code>&lt;meta http-equiv=”expires” content=”0″&gt;</code>   设置页面不缓存  </p></blockquote><ul><li>css reset 和 normalize.css 有什么区别？<br>相关知识点：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多</span><br><span class="line">兼容性问题。</span><br><span class="line"></span><br><span class="line">reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。</span><br><span class="line"></span><br><span class="line">normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>Normalize.css 保护了有价值的默认值</span><br><span class="line"></span><br><span class="line">Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize.css 保持了许多默认的浏览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normalize.css 会力求让这些样式保持一致并尽可能与现代标准相符合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Normalize.css 修复了浏览器的 bug</span><br><span class="line"></span><br><span class="line">它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize.css 修复的问题包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中的与表单相关的 bug。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>Normalize.css 没有复杂的继承链</span><br><span class="line"></span><br><span class="line">使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize.css 中就不会有这样的问题，因为在我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Normalize.css 是模块化的</span><br><span class="line"></span><br><span class="line">这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己选择性地移除掉某些永远不会用到部分（比如表单的一般化）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>Normalize.css 拥有详细的文档</span><br><span class="line"></span><br><span class="line">Normalize.css 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己的测试。</span><br></pre></td></tr></table></figure></li></ul><p>回答：</p><blockquote><p>css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器样式保持一致的效果。<br>但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成画蛇添足的效果。<br>后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。<br>相对与 css reset，normalize.css 的方法保留了有价值的默认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。</p></blockquote><ul><li>用于预格式化文本的标签是？<blockquote><p>预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。</p></blockquote></li></ul><blockquote><p><code>&lt;pre&gt;</code> 定义预格式文本，保持文本原有的格式</p></blockquote><ul><li><p>head 标签中必不少的是？</p><blockquote><p><code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。<code>&lt;head&gt;</code> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<code>&lt;base&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code>, 以及 <code>&lt;title&gt;</code>。</p><p><code>&lt;title&gt;</code> 定义文档的标题，它是 head 部分中唯一必需的元素。</p></blockquote></li><li><p>HTML5 新增的表单元素有？</p><blockquote><p>datalist 规定输入域的选项列表，通过 option 创建！ </p><p>keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！</p><p>output 元素用于不同类型的输出！</p></blockquote></li><li><p>在 HTML5 中，哪个方法用于获得用户的当前位置？<br><code>getCurrentPosition()</code></p></li><li><p>文档的不同注释方式？<br><code>HTML 的注释方法 &lt;!--注释内容--&gt;</code> </p><p><code>CSS 的��释方法 /*注释内容*/</code> </p><p><code>JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式</code></p></li><li><p>disabled 和 readonly 的区别？</p><blockquote><p>disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。</p><p>readonly 规定输入字段为只读。input 内容会随着表单提交。</p><p>无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value</p></blockquote></li><li><p>主流浏览器内核私有属性 css 前缀？</p><blockquote><p>mozilla 内核 （firefox,flock 等）    -moz<br>webkit  内核 （safari,chrome 等）   -webkit<br>opera   内核 （opera 浏览器）        -o<br>trident 内核 （ie 浏览器）           -ms</p></blockquote></li><li><p>前端性能优化？<br>前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。</p><p>第一个方面是页面的内容方面</p><blockquote><p>（1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。</p><p>（2）通过 DNS 缓存等机制来减少 DNS 的查询次数。</p><p>（3）通过设置缓存策略，对常用不变的资源进行缓存。</p><p>（4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。</p><p>（5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。</p></blockquote><p>第二个方面是服务器方面</p><blockquote><p>（1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。</p><p>（2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。</p><p>（3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie</p></blockquote><p>第三个方面是 CSS 和 JavaScript 方面</p><blockquote><p>（1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。</p><p>（2）避免使用 @import 标签。</p><p>（3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。</p><p>（4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。</p></blockquote></li></ul><ul><li><p>扫描二维码登录网页是什么原理，前后两个事件是如何联系的？<br>核心过程应该是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server的帐号信息进行展示。</span><br><span class="line">并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。</span><br><span class="line">在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。</span><br></pre></td></tr></table></figure><p>我的理解</p><blockquote><p>二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。<br>对应的二维码对应了一个对应 uid 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。<br>比如微信的二维码登录，只有用微信识这个二维码才有效。<br>当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。<br>这个时候登录网页根据先前的长连接获取到服务器传过来的用户信息进行显示。<br>然后提前预加载一些登录后可能用到的信息。<br>当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。<br>由于整个授权的过程都是在手机端进行的，因此能够很好的防止 PC 上泛滥的病毒。<br>并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成有效的安全防护。</p></blockquote></li><li><p>Html 规范中为什么要求引用资源不加协议头http或者https？</p><blockquote><p>如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现警告信息，不同浏览器警告信息展现形式不同。</p><p>为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为<code>protocol-relative URL</code>，暂且可译作协议相对 URL。</p><p>如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似的警告信息，同时还可以节省5字节的数据量。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://jambo0624.github.io/2020-04-10-html-question.html&quot;&gt;前一篇文章&lt;/a&gt;整理了 html 在面试中可能会被问到的问题，现在把整理的第二部分记录下来。&lt;br&gt;我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jambo0624.github.io/categories/html/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>『question 系列』html questions</title>
    <link href="https://jambo0624.github.io/2020-04-10-html-question.html"/>
    <id>https://jambo0624.github.io/2020-04-10-html-question.html</id>
    <published>2020-04-10T13:26:34.000Z</published>
    <updated>2020-10-19T08:55:56.106Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是前期针对面试的一些沉淀，全都来自于各题目的汇总。首先是html部分内容，下面我们开始。 </p><a id="more"></a><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li>你是如何理解html语义化的<br>一句话就是该用什么标签时，就要用什么标签。<br>因为更好地用户体验，SEO，其他特殊设备的解析，更好地团队开发<br>比如常用的结构标记        <blockquote><p>1.header 定义网页的头部<br>2.nav 定义导航链接内部<br>3.section 定义网页主体<br>4.aside 定义网页的侧边栏内容<br>5.footer 定义网页偏底部内容<br>6.article 定义与文字描述相关的内容，如果，论坛中帖子，微博条目，用户评论等等。        </p></blockquote></li></ul><ul><li><p>img的title和alt有什么区别？<br>title是鼠标覆盖时显示的文字，在其他方面也可以使用；而alt是网页无法加载图片时代替的文字，只针对img。        </p></li><li><p>对web标准以及W3C的理解与认识?<br>web标准：是一系列标准的集合，标签闭合，标签小写，使用外链等。<br>W3C：只是一个web开发的联盟        </p></li><li><p>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code><br>html5不再基于标准通用标记语言（SGML）        </p></li><li><p>DOCTYPE 作用？严格模式与混杂模式如何区分？它们有何意义？        </p><!DOCTYPE><p>是为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档。<br>严格模式与混杂模式在DOCTYPE声明中区分。历史产物，现在几乎没意义。        </p></li><li><p>HTML 全局属性（Global Attribute）有哪些</p></li></ul><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>accesskey</td><td>规定激活元素的快捷键</td></tr><tr><td>class</td><td>规定元素的一个或多个类名（引用样式表中的类）</td></tr><tr><td>contenteditable</td><td>规定元素内容是否可编辑</td></tr><tr><td>contextmenu</td><td>规定元素的上下文菜单。上下文菜单在用户点击元素时示</td></tr><tr><td>data-*</td><td>用于存储页面或应用程序的私有定制数据</td></tr><tr><td>dir</td><td>规定元素中内容的文本方向</td></tr><tr><td>draggable</td><td>规定元素是否可拖动</td></tr><tr><td>dropzone</td><td>规定在拖动被拖动数据时是否进行复制、移动或链接</td></tr><tr><td>hidden</td><td>样式上会导致元素不显示，但是不能用这个属性实现样式</td></tr><tr><td>id</td><td>规定元素的唯一</td></tr><tr><td>lang</td><td>规定元素内容的语言</td></tr><tr><td>spellcheck</td><td>规定是否对元素进行拼写和语法检查</td></tr><tr><td>style</td><td>规定元素的CSS行内元素</td></tr><tr><td>tabindex</td><td>规定元素的tab键次序</td></tr><tr><td>title</td><td>规定有关元素的额外信息</td></tr><tr><td>translate</td><td>规定是否应该翻译元素内容</td></tr></tbody></table><ul><li><p>meta 有哪些常见的值？<br>http-equiv + content<br>name + content        </p></li><li><p>前端需要注意哪些SEO?        </p><blockquote><p>1.合理的title、description、keywords：搜索对着三项的权重逐个减小<br>2.语义化的HTML代码<br>3.重要内容HTML代码放在最前<br>4.重要内容不要用js输出：爬虫不会执行js获取内容<br>5.少用iframe：搜索引擎不会抓取iframe中的内容<br>6.非装饰性图片必须加alt<br>7.提高网站速度</p></blockquote></li><li><p>DOCTYPE 的作用是什么？</p></li></ul><blockquote><p><code>&lt;!DOCTYPE&gt;</code>  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。</p></blockquote><blockquote><p>在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。</p></blockquote><ul><li>标准模式与兼容模式各有什么区别？</li></ul><blockquote><p>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</p></blockquote><ul><li>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>，而不需要引入 DTD？<blockquote><p>HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。</p></blockquote></li></ul><blockquote><p>而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</p></blockquote><ul><li>SGML 、 HTML 、XML 和 XHTML 的区别？<blockquote><p>SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</p></blockquote></li></ul><blockquote><p>HTML 是超文本标记语言，主要是用于规定怎么显示网页。</p></blockquote><blockquote><p>XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。</p></blockquote><blockquote><p>XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p></blockquote><ul><li>DTD 介绍<blockquote><p>DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。</p></blockquote></li></ul><blockquote><p>DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。</p></blockquote><ul><li>行内元素定义<blockquote><p>HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空<br>间。</p></blockquote></li></ul><blockquote><p>常见的行内元素有 a b span img strong sub sup button input label select textarea</p></blockquote><ul><li>块级元素定义<blockquote><p>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。</p></blockquote></li></ul><blockquote><p>常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</p></blockquote><ul><li>行内元素与块级元素的区别？<br>HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。</li></ul><blockquote><p>（1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。<br>（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。<br>（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei<br>     ght），设置 margin 和 padding 的上下不会对其他元素产生影响。</p></blockquote><ul><li>HTML5 元素的分类</li></ul><blockquote><p>HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为inline 与 block 已经不再符合实际需求。</p></blockquote><blockquote><p>HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive</p></blockquote><ul><li>空元素定义<blockquote><p>标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。</p></blockquote></li></ul><blockquote><p>常见的空元素有：br hr img input link meta</p></blockquote><ul><li>link 标签定义<blockquote><p>link 标签定义文档与外部资源的关系。</p></blockquote></li></ul><blockquote><p>link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。</p></blockquote><blockquote><p>link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。</p></blockquote><ul><li>页面导入样式时，使用 link 和 @import 有什么区别？<blockquote><p>（1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。</p></blockquote></li></ul><blockquote><p>（2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</p></blockquote><blockquote><p>（3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼性问题。</p></blockquote><blockquote><p>（4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式。</p></blockquote><ul><li>你对浏览器的理解？<blockquote><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p></blockquote></li></ul><blockquote><p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。</p></blockquote><blockquote><p>但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p></blockquote><blockquote><p>简单来说浏览器可以分为两部分，shell 和 内核。</p></blockquote><p>其中 shell 的种类相对比较多，内核则比较少。<br>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。<br>它是调用内核来实现各种功能的。内核才是浏览器的核心。<br>内核是基于标记语言显示内容的程序或模块。<br>也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p><ul><li>介绍一下你对浏览器内核的理解？<blockquote><p>主要分成两部分：渲染引擎和 JS 引擎。</p></blockquote></li></ul><blockquote><p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</p></blockquote><blockquote><p>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</p></blockquote><p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><ul><li>常见的浏览器内核比较<blockquote><p>Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</p></blockquote></li></ul><blockquote><p>Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</p></blockquote><blockquote><p>Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</p></blockquote><blockquote><p>Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</p></blockquote><blockquote><p>Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</p></blockquote><ul><li><p>常见浏览器所用内核</p><blockquote><p>（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p><p>（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p><p>（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p><p>（4） Safari 浏览器内核：Webkit 内核；</p><p>（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p><p>（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p><p>（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p><p>（8） 百度浏览器、世界之窗内核：IE 内核；</p><p>（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p><p>（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p></blockquote></li><li><p>浏览器的渲染原理？</p><blockquote><p>（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</p><p>（2）然后对 CSS 进行解析，生成 CSSOM 规则树。</p><p>（3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p><p>（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p><p>（5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p></blockquote></li></ul><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><ul><li>渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）<blockquote><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p></blockquote></li></ul><blockquote><p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p></blockquote><ul><li><p>async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</p><blockquote><p>（1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><p>（2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</p><p>（3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</p></blockquote></li><li><p>什么是文档的预解析？（浏览器解析过程）</p><blockquote><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p></blockquote></li><li><p>CSS 如何阻塞文档解析？（浏览器解析过程）</p><blockquote><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</p></blockquote></li></ul><blockquote><p>所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p></blockquote><ul><li>渲染页面时常见哪些不良现象？（浏览器渲染过程）<blockquote><p>FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。</p></blockquote></li></ul><blockquote><p>白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</p></blockquote><ul><li>如何优化关键渲染路径？（浏览器渲染过程）<br>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</li></ul><blockquote><p>（1）关键资源的数量。<br>（2）关键路径长度。<br>（3）关键字节的数量。</p></blockquote><p> 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</p><p> 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。</p><p> 最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p><p> 优化关键渲染路径的常规步骤如下：</p><blockquote><p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。<br>（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。<br>（3）优化关键字节数以缩短下载时间（往返次数）。<br>（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</p></blockquote><ul><li>什么是重绘和回流？（浏览器绘制过程）<blockquote><p>重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。</p></blockquote></li></ul><blockquote><p>回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p></blockquote><p>常见引起回流属性和方法：<br>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p><blockquote><p>（1）添加或者删除可见的 DOM 元素；<br>（2）元素尺寸改变——边距、填充、边框、宽度和高度<br>（3）内容变化，比如用户在 input 框中输入文字<br>（4）浏览器窗口尺寸改变——resize事件发生时<br>（5）计算 offsetWidth 和 offsetHeight 属性<br>（6）设置 style 属性的值<br>（7）当你修改网页的默认字体时。</p></blockquote><p> 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列<br> 回流。</p><ul><li>如何减少回流？（浏览器绘制过程）<blockquote><p>（1）使用 transform 替代 top</p><p>（2）不要把节点的属性值放在一个循环里当成循环里的变量</p><p>（3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</p><p>（4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</p><p>（5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是前期针对面试的一些沉淀，全都来自于各题目的汇总。首先是html部分内容，下面我们开始。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jambo0624.github.io/categories/html/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="question" scheme="https://jambo0624.github.io/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>轮播图在切换页面时，显示凌乱的问题</title>
    <link href="https://jambo0624.github.io/2020-03-27-swiperIntervalBug.html"/>
    <id>https://jambo0624.github.io/2020-03-27-swiperIntervalBug.html</id>
    <published>2020-03-27T02:53:24.000Z</published>
    <updated>2020-10-19T03:51:06.350Z</updated>
    
    <content type="html"><![CDATA[<p>自己写轮播图时，发现轮播图效果在切换页面后，首先会有一段加速过程，之后才会正常播放。这是什么原因呢？<br>今天我们来解决这个问题。<br>下面开始。</p><a id="more"></a><p>原因是浏览器本着节省内存的原则，在页面切换到其他页面时，定时器不运动，但是动画依然排列，当切换回来的时候，动画加速运动，出现错误，在轮播图之类的页面经常会发生这样的情况      </p><p>具体需要三个知识点</p><ul><li>document.onvisibilitychange<br>只要页面发生变化，就会触发这个事件    </li><li>document.hidden<br>这个是指当页面不是当前页面时为true，否则为false   </li><li>document.visibilityState<br>visible 表示当前网页是可见或者是部分可见的。<br>hidden：当前网页是不可见的<br>prerender 网页内容被预渲染并且用户不可见<br>unloaded 如果文档被卸载，那么这个值将被返回      <h3 id="解决setInterval在浏览器切换中的问题："><a href="#解决setInterval在浏览器切换中的问题：" class="headerlink" title="解决setInterval在浏览器切换中的问题："></a>解决setInterval在浏览器切换中的问题：</h3>思路：如果页面是不可见的，那么我们就会清除定时器，如果页面是可见的，那么我们就重新开启定时器。<br>所以我们需要用<code>document.onvisibilitychange</code>进行监听，然后用<code>document.visibilityState</code>或者是<code>document.hidden</code>进行判断。<br>实际操作:    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onvisibilitychange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">document</span>.visibilityState==<span class="string">"visible"</span>)&#123;</span><br><span class="line">      timer=setInterval(slidemove, <span class="number">1000</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="jq中animate的解决"><a href="#jq中animate的解决" class="headerlink" title="jq中animate的解决"></a>jq中animate的解决</h3><p>如果用的是jq的animate这个方法，就只需要到这个方法的前面加上<code>stop(true,true)</code>       </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".slidePanel"</span>).stop(<span class="literal">true</span>,<span class="literal">true</span>).animate(&#123;</span><br><span class="line">  <span class="string">"left"</span>: -iNow*varWidth+<span class="string">"px"</span>,</span><br><span class="line">  <span class="string">"speed"</span>:<span class="number">300</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己写轮播图时，发现轮播图效果在切换页面后，首先会有一段加速过程，之后才会正常播放。这是什么原因呢？&lt;br&gt;今天我们来解决这个问题。&lt;br&gt;下面开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="interval" scheme="https://jambo0624.github.io/tags/interval/"/>
    
  </entry>
  
  <entry>
    <title>Promise 知识梳理</title>
    <link href="https://jambo0624.github.io/2020-03-08-promise.html"/>
    <id>https://jambo0624.github.io/2020-03-08-promise.html</id>
    <published>2020-03-08T07:13:32.000Z</published>
    <updated>2020-10-19T03:46:17.253Z</updated>
    
    <content type="html"><![CDATA[<p>最近会梳理一些带题目的知识点，除了让知识更系统。也让知识更具有细节，也更经得起考验。<br>今天先从 Promise 开始。</p><a id="more"></a><p>promise 知识梳理</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><code>event loop</code>它的执行顺序：  </p><blockquote><p>一开始整个脚本作为一个宏任务执行<br>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列<br>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完<br>执行浏览器<code>UI线程</code>的渲染工作<br>检查是否有<code>Web Worker</code>任务，有则执行<br>执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空 </p></blockquote><p>微任务包括：<code>MutationObserver</code>、<code>Promise.then()</code>或<code>reject()</code>、<code>Promise</code>为基础开发的其它技术，比如<code>fetch API</code>、<code>V8的垃圾回收过程</code>、Node独有的<code>process.nextTick</code><br>宏任务包括：<code>script</code> 、<code>setTimeout</code>、<code>setInterval</code> 、<code>setImmediate</code> 、<code>I/O</code>、<code>UI rendering</code>。<br>注意⚠️：在所有任务开始的时候，由于宏任务中包括了<code>script</code>，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如<code>setTimeout</code>)将被放到下一轮宏任务中来执行。  </p><h3 id="1-Promise的几道基础题"><a href="#1-Promise的几道基础题" class="headerlink" title="1. Promise的几道基础题"></a>1. Promise的几道基础题</h3><ul><li><p>题目一  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, promise1)</span><br></pre></td></tr></table></figure><p>过程分析：<br>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code><br>然后执行同步代码<code>1</code>，此时<code>promise1</code>没有被<code>resolve</code>或者<code>reject</code>，因此状态还是<code>pending</code><br>结果：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure></li><li><p>题目二  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>过程分析：<br>从上至下，先遇到<code>new Promise</code>，执行其中的同步代码<code>1</code><br>再遇到<code>resolve(&#39;success&#39;)</code>， 将<code>promise</code>的状态改为了<code>resolved</code>并且将值保存下来<br>继续执行同步代码<code>2</code><br>跳出<code>promise</code>，往下执行，碰到<code>promise.then</code>这个微任务，将其加入微任务队列<br>执行同步代码<code>4</code><br>本轮宏任务全部执行完毕，检查微任务队列，发现<code>promise.then</code>这个微任务且状态为<code>resolved</code>，执行它。<br>结果：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目三  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>过程分析<br>和题目二相似，只不过在<code>promise</code>中并没有<code>resolve</code>或者<code>reject</code><br>因此<code>promise.then</code>并不会执行，它只有在被改变了状态之后才会执行。<br>结果：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目四   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve(<span class="string">'resolve1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>,promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>,promise2)</span><br></pre></td></tr></table></figure>过程分析：<br>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code><br>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来<br>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列<br><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code><br>执行同步代码<code>1</code>， 同时打印出<code>promise1</code>的状态是<code>resolved</code><br>执行同步代码<code>2</code>，同时打印出<code>promise2</code>的状态是<code>pending</code><br>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。<br>结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">'resolve1'</span>&#125;</span><br><span class="line"><span class="string">'2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'resolve1'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目五  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>结果：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'success'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目六  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>是的，现在<code>start</code>就在<code>1</code>之前打印出来了，因为<code>fn</code>函数是之后执行的。<br>注意⚠️：之前我们很容易就以为看到<code>new Promise()</code>就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。<br>结果：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start"</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Promise结合setTimeout"><a href="#Promise结合setTimeout" class="headerlink" title="Promise结合setTimeout"></a>Promise结合setTimeout</h3><ul><li><p>题目一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'time'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><p>过程分析：<br>刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出<code>start</code>和<code>end</code>。<br><code>setTimout</code>作为一个宏任务被放入宏任务队列(下一个)<br><code>Promise.then</code>作为一个微任务被放入微任务队列<br>本次宏任务执行完，检查微任务，发现<code>Promise.then</code>，执行它<br>接下来进入下一个宏任务，发现<code>setTimeout</code>，执行。<br>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'end'</span></span><br><span class="line"><span class="string">'resolve'</span></span><br><span class="line"><span class="string">'time'</span></span><br></pre></td></tr></table></figure></li><li><p>题目二  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timerStart"</span>);</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timerEnd"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>过程分析：<br>和题目<code>1.2</code>很像，不过在<code>resolve</code>的外层加了一层<code>setTimeout</code>定时器。<br>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>1</code><br>然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行<br>执行同步代码<code>2</code><br>跳出<code>promise</code>函数，遇到<code>promise.then</code>，但其状态还是为<code>pending</code>，这里理解为先不执行<br>执行同步代码<code>4</code><br>一轮循环过后，进入第二次宏任务，发现延迟队列中有<code>setTimeout</code>定时器，执行它<br>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列<br>继续执行同步代码<code>timerEnd</code><br>宏任务全部执行完毕，查找微任务队列，发现<code>promise.then</code>这个微任务，执行它。<br>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="string">"timerStart"</span></span><br><span class="line"><span class="string">"timerEnd"</span></span><br><span class="line"><span class="string">"success"</span></span><br></pre></td></tr></table></figure></li><li><p>题目三<br>题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么：<br>(1)  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer3'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure><p>(2)  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure><p>结果：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer3'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br></pre></td></tr></table></figure><p>这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。<br>一个是为定时器<code>timer3</code>，一个是为<code>Promise.then</code><br>但是如果是定时器<code>timer3</code>的话，它会在<code>timer2</code>后执行，而<code>Promise.then</code>却是在<code>timer2</code>之前执行。<br>你可以这样理解，<code>Promise.then</code>是微任务，它会被加入到本轮中的微任务列表，而定时器<code>timer3</code>是宏任务，它会被加入到下一轮的宏任务中。<br>理解完这两个案例，可以来看看下面一道比较难的题目了。     </p></li></ul><ul><li>题目四<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  <span class="keyword">const</span> timer2 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> timer1 = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>这道题稍微的难一些，在promise中执行定时器，又在定时器中执行promise；<br>并且要注意的是，这里的Promise是直接resolve的，而之前的new Promise不一样。<br>因此过程分析为：<br>刚开始整个脚本作为第一次宏任务来执行，我们将它标记为<strong>宏1</strong>，从上至下执行<br>遇到<code>Promise.resolve().then</code>这个微任务，将<code>then</code>中的内容加入第一次的微任务队列标记为<strong>微1</strong><br>遇到定时器<code>timer1</code>，将它加入下一次宏任务的延迟列表，标记为<strong>宏2</strong>，等待执行(先不管里面是什么内容)<br>执行<strong>宏1</strong>中的同步代码<code>start</code><br>第一次宏任务(<strong>宏1</strong>)执行完毕，检查第一次的微任务队列(<strong>微1</strong>)，发现有一个<code>promise.then</code>这个微任务需要执行<br>执行打印出<strong>微1</strong>中同步代码<code>promise1</code>，然后发现定时器<code>timer2</code>，将它加入<strong>宏2</strong>的后面，标记为<strong>宏3</strong><br>第一次微任务队列(<strong>微1</strong>)执行完毕，执行第二次宏任务(<strong>宏2</strong>)，首先执行同步代码<code>timer1</code><br>然后遇到了<code>promise2</code>这个微任务，将它加入此次循环的微任务队列，标记为<strong>微2</strong><br><strong>宏2</strong>中没有同步代码可执行了，查找本次循环的微任务队列(<strong>微2</strong>)，发现了<code>promise2</code>，执行它<br>第二轮执行完毕，执行<strong>宏3</strong>，打印出<code>timer2</code><br>所以结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br></pre></td></tr></table></figure><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>从上至下，先执行第一个new Promise中的函数，碰到setTimeout将它加入下一个宏任务列表<br>跳出new Promise，碰到promise1.then这个微任务，但其状态还是为pending，这里理解为先不执行<br>promise2是一个新的状态为pending的Promise<br>执行同步代码console.log(‘promise1’)，且打印出的promise1的状态为pending<br>执行同步代码console.log(‘promise2’)，且打印出的promise2的状态为pending<br>碰到第二个定时器，将其放入下一个宏任务列表<br>第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务<br>先执行第一个定时器里的内容，将promise1的状态改为resolved且保存结果并将之前的promise1.then推入微任务队列<br>该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是promise1.then，它抛出了一个错误，且将promise2的状态设置为了rejected<br>第一个定时器执行完毕，开始执行第二个定时器中的内容<br>打印出’promise1’，且此时promise1的状态为resolved<br>打印出’promise2’，且此时promise2的状态为rejected    </p><p>完整的结果为：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line">test5.html:<span class="number">102</span> Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!! at test.html:<span class="number">102</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">"success"</span>&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;rejected&gt;: <span class="built_in">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure><ul><li>题目六<br>如果你上面这道题搞懂了之后，我们就可以来做做这道了，你应该能很快就给出答案：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timer1"</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1里的内容"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error!!!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"timer2"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1里的内容'</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line">test5.html:<span class="number">102</span> Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!! at test.html:<span class="number">102</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'promise1'</span> <span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="string">"success"</span>&#125;</span><br><span class="line"><span class="string">'promise2'</span> <span class="built_in">Promise</span>&#123;&lt;rejected&gt;: <span class="built_in">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Promise中的then、catch、finally"><a href="#Promise中的then、catch、finally" class="headerlink" title="Promise中的then、catch、finally"></a>Promise中的then、catch、finally</h3><p>总结：</p><blockquote><p>Promise的状态一经改变就不能再改变。(见3.1)<br>.then和.catch都会返回一个新的Promise。(上面的👆1.4证明了)<br>catch不管被连接到哪里，都能捕获上层的错误。(见3.2)<br>在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。<br>Promise 的 .then 或者 .catch 可以被调用多次, 当如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。(见3.5)<br>.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。(见3.6)<br>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。(见3.7)<br>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。(见3.8)<br>.then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。(见3.9)<br>.finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。  </p></blockquote><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then: "</span>, res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"then: success1"</span></span><br></pre></td></tr></table></figure>构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用 。验证了第一个结论，Promise的状态一经改变就不能再改变。</li></ul><hr><ul><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then1: "</span>, res);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then2: "</span>, res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then3: "</span>, res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"catch: "</span> <span class="string">"error"</span></span><br><span class="line"><span class="string">"then3: "</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>验证了第三个结论，catch不管被连接到哪里，都能捕获上层的错误。<br>至于then3也会被执行，那是因为catch()也会返回一个Promise，且由于这个Promise没有返回值，所以打印出来的是undefined。   </li></ul><hr><ul><li>题目三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>Promise可以链式调用，不过promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般我们任务的链式调用一样return this。<br>上面的输出结果之所以依次打印出1和2，那是因为resolve(1)之后走的是第一个then方法，并没有走catch里，所以第二个then中的res得到的实际上是第一个then的返回值。<br>且return 2会被包装成resolve(2)。  </li></ul><hr><ul><li>题目四<br>如果把3.3中的Promise.resolve(1)改为Promise.reject(1)又会怎么样呢？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>结果打印的当然是 1 和 3啦，因为reject(1)此时走的就是catch，且第二个then中的res得到的就是catch中的返回值。  </li></ul><hr><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'timer'</span></span><br><span class="line">success <span class="number">1001</span></span><br><span class="line">success <span class="number">1002</span></span><br></pre></td></tr></table></figure>当然，如果你足够快的话，也可能两个都是1001。<br>Promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。  </li></ul><hr><ul><li>题目六<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then: "</span>, res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>你可能想到的是进入.catch然后被捕获了错误。</li></ul><p>结果并不是这样的，它走的是.then里面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"then: "</span> <span class="string">"Error: error!!!"</span></span><br></pre></td></tr></table></figure><p>这也验证了第4点和第6点，返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的return new Error(‘error!!!’)也被包裹成了return Promise.resolve(new Error(‘error!!!’))。<br>当然如果你抛出一个错误的话，可以用下面👇两的任意一种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>));</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br></pre></td></tr></table></figure><ul><li>题目七<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="built_in">console</span>.err)</span><br></pre></td></tr></table></figure>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。  </li></ul><p>因此结果会报错： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure><ul><li>题目八<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="number">2</span>)</span><br><span class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>其实你只要记住原则8：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。  </li></ul><p>第一个then和第二个then中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将resolve(1) 的值直接传到最后一个then里。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>题目九<br>下面来介绍一下.then函数中的两个参数。  </li></ul><p>第一个参数是用来处理Promise成功的函数，第二个则是处理失败的函数。  </p><p>也就是说Promise.resolve(‘1’)的值会进入成功的函数，Promise.reject(‘2’)的值会进入失败的函数。<br>让我们来看看这个例子🌰：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err!!!'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'catch'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的执行结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'error'</span> <span class="string">'error!!!'</span></span><br></pre></td></tr></table></figure><p>它进入的是then()中的第二个参数里面，而如果把第二个参数去掉，就进入了catch()中：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err!!!'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'catch'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'catch'</span> <span class="string">'error!!!'</span></span><br></pre></td></tr></table></figure><p>但是有一个问题，如果是这个案例呢？  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> <span class="title">success</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail1</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fail1'</span>, err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">fail2</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fail2'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于Promise调用的是resolve()，因此.then()执行的应该是success()函数，可是success()函数抛出的是一个错误，它会被后面的catch()给捕获到，而不是被fail1函数捕获。  </p><p>因此执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fail2 <span class="built_in">Error</span>: error!!!</span><br></pre></td></tr></table></figure><ul><li>题目十<br>接着来看看.finally()，这个功能一般不太用在面试中，不过如果碰到了你也应该知道该如何处理。<br>其实你只要记住它三个很重要的知识点就可以了：  </li></ul><blockquote><p>.finally()方法不管Promise对象最后的状态如何都会执行<br>.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的<br>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。  </p></blockquote><p>来看看这个简单的例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'2'</span>)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally2'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我是finally2返回的值'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally2后面的then函数'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这两个Promise的.finally都会执行，且就算finally2返回了新的值，它后面的then()函数接收到的结果却还是’2’，因此打印结果为：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="string">'finally2'</span></span><br><span class="line"><span class="string">'finally'</span></span><br><span class="line"><span class="string">'finally2后面的then函数'</span> <span class="string">'2'</span></span><br></pre></td></tr></table></figure><p>至于为什么finally2的打印要在finally前面，请看下一个例子中的解析。  </p><p>不过在此之前让我们再来确认一下，finally中要是抛出的是一个异常是怎样的：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally1'</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'我是finally中抛出的异常'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally后面的then函数'</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获错误'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'finally1'</span></span><br><span class="line"><span class="string">'捕获错误'</span> <span class="built_in">Error</span>: 我是<span class="keyword">finally</span>中抛出的异常</span><br></pre></td></tr></table></figure><p>但是如果改为return new Error(‘我是finally中抛出的异常’)，打印出来的就是’finally后面的then函数 1’   </p><p>OK，👌，让我们来看一个比较难的例子🌰：   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve(<span class="string">'1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally1'</span>))</span><br><span class="line"></span><br><span class="line">promise2()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally2'</span>))</span><br></pre></td></tr></table></figure><p>执行过程：  </p><p>首先定义了两个函数promise1和promise2，先不管接着往下看。<br>promise1函数先被调用了，然后执行里面new Promise的同步代码打印出promise1<br>之后遇到了resolve(1)，将p的状态改为了resolved并将结果保存下来。<br>此时promise1内的函数内容已经执行完了，跳出该函数<br>碰到了promise1().then()，由于promise1的状态已经发生了改变且为resolved因此将promise1().then()这条微任务加入本轮的微任务列表(这是第一个微任务)<br>这时候要注意了，代码并不会接着往链式调用的下面走，也就是不会先将.finally加入微任务列表，那是因为.then本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管.finally()<br>再往下走碰到了promise2()函数，其中返回的new Promise中并没有同步代码需要执行，所以执行reject(‘error’)的时候将promise2函数中的Promise的状态变为了rejected<br>跳出promise2函数，遇到了promise2().then()，将其加入当前的微任务队列(这是第二个微任务)，且链式调用后面的内容得等该任务执行完后才执行，和.then()一样。<br>OK， 本轮的宏任务全部执行完了，来看看微任务列表，存在promise1().then()，执行它，打印出1，然后遇到了.finally()这个微任务将它加入微任务列表(这是第三个微任务)等待执行<br>再执行promise2().catch()打印出error，执行完后将finally2加入微任务加入微任务列表(这是第四个微任务)<br>OK， 本轮又全部执行完了，但是微任务列表还有两个新的微任务没有执行完，因此依次执行finally1和finally2。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="string">'error'</span></span><br><span class="line"><span class="string">'finally1'</span></span><br><span class="line"><span class="string">'finally2'</span></span><br></pre></td></tr></table></figure><p>在这道题中其实能拓展的东西挺多的，之前没有提到，那就是你可以理解为链式调用后面的内容需要等前一个调用执行完才会执行。<br>就像是这里的finally()会等promise1().then()执行完才会将finally()加入微任务队列，其实如果这道题中你把finally()换成是then()也是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve(<span class="string">'1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally1'</span>))</span><br><span class="line"></span><br><span class="line">promise2()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally2'</span>))</span><br></pre></td></tr></table></figure><h3 id="Promise中的all和race"><a href="#Promise中的all和race" class="headerlink" title="Promise中的all和race"></a>Promise中的all和race</h3><p>在做下面👇的题目之前，让我们先来了解一下Promise.all()和Promise.race()的用法。<br>通俗来说，.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。<br>.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</p><ul><li>题目一<br>我们知道如果直接在脚本文件中定义一个Promise，它构造函数的第一个参数是会立即执行的，就像这样：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'立即打印'</span>))</span><br></pre></td></tr></table></figure>控制台中会立即打印出 “立即打印”。</li></ul><p>因此为了控制它什么时候执行，我们可以用一个函数包裹着它，在需要它执行的时候，调用这个函数就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runP1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'立即打印'</span>))</span><br><span class="line">  <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runP1() <span class="comment">// 调用此函数时才执行</span></span><br></pre></td></tr></table></figure><p>OK 👌， 让我们回归正题。</p><p>现在来构建这么一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数传入一个值x，然后间隔一秒后打印出这个x。</p><p>如果我用.all()来执行它会怎样呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>先来想想此段代码在浏览器中会如何执行？</p><p>没错，当你打开页面的时候，在间隔一秒后，控制台会同时打印出1, 2, 3，还有一个数组[1, 2, 3]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>所以你现在能理解这句话的意思了吗：有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。<br>.all()后面的.then()里的回调函数接收的就是所有异步操作的结果。<br>而且这个结果中数组的顺序和Promise.all()接收到的数组顺序一致！！！</p><blockquote><p>有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p></blockquote><ul><li>题目二<br>我新增了一个runReject函数，它用来在1000 * x秒后reject一个错误。</li></ul><p>同时.catch()函数能够捕获到.all()里最先的那个异常，并且只执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> rej(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="built_in">console</span>.log(x)), <span class="number">1000</span> * x))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 2s后输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">Error</span>: <span class="number">2</span></span><br><span class="line"><span class="comment">// 4s后输出</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>没错，就像我之前说的，.catch是会捕获最先的那个异常，在这道题目中最先的异常就是runReject(2)的结果。<br>另外，如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。</p><p>哈哈，大家别忘了.then()方法的第二个参数也是可以捕获错误的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), </span><br><span class="line">err =&gt; <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><ul><li>题目三<br>所以使用.race()方法，它只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，不过race已经不管那些任务的结果了。</li></ul><p>来，改造一下4.1这道题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'result: '</span>, res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'result: '</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p></blockquote><ul><li>题目四<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> rej(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="built_in">console</span>.log(x)), <span class="number">1000</span> * x)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([runReject(<span class="number">0</span>), runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"result: "</span>, res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>遇到错误的话，也是一样的，在这道题中，runReject(0)最先执行完，所以进入了catch()中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="string">'Error: 0'</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>总结<br>好的，让我们来总结一下.then()和.race()吧，😄</li></ul><blockquote><p>Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。<br>.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。<br>Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。</p></blockquote><h3 id="async-await的几道题"><a href="#async-await的几道题" class="headerlink" title="async/await的几道题"></a>async/await的几道题</h3><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>答案：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>首先一进来是创建了两个函数的，我们先不看函数的创建位置，而是看它的调用位置<br>发现async1函数被调用了，然后去看看调用的内容<br>执行函数中的同步代码async1 start，之后碰到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1<br>跳出async1函数后，执行同步代码start<br>在一轮宏任务全部执行完之后，再来执行刚刚await后面的内容async1 end。</p><p>在这里，你可以理解为await后面的内容就相当于放到了Promise.then的里面。<br>让我们来看看将await转换为Promise.then的伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="comment">// 原来代码</span></span><br><span class="line">  <span class="comment">// await async2();</span></span><br><span class="line">  <span class="comment">// console.log("async1 end");</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 转换后代码</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async2"</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><p>另外关于await和Promise的区别，如果我们把await async2()换成一个new Promise呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><p>此时的执行结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async start'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'start'</span></span><br></pre></td></tr></table></figure><p><strong>可以看到new Promise()并不会阻塞后面的同步代码async1 end的执行。</strong></p><ul><li>题目二<br>现在将async结合定时器看看。<br>给题目一中的 async2函数中加上一个定时器：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure>没错，定时器始终还是最后执行的，它被放到下一条宏任务的延迟队列中。<br>答案：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'timer'</span></span><br></pre></td></tr></table></figure></li><li>题目三<br>来吧，小伙伴们，让我们多加几个定时器看看。😁<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer3'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer3'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br></pre></td></tr></table></figure>复制代码定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是0，所以只要关注谁先被调用的。</li></ul><hr><ul><li>题目四<br>正常情况下，async中的await命令是一个Promise对象，返回该对象的结果。</li></ul><p>但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return await 1234</span></span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li>题目五<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt end'</span>)</span><br></pre></td></tr></table></figure>这道题目比较有意思，大家要注意了。<br>在async1中await后面的Promise是没有返回值的，也就是它的状态始终是pending状态，因此相当于一直在await，await，await却始终没有响应…<br>所以在await之后的内容是不会执行的，也包括async1后面的 .then。<br>答案为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目六<br>让我们给5.5中的Promise加上resolve：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve(<span class="string">'promise1 resolve'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt end'</span>)</span><br></pre></td></tr></table></figure>现在Promise有了返回值了，因此await后面的内容将会被执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="string">'promise1 resolve'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目七<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve(<span class="string">'promise resolve'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>这道题应该也不难，不过有一点需要注意的，在async1中的new Promise它的resovle的值和async1().then()里的值是没有关系的，很多小伙伴可能看到resovle(‘promise resolve’)就会误以为是async1().then()中的返回值。<br>因此这里的执行结果为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br><span class="line"><span class="string">'sync1 end'</span></span><br><span class="line"><span class="string">'timer'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目八<br>我们再来看一道头条曾经的面试题：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1 start'</span></span><br><span class="line"><span class="string">'async2'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="string">'async1 end'</span></span><br><span class="line"><span class="string">'promise2'</span></span><br><span class="line"><span class="string">'setTimeout'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>题目九<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testSometing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行testSometing"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"testSometing"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行testAsync"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"hello async"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test start..."</span>);</span><br><span class="line">  <span class="keyword">const</span> v1 = <span class="keyword">await</span> testSometing();</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line">  <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise start..."</span>);</span><br><span class="line">  resolve(<span class="string">"promise"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"test end..."</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'test start...'</span></span><br><span class="line"><span class="string">'执行testSometing'</span></span><br><span class="line"><span class="string">'promise start...'</span></span><br><span class="line"><span class="string">'test end...'</span></span><br><span class="line"><span class="string">'testSometing'</span></span><br><span class="line"><span class="string">'执行testAsync'</span></span><br><span class="line"><span class="string">'promise'</span></span><br><span class="line"><span class="string">'hello async'</span></span><br><span class="line"><span class="string">'testSometing'</span> <span class="string">'hello async'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="async处理错误"><a href="#async处理错误" class="headerlink" title="async处理错误"></a>async处理错误</h3><ul><li>题目一<br>在async中，如果 await后面的内容是一个异常或者错误的话，会怎样呢？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>例如这道题中，await后面跟着的是一个状态为rejected的promise。</li></ul><p><strong>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</strong></p><p>所以答案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async2'</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) error</span><br></pre></td></tr></table></figure><p>如果改为throw new Error也是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'async1'</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!!</span><br></pre></td></tr></table></figure><ul><li>题目二<br>如果想要使得错误的地方不影响async函数后续的执行的话，可以使用try catch<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error!!!'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'async1 success'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br></pre></td></tr></table></figure>这里的结果为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'error!!!'</span></span><br><span class="line"><span class="string">'async1'</span></span><br><span class="line"><span class="string">'async1 success'</span></span><br></pre></td></tr></table></figure>或者你可以直接在Promise.reject后面跟着一个catch()方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// try &#123;</span></span><br><span class="line">  <span class="comment">//   await Promise.reject('error!!!')</span></span><br><span class="line">  <span class="comment">// &#125; catch(e) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(e)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error!!!'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'async1 success'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br></pre></td></tr></table></figure>运行结果是一样的</li></ul><h3 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h3><ul><li>题目一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">          resolve(<span class="number">6</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(p)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">  p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(arg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>过程分析：</li></ul><p>第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在4之前，所以可以来看看first函数里面的内容了。(这一步有点类似于题目1.5)<br>函数first返回的是一个new Promise()，因此先执行里面的同步代码3<br>接着又遇到了一个new Promise()，直接执行里面的同步代码7<br>执行完7之后，在p中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走<br>碰到了resolve(1)，这里就把p的状态改为了resolved，且返回值为1，不过这里也先不执行<br>跳出p，碰到了resolve(2)，这里的resolve(2)，表示的是把first函数返回的那个Promise的状态改了，也先不管它。<br>然后碰到了p.then，将它加入本次循环的微任务列表，等待执行<br>跳出first函数，遇到了first().then()，将它加入本次循环的微任务列表(p.then的后面执行)<br>然后执行同步代码4<br>本轮的同步代码全部执行完毕，查找微任务列表，发现p.then和first().then()，依次执行，打印出1和2<br>本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码5<br>然后又遇到了一个resolve(6)，它是放在p里的，但是p的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说resolve(6)相当于没任何用处，因此打印出来的p为<code>Promise{&lt;resolved&gt;: 1}</code>。(这一步类似于题目3.1)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>题目二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async1 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">.then(<span class="number">2</span>)</span><br><span class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">.catch(<span class="number">4</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>注意的知识点：</li></ul><p>async函数中await的new Promise要是没有返回值的话则不执行后面的内容(类似题5.5)<br>.then函数中的参数期待的是函数，如果不是函数的话会发生透传(类似题3.8 )<br>注意定时器的延迟时间<br>因此本题答案为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'script start'</span></span><br><span class="line"><span class="string">'async1'</span></span><br><span class="line"><span class="string">'promise1'</span></span><br><span class="line"><span class="string">'script end'</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'timer2'</span></span><br><span class="line"><span class="string">'timer1'</span></span><br></pre></td></tr></table></figure><ul><li>题目三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'resolve3'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  resolve(<span class="string">'resovle1'</span>);</span><br><span class="line">  resolve(<span class="string">'resolve2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p1)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>注意的知识点：</li></ul><p>Promise的状态一旦改变就无法改变(类似题目3.5)<br>finally不管Promise的状态是resolved还是rejected都会执行，且它的回调函数是接收不到Promise的结果的，所以finally()中的res是一个迷惑项(类似3.10)。<br>最后一个定时器打印出的p1其实是.finally的返回值，我们知道.finally的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值(3.10中也有提到), 而这道题中.finally上一个Promise是.then()，但是这个.then()并没有返回值，所以p1打印出来的Promise的值会是undefined，如果你在定时器的下面加上一个return 1，则值就会变成1(感谢掘友JS丛中过的指出)。</p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'resolve1'</span></span><br><span class="line"><span class="string">'finally'</span> <span class="literal">undefined</span></span><br><span class="line"><span class="string">'timer1'</span></span><br><span class="line"><span class="built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="literal">undefined</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="几道大厂的面试题"><a href="#几道大厂的面试题" class="headerlink" title="几道大厂的面试题"></a>几道大厂的面试题</h3><ul><li>使用Promise实现每隔1秒输出1<br>这道题比较简单的一种做法是可以用Promise配合着reduce不停的在promise后面叠加.then，请看下面的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">p, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(<span class="built_in">console</span>.log(x)), <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure>或者你可以更简单一点写：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">p, x</span>) =&gt;</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> r(<span class="built_in">console</span>.log(x)), <span class="number">1000</span>))), <span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></li></ul><ul><li>使用Promise实现红绿灯交替重复亮</li></ul><p>红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"red"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"green"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"yellow"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> light = <span class="function"><span class="keyword">function</span> (<span class="params">timer, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      cb()</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> step = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">3000</span>, red)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">2000</span>, green)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> light(<span class="number">1000</span>, yellow)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> step()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step();</span><br></pre></td></tr></table></figure><ul><li>实现mergePromise函数<br>实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="function">(<span class="params">timer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> time(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里写代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"done"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>这道题有点类似于Promise.all()，不过.all()不需要管执行顺序，只需要并发执行就行了。但是这里需要等上一个执行完毕之后才能执行下一个。<br>解题思路：</li></ul><p>定义一个数组data用于保存所有异步操作的结果<br>初始化一个const promise = Promise.resolve()，然后循环遍历数组，在promise后面添加执行ajax任务，同时要将添加的结果重新赋值到promise上。</p><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span> (<span class="params">ajaxArray</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放每个ajax的结果</span></span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  ajaxArray.forEach(<span class="function"><span class="params">ajax</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次的then为了用来调用ajax</span></span><br><span class="line">    <span class="comment">// 第二次的then是为了获取ajax的结果</span></span><br><span class="line">    promise = promise.then(ajax).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      data.push(res);</span><br><span class="line">      <span class="keyword">return</span> data; <span class="comment">// 把每次的结果返回</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最后得到的promise它的值就是data</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据promiseA+实现一个自己的promise<br><a href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b#heading-7" target="_blank" rel="noopener">Promise不会？？看这里！！！史上最通俗易懂的Promise</a><br><a href="https://zhuanlan.zhihu.com/p/23312442" target="_blank" rel="noopener">写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近会梳理一些带题目的知识点，除了让知识更系统。也让知识更具有细节，也更经得起考验。&lt;br&gt;今天先从 Promise 开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="ES6" scheme="https://jambo0624.github.io/tags/ES6/"/>
    
      <category term="promise" scheme="https://jambo0624.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>Vue 登录业务及上线注意事项</title>
    <link href="https://jambo0624.github.io/2020-02-25-management.html"/>
    <id>https://jambo0624.github.io/2020-02-25-management.html</id>
    <published>2020-02-25T08:23:41.000Z</published>
    <updated>2020-10-17T08:17:27.171Z</updated>
    
    <content type="html"><![CDATA[<p>前些天读完几本书之后，现在准备整理一下去年工作的一些收获。<br>尤其是将其中一些自己没有参与，但是还比较关键的环节进行梳理。希望能有进一步的感想。<br>下面开始</p><a id="more"></a><h2 id="登录退出功能"><a href="#登录退出功能" class="headerlink" title="登录退出功能"></a>登录退出功能</h2><ul><li>登录业务的相关技术点</li></ul><ol><li>http是无状态的</li><li>通过cookie在客户端记录状态</li><li>通过session在服务端记录状态</li><li>通过token方式维持状态<br>如果前后端是存在跨域问题，那么推荐使用token方式。反之，就用cookie和session方式。</li></ol><p><img src="https://s1.ax1x.com/2020/05/18/YWh1pT.png" alt="token" title="token原理"></p><ul><li><p>登录按钮所对应方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">login() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$refs.loginFormRef.validate(<span class="keyword">async</span> validate =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validate) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: result &#125; = <span class="keyword">this</span>.$http.post(<span class="string">'login'</span>, <span class="keyword">this</span>.loginForm)</span><br><span class="line">    <span class="keyword">if</span> (result.data.meta !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'登录失败'</span>)</span><br><span class="line">    <span class="keyword">this</span>.$message.success(<span class="string">'登录成功'</span>)</span><br><span class="line">     <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">'token'</span>, result.data.token)</span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/home'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是仅网页打开期间需要，不用永久化存储，所以用sessionStorage。而不用localStorage</p></li><li><p>路由守卫控制访问权限</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为路由对象添加路由守卫</span></span><br><span class="line">router.beforeEach(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 如果访问的是login页面，直接放行</span></span><br><span class="line">  <span class="keyword">if</span>( to.path === <span class="string">'/login'</span> ) <span class="keyword">return</span> next()</span><br><span class="line">  <span class="comment">// 从sessionStorage获取token</span></span><br><span class="line">  <span class="keyword">const</span> tokenStr = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">  <span class="comment">// 如果没有token，强制跳转到login页面</span></span><br><span class="line">  <span class="keyword">if</span>( !tokenStr ) <span class="keyword">return</span> next(<span class="string">'/login'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>退出功能实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.clear()</span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="主页内容"><a href="#主页内容" class="headerlink" title="主页内容"></a>主页内容</h2><ul><li>发送请求的权限获取<br>因为是后台管理系统，所以除了login页面外，发送请求都需要Authorization<br>我们采取的是axios拦截器的方法<br>意思就是请求发起之前，在请求头中添加Authorization字段，并且将之设置为token<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">  request.headers.Authorization = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><ul><li><p>二级菜单点击可跳转，是因为el-menu设置了router</p></li><li><p>element-ui和vue中的插槽</p><blockquote><p>个人理解的就是，如果某个元素内部还要依据自己的数据，进行下一步的处理。那么可以在内部使用插槽获取上级元素数据。比如dialog组件等</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">  &#123;&#123;scope.row&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>表单预验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.addFormRef.validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!valid) <span class="keyword">return</span> </span><br><span class="line">  <span class="comment">// 说明通过验证了，下一步发起请求</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>权限管理部分-分配权限功能<br>首先是点击分配权限按钮，获取所有被选中的三级标签。采用递归的方法，具体实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getLeafKeys(node, arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.children) &#123;</span><br><span class="line">    arr.push(node.id)</span><br><span class="line">  &#125;</span><br><span class="line">  node.children.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getLeafKeys(item, arr)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>其次是提交时，获取所有选中和半选中的标签。调用element-ui提供的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = [...this.$refs.treeRef.getCheckedKeys(),...this.$refs.treeRef.getHalfCheckedKeys()]</span><br></pre></td></tr></table></figure><h2 id="商品管理"><a href="#商品管理" class="headerlink" title="商品管理"></a>商品管理</h2><ul><li><p>分类参数-标签管理<br>参数管理页面在添加tags时，当tags变成input之后，input自动获取焦点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showInput(row) &#123;</span><br><span class="line">  row.inputVisible = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// $nextTick当页面上元素被重新渲染之后，才会指定回调函数中的代码</span></span><br><span class="line">    <span class="comment">// 👆注释的意思就是说等tags变成input之后再获取焦点，保证不出bug</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$refs.saveTagInput.$refs.input.focus()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>商品列表-添加时间<br>在main.js里面添加一个filter。主要解决的是时间格式的问题。具体来说是后台返回的是毫秒数，我们需要对应格式的时间。实现方式如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dateFormat'</span>,(originVal)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(originVal)</span><br><span class="line">  <span class="keyword">const</span> y = dt.getFullYear()</span><br><span class="line">  <span class="keyword">const</span> m = (dt.getMonth()+<span class="number">1</span>+<span class="string">''</span>).padStart(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> d = (dt.getDate() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> hh = (dt.getHours() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> mm = (dt.getMinutes() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">const</span> ss = (dt.getSeconds() + <span class="string">''</span>).padStart(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//String.prototype.padStart()</span></span><br><span class="line">str.padStart(targetLength [, padString])  <span class="comment">//语法</span></span><br><span class="line"><span class="comment">//例子如下</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>);         <span class="comment">// "       abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">"foo"</span>);  <span class="comment">// "foofoofabc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">6</span>,<span class="string">"123465"</span>); <span class="comment">// "123abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">8</span>, <span class="string">"0"</span>);     <span class="comment">// "00000abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">1</span>);          <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure></li></ul><p>使用方法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"创建时间"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span>&#123;&#123;scope.row.add_time | dateFormat&#125;&#125;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在数组中，找到指定index的元素，并返回index<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleRemove(file) &#123;</span><br><span class="line">  <span class="comment">// console.log(file)</span></span><br><span class="line">  <span class="comment">// 获取将要删除的图片的临时路径</span></span><br><span class="line">  <span class="keyword">const</span> filePath = file.response.data.tmp_path</span><br><span class="line">  <span class="comment">// 从pics数组中，找到这个图片对应的索引值</span></span><br><span class="line">  <span class="keyword">const</span> i = <span class="keyword">this</span>.addForm.pics.findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x.pic === filePath)</span><br><span class="line">  <span class="comment">// 调用splice方法，把图片移除</span></span><br><span class="line">  <span class="keyword">this</span>.addForm.pics.splice(i, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// console.log(this.addForm.pics)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="项目优化上线"><a href="#项目优化上线" class="headerlink" title="项目优化上线"></a>项目优化上线</h2><p>项目优化策略</p><h4 id="1-生成打包报告–命令行和图形界面"><a href="#1-生成打包报告–命令行和图形界面" class="headerlink" title="1. 生成打包报告–命令行和图形界面"></a>1. 生成打包报告–命令行和图形界面</h4><h4 id="2-第三方库开启-CDN"><a href="#2-第三方库开启-CDN" class="headerlink" title="2. 第三方库开启 CDN"></a>2. 第三方库开启 CDN</h4><ul><li><p>通过修改<code>vue.config.js</code>来修改webpack的配置<br>vue-cli3.0 默认隐藏了所有webpack的配置项，目的是为了屏蔽项目的配置过程，让具体功能和业务逻辑的实现称为中心</p></li><li><p>为开发模式与发布模式指定不同的打包入口  通过externals加载外部CDN资源  首页内容定制</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 发布模式</span></span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'production'</span>,config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-prod.js'</span>)</span><br><span class="line">      config.set(<span class="string">'externals'</span>,&#123;</span><br><span class="line">        vue: <span class="string">'Vue'</span>,</span><br><span class="line">        <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">        axios: <span class="string">'axios'</span>,</span><br><span class="line">        echarts: <span class="string">'echarts'</span>,</span><br><span class="line">        nprogress: <span class="string">'NProgress'</span>,</span><br><span class="line">        <span class="string">'vue-quill-editor'</span>: <span class="string">'VueQuillEditor'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">        args[<span class="number">0</span>].isProd = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开发模式</span></span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'development'</span>,config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main.js'</span>)</span><br><span class="line">      config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">        args[<span class="number">0</span>].isProd = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-通过CDN优化element-ui的打包"><a href="#3-通过CDN优化element-ui的打包" class="headerlink" title="3. 通过CDN优化element-ui的打包"></a>3. 通过CDN优化element-ui的打包</h4><p>注释掉elemen-ui的引入，然后在<code>index.html</code>头部引入element-ui的js和css文件</p><h4 id="4-路由懒加载"><a href="#4-路由懒加载" class="headerlink" title="4. 路由懒加载"></a>4. 路由懒加载</h4><p>安装<code>bebel/plugin-syntax-dynamic-import</code><br>在<code>babel.config.js</code>中声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "index" */</span> <span class="string">'../components/Login.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "index" */</span> <span class="string">'../components/Home.vue'</span>)</span><br></pre></td></tr></table></figure><h4 id="5-一些小点"><a href="#5-一些小点" class="headerlink" title="5. 一些小点"></a>5. 一些小点</h4><ul><li><p>添加NProcess<br>这个插件的作用就是在页面顶部添加一个加载的进度条。在请求开始时出现，得到相应后结束<br>具体实现如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use( <span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">  NProcess.start()</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;)</span><br><span class="line">axios.interceptors.response.use( <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  NProcess.done()</span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>build之后去除console<br>解决方法就是添加<code>babel-plugin-transform-remove-console</code></p></li></ul><h2 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h2><p>开启gzip配置，配置https服务，使用pm2管理应用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天读完几本书之后，现在准备整理一下去年工作的一些收获。&lt;br&gt;尤其是将其中一些自己没有参与，但是还比较关键的环节进行梳理。希望能有进一步的感想。&lt;br&gt;下面开始&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://jambo0624.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="login" scheme="https://jambo0624.github.io/tags/login/"/>
    
      <category term="CDN" scheme="https://jambo0624.github.io/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (下卷)--ES6+》</title>
    <link href="https://jambo0624.github.io/2020-02-16-dont-know-js-last2.html"/>
    <id>https://jambo0624.github.io/2020-02-16-dont-know-js-last2.html</id>
    <published>2020-02-16T05:14:16.000Z</published>
    <updated>2020-10-16T13:38:42.528Z</updated>
    
    <content type="html"><![CDATA[<p>近期的生活，是一种非常规的模式。<br>自己一方面期待着什么时候能自由地活动；另一方面也想着成年以来，第一次能有这么长时间陪着父母，挺好。<br>今天我们继续将《你不知道的js (下卷)》读完，下面开始。</p><a id="more"></a><h2 id="ES？现在与未来"><a href="#ES？现在与未来" class="headerlink" title="ES？现在与未来"></a>ES？现在与未来</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>2009年，ES5正式发布<br>2015年，ES6发布</p><p>有人建议未来的版本应该改成基于年份，比如ES2016（也就是ES7）来标示在2016年结束之前敲定的任何版本的规范。<br>尽管有异议，但比起后来提出的方案ES2015，很可能保持统治地位的版本命名仍是ES6。<br>而ES2016可能会采用新的基于年份的命名方案。</p><h3 id="transpiling"><a href="#transpiling" class="headerlink" title="transpiling"></a>transpiling</h3><p>简单地说，其思路是利用专门的工具把你的ES6代码转化为等价（或近似！）的可以在ES5环境下工作的代码。</p><h2 id="新语法"><a href="#新语法" class="headerlink" title="新语法"></a>新语法</h2><h3 id="块作用域声明"><a href="#块作用域声明" class="headerlink" title="块作用域声明"></a>块作用域声明</h3><p><a href="https://jambo0624.github.io/2019-11-09-const-let-var.html">let, const声明</a>，我在之前的文章做了比较。<br>这里就不再记录了。</p><h3 id="spread-rest"><a href="#spread-rest" class="headerlink" title="spread/rest"></a>spread/rest</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>这种用法最好的一点是，它为弃用很久的arguments数组 —— 实际上它并不是真正的数组，而是类似数组的对象——提供了一个非常可靠的替代形式。<br>因为args是一个真正的数组，前ES6中有很多技巧用来把arguments转变为某种我们可以当作数组来使用的东西，现在我们可以摆脱这些愚蠢的技巧了。<br>考虑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照新的 ES6 的行为方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// args 已经是一个真正的数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 丢弃 args 中第一个元素</span></span><br><span class="line">  args.shift()  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把整个 args 作为参数传给 console.log()</span></span><br><span class="line">  <span class="built_in">console</span>.log( ...args )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照前 ES6 的老派行为方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把 arguments 转换为一个真正的数组</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在尾端添加几个元素</span></span><br><span class="line">  args.push(<span class="number">4</span>, <span class="number">5</span>)  </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 过滤掉奇数</span></span><br><span class="line">  args = args.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  &#125;) </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 把整个 args 作为参数传给 foo()</span></span><br><span class="line">  foo.apply(<span class="literal">null</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">11</span>, y=<span class="number">31</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x+y)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 42</span></span><br><span class="line">foo(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 11</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="number">42</span>) <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 36</span></span><br><span class="line">foo(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 36 &lt;-- 丢了undefined</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="number">42</span>) <span class="comment">// 5 &lt;-- null被强制转换为 0</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 17 &lt;--  丢了undefined</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="number">42</span>) <span class="comment">// 6 &lt;-- null被强制转换为 0</span></span><br></pre></td></tr></table></figure><p>函数默认值可以不只是像31这样的简单值；它们可以是任意合法表达式，甚至是函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar called! '</span>)</span><br><span class="line">  <span class="keyword">return</span> y + val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=y+<span class="number">3</span>, z=bar(x</span>)) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">5</span></span><br><span class="line">foo() <span class="comment">// 'bar called' // 8 13</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>) <span class="comment">// 'bar called' // 10 15</span></span><br><span class="line"></span><br><span class="line">y=<span class="number">6</span></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="number">10</span>) <span class="comment">// 9 10</span></span><br></pre></td></tr></table></figure><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>可以把将数组或者对象属性中带索引的值手动赋值看作结构化赋值。<br>ES6为解构新增了一个专门语法，专用于<strong>数组解构</strong>和<strong>对象解构</strong>。<br>这个语法消除了前面代码中对临时变量tmp的需求，使代码简洁很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c] = foo()</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y, <span class="attr">z</span>: z &#125; = bar()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) <span class="comment">// 4 5 6</span></span><br></pre></td></tr></table></figure><p><strong>对象属性赋值模式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了 source: target</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: bam, <span class="attr">y</span>: baz, <span class="attr">z</span>: bap &#125; = bar()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bam, baz, bap) <span class="comment">// 4 5 6</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>这里的语法模式是<code>souce: target</code>（或者说是value:variable-alias)。<br>x: bam表示x属性是源值，而bam是要赋值的目标变量。<br>换句话说，对象字面值是target &lt;–source，而对象解构赋值是source –&gt; target。</p><p><strong>不只是声明</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>, y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// 20 10</span></span><br></pre></td></tr></table></figure><p><strong>重复赋值</strong><br>对象解构形式允许多次列出同一个源属性（持有值类型任意）。举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: X, <span class="attr">a</span>: Y &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">X  <span class="comment">// 1</span></span><br><span class="line">Y  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这也意味着可以解构子对象/数组属性，同时捕获子对象/类的值本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: &#123; <span class="attr">x</span>: X, <span class="attr">x</span>: Y&#125;, a &#125; = &#123; <span class="attr">a</span>: &#123; <span class="attr">x</span>: <span class="number">1</span> &#125; &#125;</span><br><span class="line">X <span class="comment">// 1</span></span><br><span class="line">Y <span class="comment">// 1</span></span><br><span class="line">a <span class="comment">// &#123; x: 1 &#125;</span></span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">a</span>: X, <span class="attr">a</span>: Y, <span class="attr">a</span>: [ Z ] &#125; = &#123; <span class="attr">a</span>: [<span class="number">1</span>] &#125;)</span><br><span class="line"></span><br><span class="line">x.push(<span class="number">2</span>)</span><br><span class="line">Y[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">X <span class="comment">// [10, 2]</span></span><br><span class="line">Y <span class="comment">// [10, 2]</span></span><br><span class="line">Z <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>记住：解构的目的不只是为了打字更少，而是为了可读性更强。</p><h3 id="太多，太少，刚刚好"><a href="#太多，太少，刚刚好" class="headerlink" title="太多，太少，刚刚好"></a>太多，太少，刚刚好</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> [b, ...c] = a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b, c) <span class="comment">// 2 [3, 4]</span></span><br></pre></td></tr></table></figure><p><strong>默认值赋值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; x, y, z, <span class="attr">w</span>: WW =<span class="number">20</span>&#125; = bar()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z, w) <span class="comment">// 4 5 6 20</span></span><br></pre></td></tr></table></figure><p><strong>嵌套解构</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">x</span>: &#123; <span class="attr">y</span>: &#123;<span class="attr">z</span> :<span class="number">6</span>&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, [b, c, d], e] = a1</span><br><span class="line"><span class="keyword">var</span> [x: &#123;<span class="attr">y</span>:&#123;<span class="attr">z</span>:w&#125;&#125;] = o1</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d, e) <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">console</span>.log(w) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><strong>解构参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line">foo([<span class="number">1</span>,<span class="number">2</span>]) <span class="comment">// 1 2</span></span><br><span class="line">foo([<span class="number">1</span>]) <span class="comment">// 1 undefined</span></span><br><span class="line">foo() <span class="comment">// undefined undefined</span></span><br></pre></td></tr></table></figure><h3 id="对象字面量扩展"><a href="#对象字面量扩展" class="headerlink" title="对象字面量扩展"></a>对象字面量扩展</h3><p><strong>简洁属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">x:x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line">&#123;x&#125;</span><br></pre></td></tr></table></figure><p><strong>简洁方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  x: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line">&#123;</span><br><span class="line">  x()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">'hello '</span> + name + <span class="string">'! '</span></span><br><span class="line"><span class="comment">//新的方式可以写为</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">`hello <span class="subst">$&#123;name&#125;</span>! `</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>虽然不是一条严格的规律，但我认为=&gt;箭头函数转变带来的可读性提升与被转化函数的长度负相关。<br>这个函数越长，=&gt;带来的好处就越小；函数越短，=&gt;带来的好处就越大。<br>我认为更合理的做法是只在确实需要简短的在线函数表达式的时候才采用=&gt;，而对于那些一般长度的函数则无需改变。</p><p><strong>不只是更短的语法，而是this</strong><br>实际上，=&gt;箭头函数的主要设计目的就是以特定的方式改变this的行为特性，解决this相关编码的一个特殊而又常见的痛点。</p><h3 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for..of循环"></a>for..of循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> idx <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(idx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> val <span class="keyword">of</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a' 'b' 'c'</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h3 id="数字字面量扩展"><a href="#数字字面量扩展" class="headerlink" title="数字字面量扩展"></a>数字字面量扩展</h3><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>下面是创建symbol的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'some optional description'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> sym <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure><p>以下几点需要注意。</p><ul><li>不能也不应该对Symbol(..)使用new。它并不是一个构造器，也不会创建一个对象。</li><li>传给Symbol(..)的参数是可选的。如果传入了的话，应该是一个为这个symbol的用途给出用户友好描述的字符串。</li><li>typeof的输出是一个新的值(“symbol”)，这是识别symbol的首选方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期的生活，是一种非常规的模式。&lt;br&gt;自己一方面期待着什么时候能自由地活动；另一方面也想着成年以来，第一次能有这么长时间陪着父母，挺好。&lt;br&gt;今天我们继续将《你不知道的js (下卷)》读完，下面开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (下卷)》</title>
    <link href="https://jambo0624.github.io/2020-02-04-dont-know-js-last.html"/>
    <id>https://jambo0624.github.io/2020-02-04-dont-know-js-last.html</id>
    <published>2020-02-04T00:03:09.000Z</published>
    <updated>2020-10-16T11:10:27.827Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点流年不利，不论是大环境还是个人的境遇。<br>好的方面是又可以静下心来，读书，学习新的东西。要一直保持积极乐观的心态啊！<br>今天我们继续读《你不知道的js》的最后一卷。开始吧。</p><a id="more"></a><h2 id="深入编程"><a href="#深入编程" class="headerlink" title="深入编程"></a>深入编程</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>程序常被称为源码或代码，它是一组特定的指令，用来指示计算机要执行哪些任务。</p><p>指令的格式和组合规则被称为计算机语言，有时也被称为语法，这非常类似于英语中告诉你如何拼写单词以及如何使用单词和标点符号来构造有效的句子。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>语句由一个或多个表达式组成。<br>一个表达式是对一个变量或值的引用，或者是一组值和变量与运算符的组合。<br>举例来说，a = b ＊ 2；这个语句中有四个表达式。</p><ul><li>2是一个<strong>字面值表达式</strong>。</li><li>b是一个<strong>变量表达式</strong>，表示获取它的当前值。</li><li>b ＊ 2是一个<strong>算术表达式</strong>，表示进行乘法运算。</li><li>a = b ＊ 2是一个<strong>赋值表达式</strong>，意思是将表达式b ＊ 2的结果赋值给变量a。</li></ul><p>程序需要被执行，我们也将这一过程称为<strong>运行程序</strong>。</p><p>a = b ＊ 2这样的语句便于开发者读写，但实际上计算机并不能直接理解这种形式。<br>因此，需要通过计算机上一个专门的工具（解释器或编译器）将你编写的代码翻译成计算机可以理解的命令。</p><p>对某些计算机语言来说，在程序被执行时，对命令的翻译通常是自上而下逐行执行的，这通常被称为<strong>代码解释</strong>。</p><p>对另外一些语言来说，这种翻译是预先进行的，被称为<strong>代码编译</strong>，这样一来，当执行程序时，实际上运行的是已经编译好的、可以执行的计算机指令。</p><p>基本上可以说JavaScript是<strong>解释型</strong>的，因为每次执行JavaScript源码时都需要进行处理。<br>但这么说并不完全精确。JavaScript引擎实际上是<strong>动态编译程序</strong>，然后立即执行编译后的代码。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>学习编程的最好方法就是编写代码！</strong></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>赋值=，如a = 2就表示将值2保存在变量a中。</li><li>算术+（加）、-（减）、＊（乘）、/（除），如a ＊ 3。</li><li>复合赋值+=、-=、＊=和/=是复合运算符，可以将算术运算符与赋值组合起来，比如，a += 2等同于a = a + 2。</li><li>递增/递减++表示递增，–表示递减，比如a++就类似于a = a + 1。</li><li>对象属性访问如console.log()中的.。</li><li>相等==（粗略相等）、===（严格相等）、! =（粗略不等）和！==（严格不等），如a == b</li><li>比较&lt;（小于）、&gt;（大于）、&lt;=（小于或粗略等于）和&gt;=（大于或粗略等于），如a &lt;= b</li><li>逻辑&amp;&amp;（与）和||（或），如a || b就表示a或者b</li></ul><h3 id="值与类型"><a href="#值与类型" class="headerlink" title="值与类型"></a>值与类型</h3><p>在编程术语中，对<strong>值</strong>的不同表示方法称为<strong>类型</strong></p><h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>有关如何编写注释良好的代码有很多种观点；我们确实无法定义绝对的普遍标准。但是以下这些观察结论和指导原则是很有用的。</p><ul><li>没有注释的代码不是最优的。</li><li>过多注释（比如每行一个）可能是拙劣代码的征兆。</li><li>代码应该解释为什么，而非是什么。如果编写的代码特别容易令人迷惑的话，那么注释也可以解释一下实现原理。</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在程序中实现这一点的最简单方法是将值赋给一个符号容器，这个符号容器称为变量，使用这个名字是因为这个容器中的值是可以变化的。</p><p>在某些编程语言中，你需要声明一个变量（容器）用于存放指定类型的值（如数字或字符串）。通过避免不想要的值转换，人们认为这种<strong>静态类型</strong>（也称为类型强制）提高了程序的正确性。</p><p>其他语言强调的是值的类型而不是变量的类型。<strong>弱类型</strong>（也称为动态类型）允许一个变量在任意时刻存放任意类型的值。这种方式允许一个变量在程序的逻辑流中的任意时刻代表任意类型的值，人们认为这样可以提高程序的灵活性。</p><p>JavaScript采用了后一种机制——动态类型，这也就是说，变量可以持有任意类型值而不存在类型强制。</p><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>我们常常需要将在代码中的一系列语句组织到一起，这些语句通常被称为块。<br>在JavaScript中，使用一对大括号{ .. }在一个或多个语句外来表示块。</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>程序中有很多种方法可以用于表示条件判断（也就是决策）。<br>最常用的是if语句。本质上就是在表达“如果这个条件是真的，那么进行后续这些……”。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>重复一系列动作，直到不满足某个条件，换句话说，重复只发生在满足条件的情况下，这就是程序循环的工作。</p><p>循环包括测试条件以及一个块（通常就是{ .. }）。循环块的每次执行被称为一个<strong>迭代</strong>。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>程序也几乎总是需要将代码的任务分割成可复用的片段，而不是一直重复编码。<br>实现这一点的方法就是定义一个函数。</p><h2 id="深入-JavaScript"><a href="#深入-JavaScript" class="headerlink" title="深入 JavaScript"></a>深入 JavaScript</h2><h3 id="值与类型-1"><a href="#值与类型-1" class="headerlink" title="值与类型"></a>值与类型</h3><p><strong>对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'hello world'</span>,</span><br><span class="line">  b: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">obj[b] <span class="comment">// 'hello world</span></span><br><span class="line">obj[<span class="string">'b'</span>] <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p><strong>内置类型方法</strong><br>内置类型和子类型拥有作为属性和方法暴露出来的行为，这是非常强大有力的功能。<br>举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 11</span></span><br><span class="line">a.toUpperCase() <span class="comment">// 'HELLO WORLD'</span></span><br><span class="line">b.toFixed(<span class="number">4</span>) <span class="comment">// '3.1416'</span></span><br></pre></td></tr></table></figure><p><strong>值的比较</strong><br>1.类型转换<br>JavaScript中有两种类型转换：显式的类型转换与隐式的类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'42'</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">Number</span>(a)</span><br><span class="line">  a <span class="comment">// '42'</span></span><br><span class="line">  b <span class="comment">// 42</span></span><br><span class="line"><span class="comment">// 隐式</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'42'</span></span><br><span class="line">  <span class="keyword">var</span> b = a*<span class="number">1</span></span><br><span class="line">  a <span class="comment">// '42'</span></span><br><span class="line">  b <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>2.真与假<br>JavaScript中“假”值的详细列表如下：</p><ul><li>“”（空字符串）</li><li>0、-0、NaN(无效数字）</li><li>null、undefined</li><li>false</li></ul><p>3.相等<br>==检查的是允许类型转换情况下的值的相等性，而===检查不允许类型转换情况下的值的相等性；<br>因此，===经常被称为“严格相等”。</p><p>4.不等关系<br>运算符&lt;, &gt;、&lt;=和&gt;=用于表示不等关系，在规范中被称为“关系比较”。</p><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p>1.提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>2.嵌套作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">      <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    baz()</span><br><span class="line">    <span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>c在bar()的内部是不可访问的，因为它只声明在内层baz()作用域，b在foo()中是不可访问的，也是同样的原因。</p><h3 id="条件判断-1"><a href="#条件判断-1" class="headerlink" title="条件判断"></a>条件判断</h3><p>在JavaScript中，条件判断的另一种形式是“条件运算符”，通常被称为“三进制运算符”。<br>它更像是单个if..else语句的紧凑版，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> b = (a&gt;<span class="number">41</span>)? <span class="string">'hello'</span>:<span class="string">'world'</span></span><br></pre></td></tr></table></figure><p>如果条件表达式（这里是a &gt; 41）求值为真，那么就会返回第一个子句（”hello”）；否则，结果就是第二个子句（”world”），不论结果是什么，都会赋给b。<br>条件运算符并不一定要用在赋值上，但这肯定是最常见的用法。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>遵循严格模式也更容易让引擎优化你的代码。<br>严格模式是代码的一次重大突破，你应该在自己的程序中一直使用。</p><p>使用严格模式的一个关键区别（改进！）是，不允许省略var的隐式自动全局变量声明</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>不仅你可以向函数传入值（参数），<strong>函数本身也可以作为值</strong>赋给变量或者向其他函数传入，又或者从其他函数传出。<br>因此，应该将函数值视为一个表达式，与其他的值或者表达式类似。</p><p><strong>立即调用函数表达式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello! '</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 'Hello! '</span></span><br></pre></td></tr></table></figure><p><strong>闭包</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数x是一个内层变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 内层函数 add() 使用x，所以它外围有一个'闭包'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y + x</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用外层<code>makeAdder(..)</code>返回的、指向内层<code>add(..)</code>函数的引用能够记忆传入<code>makeAdder(..)</code>的<code>x</code>值。<br>现在，我们来使用<code>makeAdder(..)</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = makeAdder(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plusTen = makeAdder(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plusOne(<span class="number">3</span>)  <span class="comment">// 4 &lt;-- 1+3</span></span><br><span class="line">plusOne(<span class="number">41</span>)  <span class="comment">// 42 &lt;-- 1+41</span></span><br><span class="line"></span><br><span class="line">plusTen(<span class="number">13</span>) <span class="comment">// 23 &lt;-- 10+13</span></span><br></pre></td></tr></table></figure><p>我们来详细说明一下这段代码是如何执行的。<br>(1)调用<code>makeAdder(1)</code>时得到了内层<code>add(..)</code>的一个引用，它会将x记为1。我们将这个函数引用命名为<code>plusOne()</code>。<br>(2)调用<code>makeAdder(10)</code>时得到了内层<code>add(..)</code>的另一个引用，它会将x记为10，我们将这个函数引用命名为<code>plusTen()</code>。<br>(3)调用<code>plusOne(3)</code>时，它会向1（记住的x）加上3（内层y），从而得到结果4。<br>(4)调用<code>plusTen(13)</code>时，它会向10（记住的x）加上13（内层y），从而得到结果23。</p><p><strong>模块</strong><br>在JavaScript中，闭包最常见的应用是模块模式。<br>模块允许你定义外部不可见的私有实现细节（变量、函数），同时也可以提供允许从外部访问的公开API。</p><h3 id="this标识符"><a href="#this标识符" class="headerlink" title="this标识符"></a>this标识符</h3><p>关于如何设置this有4条规则，上述代码中的最后4行展示了这4条规则。<br>(1) 在非严格模式下，foo()最后会将this设置为全局对象。在严格模式下，这是未定义的行为，在访问bar属性时会出错——因此”global”是为this.bar创建的值。<br>(2) obj1.foo()将this设置为对象obj1。<br>(3) foo.call(obj2)将this设置为对象obj2。<br>(4) new foo()将this设置为一个全新的空对象。</p><p>底线：为了搞清楚this指向什么，你必须检查相关的函数是如何被调用的。<br>调用方式会是以上4种之一，这也会回答“this是什么”这个问题。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>当引用对象的某个属性时，如果这个属性并不存在，那么JavaScript会自动使用对象的内部原型引用找到另外一个对象来寻找这个属性。<br>你可以将这点看作是<strong>属性缺失情况的备用模式</strong>。</p><h3 id="旧与新"><a href="#旧与新" class="headerlink" title="旧与新"></a>旧与新</h3><p><strong>polyfilling</strong><br>单词“polyfill”是由Remy Sharp发明的一个<a href="https://remysharp.com/2010/10/08/what-is-a-polyfill" target="_blank" rel="noopener">新术语</a>，用于<strong>表示根据新特性的定义，创建一段与之行为等价但能够在旧的JavaScript环境中运行的代码</strong>。</p><p>ES6定义了一个名为Number.isNaN(..)的工具，用于提供一个精确无bug的NaN值检查，取代原来的isNaN(..)。但对这个工具进行兼容处理很容易，这样一来，无论终端用户是否使用ES6浏览器，你都能够开始使用它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Number</span>.isNaN)&#123;</span><br><span class="line">  <span class="built_in">Number</span>.isNaN = <span class="function"><span class="keyword">function</span> <span class="title">isNaN</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许更好的办法是，使用一个已有的、可信任的polyfilling版本，比如由<a href="https://github.com/es-shims/es5-shim" target="_blank" rel="noopener">ES5-Shim</a>和<a href="https://github.com/es-shims/es6-shim" target="_blank" rel="noopener">ES6-Shim</a>提供的版本。</p><p><strong>transpiling</strong><br>语言中新增的语法是无法进行polyfilling的。<br>新语法在旧版JavaScript引擎上会抛出未识别/无效错误。<br>因此，更好的方法是，通过工具将新版代码转换为等价的旧版代码。<br>这个过程通常被称为“transpiling”。它是由transforming（转换）和compiling（编译）组合而成的术语。</p><p>有几点重要原因使得transpiling值得被关注。</p><ul><li>语言中新添加的语法的设计目的是让代码更容易阅读和维护。等价的旧版本通常更加繁复。你应该编写更新、更简洁的语法，这不只是为你自己，同时也是为开发组中的所有其他成员着想。</li><li>如果只是为旧版本进行编译转换，对新版本应用新语法，那么你就得到了新语法浏览器性能优化的好处。这也使得浏览器开发者可以拥有更真实的代码，以便测试它们的实现和优化。</li><li>越早使用新语法，就可以越早在现实世界中更健壮地测试这些语法，也就可以越早地为JavaScript委员会（TC39）提供反馈。如果能够很早就发现问题，那么就能够在这些语言设计错误被固化前对其进行修改/修复。</li></ul><p>以下是transpiling的一个简单示例。ES6新增了一个名为“默认参数值”的新特性。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a=<span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 2</span></span><br><span class="line">foo(<span class="number">42</span>) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>很简单，对不对？但也非常有用！<br>然而这个新语法在ES6前的引擎中是无效的。<br>那么transpiler是如何改变这段代码，从而让其能够在旧环境下运行的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">arguments</span>[<span class="number">0</span>] !== (<span class="keyword">void</span> <span class="number">0</span>) ? <span class="built_in">arguments</span>[<span class="number">0</span>] : <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你可以看到的，它会检查arguments[0]的值是否为void 0（也就是undefined），如果是的话就提供默认值2；否则就使用传入值。</p><p>除了能够在旧版浏览器中使用更好的新语法，编译转换后的代码实际上也更好地表达了编程意图。<br>单看这段ES6版本的代码，你可能不会意识到undefined是唯一一个无法作为默认值参数显式传入的值。<br>而编译转换后的代码就更清楚地展示了这一点。</p><p>有很多很棒的transpiler可供选择。<br>以下是编写本部分时几个很好的选择：<br>· <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 从ES6+编译转换到ES5<br>· <a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a> 将ES6、ES7及后续版本转换到ES5</p><h3 id="非JavaScript"><a href="#非JavaScript" class="headerlink" title="非JavaScript"></a>非JavaScript</h3><p>你将遇到的最常见的非JavaScript就是DOM API。举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><p>当你的代码在浏览器中运行时，变量document作为一个全局变量存在。<br>它既不是由JavaScript引擎提供的，也不由JavaScript标准控制。<br>它的存在形式看起来非常类似于普通的JavaScript对象，但实际上并不完全是这样。<br>它是一个特殊的对象，通常被称为<strong>宿主对象</strong>。</p><h2 id="深入“你不知道的JavaScript”系列"><a href="#深入“你不知道的JavaScript”系列" class="headerlink" title="深入“你不知道的JavaScript”系列"></a>深入“你不知道的JavaScript”系列</h2><h3 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h3><p>JavaScript引擎在执行前（有时是执行中！）就编译了代码。<br>因此，通过深入理解编译器对代码的处理方式，我们可以尝试理解它是如何找到并处理变量和函数声明的。<br>沿着这条路，我们看到了JavaScript变量作用域管理的常见方式——“提升”。</p><p>闭包可能是JavaScript所有概念中最重要的一个，但如果你没有深刻了解作用域的工作原理，那么很可能就无法理解闭包。</p><p>正如我们在第2章中简单提到的那样，闭包的一个重要应用就是模块模式。<br>模块模式可能是JavaScript所有代码组织模式中最普遍的方法；深入理解模块模式应该是你最高优先级的任务之一。</p><h3 id="this和对象"><a href="#this和对象" class="headerlink" title="this和对象"></a>this和对象</h3><p>关键词this是根据相关函数的执行方式而动态绑定的，事实证明，可以通过4条简单的规则理解并完全确定this绑定。</p><p>与this紧密关联的是对象原型机制，这种机制是一个<strong>属性查找链</strong>，与寻找词法作用域变量的方式类似。</p><h3 id="类型和语法"><a href="#类型和语法" class="headerlink" title="类型和语法"></a>类型和语法</h3><p>到底类型转换的哪些部分是出乎意料的，哪些部分在花费精力学习后则是完全可以理解的。</p><p>这不仅仅只是声称类型转换是合理的、可学习的；我想表明的是，类型转换是非常有用且被低估了的工具，<strong>你应该在自己的代码中使用它</strong>。<br>在我看来，如果能够正确使用的话，类型转换不仅能够工作，而且也会让你的代码质量更高。</p><h3 id="异步和性能"><a href="#异步和性能" class="headerlink" title="异步和性能"></a>异步和性能</h3><p>“作用域和闭包”“this和对象原型”以及“类型和语法”关注的都是语言的核心机制，而“异步和性能”则稍微偏重于在语言机制之上处理异步编程的模式。<br>异步不只是对应用的性能至关重要，而且正在慢慢成为代码易写性和可维护性方面的关键因素。</p><p><strong>promise</strong>是对“未来值”的与时间无关的封装，使得不管这个值是否已经可用，你都可以推导和组合使用它们。<br>另外，通过一种可信任的、可组合的promise机制，分发回调它们也有效地解决了IoC信任问题。</p><p><strong>生成器</strong>为JavaScript函数引入了一种新的执行模式，其中生成器可以暂停在yield点上，并在之后被异步继续。<br>暂停与继续的能力使得生成器中同步的、看似连续的代码可以在后台异步执行。<br>通过这种方式，我们解决了回调的非线性、非局部跳转引发的代码混乱问题，因而让我们的异步代码看似同步，更容易追踪。</p><p>编写高效的JavaScript代码意味着，你编写的代码可以打破不同浏览器和环境的壁垒，达到动态运行。<br>这要求大量复杂而详细的计划和努力，只有这样，才能让程序从“可以运行”到“可以很好地运行”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有点流年不利，不论是大环境还是个人的境遇。&lt;br&gt;好的方面是又可以静下心来，读书，学习新的东西。要一直保持积极乐观的心态啊！&lt;br&gt;今天我们继续读《你不知道的js》的最后一卷。开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>axios 知识梳理</title>
    <link href="https://jambo0624.github.io/2020-01-04-axios.html"/>
    <id>https://jambo0624.github.io/2020-01-04-axios.html</id>
    <published>2020-01-04T14:03:54.000Z</published>
    <updated>2020-10-16T08:35:39.798Z</updated>
    
    <content type="html"><![CDATA[<p>axios是一个非常小巧而好用的http请求库，支持promise以及同时支持浏览器和node端。<br>axios使用简单，配置灵活，也是vue官方推荐的请求库。<br>今天我们就对 axios 相关知识进行整理。</p><a id="more"></a><p>首先介绍一下他的特性</p><blockquote><p>从浏览器中创建 XMLHttpRequest<br>从 node.js 发出 http 请求<br>支持 Promise API<br>拦截请求和响应<br>转换请求和响应数据<br>取消请求<br>自动转换JSON数据<br>客户端支持防止 CSRF/XSRF</p></blockquote><p>接下来看几个使用的栗子🌰：<br><strong>执行 GET 请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向具有指定ID的用户发出请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 params 对象传递参数</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>执行 POST 请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>执行多个并发请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//两个请求现已完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><p>可以通过将相关配置传递给 axios 来进行请求。</p><p><strong>axios(config)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Aaa'</span>,</span><br><span class="line">    lastName: <span class="string">'Bbb'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>axios(url[, config])</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个 GET 请求 (GET请求是默认请求模式)</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure><p><strong>请求方法别名</strong><br>为了方便起见，已经为所有支持的请求方法提供了别名。</p><ul><li><code>axios.request(config)</code></li><li><code>axios.get(url[,config])</code></li><li><code>axios.delete(url[,config])</code></li><li><code>axios.head(url[,config])</code></li><li><code>axios.post(url[,data[,config]])</code></li><li><code>axios.put(url [,data[,config]])</code></li><li><code>axios.patch(url[,data[,config]])</code><br>注意: 当使用别名方法时，不需要在config中指定url，method和data属性。</li></ul><p><strong>并发</strong><br>帮助函数处理并发请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.all（iterable）</span><br><span class="line">axios.spread（callback）</span><br></pre></td></tr></table></figure><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><p>这些是用于发出请求的可用配置选项。 只有url是必需的。 如果未指定方法，请求将默认为GET。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `url`是将用于请求的服务器URL</span></span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method`是发出请求时使用的请求方法</span></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL`将被添加到`url`前面，除非`url`是绝对的。</span></span><br><span class="line">  <span class="comment">// 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。</span></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest`允许在请求数据发送到服务器之前对其进行更改</span></span><br><span class="line">  <span class="comment">// 这只适用于请求方法'PUT'，'POST'和'PATCH'</span></span><br><span class="line">  <span class="comment">// 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做任何你想要的数据转换</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse`允许在 then / catch之前对响应数据进行更改</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers`是要发送的自定义 headers</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params`是要与请求一起发送的URL参数</span></span><br><span class="line">  <span class="comment">// 必须是纯对象或URLSearchParams对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer`是一个可选的函数，负责序列化`params`</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data`是要作为请求主体发送的数据</span></span><br><span class="line">  <span class="comment">// 仅适用于请求方法“PUT”，“POST”和“PATCH”</span></span><br><span class="line">  <span class="comment">// 当没有设置`transformRequest`时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - Browser only: FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node only: Stream</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout`指定请求超时之前的毫秒数。</span></span><br><span class="line">  <span class="comment">// 如果请求的时间超过'timeout'，请求将被中止。</span></span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials`指示是否跨站点访问控制请求</span></span><br><span class="line">  <span class="comment">// should be made using credentials</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter'允许自定义处理请求，这使得测试更容易。</span></span><br><span class="line">  <span class="comment">// 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api））</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;, </span><br><span class="line"></span><br><span class="line">  <span class="comment">// `auth'表示应该使用 HTTP 基本认证，并提供凭据。</span></span><br><span class="line">  <span class="comment">// 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// “responseType”表示服务器将响应的数据类型</span></span><br><span class="line">  <span class="comment">// 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称</span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName`是携带xsrf令牌值的http头的名称</span></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress`允许处理上传的进度事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用本地 progress 事件做任何你想要做的</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress`允许处理下载的进度事件</span></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength`定义允许的http响应内容的最大大小</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus`定义是否解析或拒绝给定的promise</span></span><br><span class="line">  <span class="comment">// HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被</span></span><br><span class="line">  <span class="comment">// 拒绝。</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects`定义在node.js中要遵循的重定向的最大数量。</span></span><br><span class="line">  <span class="comment">// 如果设置为0，则不会遵循重定向。</span></span><br><span class="line">  maxRedirects: <span class="number">5</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。</span></span><br><span class="line">  <span class="comment">// 允许配置类似`keepAlive`的选项，</span></span><br><span class="line">  <span class="comment">// 默认情况下不启用。</span></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'proxy'定义代理服务器的主机名和端口</span></span><br><span class="line">  <span class="comment">// `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。</span></span><br><span class="line">  <span class="comment">// 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: : &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// “cancelToken”指定可用于取消请求的取消令牌</span></span><br><span class="line">  <span class="comment">// (see Cancellation section below for details)</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>使用 then 时，您将收到如下响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="配置默认值"><a href="#配置默认值" class="headerlink" title="配置默认值"></a>配置默认值</h3><p>您可以指定将应用于每个请求的配置默认值。</p><p><strong>全局axios默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure><p><strong>自定义实例默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在创建实例时设置配置默认值</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create（&#123;</span><br><span class="line">   baseURL：<span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在实例创建后改变默认值</span></span><br><span class="line">instance.defaults.headers.common [<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure><p><strong>配置优先级顺序</strong><br>配置将与优先顺序合并。<br>顺序是<code>lib/defaults.js</code>中的库默认值，然后是实例的defaults属性，最后是请求的config参数。<br>后者将优先于前者。<br>这里有一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用库提供的配置默认值创建实例</span></span><br><span class="line"><span class="comment">//此时，超时配置值为`0`，这是库的默认值</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create（）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//覆盖库的超时默认值</span></span><br><span class="line"><span class="comment">//现在所有请求将在超时前等待2.5秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//覆盖此请求的超时，因为它知道需要很长时间</span></span><br><span class="line">instance.get（<span class="string">'/ longRequest'</span>，&#123;</span><br><span class="line">   timeout：<span class="number">5000</span></span><br><span class="line">&#125;）;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>你可以截取请求或响应在被 then 或者 catch 处理之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use（<span class="function"><span class="keyword">function</span>（<span class="title">config</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//在发送请求之前做某事</span></span><br><span class="line">     <span class="keyword">return</span> config;</span><br><span class="line">   &#125;，<span class="function"><span class="keyword">function</span>（<span class="title">error</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//请求错误时做些事</span></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Promise</span>.reject（error）;</span><br><span class="line">   &#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use（<span class="function"><span class="keyword">function</span>（<span class="title">response</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//对响应数据做些事</span></span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">   &#125;，<span class="function"><span class="keyword">function</span>（<span class="title">error</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//请求错误时做些事</span></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Promise</span>.reject（error）;</span><br><span class="line">   &#125;）;</span><br></pre></td></tr></table></figure><p>如果你以后可能需要删除拦截器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure><p>你可以将拦截器添加到axios的自定义实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios.get（<span class="string">'/ user / 12345'</span>）</span><br><span class="line">   .catch（<span class="function"><span class="keyword">function</span>（<span class="title">error</span>）</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>（error.response）&#123;</span><br><span class="line">       <span class="comment">//请求已发出，但服务器使用状态代码进行响应</span></span><br><span class="line">       <span class="comment">//落在2xx的范围之外</span></span><br><span class="line">       <span class="built_in">console</span>.log（error.response.data）;</span><br><span class="line">       <span class="built_in">console</span>.log（error.response.status）;</span><br><span class="line">       <span class="built_in">console</span>.log（error.response.headers）;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//在设置触发错误的请求时发生了错误</span></span><br><span class="line">       <span class="built_in">console</span>.log（<span class="string">'Error'</span>，error.message）;</span><br><span class="line">     &#125;&#125;</span><br><span class="line">     <span class="built_in">console</span>.log（error.config）;</span><br><span class="line">   &#125;）;</span><br></pre></td></tr></table></figure><p>您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get（<span class="string">'/ user / 12345'</span>，&#123;</span><br><span class="line">   validateStatus：<span class="function"><span class="keyword">function</span>（<span class="title">status</span>）</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">//仅当状态代码大于或等于500时拒绝</span></span><br><span class="line">   &#125;&#125;</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><h3 id="消除"><a href="#消除" class="headerlink" title="消除"></a>消除</h3><p>您可以使用取消令牌取消请求。</p><blockquote><p>axios cancel token API基于可取消的promise提议，目前处于阶段1。</p></blockquote><p>您可以使用CancelToken.source工厂创建一个取消令牌，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> source = CancelToken.source（）;</span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//取消请求（消息参数是可选的）</span></span><br><span class="line">source.cancel（<span class="string">'操作被用户取消。'</span>）;</span><br></pre></td></tr></table></figure><p>您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> cancel;</span><br><span class="line"> </span><br><span class="line">axios.get（<span class="string">'/ user / 12345'</span>，&#123;</span><br><span class="line">   cancelToken：<span class="keyword">new</span> CancelToken（<span class="function"><span class="keyword">function</span> <span class="title">executor</span>（<span class="title">c</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//一个执行器函数接收一个取消函数作为参数</span></span><br><span class="line">     cancel = c;</span><br><span class="line">   &#125;）</span><br><span class="line">&#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">clear();</span><br></pre></td></tr></table></figure><p>注意：<strong>您可以使用相同的取消令牌取消几个请求。</strong></p><h3 id="使用application-x-www-form-urlencoded格式"><a href="#使用application-x-www-form-urlencoded格式" class="headerlink" title="使用application / x-www-form-urlencoded格式"></a>使用application / x-www-form-urlencoded格式</h3><p>默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。</p><p><strong>浏览器</strong><br>在浏览器中，您可以使用URLSearchParams API，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, params);</span><br></pre></td></tr></table></figure><p>请注意，<strong>所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。</strong></p><p>或者，您可以使用qs库对数据进行编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, qs.stringify(&#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>Node.js</strong><br>在node.js中，可以使用querystring模块，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">axios.post(<span class="string">'http://something.com/'</span>, querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;);</span><br></pre></td></tr></table></figure><p>你也可以使用qs库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;axios是一个非常小巧而好用的http请求库，支持promise以及同时支持浏览器和node端。&lt;br&gt;axios使用简单，配置灵活，也是vue官方推荐的请求库。&lt;br&gt;今天我们就对 axios 相关知识进行整理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="http" scheme="https://jambo0624.github.io/tags/http/"/>
    
      <category term="axios" scheme="https://jambo0624.github.io/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (中卷)--程序性能》</title>
    <link href="https://jambo0624.github.io/2019-12-22-dont-know-js-second3.html"/>
    <id>https://jambo0624.github.io/2019-12-22-dont-know-js-second3.html</id>
    <published>2019-12-22T06:13:49.000Z</published>
    <updated>2020-10-16T07:35:33.228Z</updated>
    
    <content type="html"><![CDATA[<p>对于中卷的部分，之前已经分了两篇文章进行了介绍。<br>分别是<a href="https://jambo0624.github.io/2019-03-19-dont-know-js-second.html">中卷一</a>和<a href="https://jambo0624.github.io/2019-07-07-dont-know-js-second2.html">中卷二</a><br>但是真的由于内容很多，很精华，每一章节单拿出来都可以写成几篇文章。<br>就算仅仅记录表面意思，仍然足以撑满篇幅。<br>今天我们开始记录性能部分内容，真的是中卷的最后一篇文章啦。</p><a id="more"></a><h2 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h2><h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><p>如果你有一些处理密集型的任务要执行，但不希望它们都在主线程运行（这可能会减慢浏览器/UI），可能你就会希望JavaScript能够以多线程的方式运行。</p><p>像浏览器这样的环境，很容易提供多个JavaScript引擎实例，各自运行在自己的线程上，这样你可以在每个线程上运行不同的程序。<br>程序中每一个这样的独立的多线程部分被称为一个（Web）Worker。<br>这种类型的并行化被称为任务并行，因为其重点在于把程序划分为多个块来并发运行。</p><p>从JavaScript主程序（或另一个Worker）中，可以这样实例化一个Worker：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w1 = <span class="keyword">new</span> Worker(<span class="string">'http://some.url.1/mycoolworker.js'</span>)</span><br></pre></td></tr></table></figure><p>这个URL应该指向一个JavaScript文件的位置（而不是一个HTML页面！），这个文件将被加载到一个Worker中。<br>然后浏览器启动一个独立的线程，让这个文件在这个线程中作为独立的程序运行。</p><p>Worker之间以及它们和主程序之间，<strong>不会共享任何作用域或资源</strong>，那会把所有多线程编程的噩梦带到前端领域，而是<strong>通过一个基本的事件消息机制</strong>相互联系。<br>Worker w1对象是一个事件侦听者和触发者，可以通过订阅它来获得这个Worker发出的事件以及发送事件给这个Worker。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'mycoolworker.js'</span></span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// evt.data</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">postMessage(<span class="string">'a really cool reply'</span>)</span><br></pre></td></tr></table></figure><p>注意，专用Worker和创建它的程序之间是一对一的关系。<br>也就是说，”message”事件没有任何歧义需要消除，因为我们确定它只能来自这个一对一的关系：<strong>它要么来自这个Worker，要么来自主页面。</strong></p><p><strong>Worker环境</strong><br>在Worker内部是无法访问主程序的任何资源的。<br>这意味着你不能访问它的任何全局变量，也不能访问页面的DOM或者其他资源。<br>记住，这是一个完全独立的线程。</p><p>但是，你可以执行网络操作（Ajax、WebSockets）以及设定定时器。<br>还有，Worker可以访问几个重要的全局变量和功能的本地复本，包括navigator、location、JSON和applicationCache。</p><p>你还可以通过importScripts(..)向Worker加载额外的JavaScript脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker 内部</span></span><br><span class="line">importScripts(<span class="string">'foo.js'</span>, <span class="string">'bar.js'</span>)</span><br></pre></td></tr></table></figure><p>这些脚本加载是同步的。<br>也就是说，<code>importScripts(..)</code>调用会阻塞余下Worker的执行，直到文件加载和执行完成。</p><p><strong>数据传递</strong><br>如果要传递一个对象，可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">结构化克隆算法</a>(structured clone algorithm)把这个对象复制到另一边。<br>这个算法非常高级，甚至可以处理要复制的对象有循环引用的情况。<br>这样就不用付出to-string和from-string的性能损失了，但是这种方案还是要使用双倍的内存。IE10及更高版本以及所有其他主流浏览器都支持这种方案。<br>这里有一篇文章关于<a href="https://zhuanlan.zhihu.com/p/33489557" target="_blank" rel="noopener">结构化克隆算法</a>的<strong>应用</strong>。</p><p>还有一个更好的选择，特别是对于大数据集而言，就是使用<a href="http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast" target="_blank" rel="noopener">Transferable对象</a>。<br>这时发生的是对象所有权的转移，数据本身并没有移动。<br>一旦你把对象传递到一个Worker中，在原来的位置上，它就变为空的或者是不可访问的，这样就消除了多线程编程作用域共享带来的混乱。<br>当然，所有权传递是可以双向进行的。</p><p>如果选择Transferable对象的话，其实不需要做什么。<br>任何实现了<a href="http://developer.mozilla.org/en-US/docs/Web/API/Transferable" target="_blank" rel="noopener">Transferable接口</a>的数据结构就自动按照这种方式传输（Firefox和Chrome都支持）</p><p>下面是如何使用postMessage(..)发送一个Transferable对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如 Unit8Array</span></span><br><span class="line">postMessage( foo.buffer, [foo.buffer] )</span><br></pre></td></tr></table></figure><p>第一个参数是一个原始缓冲区，第二个是一个要传输的内容的列表。<br>不支持Transferable对象的浏览器就降级到结构化克隆，这会带来性能下降而不是彻底的功能失效。```</p><p><strong>共享Worker</strong><br>共享Worker可以与站点的多个程序实例或多个页面连接，所以这个Worker需要通过某种方式来得知消息来自于哪个程序。<br>这个唯一标识符称为端口（port），可以类比网络socket的端口。因此，调用程序必须使用Worker的port对象用于通信：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w1.port.addEventListener(<span class="string">'message'</span>,handleMessage)</span><br><span class="line">w1.port.postMessage(<span class="string">'something cool'</span>)</span><br></pre></td></tr></table></figure><p>还有，端口连接必须要初始化，形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w1.port.start()</span><br></pre></td></tr></table></figure><p>在共享Worker内部，必须要处理额外的一个事件：”connect”。<br>这个事件为这个特定的连接提供了端口对象。<br>保持多个连接独立的最简单办法就是使用port上的闭包，就像下面的代码一样，把这个链接上的事件侦听和传递定义在”connect”事件的处理函数内部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker 内部</span></span><br><span class="line">addEventListener(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> port = evt.ports[<span class="number">0</span>]</span><br><span class="line">  port.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    port.postMessage()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  port.start()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="SMID"><a href="#SMID" class="headerlink" title="SMID"></a>SMID</h3><p>单指令多数据（SIMD）是一种数据并行（data parallelism）方式，与WebWorker的任务并行（task parallelism）相对，因为这里的重点实际上不再是把程序逻辑分成并行的块，而是并行处理数据的多个位。</p><p>通过SIMD，线程不再提供并行。<br>取而代之的是，现代CPU通过数字“向量”（特定类型的数组），以及可以在所有这些数字上并行操作的指令，来提供SIMD功能。<br>这是利用低级指令级并行的底层运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = SMID.float32x4(<span class="number">3.14159</span>, <span class="number">21.0</span>, <span class="number">32.3</span>, <span class="number">55.55</span>)</span><br><span class="line"><span class="keyword">var</span> v2 = SMID.float32x4(<span class="number">2.1</span>, <span class="number">3.2</span>, <span class="number">4.3</span>, <span class="number">5.4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v3 = SMID.int32x4(<span class="number">10</span>, <span class="number">101</span>, <span class="number">1001</span>, <span class="number">10001</span>)</span><br><span class="line"><span class="keyword">var</span> v4 = SMID.int32x4(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">SMID.float32x4.mul(v1, v2) <span class="comment">// [6.597339, 67.2, 138.89, 299.97]</span></span><br><span class="line">SMID.int32x4.mul(v3, v4) <span class="comment">// [20, 121, 1031, 10041]</span></span><br></pre></td></tr></table></figure><h3 id="asm-js"><a href="#asm-js" class="headerlink" title="asm.js"></a>asm.js</h3><p><a href="http://asmjs.org" target="_blank" rel="noopener">asm.js</a>这个标签是指JavaScript语言中可以高度优化的一个子集。<br>通过小心避免某些难以优化的机制和模式（垃圾收集、类型强制转换，等等）, asm.js风格的代码可以被JavaScript引擎识别并进行特别激进的底层优化。</p><h2 id="性能测试与调优"><a href="#性能测试与调优" class="headerlink" title="性能测试与调优"></a>性能测试与调优</h2><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> end = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Duration:'</span>,(end-start))</span><br></pre></td></tr></table></figure><p>使用这个方法测试某个运算的速度（执行时间）<strong>有很多错误</strong>。</p><p><strong>重复</strong><br>如果想要用重复来测试，要确保把异常因素排除，你需要大量的样本来平均化。<br>你还会想要知道最差样本有多慢，最好的样本有多快，以及最好和最差情况之间的偏离度有多大，等等。<br>司仪重复也不是正确的方法。</p><p><strong>Benchmark.js</strong><br>任何有意义且可靠的性能测试都应该基于统计学上合理的实践。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 要测试的运算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bench= <span class="keyword">new</span> Benchmark(      </span><br><span class="line"> <span class="string">'foo test'</span>,  <span class="comment">// 测试名称</span></span><br><span class="line">  foo,  <span class="comment">// 要测试的函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 可选的额外选项</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">bench.hz <span class="comment">// 每秒运算数</span></span><br><span class="line">bench.stats.moe <span class="comment">// 出错边界</span></span><br><span class="line">bench.stats.variance <span class="comment">// 样本方差</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="环境为王"><a href="#环境为王" class="headerlink" title="环境为王"></a>环境为王</h3><p>对特定的性能测试来说，不要忘了检查测试环境，特别是比较任务Ⅹ和Y这样的比对测试。<br>仅仅因为你的测试显示Ⅹ比Y快，并不能说明结论Ⅹ比Y快就有实际的意义。</p><p><strong>引擎优化</strong><br>我们设想的所有优化可能性在受限的测试中都有可能发生，而且在更复杂的程序中（出于各种各样的原因），引擎可能不会进行这样的优化。<br>也可能恰恰相反，引擎可能不会优化这样无关紧要的代码，但是在系统已经在运行更复杂的程序时可能会倾向于激进的优化。</p><p>这是不是意味着无法真正进行任何有用的测试呢？绝对不是！<br>测试不真实的代码只能得出不真实的结论。<br>如果有实际可能的话，你应该测试实际的而非无关紧要的代码，测试条件与你期望的真实情况越接近越好。<br>只有这样得出的结果才有可能接近事实。<br>像++x对比x++这样的微观性能测试结果为虚假的可能性相当高，可能我们最好就假定它们是假的。</p><h3 id="jsPerf-com"><a href="#jsPerf-com" class="headerlink" title="jsPerf.com"></a>jsPerf.com</h3><p>如果想要在不止一个环境下得出像“Ⅹ比Y快”这样的有意义的结论成立，那你需要在尽可能多的真实环境下进行实际测试。仅仅因为在Chrome上某个Ⅹ运算比Y快并不意味着这在所有的浏览器中都成立。<br>当然你可能还想要交叉引用多个浏览器上的测试运行结果，并有用户的图形展示。</p><p>有一个很棒的网站正是因这样的需求而诞生的，名为<a href="http://jsperf.com" target="_blank" rel="noopener">jsPerf</a></p><h3 id="写好测试"><a href="#写好测试" class="headerlink" title="写好测试"></a>写好测试</h3><p>要写好测试，需要认真分析和思考两个测试用例之间有什么区别，以及这些区别是有意还是无意的。</p><p>编写更好更清晰的测试。<br>但还有，花一些时间来编写文档（使用jsPerf.com上的Description字段和/或代码注释）精确表达你的测试目的，甚至对于那些微小的细节也要如此。<br>找出那些有意的区别，这会帮助别人和未来的你更好地识别出那些可能扭曲测试结果的无意区别。</p><p>不要试图窄化到真实代码的微小片段，以及脱离上下文而只测量这一小部分的性能，因为包含更大（仍然有意义的）上下文时功能测试和性能测试才会更好。<br>这些测试可能也会运行得慢一点，这意味着环境中发现的任何差异都更有意义。</p><h3 id="微性能"><a href="#微性能" class="headerlink" title="微性能"></a>微性能</h3><p>在考虑对代码进行性能测试时，你应该习惯的第一件事情就是你所写的代码并不总是引擎真正运行的代码。</p><p>来考虑下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">41</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> baz = foo + baz</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)(<span class="number">1</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>可能你会认为最内层函数中的引用foo需要进行三层作用域查找。<br>事实上，编译器通常会缓存这样的查找结果，使得从不同的作用域引用foo实际上并没有任何额外的花费。<br>但是，还有一些更深入的问题需要思考。<br>如果编译器意识到这个foo只在一个位置被引用而别处没有任何引用，并且注意到这个值只是41而从来不会变成其他值呢？</p><p>JavaScript可能决定完全去掉foo变量，将其值在线化，这不是很可能发生也可以接受的吗？就像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> baz = <span class="number">41</span> + baz</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)(<span class="number">1</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>当你把JavaScript代码看作对引擎要做什么的提示和建议，而不是逐字逐句的要求时，你就会意识到，对于具体语法细节的很多执着迷恋已经烟消云散了。</p><p>这里是另一个常见的愚蠢的执迷于微观性能的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [...]</span><br><span class="line"><span class="comment">// 选择1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;x.length;i++)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=x.length;i&lt;len;i++)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上说，这里应该在变量len中缓存x数组的长度，因为表面上它不会改变，来避免在每个循环迭代中计算x.length的代价。<br>如果运行性能测试来比较使用x.length和将其缓存到len变量中的方案，你会发现尽管理论听起来没错，但实际的可测差别在统计上是<strong>完全无关紧要</strong>的。</p><p>实际上，在某些像v8这样的引擎中，可以<a href="http://mrale.ph/blog/2014/12/24/array-length-caching.html" target="_blank" rel="noopener">看到</a>，预先缓存长度而不是让引擎为你做这件事情，会使性能稍微下降一点。<br>不要试图和JavaScript引擎比谁聪明。对性能优化来说，你很可能会输。</p><p><strong>不是所有的引擎都类似</strong><br>引擎可以自由决定一个运算是否需要优化，可能进行权衡，替换掉运算次要性能。<br>对一个运算来说，很难找到一种方法使其在所有浏览器中都运行得较快</p><p>在一些JavaScript开发社区有一场运动，特别是在那些使用Node.js工作的开发者中间。<br>这场运动是要分析v8 JavaScript引擎的特定内部实现细节，决定编写裁剪过的JavaScript代码来最大程度地利用v8的工作模式。<br>通过这样的努力，你可能会获得令人吃惊的高度性能优化。因此，这种努力的回报可能会很高。</p><p><strong>大局</strong><br>怎么知道什么是大局呢？<br>首先要了解你的代码是否运行在关键路径上。<br>如果不在关键路径上，你的优化就很可能得不到很大的收益。</p><p>有没有听过“这是过早优化”这样的警告？<br>这来自于高德纳著名的一句话：<strong>“过早优化是万恶之源。”</strong><br>很多开发者都会引用这句话来说明多数优化都是“过早的”，因此是白费力气。和通常情况一样，事实要更加微妙一些。</p><p>尽管程序关键路径上的性能非常重要，但这并不是唯一要考虑的因素。<br>在性能方面大体相似的几个选择中，<strong>可读性</strong>应该是另外一个重要的考量因素。</p><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用优化（Tail Call Optimization, TCO）<br>尾调用就是一个出现在另一个函数“结尾”处的函数调用。<br>这个调用结束后就没有其余事情要做了（除了可能要返回结果值）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(y+<span class="number">1</span>) <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + bar(<span class="number">40</span>) <span class="comment">// 非尾调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz() <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>调用一个新的函数需要额外的一块预留内存来管理调用栈，称为<strong>栈帧</strong>。<br>所以前面的代码一般会同时需要为每个baz()、bar(..)和foo(..)保留一个栈帧。</p><p>然而，如果支持TCO的引擎能够意识到foo(y+1)调用位于尾部，这意味着bar(..)基本上已经完成了，那么在调用foo(..)时，它就不需要创建一个新的栈帧，而是可以重用已有的bar(..)的栈帧。<br>这样不仅速度更快，也更节省内存。</p><p>在简单的代码片段中，这类优化算不了什么，但是在处理递归时，这就解决了大问题，特别是如果递归可能会导致成百上千个栈帧的时候。<br>有了TCO，引擎可以用同一个栈帧执行所有这类调用！</p><p>递归是JavaScript中一个纷繁复杂的主题。<br>因为如果没有TCO的话，引擎需要实现一个随意（还彼此不同！）的限制来界定递归栈的深度，达到了就得停止，以防止内存耗尽。<br>有了TCO，尾调用的递归函数本质上就可以任意运行，因为再也不需要使用额外的内存！</p><p>ES6之所以要求引擎实现TCO而不是将其留给引擎自由决定，一个原因是缺乏TCO会导致一些JavaScript算法因为害怕调用栈限制而降低了通过递归实现的概率。</p><p>最后今天冬至了，愿大家都能吃上一碗热乎的饺子🥟！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于中卷的部分，之前已经分了两篇文章进行了介绍。&lt;br&gt;分别是&lt;a href=&quot;https://jambo0624.github.io/2019-03-19-dont-know-js-second.html&quot;&gt;中卷一&lt;/a&gt;和&lt;a href=&quot;https://jambo0624.github.io/2019-07-07-dont-know-js-second2.html&quot;&gt;中卷二&lt;/a&gt;&lt;br&gt;但是真的由于内容很多，很精华，每一章节单拿出来都可以写成几篇文章。&lt;br&gt;就算仅仅记录表面意思，仍然足以撑满篇幅。&lt;br&gt;今天我们开始记录性能部分内容，真的是中卷的最后一篇文章啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>vim命令</title>
    <link href="https://jambo0624.github.io/2019-12-09-vim-command.html"/>
    <id>https://jambo0624.github.io/2019-12-09-vim-command.html</id>
    <published>2019-12-09T02:08:25.000Z</published>
    <updated>2020-10-15T12:29:23.002Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇文章摘转了一篇 vim 的教程。今天我们用简短集中的方式来梳理 vim 相关的知识。<br>大致意思就是去掉说明性的文字，直接让代码说话。<br>下面我们开始吧。</p><a id="more"></a><h1 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h1><p><a href="https://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">Vim命令合集</a><br><strong>退出方式</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>保存文件但不退出vi</td></tr><tr><td>:w</td><td>file 将修改另外保存到file中，不退出vi</td></tr><tr><td>:w!</td><td>强制保存，不推出vi</td></tr><tr><td>:wq</td><td>保存文件并退出vi</td></tr><tr><td>:wq!</td><td>强制保存文件，并退出vi</td></tr><tr><td>q:</td><td>不保存文件，退出vi</td></tr><tr><td>:q!</td><td>不保存文件，强制退出vi</td></tr><tr><td>:e!</td><td>放弃所有修改，从上次保存文件开始再编辑</td></tr></tbody></table><p><strong>命令历史</strong></p><blockquote><p>以<code>:</code>和<code>/</code>开头的命令都有历史记录，可以首先键入<code>:</code>或<code>/</code>然后按上下箭头来选择某个历史命令。</p></blockquote><p><strong>文件命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>vim file</td><td>打开单个文件</td></tr><tr><td>vim file1 file2 file3 …</td><td>同时打开多个文件</td></tr><tr><td>:open file</td><td>在vim窗口中打开一个新文件</td></tr><tr><td>:split file</td><td>在新窗口中打开文件</td></tr><tr><td>:bn</td><td>切换到下一个文件</td></tr><tr><td>:bp</td><td>切换到上一个文件</td></tr><tr><td>:args</td><td>查看当前打开的文件列表，当前正在编辑的文件会用<code>[]</code>括起来</td></tr><tr><td><code>:e ftp://192.168.10.76/abc.txt</code></td><td>打开远程文件，比如ftp</td></tr><tr><td>:e \qadrive\test\1.txt</td><td>打开远程文件，比如share folder</td></tr></tbody></table><p><strong>vim的模式</strong></p><table><thead><tr><th>模式</th><th>状态</th></tr></thead><tbody><tr><td>正常模式</td><td>（按Esc或Ctrl+[进入） 左下角显示文件名或为空</td></tr><tr><td>插入模式</td><td>（按i键进入） 左下角显示–INSERT–</td></tr><tr><td>可视模式</td><td>左下角显示–VISUAL–</td></tr></tbody></table><p><strong>导航命令</strong></p><blockquote><p>% 括号匹配</p></blockquote><p><strong>插入命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>在当前位置生前插入</td></tr><tr><td>I</td><td>在当前行首插入</td></tr><tr><td>a</td><td>在当前位置后插入</td></tr><tr><td>A</td><td>在当前行尾插入</td></tr><tr><td>o</td><td>在当前行之后插入一行</td></tr><tr><td>O</td><td>在当前行之前插入一行</td></tr></tbody></table><p><strong>查找命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>/text</td><td>查找text，按n健查找下一个，按N健查找前一个。</td></tr><tr><td>?text</td><td>查找text，反向查找，按n健查找下一个，按N健查找前一个。</td></tr><tr><td>:set ignorecase</td><td>忽略大小写的查找</td></tr><tr><td>:set noignorecase</td><td>不忽略大小写的查找</td></tr><tr><td>:set hlsearch</td><td>高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</td></tr><tr><td>:set nohlsearch</td><td>关闭高亮搜索显示</td></tr><tr><td>:nohlsearch</td><td>关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</td></tr><tr><td>:set incsearch</td><td>逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</td></tr><tr><td>:set wrapscan</td><td>重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</td></tr></tbody></table><ul><li>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</li><li>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</li></ul><p><strong>替换命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ra</td><td>将当前字符替换为a，当期字符即光标所在字符。</td></tr><tr><td>s/old/new/</td><td>用old替换new，替换当前行的第一个匹配</td></tr><tr><td>s/old/new/g</td><td>用old替换new，替换当前行的所有匹配</td></tr><tr><td>%s/old/new/</td><td>用old替换new，替换所有行的第一个匹配</td></tr><tr><td>%s/old/new/g</td><td>用old替换new，替换整个文件的所有匹配</td></tr><tr><td>:10,20 s/^//g</td><td>在第10行知第20行每行前面加四个空格，用于缩进。</td></tr><tr><td>ddp</td><td>交换光标所在行和其下紧邻的一行。</td></tr></tbody></table><p><strong>移动命令</strong></p><blockquote><p>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符</p></blockquote><p>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<code>&lt;Esc&gt;</code>，这里的Esc是必须的，否则命令不生效。</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>w</td><td>向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</td></tr><tr><td>b</td><td>向后移动一个单词 2b 向后移动2个单词</td></tr><tr><td>e，同w，</td><td>只不过是光标停在单词尾部</td></tr><tr><td>ge，同b，</td><td>光标停在单词尾部。</td></tr><tr><td>^</td><td>移动到本行第一个非空白字符上。</td></tr><tr><td>0</td><td>（数字0）移动到本行第一个字符上，</td></tr><tr><td><code>&lt;HOME&gt;</code></td><td>移动到本行第一个字符。同0健。</td></tr><tr><td>$</td><td>移动到行尾 3$ 移动到下面3行的行尾</td></tr><tr><td>gg( [[)</td><td>移动到文件头。</td></tr><tr><td>G（shift + g）( ]])</td><td>移动到文件尾。</td></tr><tr><td>f（find）</td><td>命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</td></tr><tr><td>F 同f</td><td>反向查找</td></tr><tr><td>Ctrl + e</td><td>向下滚动一行</td></tr><tr><td>Ctrl + y</td><td>向上滚动一行</td></tr><tr><td>Ctrl + d</td><td>向下滚动半屏</td></tr><tr><td>Ctrl + u</td><td>向上滚动半屏</td></tr><tr><td>Ctrl + f</td><td>向下滚动一屏</td></tr><tr><td>Ctrl + b</td><td>向上滚动一屏</td></tr><tr><td>跳到指定行，冒号+行号，回车</td><td>比如跳到240行就是 <code>:240回车</code>。另一个方法是行号+G，比如230G跳到230行。</td></tr></tbody></table><p><strong>撤销和重做</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>u</td><td>撤销（Undo）</td></tr><tr><td>U</td><td>撤销对整行的操作</td></tr><tr><td>Ctrl + r</td><td>重做（Redo），即撤销的撤销</td></tr></tbody></table><p><strong>删除命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>x</td><td>删除当前字符</td></tr><tr><td>3x</td><td>删除当前光标开始向后三个字符</td></tr><tr><td>X</td><td>删除当前字符的前一个字符。X=dh</td></tr><tr><td>dl</td><td>删除当前字符， dl=x</td></tr><tr><td>dh</td><td>删除前一个字符</td></tr><tr><td>dd</td><td>删除当前行</td></tr><tr><td>dj</td><td>删除上一行</td></tr><tr><td>dk</td><td>删除下一行</td></tr><tr><td>10d</td><td>删除当前行开始的10行。</td></tr><tr><td>D</td><td>删除当前字符至行尾。D=d$</td></tr><tr><td>d$</td><td>删除当前字符之后的所有字符（本行）</td></tr><tr><td>kdgg</td><td>删除当前行之前所有行（不包括当前行）</td></tr><tr><td>jdG（jd shift + g）</td><td>删除当前行之后所有行（不包括当前行）</td></tr><tr><td>:1,10d</td><td>删除1-10行</td></tr><tr><td>:11,$d</td><td>删除11行及以后所有的行</td></tr><tr><td>:1,$d</td><td>删除所有行</td></tr><tr><td>J(shift + j)</td><td>删除两行之间的空行，实际上是合并两行。</td></tr></tbody></table><p><strong>拷贝和粘贴</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>yy</td><td>拷贝当前行</td></tr><tr><td>nyy</td><td>拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</td></tr><tr><td>p</td><td>在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</td></tr><tr><td>shift+p</td><td>在当前行前粘贴</td></tr><tr><td>:1,10 co 20</td><td>将1-10行插入到第20行之后。</td></tr><tr><td>:1,$ co $</td><td>将整个文件复制一份并添加到文件尾部。</td></tr><tr><td>ddp</td><td>交换当前行和其下一行</td></tr><tr><td>xp</td><td>交换当前字符和其后一个字符</td></tr><tr><td>+ 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</td><td></td></tr></tbody></table><p><strong>剪切命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ndd</td><td>剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</td></tr><tr><td>:1,10d</td><td>将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</td></tr><tr><td>:1, 10 m 20</td><td>将第1-10行移动到第20行之后。</td></tr><tr><td>+ 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</td><td></td></tr></tbody></table><p><strong>退出命令</strong></p><blockquote><p>:wq 保存并退出<br>ZZ 保存并退出<br>:q! 强制退出并忽略所有更改<br>:e! 放弃所有修改，并打开原来文件。</p></blockquote><p><strong>窗口命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:split或new</td><td>打开一个新窗口，光标停在顶层的窗口上</td></tr><tr><td>:split file或:new file</td><td>用新窗口打开文件</td></tr><tr><td>Ctrl+ww</td><td>移动到下一个窗口</td></tr><tr><td>Ctrl+wj</td><td>移动到下方的窗口</td></tr><tr><td>Ctrl+wk</td><td>移动到上方的窗口</td></tr><tr><td>+ split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。</td><td></td></tr></tbody></table><p><strong>关闭窗口</strong></p><blockquote><p>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。<br>:q 如果是最后一个被关闭的窗口，那么将退出vim。<br>ZZ 保存并退出。<br>关闭所有窗口，只保留当前窗口 :only</p></blockquote><p><strong>录制宏</strong></p><blockquote><p>按<code>q</code>键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p></blockquote><p><strong>执行shell命令</strong></p><blockquote><p>:!command<br>:!ls 列出当前目录下文件<br>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。<br>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。<br>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p></blockquote><p><strong>注释命令</strong></p><blockquote><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#<br>3,5 s/^/#/g 注释第3-5行<br>3,5 s/^#//g 解除3-5行的注释<br>1,$ s/^/#/g 注释整个文档。<br>:%s/^/#/g 注释整个文档，此法更快。</p></blockquote><p><strong>帮助命令</strong></p><blockquote><p><code>:help or F1</code> 显示整个帮助<br><code>:help xxx</code> 显示xxx的帮助，比如 <code>:help i, :help CTRL-[</code>（即<code>Ctrl+[的帮助</code>）<br><code>:help &#39;number&#39;</code> Vim选项的帮助用单引号括起<br><code>:help &lt;Esc&gt;</code> 特殊键的帮助用&lt;&gt;扩起<br><code>:help -t</code> Vim启动参数的帮助用-<br><code>:help i_&lt;Esc&gt;</code> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</p></blockquote><p>其他非编辑命令</p><blockquote><p><code>.</code> 重复前一次命令<br><code>:set ruler?</code>　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看<br><code>:scriptnames</code>　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。<br><code>:set list</code> 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</p></blockquote><p>Vim教程<br>在Unix系统上</p><blockquote><p>$ vimtutor</p></blockquote><p>在Windows系统上</p><blockquote><p>:help tutor<br>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一篇文章摘转了一篇 vim 的教程。今天我们用简短集中的方式来梳理 vim 相关的知识。&lt;br&gt;大致意思就是去掉说明性的文字，直接让代码说话。&lt;br&gt;下面我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/categories/vim/"/>
    
    
      <category term="command" scheme="https://jambo0624.github.io/tags/command/"/>
    
      <category term="vim" scheme="https://jambo0624.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>vim教程--vimtutor</title>
    <link href="https://jambo0624.github.io/2019-12-07-vim.html"/>
    <id>https://jambo0624.github.io/2019-12-07-vim.html</id>
    <published>2019-12-07T10:17:35.000Z</published>
    <updated>2020-10-15T11:46:08.840Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到别人在用一款及其酷炫的编辑器 <strong>vim</strong> ，操作起来的场景就是自己最初对程序员的认识。<br>虽然现在不是了，哈哈。今天在这里是摘录了官方的一个tutor，类似于教程。<br>我们开始吧。</p><a id="more"></a><blockquote><p>vim 是一个具有很多命令的功能非常强大的编辑器。<br>本教程的设计目标是讲述一些必要的基本命令。<br>而掌握好这些命令，您就能够很容易将vim当作一个通用的万能编辑器来使用了。<br>完成本教程的内容大约需要25-30分钟，取决于您训练的时间。<br>每一节的命令操作将会更改本文。<br>推荐您复制本文的一个副本，然后在副本上进行训练(如果您是通过”vimtutor”来启动教程的，那么本文就已经是副本了)。<br>切记一点∶<strong>本教程的设计思路是在使用中进行学习的</strong>。也就是说，您需要通过执行命令来学习它们本身的正确用法。<br>如果您只是阅读而不操作，那么您可能会很快遗忘这些命令的！<br>好了，现在请确定您的Shift-Lock(大小写锁定键)还没有按下，然后按键盘上的字母键 j 足够多的次数来移动光标，直到第一节的内容能够完全充满屏幕。</p></blockquote><h2 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h2><h3 id="第一节∶移动光标"><a href="#第一节∶移动光标" class="headerlink" title="第一节∶移动光标"></a>第一节∶移动光标</h3><p>※※ 要移动光标，请依照说明分别按下 h、j、k、l 键。 ※※</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     ^</span><br><span class="line">     k      提示∶ h 的键位于左边，每次按下就会向左移动。</span><br><span class="line">&lt; h     l &gt;      l 的键位于右边，每次按下就会向右移动。</span><br><span class="line">     j           j 键看起来很象一支尖端方向朝下的箭头。</span><br><span class="line">     v</span><br></pre></td></tr></table></figure><blockquote><p>1.请随意在屏幕内移动光标，直至您觉得舒服为止。<br>2.按下下行键(j)，直到出现光标重复下行。     —&gt; 现在您应该已经学会如何移动到下一讲吧。<br>3.现在请使用下行键，将光标移动到第二讲。</p></blockquote><p>提示∶<br><strong>如果您不敢确定您所按下的字母，请按下<ESC>键回到正常(Normal)模式。然后再次从键盘输入您想要的命令。</strong></p><p>提示∶<br><strong>光标键应当也能正常工作的。但是使用hjkl键，在习惯之后您就能够快速地在屏幕内四处移动光标了。</strong></p><h3 id="第二节∶Vim的进入和退出"><a href="#第二节∶Vim的进入和退出" class="headerlink" title="第二节∶Vim的进入和退出"></a>第二节∶Vim的进入和退出</h3><p>!! 特别提示∶敬请阅读完整本一节的内容，然后才能执行以下所讲解的命令。<br>1.请按<code>&lt;ESC&gt;</code>键(这是为了确保您处在正常模式)。</p><p>2.然后输入∶ <code>:q! &lt;回车&gt;</code> —&gt; 这种方式的退出编辑器绝<strong>不会保存</strong>您进入编辑器以来所做的改动。<br>如果您想<strong>保存</strong>更改再退出，请输入∶ <code>:wq &lt;回车&gt;</code></p><p>3.如果您看到了命令行提示符，请输入能够带您回到本教程的命令，那就是∶ <code>vimtutor &lt;回车&gt;</code><br>通常情况下您也可以用这种方式∶<code>vim tutor &lt;回车&gt;</code>  —&gt; 这里的 ‘vim’ 表示进入vim编辑器，而 ‘tutor’则是您准备要编辑的文件。</p><p>4.如果您自信已经牢牢记住了这些步骤的话，请从步骤1执行到步骤3退出，然后再次进入编辑器。接着将光标移动到第一讲第三节来继续我们的教程讲解。</p><h3 id="第三节∶文本编辑之删除"><a href="#第三节∶文本编辑之删除" class="headerlink" title="第三节∶文本编辑之删除"></a>第三节∶文本编辑之删除</h3><p><strong>在正常(Normal)模式下，可以按下 x 键来删除光标所在位置的字符</strong></p><p>1.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>2.为了修正输入错误，请将光标移至准备删除的字符的位置处。</p><p>3.然后按下 x 键将错误字符删除掉。</p><p>4.重复步骤2到步骤4，直到句子修正为止。 —&gt; The ccow jumpedd ovverr thhe mooon.</p><p>5.好了，该行已经修正了，下一节内容是第一讲第四节。</p><p>特别提示∶在您浏览本教程时，不要强行记忆。记住一点∶<strong>在使用中学习</strong></p><h3 id="第四节∶文本编辑之插入"><a href="#第四节∶文本编辑之插入" class="headerlink" title="第四节∶文本编辑之插入"></a>第四节∶文本编辑之插入</h3><p>** 在正常模式下，可以按下 i 键来插入文本。**</p><p>1.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>2.为了使得第一行内容雷同于第二行，请将光标移至文本第一个字符准备插入的位置。</p><p>3.然后按下 i 键，接着输入必要的文本字符。</p><p>4.所有文本都修正完毕，请按下 <code>&lt;ESC&gt;</code> 键返回正常模式。<br>重复步骤2至步骤4以便修正句子。</p><p>—&gt; There is text misng this .<br>—&gt; There is some text missing from this line.</p><p>5.如果您对文本插入操作已经很满意，请接着阅读下面的小结。</p><h3 id="第一讲小结"><a href="#第一讲小结" class="headerlink" title="第一讲小结"></a>第一讲小结</h3><p>1.光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 <code>h (左移)</code>  <code>j (下行)</code> <code>k (上行)</code> <code>l (右移)</code></p><p>2.欲进入vim编辑器(从命令行提示符)，请输入<code>∶vim 文件名 &lt;回车&gt;</code></p><p>3.欲退出vim编辑器，请输入以下命令放弃所有修改∶ <code>&lt;ESC&gt;   :q!  &lt;回车&gt;</code><br>  或者输入以下命令保存所有修改∶ <code>&lt;ESC&gt;   :wq  &lt;回车&gt;</code></p><p>4.在正常模式下删除光标所在位置的字符，请按∶ <code>x</code></p><p>5.在正常模式下要在光标所在位置开始插入文本，请按∶ <code>i     输入必要文本 &lt;ESC&gt;</code></p><p>特别提示∶按下 <code>&lt;ESC&gt;</code> 键会带您回到正常模式或者取消一个不期望或者部分完成的命令。<br>好了，第一讲到此结束。下面接下来继续第二讲的内容。</p><h2 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h2><h3 id="第一节∶删除类命令"><a href="#第一节∶删除类命令" class="headerlink" title="第一节∶删除类命令"></a>第一节∶删除类命令</h3><p><strong>输入 <code>dw</code> 可以从光标处删除至一个单字/单词的末尾。</strong><br>1.请按下 <code>&lt;ESC&gt;</code> 键确保您处于正常模式。</p><p>2.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>3.请将光标移至准备要删除的单词的开始。</p><p>4.接着输入 dw 删除掉该单词。</p><p>特别提示∶您所输入的 dw 会在您输入的同时出现在屏幕的最后一行。如果您输入有误，请按下 <ESC> 键取消，然后重新再来。</p><p>—&gt; There are a some words fun that don’t belong paper in this sentence.</p><p>5.重复步骤3至步骤4，直至句子修正完毕。接着继续第二讲第二节内容。</p><h3 id="第二节∶其他删除类命令"><a href="#第二节∶其他删除类命令" class="headerlink" title="第二节∶其他删除类命令"></a>第二节∶其他删除类命令</h3><p><strong>输入 <code>d$</code> 从当前光标删除到行末。</strong></p><p>  1.请按下 <ESC> 键确保您处于正常模式。</p><p>  2.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>  3.请将光标移动到该行的尾部(也就是在第一个点号‘.’后面)。</p><p>  4.然后输入 d$ 从光标处删至当前行尾部。</p><p>—&gt; Somebody typed the end of this line twice. end of this line twice.</p><p>  5.请继续学习第二讲第三节就知道是怎么回事了。</p><h3 id="第三节∶关于命令和对象"><a href="#第三节∶关于命令和对象" class="headerlink" title="第三节∶关于命令和对象"></a>第三节∶关于命令和对象</h3><p>删除命令 <code>d</code> 的格式如下∶<br><code>[number] d object</code> 或者 <code>d [number] object</code></p><p>其意如下∶</p><blockquote><p><code>number</code> - 代表执行命令的次数(可选项，缺省设置为 1 )。<br><code>d</code> - 代表删除。<br><code>object</code> - 代表命令所要操作的对象(下面有相关介绍)。</p></blockquote><p>一个简短的对象列表∶</p><blockquote><p><code>w</code> - 从当前光标当前位置直到单字/单词末尾，包括空格。<br><code>e</code> - 从当前光标当前位置直到单字/单词末尾，但是 不 包括空格。<br><code>$</code> - 从当前光标当前位置直到当前行末。</p></blockquote><p>特别提示∶<br>对于勇于探索者，请在正常模式下面仅按代表相应对象的键而不使用命令，则将看到光标的移动正如上面的对象列表所代表的一样。</p><h3 id="第四节∶对象命令的特殊情况"><a href="#第四节∶对象命令的特殊情况" class="headerlink" title="第四节∶对象命令的特殊情况"></a>第四节∶对象命令的特殊情况</h3><p><strong>输入 <code>dd</code> 可以删除整一个当前行。</strong></p><p>鉴于整行删除的高频度，VIM 的设计者决定要简化整行删除，仅需要在同一行上击打两次 d 就可以删除掉光标所在的整行了。<br>  1.请将光标移动到本节中下面的短句段落中的第二行。<br>  2.输入 <code>dd</code> 删除该行。<br>  3.然后移动到第四行。<br>  4.接着输入 <code>2dd</code> (还记得前面讲过的 number-command-object 吗？) 删除两行。</p><blockquote><p>Roses are red,<br>Mud is fun,<br>Violets are blue,<br>I have a car,<br>Clocks tell time,<br>Sugar is sweet<br>And so are you.</p></blockquote><h3 id="第五节∶撤消类命令"><a href="#第五节∶撤消类命令" class="headerlink" title="第五节∶撤消类命令"></a>第五节∶撤消类命令</h3><p><strong>输入 <code>u</code> 来撤消最后执行的命令，输入 <code>U</code> 来修正整行。</strong></p><p>1.请将光标移动到本节中下面标记有 —&gt; 的那一行，并将其置于第一个错误处。<br>2.输入 <code>x</code> 删除第一个不想保留的字母。<br>3.然后输入 <code>u</code> 撤消最后执行的(一次)命令。<br>4.这次要使用 <code>x</code> 修正本行的所有错误。<br>5.现在输入一个大写的 <code>U</code> ，恢复到该行的原始状态。<br>6.接着多次输入 <code>u</code> 以撤消 <code>U</code> 以及更前的命令。<br>7.然后多次输入 <code>CTRL-R</code> (先按下 CTRL 键不放开，接着输入 R 键) ，这样就可以执行恢复命令，也就是撤消掉撤消命令。</p><p>—&gt; Fiix the errors oon thhis line and reeplace them witth undo.</p><p>8.这些都是非常有用的命令。下面是第二讲的小结了。</p><h3 id="第二讲小结"><a href="#第二讲小结" class="headerlink" title="第二讲小结"></a>第二讲小结</h3><p>1.欲从当前光标删除至单字/单词末尾，请输入∶<code>dw</code></p><p>2.欲从当前光标删除至当前行末尾，请输入∶<code>d$</code></p><p>3.欲删除整行，请输入∶<code>dd</code></p><p>4.在正常模式下一个命令的格式是∶ <code>[number]   command   object</code>     或者     <code>command [number]   object</code><br>   其意是∶</p><blockquote><p><code>number</code> - 代表的是命令执行的次数<br><code>command</code> - 代表要做的事情，比如 d 代表删除<br><code>object</code> - 代表要操作的对象，比如 w 代表单字/单词，$ 代表到行末等等。<br>$ (to the end of line), etc.</p></blockquote><p>5.欲撤消以前的操作，请输入∶<code>u</code> (小写的u)<br>   欲撤消在一行中所做的改动，请输入∶<code>U</code> (大写的U)<br>   欲撤消以前的撤消命令，恢复以前的操作结果，请输入∶<code>CTRL-R</code></p><h2 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h2><h3 id="第一节∶置入类命令"><a href="#第一节∶置入类命令" class="headerlink" title="第一节∶置入类命令"></a>第一节∶置入类命令</h3><p><strong>输入 <code>p</code> 将最后一次删除的内容置入光标之后</strong><br>1.请将光标移动到本节中下面示范段落的首行。</p><p>2.输入 dd 将该行删除，这样会将该行保存到vim的缓冲区中。</p><p>3.接着将光标移动到准备置入的位置的上方。记住∶是上方哦。</p><p>4.然后在正常模式下(<ESC>键进入)，输入 p 将该行粘贴置入。</p><p>5.重复步骤2至步骤4，将所有的行依序放置到正确的位置上。</p><blockquote><p>Can you learn too?<br>Violets are blue,<br>Intelligence is learned,<br>Roses are red,                                 </p></blockquote><h3 id="第二节∶替换类命令"><a href="#第二节∶替换类命令" class="headerlink" title="第二节∶替换类命令"></a>第二节∶替换类命令</h3><p><strong>输入 <code>r</code> 和一个字符替换光标所在位置的字符。</strong></p><p>  1.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>  2.请移动光标到第一个错误的适当位置。</p><p>  3.接着输入 <code>r</code> ，这样就能将错误替换掉了。</p><p>  4.重复步骤2和步骤3，直到第一行已经修改完毕。</p><p>—&gt;  Whan this lime was tuoed in, someone presswd some wrojg keys!<br>—&gt;  When this line was typed in, someone pressed some wrong keys!</p><p>  5.然后我们继续学校第三讲第三节。</p><p>特别提示∶切记您要在使用中学习，而不是在记忆中学习。</p><h3 id="第三节∶更改类命令"><a href="#第三节∶更改类命令" class="headerlink" title="第三节∶更改类命令"></a>第三节∶更改类命令</h3><p><strong>要改变一个单字/单词的部分或者全部，请输入 <code>cw</code></strong><br>1.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>2.接着把光标放在单词 lubw 的字母 <code>u</code> 的位置那里。</p><p>3.然后输入 <code>cw</code> 就可以修正该单词了(在本例这里是输入 ine 。)</p><p>4.最后按 <code>&lt;ESC&gt;</code> 键，然后光标定位到下一个错误第一个准备更改的字母处。</p><p>5.重复步骤3和步骤4，直到第一个句子完全雷同第二个句子。</p><p>—&gt; This lubw has a few wptfd that mrrf changing usf the change command.<br>—&gt; This line has a few words that need changing using the change command.</p><p>提示∶请注意 <code>cw</code> 命令不仅仅是替换了一个单词，也让您进入文本插入状态了。</p><h3 id="第四节∶使用c指令的其他更改类命令"><a href="#第四节∶使用c指令的其他更改类命令" class="headerlink" title="第四节∶使用c指令的其他更改类命令"></a>第四节∶使用c指令的其他更改类命令</h3><p><strong>更改类指令可以使用同删除类命令所使用的对象参数。</strong></p><p>  1.更改类指令的工作方式跟删除类命令是一致的。操作格式是∶ <code>[number]   c   object</code> 或者   <code>c [number]   object</code></p><p>  2.对象参数也是一样的，比如 <code>w</code> 代表单字/单词，<code>$</code>代表行末等等。</p><p>  3.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>  4.接着将光标移动到第一个错误处。</p><p>  5.然后输入 <code>c$</code> 使得该行剩下的部分更正得同第二行一样。最后按 <code>&lt;ESC&gt;</code> 键。</p><p>—&gt; The end of this line needs some help to make it like the second.<br>—&gt; The end of this line needs to be corrected using the  c$  command.</p><h3 id="第三讲小结"><a href="#第三讲小结" class="headerlink" title="第三讲小结"></a>第三讲小结</h3><p>1.要重新置入已经删除的文本内容，请输入小写字母 p。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。</p><p>2.要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。</p><p>3.更改类命令允许您改变指定的对象，从当前光标所在位置直到对象的末尾。比如输入 cw 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。</p><p>4.更改类命令的格式是∶ <code>[number] c object</code> 或者 <code>c [number] object</code></p><h2 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h2><h3 id="第一节∶定位及文件状态"><a href="#第一节∶定位及文件状态" class="headerlink" title="第一节∶定位及文件状态"></a>第一节∶定位及文件状态</h3><p><strong>输入 <code>CTRL-g</code> 显示当前编辑文件中当前光标所在行位置以及文件状态信息。输入 <code>SHIFT-G</code> 则直接跳转到文件中的某一指定行。</strong><br>提示∶切记要先通读本节内容，之后才可以执行以下步骤!!!</p><p>  1.按下 <code>CTRL</code> 键不放开然后按 <code>g</code> 键。然后就会看到页面最底部出现一个状态信息行，显示的内容是当前编辑的文件名和文件的总行数。请记住步骤3的行号。</p><p>  2.按下 <code>SHIFT-G</code> 键可以使得当前光标直接跳转到文件最后一行。</p><p>  3.输入您曾停留的行号，然后按下 <code>SHIFT-G</code>。这样就可以返回到您第一次按下<code>CTRL-g</code> 时所在的行好了。注意∶输入行号时，行号是不会在屏幕上显示出来的。</p><p>  4.如果愿意，您可以继续执行步骤1至步骤三。</p><h3 id="第二节∶搜索类命令"><a href="#第二节∶搜索类命令" class="headerlink" title="第二节∶搜索类命令"></a>第二节∶搜索类命令</h3><p><strong>输入 <code>/</code> 以及尾随的字符串可以用以在当前文件中查找该字符串。</strong><br>1.在正常模式下输入 <code>/</code> 字符。您此时会注意到该字符和光标都会出现在屏幕底部，这跟 <code>:</code> 命令是一样的。</p><p>2.接着输入 <code>errroor &lt;回车&gt;</code>。那个<code>errroor</code>就是您要查找的字符串。</p><p>3.要查找同上一次的字符串，只需要按 <code>n</code> 键。要向相反方向查找同上一次的字符串，请输入 <code>Shift-N</code> 即可。</p><p>4.如果您想逆向查找字符串，请使用 <code>?</code> 代替 <code>/</code> 进行。</p><p>—&gt; When the search reaches the end of the file it will continue at the start.</p><p>“errroor” is not the way to spell error; errroor is an error.</p><p>提示∶如果查找已经到达文件末尾，查找会自动从文件头部继续查找。</p><h3 id="第三节∶配对括号的查找"><a href="#第三节∶配对括号的查找" class="headerlink" title="第三节∶配对括号的查找"></a>第三节∶配对括号的查找</h3><p><strong>按 <code>%</code> 可以查找配对的括号 )、]、}。</strong></p><p>  1.把光标放在本节下面标记有 –&gt; 那一行中的任何一个 (、[ 或 { 处。</p><p>  2.接着按 <code>%</code> 字符。</p><p>  3.此时光标的位置应当是在配对的括号处。</p><p>  4.再次按 <code>%</code> 就可以跳回配对的第一个括号处。</p><p>—&gt; This ( is a test line with (‘s, [‘s ] and {‘s } in it. ))</p><p>提示∶在程序调试时，这个功能用来查找不配对的括号是很有用的。</p><h3 id="第四节∶修正错误的方法之一"><a href="#第四节∶修正错误的方法之一" class="headerlink" title="第四节∶修正错误的方法之一"></a>第四节∶修正错误的方法之一</h3><p><strong>输入 <code>:s/old/new/g</code> 可以替换 old 为 new。</strong><br>1.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>2.输入 <code>:s/thee/the &lt;回车&gt;</code> 。请注意该命令只改变光标所在行的第一个匹配串。</p><p>3.输入 <code>:s/thee/the/g</code> 则是替换全行的匹配串。</p><p>—&gt; the best time to see thee flowers is in thee spring.</p><p>4.要替换两行之间出现的每个匹配串，请输入 <code>:#,#s/old/new/g</code> (#,#代表的是两行的行号)。<br>输入 <code>:%s/old/new/g</code> 则是替换整个文件中的每个匹配串。</p><h3 id="第四讲小结"><a href="#第四讲小结" class="headerlink" title="第四讲小结"></a>第四讲小结</h3><p>  1.<code>Ctrl-g</code> 用于显示当前光标所在位置和文件状态信息。<code>Shift-G</code> 用于将光标跳转至文件最后一行。先敲入一个行号然后按 <code>Shift-G</code> 则是将光标移动至该行号代表的行。</p><p>  2.输入 <code>/</code> 然后紧随一个字符串是则是在当前所编辑的文档中向后查找该字符串。输入问号 <code>?</code> 然后紧随一个字符串是则是在当前所编辑的文档中向前查找该字符串。<br>  完成一次查找之后按 <code>n</code> 键则是重复上一次的命令，可在同一方向上查找下一个字符串所在；或者按 <code>Shift-N</code> 向相反方向查找下该字符串所在。</p><p>  3.如果光标当前位置是括号(、)、[、]、{、}，按 <code>%</code> 可以将光标移动到配对的括号上。</p><p>  4.在一行内替换头一个字符串 old 为新的字符串 new，请输入  <code>:s/old/new</code><br>     在一行内替换所有的字符串 old 为新的字符串 new，请输入  <code>:s/old/new/g</code><br>     在两行内替换所有的字符串 old 为新的字符串 new，请输入  <code>:#,#s/old/new/g</code><br>     在文件内替换所有的字符串 old 为新的字符串 new，请输入  <code>:%s/old/new/g</code><br>     进行全文替换时询问用户确认每个替换需添加 c 选项，请输入 <code>:%s/old/new/gc</code></p><h2 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h2><h3 id="第一节∶在-VIM-内执行外部命令的方法"><a href="#第一节∶在-VIM-内执行外部命令的方法" class="headerlink" title="第一节∶在 VIM 内执行外部命令的方法"></a>第一节∶在 VIM 内执行外部命令的方法</h3><p><strong>输入 <code>:!</code> 然后紧随著输入一个外部命令可以执行该外部命令。</strong><br>1.按下我们所熟悉的 <code>:</code> 命令设置光标到屏幕底部。这样就可以让您输入命令了。</p><p>2.接着输入感叹号 <code>!</code> 这个字符，这样就允许您执行外部的 shell 命令了。</p><p>3.我们以 <code>ls</code> 命令为例。输入 <code>!ls &lt;回车&gt;</code> 。<br>该命令就会列举出您当前目录的内容，就如同您在命令行提示符下输入 <code>ls</code> 命令的结果一样。<br>如果 <code>!ls</code> 没起作用，您可以试试 <code>:!dir</code> 看看。</p><p>—&gt; 提示∶ 所有的外部命令都可以以这种方式执行。</p><p>—&gt; 提示∶ 所有的 <code>:</code> 命令都必须以 <code>&lt;回车&gt;</code> 告终。</p><h3 id="第二节∶关于保存文件的更多信息"><a href="#第二节∶关于保存文件的更多信息" class="headerlink" title="第二节∶关于保存文件的更多信息"></a>第二节∶关于保存文件的更多信息</h3><p><strong>要将对文件的改动保存到文件中，请输入 <code>:w FILENAME</code>。</strong></p><p>  1.输入 <code>:!dir</code> 或者 <code>:!ls</code> 获知当前目录的内容。您应当已知道最后还得敲 <code>&lt;回车&gt;</code> 吧。</p><p>  2.选择一个尚未存在文件名，比如 TEST 。</p><p>  3.接着输入 <code>:w TEST</code>  (此处 TEST 是您所选择的文件名。)</p><p>  4.该命令会以 TEST 为文件名保存整个文件 (VIM 教程)。为了确保正确保存，请再次输入 <code>:!dir</code> 查看您的目录列表内容。</p><p>—&gt; 请注意∶如果您退出 VIM 然后在以文件名 TEST 为参数进入，那么该文件内容应该同您保存时的文件内容是完全一样的。</p><p>  5.现在您可以通过输入 <code>:!rm TEST</code> 来删除 TEST 文件了。</p><h3 id="第三节∶一个具有选择性的保存命令"><a href="#第三节∶一个具有选择性的保存命令" class="headerlink" title="第三节∶一个具有选择性的保存命令"></a>第三节∶一个具有选择性的保存命令</h3><p><strong>要保存文件的部分内容，请输入 <code>:#,# w FILENAME</code></strong></p><p>1.再来执行一次 <code>:!dir</code> 或者 <code>:!ls</code> 获知当前目录的内容，然后选择一个合适的不重名的文件名，比如 TEST 。</p><p>2.接着将光标移动至本页的最顶端，然后按 <code>CTRL-g</code> 找到该行的行号。别忘了行号哦。</p><p>3.接着把光标移动至本页的最底端，再按一次 <code>CTRL-g</code> 。也别忘了这个行好哦。</p><p>4.为了只保存文章的某个部分，请输入 <code>:#,# w TEST</code>。这里的 <code>#</code>,<code>#</code> 就是上面要求您记住的行号(顶端行号,底端行号)，而 TEST 就是选定的文件名。</p><p>5.最后，用 <code>:!dir</code> 确认文件是否正确保存。但是这次先别删除掉。</p><h3 id="第四节∶提取和合并文件"><a href="#第四节∶提取和合并文件" class="headerlink" title="第四节∶提取和合并文件"></a>第四节∶提取和合并文件</h3><p><strong>要向当前文件中插入另外的文件的内容，请输入 <code>:r FILENAME</code></strong></p><p>  1.请键入 <code>:!dir</code> 确认您前面创建的 TEST 文件还在。</p><p>  2.然后将光标移动至当前页面的顶端。</p><p>特别提示∶ 执行步骤3之后您将看到第五讲第三节，请届时再往下移动回到这里来。</p><p>  3.接着通过 <code>:r TEST</code> 将前面创建的名为 TEST 的文件提取进来。</p><p>特别提示∶您所提取进来的文件将从光标所在位置处开始置入。</p><p>  4.为了确认文件已经提取成功，移动光标回到原来的位置就可以注意有两份第五讲第三节，一份是原本，另外一份是来自文件的副本。</p><h3 id="第五讲小结"><a href="#第五讲小结" class="headerlink" title="第五讲小结"></a>第五讲小结</h3><p>1.<code>:!command</code> 用于执行一个外部命令 command。</p><p>请看一些实际例子∶<br><code>:!dir</code> - 用于显示当前目录的内容。<br><code>:!rm FILENAME</code> - 用于删除名为 FILENAME 的文件。</p><p>2.<code>:w FILENAME</code> 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。</p><p>3.<code>:#,#w FILENAME</code> 可将当前编辑文件第 # 行至第 # 行的内容保存到文件FILENAME 中。</p><p>4.<code>:r FILENAME</code> 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。</p><h2 id="第六讲"><a href="#第六讲" class="headerlink" title="第六讲"></a>第六讲</h2><h3 id="第一节∶打开类命令"><a href="#第一节∶打开类命令" class="headerlink" title="第一节∶打开类命令"></a>第一节∶打开类命令</h3><p><strong>输入 <code>o</code> 将在光标的下方打开新的一行并进入插入模式。</strong></p><p>  1.请将光标移动到本节中下面标记有 —&gt; 的那一行。</p><p>  2.接着输入小写的 <code>o</code> 在光标 <em>下方</em> 打开新的一行并进入插入模式。</p><p>  3.然后复制标记有 —&gt; 的行并按 <code>&lt;ESC&gt;</code> 键退出插入模式而进入正常模式。</p><p>—&gt; After typing  o  the cursor is placed on the open line in Insert mode.</p><p>  4.为了在光标 <em>上方</em> 打开新的一行，只需要输入大写的 <code>O</code> 而不是小写的 <code>o</code> 就可以了。请在下行测试一下吧。当光标处在在该行上时，按 Shift-O可以在该行上方新开一行。</p><p>Open up a line above this by typing Shift-O while the cursor is on this line.</p><h3 id="第二节∶光标后插入类命令"><a href="#第二节∶光标后插入类命令" class="headerlink" title="第二节∶光标后插入类命令"></a>第二节∶光标后插入类命令</h3><p><strong>输入 <code>a</code> 将可在光标之后插入文本</strong><br>1.请在正常模式下通过输入 <code>$</code> 将光标移动到本节中下面标记有 —&gt; 的第一行的末尾。</p><p>2.接着输入小写的 <code>a</code> 则可在光标之后插入文本了。大写的 <code>A</code> 则可以直接在行末插入文本。</p><p>提示∶输入大写 <code>A</code> 的操作方法可以在行末插入文本，避免了输入 <code>i</code>，光标定位到最后一个字符，输入的文本，<code>&lt;ESC&gt;</code> 回复正常模式，箭头右键移动光标以及<code>x</code> 删除当前光标所在位置字符等等诸多繁杂的操作。</p><p>3.操作之后第一行就可以补充完整了。请注意光标后插入文本与插入模式是基本完全一致的，只是文本插入的位置定位稍有不同罢了。</p><p>—&gt; This line will allow you to practice<br>—&gt; This line will allow you to practice appending text to the end of a line.</p><h3 id="第三节∶另外一个置换类命令的版本"><a href="#第三节∶另外一个置换类命令的版本" class="headerlink" title="第三节∶另外一个置换类命令的版本"></a>第三节∶另外一个置换类命令的版本</h3><p><strong>输入大写的 <code>R</code> 可连续替换多个字符。</strong></p><p>  1.请将光标移动到本节中下面标记有 —&gt; 的第一行。</p><p>  2.移动光标到第一行中不同于标有 —&gt; 的第二行的第一个单词的开始，即单词 last 处。</p><p>  3.然后输入大写的 <code>R</code> 开始把第一行中的不同于第二行的剩余字符逐一输入，就可以全部替换掉原有的字符而使得第一行完全雷同第二行了。</p><p>—&gt; To make the first line the same as the last on this page use the keys.<br>—&gt; To make the first line the same as the second, type R and the new text.</p><p>  4.请注意∶如果您按 <code>&lt;ESC&gt;</code> 退出置换模式回复正常模式，尚未替换的文本将仍然保持原状。</p><h3 id="第四节∶设置类命令的选项"><a href="#第四节∶设置类命令的选项" class="headerlink" title="第四节∶设置类命令的选项"></a>第四节∶设置类命令的选项</h3><p>*<em>设置可使查找或者替换可忽略大小写的选项 *</em><br>1.要查找单词 ignore 可在正常模式下输入 <code>/ignore</code> 。要重复查找该词，可以重复按 <code>n</code> 键。</p><p>2.然后设置 <code>ic</code> 选项(ic就是英文忽略大小写Ignore Case的首字母缩写词)，即输入∶ <code>:set ic</code></p><p>3.现在可以通过键入 <code>n</code> 键再次查找单词 ignore。重复查找可以重复键入 <code>n</code> 键。</p><p>4.然后设置 hlsearch 和 incsearch 这两个选项，输入以下内容∶ <code>:set hls is</code></p><p>5.现在可以再次输入查找命令，看看会有什么效果∶ <code>/ignore</code></p><h3 id="第六讲小结"><a href="#第六讲小结" class="headerlink" title="第六讲小结"></a>第六讲小结</h3><p>  1.输入小写的 <code>o</code> 可以在光标下方打开新的一行并将光标置于新开的行首，进入插入模式。<br>    输入大写的 <code>O</code> 可以在光标上方打开新的一行并将光标置于新开的行首，进入插入模式。</p><p>  2.输入小写的 <code>a</code> 可以在光标所在位置之后插入文本。<br>    输入大写的 <code>A</code> 可以在光标所在行的行末之后插入文本。</p><p>  3.输入大写的 <code>R</code> 将进入替换模式，直至按 <code>&lt;ESC&gt;</code> 键退出替换模式而进入正常模式。</p><p>  4.输入 <code>:set xxx</code> 可以设置 xxx 选项。</p><h3 id="第七讲∶在线帮助命令"><a href="#第七讲∶在线帮助命令" class="headerlink" title="第七讲∶在线帮助命令"></a>第七讲∶在线帮助命令</h3><p><strong>使用在线帮助系统</strong><br>Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方法之一∶</p><p>按下 <code>&lt;HELP&gt;</code> 键 (如果键盘上有的话)<br>按下 <code>&lt;F1&gt;</code> 键 (如果键盘上有的话)<br>输入 <code>:help &lt;回车&gt;</code><br>输入 <code>:q &lt;回车&gt;</code> 可以关闭帮助窗口。</p><p>提供一个正确的参数给”:help”命令，您可以找到关于该主题的帮助。请试验以下参数(可别忘了按回车键哦。)</p><p><code>:help w &lt;回车&gt;</code><br><code>:help c_&lt;T &lt;回车&gt;</code><br><code>:help insert-index &lt;回车&gt;</code><br><code>:help user-manual &lt;回车&gt;</code></p><h3 id="第八讲∶创建一个启动脚本"><a href="#第八讲∶创建一个启动脚本" class="headerlink" title="第八讲∶创建一个启动脚本"></a>第八讲∶创建一个启动脚本</h3><p><strong>启用vim的功能</strong></p><p>Vim的功能特性要比vi多得多，但大部分功能都没有缺省激活。为了启动更多的功能，您得创建一个vimrc文件。</p><p>  1.开始编辑vimrc文件，这取决于您所使用的操作系统∶<br>  <code>:edit ~/.vimrc</code>  这是Unix系统所使用的命令<br>  <code>:edit $VIM/_vimrc</code>  这是Windows系统所使用的命令</p><p>  2.接着导入vimrc范例文件∶ <code>:read $VIMRUNTIME/vimrc_example.vim</code></p><p>  3.保存文件，命令为∶ <code>:write</code></p><p>  在下次您启动vim的时候，编辑器就会有了语法高亮的功能。您可以继续把您喜欢的其它功能设置添加到这个vimrc文件中。</p><p>  阅读vim手册，使用的命令是∶ <code>:help user-manual</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到别人在用一款及其酷炫的编辑器 &lt;strong&gt;vim&lt;/strong&gt; ，操作起来的场景就是自己最初对程序员的认识。&lt;br&gt;虽然现在不是了，哈哈。今天在这里是摘录了官方的一个tutor，类似于教程。&lt;br&gt;我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/categories/vim/"/>
    
    
      <category term="vim" scheme="https://jambo0624.github.io/tags/vim/"/>
    
      <category term="tutor" scheme="https://jambo0624.github.io/tags/tutor/"/>
    
  </entry>
  
  <entry>
    <title>ES6新增的数组和字符串API</title>
    <link href="https://jambo0624.github.io/2019-11-24-es6-new-array-api.html"/>
    <id>https://jambo0624.github.io/2019-11-24-es6-new-array-api.html</id>
    <published>2019-11-24T01:07:44.000Z</published>
    <updated>2020-10-15T09:22:37.520Z</updated>
    
    <content type="html"><![CDATA[<p>之前整理过 string 和 array 的API，最近发现好多没有总结到的。ES6新出，用的比较少的，在这里补充一下。<br>话不多说，我们开始吧。</p><a id="more"></a><h3 id="es6数组新增API"><a href="#es6数组新增API" class="headerlink" title="es6数组新增API"></a>es6数组新增API</h3><p>ES6新增数组的方法</p><ul><li>Array.from()<br>Array.from 方法用于将两类对象转为真正的数组：<br>类似数组的对象（array-like object）<br>可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）    </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="string">"1"</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="string">"2"</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike)   <span class="comment">//[a, b, c]</span></span><br><span class="line"><span class="comment">//ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike) <span class="comment">//[a, b, c]</span></span><br><span class="line"><span class="comment">// 任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</span></span><br><span class="line"><span class="comment">// 扩展运算符只能对部署 Iterator 接口的类数组转换为真正的数组 </span></span><br><span class="line"><span class="comment">// console.log([...arrayLike]); // 报错 TypeError: Cannot spread non-iterable object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from还可以接受第二个参数，作用类似于数组的map方法</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.from(arrayLike, x =&gt; x + x)</span><br><span class="line"><span class="built_in">console</span>.log(map)  <span class="comment">// [aa,bb,cc]</span></span><br></pre></td></tr></table></figure><ul><li><p>Array.of()<br>Array.of 方法用于将一组值，转换为数组。弥补数组构造函数 Array()的不足。因为参数个数的不同，会导致 Array()的行为有差异    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下代码看出差异</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3,11,8]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3, 11, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.of方法可以用下面的代码模拟实现。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组实例的 find() 和 findIndex()<br>=&gt; find()方法找到第一个符合条件的成员,没有符合的则返回 undefined<br>=&gt; findIndex 方法的用法与 find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find()</span></span><br><span class="line"><span class="keyword">var</span> item = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// -5</span></span><br><span class="line"><span class="comment">// find 也支持这种复杂的查找</span></span><br><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">20</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">30</span>, <span class="attr">y</span>: <span class="number">40</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">40</span>, <span class="attr">y</span>: <span class="number">50</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>: <span class="number">60</span> &#125;</span><br><span class="line">];</span><br><span class="line">points.find(<span class="function"><span class="keyword">function</span> <span class="title">macther</span>(<span class="params">point</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point.x % <span class="number">3</span> === <span class="number">0</span> &amp;&amp; point.y % <span class="number">4</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>=&gt; findIndex()返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1<br>=&gt; indexOf(..) 会提供这些，但是无法控制匹配逻辑；它总是使用 === 严格相等。所以 ES6 的 findIndex(..) 才是解决方案    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">20</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">30</span>, <span class="attr">y</span>: <span class="number">40</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">40</span>, <span class="attr">y</span>: <span class="number">50</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>: <span class="number">60</span> &#125;</span><br><span class="line">];</span><br><span class="line">points.findIndex(<span class="function"><span class="keyword">function</span> <span class="title">matcher</span>(<span class="params">point</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point.x % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; point.y % <span class="number">4</span> == <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">// 2</span></span><br><span class="line">points.findIndex(<span class="function"><span class="keyword">function</span> <span class="title">matcher</span>(<span class="params">point</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point.x % <span class="number">6</span> == <span class="number">0</span> &amp;&amp; point.y % <span class="number">7</span> == <span class="number">0</span>;</span><br><span class="line">&#125;); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><ul><li><p>数组实例的 fill()<br>=&gt; fill()方法使用给定值， 填充一个数组<br>=&gt; fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置   </p><pre class="line-numbers language-js"><span class="comment"><code class="language-js"><span class="comment">// fill方法使用给定值， 填充一个数组</span><span class="keyword">var</span> fillArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>).fill(<span class="number">1</span>)<span class="built_in">console</span>.log(fillArray)  <span class="comment">//[1,1,1,1,1,1]</span><span class="comment">//fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// ['a', 7, 'c']</span><span class="comment">// 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</span><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill({  name: <span class="string">"Mike"</span>})arr[<span class="number">0</span>].name = <span class="string">'Ben'</span><span class="built_in">console</span>.log(arr) <span class="comment">// [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>数组实例的 entries()，keys() 和 values()<br>entries()，keys()和 values()——用于遍历数组,可以用 for…of 循环进行遍历<br>唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历    </p><pre class="line-numbers language-js"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string"><code class="language-js"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].keys()) {  <span class="built_in">console</span>.log(index);}<span class="comment">// 0 1</span><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].values()) {  <span class="built_in">console</span>.log(elem);}<span class="comment">// a b</span><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].entries()) {  <span class="built_in">console</span>.log(index, elem);}<span class="comment">// 0 "a"</span><span class="comment">// 1 "b"</span><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];[...a.values()]; <span class="comment">// [1,2,3]</span>[...a.keys()]; <span class="comment">// [0,1,2]</span>[...a.entries()]; <span class="comment">// [ [0,1], [1,2], [2,3] ]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>includes()方法返回一个布尔值</p><pre class="line-numbers language-js">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>) <span class="comment"><code class="language-js">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>) <span class="comment">// true</span>[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].includes(<span class="number">4</span>) <span class="comment">// false</span>[(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>)].includes(<span class="literal">NaN</span>); <span class="comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>includes 方法弥补了 indexOf 方法不够语义化和误判 NaN 的缺点    </p><ul><li>数组实例的 flat()，flatMap()<br>=&gt; flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法<strong>返回一个新数组</strong>，对原数据没有影响。传参数代表拉平几层默认是一层<br>=&gt; flatMap()只能展开一层数组。方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法。该方法返回一个新数组，不改变原数组    <pre class="line-numbers language-js"><span class="comment"><code class="language-js"><span class="comment">// flat()</span>[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()   <span class="comment">// [1, 2, 3, [4, 5]]</span>[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)    <span class="comment">// [1, 2, 3, 4, 5]</span><span class="comment">//flatMap()</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =></span> [x, x * <span class="number">2</span>])  <span class="comment">//map执行完后是[[2, 4], [3, 6], [4, 8]]</span><span class="comment">// 然后在执行flat()方法得到下边的结果  // [2, 4, 3, 6, 4, 8]</span><span class="comment">// flatMap()只能展开一层数组  // 相当于 .flat()</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =></span> [ [x * <span class="number">2</span>] ])<span class="comment">// map执行完后是[[[2]], [[4]], [[6]], [[8]]]</span><span class="comment">// 然后在执行flat()方法得到如下结果</span><span class="comment">// [[2], [4], [6], [8]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="字符串API比较少"><a href="#字符串API比较少" class="headerlink" title="字符串API比较少"></a>字符串API比较少</h3><ul><li>includes(), startsWith(), endsWith()（常用）    </li><li>repeat()         </li><li>padStart()， padEnd()   –作用联想padding     </li><li>模板字符串          </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前整理过 string 和 array 的API，最近发现好多没有总结到的。ES6新出，用的比较少的，在这里补充一下。&lt;br&gt;话不多说，我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="array" scheme="https://jambo0624.github.io/tags/array/"/>
    
      <category term="string" scheme="https://jambo0624.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>const-let-var的区别</title>
    <link href="https://jambo0624.github.io/2019-11-09-const-let-var.html"/>
    <id>https://jambo0624.github.io/2019-11-09-const-let-var.html</id>
    <published>2019-11-09T10:17:35.000Z</published>
    <updated>2020-10-15T09:06:35.524Z</updated>
    
    <content type="html"><![CDATA[<p>let和const作为新的定义变量的方式，解决了var定义变量存在的一些问题。<br>但是前些天同时问我 const 定义的变量可不可更改，我只知道我们通常不会更改，但是其实也不是的。<br>某些情况还是可以更改的，于是我打算对这些情况一探究竟。<br>话不多说，我们开始吧。</p><a id="more"></a><p>首先，var定义变量存在的问题主要是  </p><ol><li>变量声明提升 </li><li>JS没有块级作用域</li><li>循环内变量过度共享，代码如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台输出了3个3</span></span><br></pre></td></tr></table></figure></li></ol><p>下面依次介绍let和const</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>let声明的变量拥有块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'a'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>let声明的全局变量不是全局对象的属性<br>这就意味着，你不可以通过window.变量名的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的外层块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="string">'c'</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">'d'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">//c</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.d) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li><li><p>形如for (let x…)的循环在每次迭代时都为x创建新的绑定<br>正因为let声明的变量不在全局中，而在一个不可见的作用域中。<br>所以，如果for循环执行多次并且循环保持了一个闭包，那么每个闭包将捕捉一个循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台输出1 2 3</span></span><br></pre></td></tr></table></figure></li></ul><p>这种情况适用于现有的三种循环方式：for-of、for-in、以及传统的用分号分隔的类C循环</p><ul><li>用let重定义变量会抛出一个语法错误（SyntaxError）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'b'</span> <span class="comment">// Uncaught SyntaxError:Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>在这些不同之外，let和var几乎很相似了。举个例子，它们都支持使用逗号分隔声明多重变量，它们也都支持解构特性。</strong></p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>一句话说明白，const 就是用来定义常量的！任何非主流的写法都是非法的<br>比如这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只声明变量不赋值</span></span><br><span class="line"><span class="keyword">const</span> a  <span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p>这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复声明变量</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'b'</span> <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><p>还有这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给变量重新赋值</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span></span><br><span class="line">a = <span class="string">'b'</span> <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><p>最后是经常容易忽略的特殊情况,看似黑科技</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不过不推荐这么干，实在没啥意思，常量常量，不变的才叫常量嘛~</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="comment">//重新赋值当然是行不通的了</span></span><br><span class="line">a = &#123;<span class="attr">a</span>:<span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="comment">//嘿嘿嘿科技</span></span><br><span class="line">a.a = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>其实不是黑科技</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="string">'a'</span>&#125;;  <span class="comment">// 绑定的是对象指针</span></span><br><span class="line"><span class="comment">//重新赋值当然是行不通的了</span></span><br><span class="line">a = &#123;<span class="attr">a</span>:<span class="string">'b'</span>&#125;;  <span class="comment">// 绑定新对象的指针</span></span><br><span class="line"><span class="comment">//并不是科技</span></span><br><span class="line">a.a = <span class="string">'b'</span> <span class="comment">// 对象指针没变，指针指向的内容可以随意改变。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;let和const作为新的定义变量的方式，解决了var定义变量存在的一些问题。&lt;br&gt;但是前些天同时问我 const 定义的变量可不可更改，我只知道我们通常不会更改，但是其实也不是的。&lt;br&gt;某些情况还是可以更改的，于是我打算对这些情况一探究竟。&lt;br&gt;话不多说，我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="basic" scheme="https://jambo0624.github.io/tags/basic/"/>
    
  </entry>
  
</feed>
