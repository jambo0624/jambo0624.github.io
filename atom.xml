<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You should know</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jambo0624.github.io/"/>
  <updated>2020-09-26T02:38:56.990Z</updated>
  <id>https://jambo0624.github.io/</id>
  
  <author>
    <name>Jambo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读《程序是怎么跑起来的》</title>
    <link href="https://jambo0624.github.io/2020-07-26-how-program-works.html"/>
    <id>https://jambo0624.github.io/2020-07-26-how-program-works.html</id>
    <published>2020-07-26T07:47:59.000Z</published>
    <updated>2020-09-26T02:38:56.990Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是《程序是怎么跑起来的》读书笔记。<br>在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。<br>下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: </p><a id="more"></a><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>程序是由指令和数据构成的。<br>CPU所负责的就是解释和运行最终转换成机器语言的程序内容。<br>从功能方面来看， CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。<br><strong>寄存器</strong> 可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。<br><strong>控制器</strong> 负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。<br><strong>运算器</strong> 负责运算从内存读入寄存器的数据。<br><strong>时钟</strong> 负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。</p><p>汇编语言 (assembly) 采用助记符 (memonic) 来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符，助记符通常为指令功能的英语单词的简写。<br>通常我们将汇编语言编写的程序转化成机器语言的过程称为 <strong>汇编</strong> ；反之，机器语言程序转化成汇编语言程序的过程则称为 <strong>反汇编</strong> 。  </p><p>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器 (基址，变址，通用) 一般有多个。<br>CPU每执行一个指令，程序计数器的值就会自动加1。也就是说，<strong>程序计数器</strong> 决定着程序的流程。<br><strong>标志寄存器</strong> 实现了对程序的流程控制。<br>函数调用处理是通过把程序计数器的值设定成函数的<strong>存储地址</strong>来实现的。<br>函数调用使用的是call指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call指令会把 <strong>调用函数后要执行的指令地址</strong> 存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行<code>return</code>命令。<code>return</code>命令的功能是把保存在栈中的地址设定到程序计数器中。  </p><p>第一张结束了，通过第一章。我们要知道几个基本的知识:</p><ol><li>程序就是数据和指令</li><li><code>高级编程语言</code>-&gt;<code>汇编语言</code>-&gt;<code>机器语言</code></li></ol><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>因为 IC 的所有引脚，只有直流电压 0V 或 5V 两个状态。所以，决定了计算机的信息数据只能用二进制数来处理。<br>计算机处理信息的最小单位——位，就相当于二进制中的一位。位的英文 <code>bit</code> 是二进制数位<code>(binary digit)</code>的缩写。<br>8位二进制数被称为一个 <strong>字节</strong> 。字节是最基本的信息计量单位。位是最小单位，字节是基本单位。   </p><p>二进制数的值转换成十进制数的值，只需将二进制数的各数位的值和 <strong>位权</strong> 相乘，然后将相乘的结果相加即可。<br><strong>移位运算</strong> 指的是将二进制数值的各数位进行左右移位 (shift=移位) 的运算。移位有左移 &lt;&lt; (向高位方向) 和右移 &gt;&gt; (向低位方向) 两种。      </p><p>为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加1。<strong>将二进制数的值取反后加1的结果，和原来的值相加，结果为 0</strong><br>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为<strong>逻辑右移</strong>。<br>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值 (0或1) 。这就称为<strong>算术右移</strong>。如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2、1/4、1/8等的数值运算。如果是正数，只需在最高位补0即可。<br>只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式 (逻辑左移) 还是相乘运算 (算术左移) ，都只需在空出来的低位补 0 即可。   </p><p><strong>符号扩充</strong>就是指在保持值不变的前提下将其转换成16位和32位的二进制数。也就是说，不管是正数还是用补数表示的负数，都只需用符号位的值 (0或者1) 填充高位即可。     </p><p>计算机能处理的运算，大体可分为<strong>算术运算</strong>和<strong>逻辑运算</strong>。算术运算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算，包括逻辑非（NOT运算）、逻辑与（AND运算）、逻辑或（OR运算）和逻辑异或（XOR运算）四种。  </p><h3 id="计算机中进行小数计算时出错的原因"><a href="#计算机中进行小数计算时出错的原因" class="headerlink" title="计算机中进行小数计算时出错的原因"></a>计算机中进行小数计算时出错的原因</h3><p>经典面试题目: 0.1 + 0.2 = ?<br>是因为 <strong>“有一些十进制数的小数无法转换成二进制数”</strong>    </p><p><strong>双精度浮点数</strong> 类型用64位、<strong>单精度浮点数</strong> 类型用32位来表示全体小数<br><strong>浮点数</strong> 是指用符号、尾数、基数和指数这四部分来表示的小数<br>64: 1位符号，11位指数，52位尾数<br>32: 1位符号，8位指数，23位尾数</p><p>如何避免计算机计算出错  </p><blockquote><p>首先是回避策略，即无视这些错误。根据程序目的的不同，有时一些微小的偏差并不会造成什么问题。<br>把小数转换成整数来计算。计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题。</p></blockquote><p>在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD方法，以确保最终得到准确的数值。BCD (Binary Coded Decimal) 是一种使用二进制表示十进制的方法。  </p><p>在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。因此，在实际程序中，也经常会用十六进制数来代替二进制数。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><strong>内存</strong> 实际上是一种名为内存IC的电子元件。内存IC中有<code>电源</code>、<code>地址信号</code>、<code>数据信号</code>、<code>控制信号</code>等用于输入输出的大量引脚（IC的引脚），通过为其指定地址（address），来进行数据的读写。  </p><p>编程语言中的<strong>数据类型</strong>表示存储的是何种类型的数据。<br>从内存来看，就是占用的内存大小的意思。<br>即使是物理上以1个字节为单位来逐一读写数据的内存，在程序中，通过指定其类型（变量的数据类型等），也能实现以特定字节数为单位来进行读写。      </p><p><strong>指针</strong>也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写。   </p><p>数组是高效实用内存的基础。<br><strong>数组</strong>是指多个同样数据类型的数据在内存中连续排列的形式。<br>作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引<code>(index)</code>。<br>指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由<strong>编译器</strong>自动实现的。<br>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。  </p><p><strong>栈</strong>用的是<code>LIFO</code>（Last Input First Out，后入先出）方式，而队列用的则是<code>FIFO</code>（First Input First Out，先入先出）方式。<br><strong>队列</strong>一般是以<code>环状缓冲区</code>（ring buffer）的方式来实现的  </p><p>在数组的各个元素中，除了数据的值之外，通过为其附带上下一个元素的索引，即可实现<strong>链表</strong>。使用<strong>链表</strong>来追加或删除数据则毫不费事。   </p><h3 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h3><blockquote><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。即使CPU可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低。总之，存储在磁盘中的程序需要读入到内存后才能运行。</p></blockquote><p>磁盘缓存 (disk cache) 指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。使用磁盘缓存可以大大改善磁盘数据的访问速度<br>虚拟内存 (virtual memory) 是指把磁盘的一部分作为假想的内存来使用。<br>虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的。也就是说，为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。    </p><p>节约内存的编程方法<br>(1) 通过DLL文件实现函数共有<br>DLL（Dynamic Link Library）文件，顾名思义，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。此外，还有一个需要大家注意的地方，那就是多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。<br>Windows的操作系统本身也是多个DLL文件的集合体。有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。<br>(2) 通过调用_stdcall来减小程序文件的大小<br><strong>栈清理处理</strong>是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。<br>该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。<br>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。这时所使用的就是_stdcall。<br>在函数前加上_stdcall，就可以把栈清理处理变为在被调用函数一方进行。</p><p>磁盘的物理结构<br>扇区是对磁盘进行物理读写的最小单位。<br>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用1簇的空间。这样一来，所有的文件都会占用1簇的整数倍的磁盘空间。<br>以簇为单位进行读写时，1簇中没有填满的区域会保持不被使用的状态。虽然这看起来是有点浪费，不过该机制就是如此规定的，所以我们也没有什么好办法。另外，如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。由于在磁盘表面上，表示扇区区分的领域是必要的，因此，如果簇的容量过小，磁盘的整体容量也会减少。扇区和簇的大小，是由处理速度和存储容量的平衡来决定的。   </p><h3 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h3><p>RLE算法: 把文件内容用<code>数据×重复次数</code>的形式来表示的压缩方法称为RLE (Run Length Encoding，行程长度编码) 算法。<br>在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE算法可以发挥不错的效果，但它并不适合文本文件的压缩。   </p><p><strong>莫尔斯编码</strong>是根据日常文本中各字符的出现频率来决定表示各字符的编码的数据长度的。<br>使用<strong>哈夫曼树</strong>后，出现频率越高的数据所占用的数据位数就越少，而且数据的区分也可以很清晰地实现。   </p><h3 id="程序是在何种环境中运行的"><a href="#程序是在何种环境中运行的" class="headerlink" title="程序是在何种环境中运行的"></a>程序是在何种环境中运行的</h3><p>应用的运行环境，是指<code>操作系统</code>和<code>计算机本身(硬件)</code>的种类   </p><p>机器语言的程序称为<strong>本地代码</strong> (native code)<br>程序员用C语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为<strong>源代码</strong>。    </p><p>应用程序向操作系统传递指令的途径称为API (ApplicationProgramming Interface)<br>BIOS (BasicInput/Output System)。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。<br><strong>引导程序</strong>是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。   </p><h3 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h3><p>源代码完成后，就可以编译生成可执行文件了。负责实现该功能的是编译器。<br><code>Dump</code> 是指把文件的内容，每个字节用2位十六进制数来表示的方式。</p><p>能够把C语言等高级编程语言编写的源代码转换成本地代码的程序称为<strong>编译器</strong>。<br>但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p><p>编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理。<br>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行连接的程序就称为<strong>链接器</strong>（linkage editor或连结器）  </p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ilink32 -Tpe -c -x -aa c0w32.obj Sample1.obj, Sample1.exe, ,</span><br><span class="line">import32.lib cw32.lib</span><br></pre></td></tr></table></figure><p>c0w32.obj这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的<strong>启动</strong>。<br>因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来。     </p><p>像import32.lib及cw32.lib这样的文件称为库文件。<br><strong>库文件</strong>指的是把多个目标文件集成保存到一个文件中的形式。<br><strong>链接器</strong>指定<strong>库文件</strong>后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件。    </p><p><code>sprintf()</code>等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为<code>标准函数</code>。<br>之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这一过程。   </p><p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL（Dynamic Link Library）文件的特殊库文件中。<br>就如Dynamic这一名称所表示的那样，DLL文件是程序运行时动态结合的文件。  </p><p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为<strong>静态链接库</strong>。<br>静态（static=静态的）同动态（dynamic=动态的）是相反的意思。存储着<code>sprintf()</code>的目标文件的cw32lib就是静态链接库。<br><code>sprintf()</code>提供了通过指定格式把数值转换成字符串的功能。   </p><p>那就是EXE文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在EXE文件的开头，追加转换内存地址所需的必要信息。这个信息称为<strong>再配置信息</strong>。<br>EXE文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离。   </p><p>EXE文件的内容分为再配置信息、变量组和函数组<br>当程序加载到内存后，除此之外还会额外生成两个组，那就是栈和堆。<br><strong>栈</strong>是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域。<br><strong>堆</strong>是用来存储程序运行时的任意数据及对象的内存领域<br>EXE文件中并不存在栈及堆的组。栈和堆需要的内存空间是在EXE文件加载到内存后开始运行时得到分配的。<br>因而，内存中的程序，就是由<code>用于变量的内存空间</code>、<code>用于函数的内存空间</code>、<code>用于栈的内存空间</code>、<code>用于堆的内存空间</code>这4部分构成的。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。不过，在内存的使用方法上，二者存在些许不同。栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。与此相对，堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。</p><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。<br><strong>栈</strong>中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。<br>与此相对，<strong>堆</strong>的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。<br>如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为<strong>内存泄露</strong>（memory leak）   </p><blockquote><p>Q：编译器和解释器有什么不同？<br>A：<strong>编译器</strong>是在运行前对所有源代码进行解释处理的。而<strong>解释器</strong>则是在运行时对源代码的内容一行一行地进行解释处理的。<br>Q：“分割编译”指的是什么？<br>A：将整个程序分为多个源代码来编写，然后分别进行编译，最后链接成一个EXE文件。这样每个源代码都相对变短，便于程序管理。<br>Q：“Build”指的是什么？<br>A：根据开发工具种类的不同，有的编译器可以通过选择“Build”菜单来生成EXE文件。这种情况下，<strong><code>Build</code>指的是连续执行编译和链接</strong>。<br>Q：使用DLL文件的好处是什么？<br>A: DLL文件中的函数可以被多个程序共用。因此，借助该功能可以节约内存和磁盘。此外，在对函数的内容进行修正时，还不需要重新链接（静态链接）使用这个函数的程序。<br>Q：不链接导入库的话就无法调用DLL文件中的函数吗？<br>A：通过使用LoadLibrary()及GetProcAddress()这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。不过使用导入库更简单一些。<br>Q：“叠加链接”这个术语指的是什么？<br>A：将不会同时执行的函数，交替加载到同一个地址中运行。通过使用“叠加链接器”这一特殊的链接器即可实现。在计算机中配置的内存容量不多的MS-DOS时代，经常使用叠加链接。</p></blockquote><p>IDE: Integrated Development Environment，即继承了变成所需的各种工具的开发软件。<br>CPU: Central Processing Unit (中央处理器)<br>IC: Integrated Circuit (集成电路)<br>DLL: Dynamic Link Library</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是《程序是怎么跑起来的》读书笔记。&lt;br&gt;在学习的过程中，会发现: 知道整个程序运行的过程，尤其是流程图和内存图是很重要的，所以找此书来读。&lt;br&gt;下面的文章，会以章节为顺序对一些内容进行摘录，并有一些自己语言的总结。同时，会在文章末尾记录一些名词的扎英文对照。下面开始: &lt;/p&gt;
    
    </summary>
    
    
      <category term="program" scheme="https://jambo0624.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://jambo0624.github.io/tags/program/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>CodeStandard</title>
    <link href="https://jambo0624.github.io/2020-07-19-code-standard.html"/>
    <id>https://jambo0624.github.io/2020-07-19-code-standard.html</id>
    <published>2020-07-19T03:16:16.000Z</published>
    <updated>2020-08-12T14:31:54.468Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：</p><ul><li>谨记代码是给人看的，它们只是恰巧能跑而已<a id="more"></a></li></ul><h4 id="能愿动词说明"><a href="#能愿动词说明" class="headerlink" title="能愿动词说明"></a>能愿动词说明</h4><p> 本文统一采用以下几个能愿动词作为规范的约束强度。</p><ul><li><code>必须（Must）</code>：只能这样做，请无条件遵守</li><li><code>绝不（Must Not）</code>：严令禁止，在任何情况下都不能这么做</li><li><code>应该（Should）</code>：强烈建议这样做，但是并不强求</li><li><code>不应该（Should Not）</code>：强烈建议不这样做，但是并不强求</li><li><code>可以（May）</code>：你可以按照自己的喜好去做</li></ul><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><p>下面几个词组指代四种命名风格。</p><ul><li><code>camelCase</code>：小驼峰</li><li><code>PascalCase</code>：大驼峰</li><li><code>kebab-case</code>：小写 + 中划线</li><li><code>kebab_ase</code>：小写 + 下划线</li></ul><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h3 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h3><h4 id="lang属性"><a href="#lang属性" class="headerlink" title="lang属性"></a>lang属性</h4><p>html 标签 <strong>必须</strong> 设置 lang 属性，此属性值 <strong>应该</strong> 与目标用户的第一语言保持一致。<br>当使用i18n等工具进行页面语言的切换时，此属性值也 <strong>应该</strong> 一并切换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh_CN"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="img-标签的-alt-属性"><a href="#img-标签的-alt-属性" class="headerlink" title="img 标签的 alt 属性"></a>img 标签的 alt 属性</h4><p>每一个 img 标签都 <strong>应该</strong> 有一个 alt 属性， 且它的内容 <strong>应该</strong> 尽可能详尽地描述这张图片的作用。<br>它除了能提供信息以及更好的 seo 之外，还能帮助视障人士。</p><h4 id="中文和西文之间的空格"><a href="#中文和西文之间的空格" class="headerlink" title="中文和西文之间的空格"></a>中文和西文之间的空格</h4><p>页面上的中文和西文（数字）之间 <strong>必须</strong> 有一个空格。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia是混成词，分别取自于网站核心技术Wiki以及英文中百科全书之意的encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wikipedia 是混成词，分别取自于网站核心技术 Wiki 以及英文中百科全书之意的 encyclopedia。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>皇后乐队是英国摇滚乐乐队，成立于 1970 年。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><h4 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h4><p><strong>必须</strong> 在所有样式文件前引入 <a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a> 用于消除各个浏览器之间的差异。<br>对于不同的项目，<strong>应该</strong> 根据需求设立 reset 样式集，并在 Normalize.css 之后引入。 Reset 样式集应该秉承最小化原则。</p><h4 id="简化版的CSS-BEM"><a href="#简化版的CSS-BEM" class="headerlink" title="简化版的CSS BEM"></a>简化版的CSS BEM</h4><p><a href="http://getbem.com/introduction/" target="_blank" rel="noopener">CSS BEM</a>是一种可以有效降低样式冲突概率的 css 选择器方法，但这种风格的代码对绝大部分项目来说是 too heavy 的。<br>这里提出一种简化的方案，只有”层级”和”断字”的概念。使用中划线 <code>-</code> 表示层级，使用下划线 <code>_</code> 表示断字。项目 <strong>必须</strong> 严格遵守该规范。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-img"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo-text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-login"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-navbar-item header-navbar-sign_up"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>如果项目要使用 Css 预处理器， <strong>应该</strong>优先使用 Sass，且 <strong>必须</strong> 使用 Scss 语法。使用 Scss 语法对上方的 html 代码进行选择会变得非常简单易行。<br>每一个 Scss 选择器后面 <strong>必须</strong> 有一个空行。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  &amp;-logo &#123;</span><br><span class="line">    &amp;-<span class="selector-tag">img</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    &amp;-text &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &amp;-navbar &#123;</span><br><span class="line">    &amp;-item &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &amp;-login &#123;&#125;</span><br><span class="line">    &amp;-sign_up &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择器命名"><a href="#选择器命名" class="headerlink" title="选择器命名"></a>选择器命名</h4><p>选择器命名的第一要务是见名知意。</p><ul><li>对于一些常见的、约定俗成的单词简写，<strong>可以</strong> 使用简写形式。如：<code>description</code>-&gt;<code>desc</code></li><li><strong>绝不</strong> 使用简写后有多种释义，或是简写后无法辨别含义的单词简写。如：<code>description</code>-&gt;<code>des</code>,<code>fc</code></li><li>嵌套层级 <strong>不应该</strong> 过深，当出现三到四层嵌套后，可以使用全新的选择器名称。如：<code>.page-header-logo{ .title ...}</code></li></ul><h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>所有项目都 <strong>应该</strong> 使用 Babel 进行转义，而源码都 <strong>应该</strong> 拥抱已经发布的 ECMAScript 特性。</p><h4 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h4><p>所有项目都 <strong>应该</strong> 使用 ESLint 进行代码格式检查。</p><h4 id="const-let-和-var"><a href="#const-let-和-var" class="headerlink" title="const, let 和 var"></a>const, let 和 var</h4><p><code>const</code> <strong>必须</strong> 是第一公民，次之是 <code>let</code>。被 Babel (或其他转义工具)转义的项目中 <strong>绝不</strong> 出现 <code>var</code>。</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>变量命名的第一要务是见名知意。</p><ul><li>布尔型的变量 <strong>应该</strong> 以 <code>is</code> 或 <code>flag</code> 开头。如：<code>isVisible</code></li><li>数值类型的变量 <strong>必须</strong> 采用复数形式的名词。如：<code>users</code>,<code>categories</code></li><li>对于单复同行的数值型变量，<strong>应该</strong> 添加其他的单词进行辅助释义。如：<code>newsList</code></li><li>对象类型的变量 <strong>必须</strong> 采用单数形式的名词。如:<code>user</code></li><li>函数 (方法) 命名 <strong>必须</strong> 是以动词开头的 camelCase 风格。如: <code>createUser</code>, <code>validateForm</code></li><li>对于项目中约定的常量 (如配置项等)，<strong>应该</strong> 使用 PASCAL_CASE 风格。如: <code>HEADER_MENU</code>, <code>PRIMARY_COLOR</code></li><li>类( Class )的名称 <strong>必须</strong> 采用 PascalCase 形式，且 <strong>应该</strong> 拟人化。如: <code>Permission</code>, <code>FormValidator</code></li><li>任何变量的命名都 <strong>不应该</strong> 过于生僻和抽象</li></ul><h4 id="一些推荐使用的函数首部动词"><a href="#一些推荐使用的函数首部动词" class="headerlink" title="一些推荐使用的函数首部动词"></a>一些推荐使用的函数首部动词</h4><ul><li><code>do</code>/<code>deal</code>：做某些事情</li><li><code>go</code>：跳转、前往</li><li><code>get</code>/<code>fetch</code>：获取某些事物</li><li><code>set</code>：设置某些事物</li><li><code>make</code>/<code>create</code>：创建</li><li><code>edit</code>/<code>update</code>：编辑</li><li><code>delete</code>/<code>destory</code>：删除</li><li><code>handle</code>：被其他操作触发了</li></ul><h4 id="Restful-Actions"><a href="#Restful-Actions" class="headerlink" title="Restful Actions"></a>Restful Actions</h4><p>对于项目中的接口，<strong>应该</strong> 将 ajax 请求拆分为请求函数以实现复用以及提高项目的可维护性。<br>如果接口使用 Restful API，那么前端对应的方法名 <strong>可以</strong> 按照下面的规范来进行命名。</p><ul><li><code>get</code> <code>/books</code>=&gt;<code>reqFetchBooks</code></li><li><code>get</code> <code>/books/:id</code>=&gt;<code>reqShowBooks</code></li><li><code>post</code> <code>/books</code>=&gt;<code>reqCreateBooks</code></li><li><code>post,put,patch</code> <code>/books/:id</code>=&gt;<code>reqUpdateBooks</code></li><li><code>delete</code> <code>/books/:id</code>=&gt;<code>reqDestoryBooks</code></li></ul><h4 id="数组的循环"><a href="#数组的循环" class="headerlink" title="数组的循环"></a>数组的循环</h4><p>在使用循环时， <strong>不应该</strong> 使用<code>item</code>作为数组的元素名，而 <strong>应该</strong> 使用数组的单数形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">books.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; &#125;);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">books.map(<span class="function"><span class="params">book</span> =&gt;</span> &#123; &#125;);</span><br><span class="line">newsList.map(<span class="function"><span class="params">news</span> =&gt;</span> &#123; &#125;)</span><br></pre></td></tr></table></figure><h4 id="if的处理"><a href="#if的处理" class="headerlink" title="if的处理"></a>if的处理</h4><p>每一个<code>if</code>都 <strong>必须</strong> 囊括所有情况，也就是说每一种逻辑都可以被 if 处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123; &#125; <span class="keyword">else</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>部分<code>if else</code>逻辑 <strong>可以</strong> 通过及时 <code>return</code> 减少嵌套层数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// correct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (a !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br></pre></td></tr></table></figure><p>过多的<code>!a || b</code> <strong>应该</strong> 被转换为<code>!(a &amp;&amp; b)</code>，这种逻辑更符合直觉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not bad</span></span><br><span class="line"><span class="keyword">if</span> (!a || !b) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> (!(a &amp;&amp; b)) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>注释本身 <strong>不应该</strong> 对变量或方法本身是做什么的进行解释。这要求变量命名尽可能得见名知意。</li></ul><h3 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h3><p><strong>NOTICE HERE</strong>： Vue 的相关规范全部基于官方的<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">风格指南</a>， 并在此基础上进行了一些修改和约束。</p><h4 id="组件文件命名"><a href="#组件文件命名" class="headerlink" title="组件文件命名"></a>组件文件命名</h4><ul><li>页面、路由相关的组件 <strong>应该</strong> 使用一个单词命名</li><li>非页面、路由相关的组件 <strong>应该</strong> 使用<code>PascalCase</code>风格命名</li><li>组件 <strong>应该</strong> 拟人化。如：<code>UserCreator</code>,<code>Selector</code></li></ul><h4 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h4><p>如果文件夹内拥有<code>index.vue</code>，那么引入时 <strong>应该</strong> 省略 index 字样， 并在末尾添加 <code>/</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./folder-name/'</span></span><br></pre></td></tr></table></figure><p>引入组件时，模块名 <strong>必须</strong> 为 <code>PascalCase</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="根标签书写规范"><a href="#根标签书写规范" class="headerlink" title="根标签书写规范"></a>根标签书写规范</h4><p>vue 文件中的标签书写顺序 <strong>必须</strong> 为：</p><ol><li><code>&lt;template&gt;&lt;/template&gt;</code></li><li><code>&lt;script&gt;&lt;/script&gt;</code></li><li><code>&lt;style&gt;&lt;/style&gt;</code></li></ol><h3 id="lt-template-gt-lt-template-gt-根标签"><a href="#lt-template-gt-lt-template-gt-根标签" class="headerlink" title="&lt;template&gt;&lt;/template&gt;根标签"></a><code>&lt;template&gt;&lt;/template&gt;</code>根标签</h3><p>每一个根标签下的顶级元素都 <strong>必须</strong> 有一个与当前文件名对应的 css 选择器。在本规范中， <strong>应该</strong> 使用<code>文件名</code>的<code>kebab_case</code>结构作为该 css 选择器。如：<code>SelectorGender</code>-&gt;<code>selector_gender</code><br>如果为了进一步降低组件间的样式冲突的可能性， <strong>可以</strong> 使用 <code>文件夹层级</code> + <code>文件名</code> 共同组装成根组件的根选择器。假定有以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- common &lt;dir&gt;</span><br><span class="line">|  |-- selectors &lt;dir&gt;</span><br><span class="line">|  |  |-- SelectorGender &lt;file&gt;</span><br></pre></td></tr></table></figure><p>那么其对应的唯一 css 选择器名应该为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;common-selectors-selector_gender&quot;&gt;</span><br><span class="line">     &lt;!--    --&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-script-gt-lt-script-gt-根标签"><a href="#lt-script-gt-lt-script-gt-根标签" class="headerlink" title="&lt;script&gt;&lt;/script&gt;根标签"></a><code>&lt;script&gt;&lt;/script&gt;</code>根标签</h3><p>实例选项顺序<br>组件实例中的选项顺序 <strong>必须</strong> 按照 vue 风格指南的要求进行排版</p><ol><li><code>el</code></li><li><code>name</code></li><li><code>parent</code></li><li><code>functional</code></li><li><code>delemiters</code></li><li><code>comments</code></li><li><code>components</code></li><li><code>directives</code></li><li><code>filters</code></li><li><code>extends</code></li><li><code>mixins</code></li><li><code>inheritAttrs</code></li><li><code>model</code></li><li><code>props/prosData</code></li><li><code>data</code></li><li><code>computed</code></li><li><code>watch</code></li><li><code>beforeCreated</code></li><li><code>created</code></li><li><code>beforeMounted</code></li><li><code>mounted</code></li><li><code>beforeUpdate</code></li><li><code>updated</code></li><li><code>activated</code></li><li><code>deactivated</code></li><li><code>beforeDestory</code></li><li><code>destoryed</code></li><li><code>methods</code></li><li><code>template/render</code></li><li><code>renderError</code></li></ol><h4 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h4><p>各个选项间 <strong>必须</strong> 间隔一个空行，而内部的值或方法不空行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Demo'</span>,</span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tableData: <span class="string">''</span>,</span><br><span class="line">      userInfo: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    getTableData () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getUserInfo () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：name"><a href="#实例选项：name" class="headerlink" title="实例选项：name"></a>实例选项：<code>name</code></h4><p>每一个组件 <strong>必须</strong> 有一个 <code>name</code> 实例选项，其值 <strong>必须</strong> 为被其他组件引入时的模块名。如果你的组件命名完全符合本规范，那么一般情况下，此属性的值应与组件的文件名保持一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file name: MyComponent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// worst</span></span><br><span class="line">  <span class="comment">// no name</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'my-component'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  name: <span class="string">'myComponent'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  name: <span class="string">'MyComponent'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * use this component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'../common/MyComponent'</span></span><br></pre></td></tr></table></figure><h4 id="实例选项：props"><a href="#实例选项：props" class="headerlink" title="实例选项：props"></a>实例选项：<code>props</code></h4><p>组件需要的参数，都 <strong>应该</strong> 拥有完善的验证规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    demo:&#123;</span><br><span class="line">      type: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="params">val</span> =&gt;</span> [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'first'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="string">'second'</span>].includes(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例选项：data"><a href="#实例选项：data" class="headerlink" title="实例选项：data"></a>实例选项：<code>data</code></h4><ul><li><strong>不应该</strong> 使用 <code>Vue.set()</code> 方式为组件扩展响应式的 data</li><li><strong>应该</strong> 将一些同属于某一块页面元素的 data 合并为对象的形式，避免 data 的扁平化</li><li>每一个 data 都 <strong>必须</strong> 是被使用到的</li></ul><h4 id="实例选项-生命周期函数"><a href="#实例选项-生命周期函数" class="headerlink" title="实例选项: 生命周期函数"></a>实例选项: 生命周期函数</h4><p>生命周期函数内 <strong>不应该</strong> 直接书写过多的业务逻辑。如果逻辑过多，<strong>应该</strong> 在 methods 中定义独立的函数并在生命周期函数中进行调用。</p><h3 id="lt-style-gt-lt-style-gt-根标签"><a href="#lt-style-gt-lt-style-gt-根标签" class="headerlink" title="&lt;style&gt;&lt;/style&gt;根标签"></a><code>&lt;style&gt;&lt;/style&gt;</code>根标签</h3><ul><li><strong>必须</strong> 添加 scoped 属性</li><li><strong>必须</strong> 使用 sass 预处理器，并且使用 scss 语法</li><li>所有的组件内样式 <strong>必须</strong> 被该组件的唯一 css 选择器包裹<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"selector_gender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.selector_gender</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* ... */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="关于命名的（最佳）实践"><a href="#关于命名的（最佳）实践" class="headerlink" title="关于命名的（最佳）实践"></a>关于命名的（最佳）实践</h3><ul><li>在 Dom 上绑定的事件回调方法 <strong>应该</strong> 使用<code>on</code>+<code>动词</code>+<code>名词</code>形式。如：<code>@click=&quot;onCreateUser&quot;</code></li><li>子组件 emit 的事件名称 <strong>应该</strong> 使用 <code>动词的一般现在时</code>。如：<code>@click</code>,<code>@submit</code></li><li>子组件 emit 的事件回调方法 <strong>应该</strong> 使用<code>handle</code>+<code>名词</code>+<code>动词过去式</code>形式。如：<code>@submit=&quot;handleUserCreated&quot;</code></li><li><strong>应该</strong> 正确使用<code>or</code>和<code>and</code>。详见下方示例<br>一个完整的例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"users"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onCreateUser"</span>&gt;</span>Create User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span>...<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"onEditUser(scope.row)"</span>&gt;</span>Edit User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">:loading</span>=<span class="string">"isDeletingUser"</span> @<span class="attr">click</span>=<span class="string">"onDeleteUser(scope.row)"</span>&gt;</span>Delete User<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">user-creator-and-editor</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ref</span>=<span class="string">"userCreatorAndEditor"</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">submit</span>=<span class="string">"handleUserCreatedOrEdited"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user-creator-and-editor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> UserCreatorAndEditor <span class="keyword">from</span> <span class="string">'./UserCreatorAndEditor'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; reqDestoryUser &#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'Users'</span>,</span></span><br><span class="line"></span><br><span class="line">    components: &#123; UserCreatorAndEditor &#125;,</span><br><span class="line"></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        isDeletingUser: <span class="literal">false</span>,</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">      onCreateUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'create'</span> &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      onEditUser() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.userCreatorAndEditor.open(&#123; type: <span class="string">'edit'</span>, userId: id &#125;);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      handleUserCreatedOrEdited(result) &#123;</span><br><span class="line">        if(result) &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line">        &#125;     </span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="keyword">async</span> onDeleteUser(&#123; id &#125;) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">await</span> reqDestoryUser(id);</span></span><br><span class="line"><span class="actionscript">           <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">finally</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.isDeletingUser = <span class="literal">false</span></span></span><br><span class="line">        &#125;   </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>每个方法和变量都见名知意，并且永不重复！</li></ul><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><p><strong>不应该</strong> 使用路由大量传递参数,请尽可能地保证<code>clean and beautiful</code>。</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p><strong>应该</strong> 使用<code>module</code>组织 vuex，而非全部注册在顶级。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>绝不</strong> 给 Vue 挂载大体量的插件或扩展， <strong>应该</strong> 在需要用到的页面进行按需引入</li><li><strong>不应该</strong> 直接选取某个 dom 元素进行直接的 dom 操作( Echarts 等插件除外)</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>项目的技术文档 <strong>必须</strong> 使用 Markdown 格式编写。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><ul><li>英文文档 <strong>必须</strong> 使用半角标点符号</li><li>中文文档中以下标点符号 <strong>必须</strong> 使用半角，并在其后添加一个空格<ul><li>引号: <code>&quot;&quot;</code></li><li>冒号: <code>:</code></li><li>感叹号: <code>!</code></li><li>问号: <code>?</code></li><li>所有的括号: <code>() [] {}</code></li></ul></li><li>中文文档中以下标点符号 <strong>必须</strong> 使用全角，其后不需要添加空格<ul><li>逗号: <code>，</code></li><li>句号: <code>。</code></li><li>省略号: <code>……</code></li></ul></li></ul><h3 id="Markdown-语法约束"><a href="#Markdown-语法约束" class="headerlink" title="Markdown 语法约束"></a>Markdown 语法约束</h3><ul><li><strong>必须</strong> 有且仅有一个一级标题</li><li>标题的层级最多 <strong>不应该</strong> 超过三级</li><li>句子的末尾 <strong>必须</strong> 有句号</li><li>无序列表和有序列表的末尾 <strong>不应该</strong> 添加句号</li><li><strong>应该</strong> 优先选用无需列表而非有序列表</li><li>用于表明格式的关键字符 <strong>必须</strong> 前后各留一个空格</li><li>标题与段落之间 <strong>必须</strong> 前后各留一个空行</li></ul><h3 id="的，得，地"><a href="#的，得，地" class="headerlink" title="的，得，地"></a>的，得，地</h3><p><strong>必须</strong> 正确使用<code>的</code>，<code>得</code>，<code>地</code>。</p><h3 id="项目版本"><a href="#项目版本" class="headerlink" title="项目版本"></a>项目版本</h3><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>项目开发过程中的版本迭代 <strong>应该</strong> 遵循类似 npm 的版本定义方法。即:</p><ul><li><code>1.1.1</code> -&gt; <code>1.1.2</code>: 向下兼容的问题修复</li><li><code>1.1.1</code> -&gt; <code>1.2.1</code>: 向下兼容的功能迭代</li><li><code>1.1.1</code> -&gt; <code>2.1.1</code>: 发生了非向下兼容的功能迭代</li></ul><h4 id="版本迭代及分支管理"><a href="#版本迭代及分支管理" class="headerlink" title="版本迭代及分支管理"></a>版本迭代及分支管理</h4><ul><li><code>master</code>分支 <strong>必须</strong> 对应线上代码</li><li>对于开发告一段落，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><ul><li>安装依赖时 <strong>必须</strong> 按照功能严格区分生产环境依赖和开发环境依赖</li><li><strong>绝不</strong> 遗留未被使用的依赖。如果不使用某个依赖时， <strong>必须</strong> 第一时间进行卸载</li><li><strong>绝不</strong> 在未获得其他开发人员同意的情况下升级依赖版本</li><li><strong>应该</strong> 优先使用使用量大、受众面广的依赖</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="使用If"><a href="#使用If" class="headerlink" title="使用If"></a>使用If</h4><p>Windows 下的 Git 默认使用<code>crlf</code>作为换行符，甚至会将<code>lf</code>转换为<code>crlf</code>。本规范要求所有的换行都 <strong>必须</strong> 使用<code>lf</code>风格。</p><p>Q: 安装 Git 时，忘记去勾了 crlf 自动替换的选项，怎么办？<br>A: 执行以下命令:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.eol lf</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><ul><li>开发分支 <strong>必须</strong> 是<code>develop</code></li><li>功能分支 <strong>必须</strong> 以<code>feature/</code>开头。如: <code>feature/user_system</code></li><li>开发完毕，但仍需维护的版本， <strong>必须</strong> 检出一条以<code>stable/</code>开头的分支进行维护。如：<code>stable/v1</code></li></ul><h4 id="Merge-Request-Pull-Request"><a href="#Merge-Request-Pull-Request" class="headerlink" title="Merge Request(Pull Request)"></a>Merge Request(Pull Request)</h4><p>每一次分支合并都 <strong>必须</strong> 发起一个<code>Merge Request</code>，并且交由他人评审。</p><h3 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h3><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><ul><li><code>src</code><ul><li><code>api</code>: 存放 API 资源</li><li><code>assets</code>: 存放需要被 Webpack 处理的静态资源</li><li><code>components</code>: 存放于项目无关的公共组件。理论上这些组件可以被任何项目直接使用</li><li><code>config</code>: 存放一些项目配置文件</li><li><code>models</code>: 存放前端的数据模型。如果项目使用了 Typescript， 理论上不需要设置改目录</li><li><code>router</code>: Vue 路由</li><li><code>store</code>: Vuex。 <strong>应该</strong> 只包含<code>modules</code>和<code>index.js</code>，保证 vuex 所有功能都尽可能按照模块划分<ul><li><code>modules</code>: Vuex 的模块</li><li><code>index.js</code></li></ul></li><li><code>styles</code>: 存放全局样式。样式文件 <strong>必须</strong> 使用 Scss 进行组织; 作为子文件的样式文件 <strong>必须</strong> 使用 <code>_</code>开头<ul><li><code>_common.scss</code>: 公共样式文件</li><li><code>_hack.scss</code>: 对各种组件库或其他样式进行加强修改。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>_mixins.scss</code>: 提供全局的 Scss Mixins</li><li><code>_reset.scss</code>: 对页面样式进行重置。理论上这个样式文件的内容 <strong>应该</strong> 尽可能地少</li><li><code>main.scss</code>: 按照一定的顺序注册全部样式文件。被<code>main.js</code>引入</li><li><code>resource.scss</code>: 被<code>scss-loader</code>处理，注册全局可用的 Scss 资源</li></ul></li><li><code>utils</code>: 各种工具<ul><li><code>http.js</code>: 请求层。<strong>必须</strong> 优先使用<code>axios</code></li></ul></li><li><code>views</code>: 视图层</li><li><code>App.vue</code></li><li><code>main.js</code>: 文件内容 <strong>必须</strong> 尽可能短小且清晰</li></ul></li><li><code>.editorconfig</code></li><li><code>.prettierignore</code></li><li><code>.prettierrc.js</code></li><li><code>.prettierrc.js</code></li><li><code>CHANGELOG.md</code>: 项目更新日志。在每一次上线前都 <strong>必须</strong> 进行补全</li><li><code>README.md</code>: 用来说明项目，以及帮助其他人快速上手项目</li></ul><h4 id="main-scss-组织"><a href="#main-scss-组织" class="headerlink" title="main.scss 组织"></a>main.scss 组织</h4><p>由于样式存在后者覆盖前者的问题，因此 main.scss <strong>必须</strong> 按照一定的顺序进行组织。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络资源 (network resources)</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">"https://fonts.googleapis.com/css?family=Nunito"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地资源 (local resources)。如: 变量，mixin，图标</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"iconfont"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式重置 (reset)。推荐优先使用 normalize.css，自己书写的 reset 文件的内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~normalize.css/normalize.css"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"reset"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方库 (libraries)</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~element-ui/packages/theme-chalk/src/index"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~swiper/css/swiper"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共样式 (common)。如果有需要的话，给公共样式加入一个前缀以作区分，如 ` g-container `</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"common"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图 (views)。对于一个 vue 项目，可能不需要引入视图内的样式</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/layout/home"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/widgets/header"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"views/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强行重置某些样式 (hack)。内容应当尽可能少</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"hack"</span>;</span><br></pre></td></tr></table></figure><h4 id="Scss全局资源"><a href="#Scss全局资源" class="headerlink" title="Scss全局资源"></a>Scss全局资源</h4><blockquote><p>参考官方文档: <a href="https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/css.html#向预处理器-loader-传递选项</a></p></blockquote><p>在<code>src/styles/</code>目录下创建<code>resources.scss</code>文件，用于存放全局可以使用的样式资源，如变量，mixin 等。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"variables"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins"</span>;</span><br></pre></td></tr></table></figure><p>在<code>vue.config.js</code>中进行了配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modules.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: <span class="string">`@import "@/styles/resources.scss";`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Editorconfig"><a href="#Editorconfig" class="headerlink" title="Editorconfig"></a>Editorconfig</h3><p>每一个项目都 <strong>必须</strong> 添加<code>Editorconfig</code>文件，并且每一个开发人员的编辑器都 <strong>必须</strong> 安装该插件。<br>下面是一份推荐使用的 editorconfig 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset = utf<span class="number">-8</span></span><br><span class="line">end_of_line = lf</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = <span class="number">2</span></span><br><span class="line">tab_width = <span class="number">2</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p>所有项目都 <strong>必须</strong> 使用<code>Prettier</code>进行代码的格式化。<br>下面是一份推荐使用的 prettier 配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line">modules.export = &#123;</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: <span class="string">"*.&#123;js,ts,jsx,tsx,vue&#125;"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        singleQuote: <span class="literal">true</span>,</span><br><span class="line">        printWidth: <span class="number">100</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇自己推崇的前端基础代码规范，如果之后在实践的过程中有更适合自己的，会再更新。首先奉上一句话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谨记代码是给人看的，它们只是恰巧能跑而已
    
    </summary>
    
    
      <category term="standard" scheme="https://jambo0624.github.io/categories/standard/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="css" scheme="https://jambo0624.github.io/tags/css/"/>
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://jambo0624.github.io/tags/vue/"/>
    
      <category term="standard" scheme="https://jambo0624.github.io/tags/standard/"/>
    
  </entry>
  
  <entry>
    <title>meta 标签的一些用法</title>
    <link href="https://jambo0624.github.io/2019-08-04-meta-tag.html"/>
    <id>https://jambo0624.github.io/2019-08-04-meta-tag.html</id>
    <published>2019-08-04T13:17:32.000Z</published>
    <updated>2020-10-13T11:14:00.448Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一段 meta 标签的代码，<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>具体用意不太知道。<br>说明还是有每一行代码，每一个细节都是值得进一步了解的，话不多说，咱们开始。</p><a id="more"></a><p>X-UA-Compatible是自从IE8新加的一个设置，对于IE8以下的浏览器是不识别的。<br>通过在meta中设置X-UA-Compatible的值，可以指定网页的兼容性模式设置。</p><p>在网页中指定的模式优先权高于服务器中(通过HTTP Header)所指定的模式。 兼容性模式设置优先级：</p><blockquote><p>meta tag &gt; http header</p></blockquote><p>常用的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7"</span>&gt;</span>  </span><br><span class="line">#以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面。  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=8"</span>&gt;</span>  </span><br><span class="line">#以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面。  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span>  </span><br><span class="line">#以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面。  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7,IE=9"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7,9"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=Edge,chrome=1"</span>&gt;</span></span><br><span class="line">#以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame.</span><br></pre></td></tr></table></figure><p>通过 wiki 发现，google frame 已经是历史了，没必要知之甚祥。</p><p>下面我们将常用的 meta 标签做个总结。<br>meta是html文档在head标签里定义的一个对文档进行描述的功能性标签<br>meta标签有下面的作用：</p><ul><li>1.搜索引擎优化（SEO）</li><li>2.定义页面使用语言</li><li>3.自动刷新并指向新的页面</li><li>4.实现网页转换时的动态效果</li><li>5.控制页面缓冲</li><li>6.网页定级评价</li><li>7.控制网页显示的窗口</li></ul><p>meta标签的组成：<br>meta标签共有两个属性，它们分别是<strong>http-equiv属性</strong>和<strong>name属性</strong>，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</p><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。</p><p>meta标签的name属性语法格式是：<br><code>&lt;meta name=&quot;参数&quot; content=&quot;具体的参数值&quot;&gt;</code></p><p>其中name属性主要有以下几种参数：　<br>A、Keywords(关键字)　<br>说明：keywords用来告诉搜索引擎你网页的关键字是什么。<br><code>&lt;meta name=&quot;keywords&quot; content=&quot;science,education,culture,politics,ecnomics，relationships,entertaiment,human&quot;&gt;</code></p><p>B、description(网站内容描述)<br>说明：description用来告诉搜索引擎你的网站主要内容。<br><code>&lt;meta name=&quot;description&quot; content=&quot;This page is about the meaning of science,education,culture.&quot;&gt;</code></p><p>C、robots(机器人向导)<br>说明：robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。<br>content的参数有all,none,index,noindex,follow,nofollow。默认是all。<br><code>&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt;</code></p><p>D、author(作者)<br>说明：标注网页的作者<br><code>&lt;meta name=&quot;author&quot; content=&quot;root,root@xxxx.com&quot;&gt;</code></p><p>E:renderer(渲染)<br>告诉浏览器你的渲染模式<br><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code></p><p>F：viewport(视图模式）<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;/&gt;</code></p><h3 id="http-equiv属性"><a href="#http-equiv属性" class="headerlink" title="http-equiv属性"></a>http-equiv属性</h3><p>http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。</p><p>meta标签的http-equiv属性语法格式是：<br><code>&lt;meta http-equiv=&quot;参数&quot; content=&quot;参数变量值&quot;&gt;</code></p><p>其中http-equiv属性主要有以下几种参数：<br>常用项：X-UA-Compatible（浏览模式）<br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code></p><p>A、Expires(期限)<br>说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。<br><code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri,01Jan201618:18:18GMT&quot;&gt;</code><br>注意：必须使用GMT的时间格式。</p><p>B、Pragma(cache模式)<br>说明：禁止浏览器从本地计算机的缓存中访问页面内容。<br><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;</code><br>注意：这样设定，访问者将无法脱机浏览。</p><p>C、Refresh(刷新)<br>说明：自动刷新并指向新页面。<br><code>&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2;URL=http://www.xxxx.net&quot;&gt;</code><br>注意：其中的2是指停留2秒钟后自动刷新到URL网址。</p><p>D、Set-Cookie(cookie设定)<br>说明：如果网页过期，那么存盘的cookie将被删除。<br><code>&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt;</code><br>注意：必须使用GMT的时间格式。</p><p>E、Window-target(显示窗口的设定)<br>说明：强制页面在当前窗口以独立页面显示。<br><code>&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_blank&quot;&gt;</code><br>注意：用来防止别人在框架里调用自己的页面。</p><p>F、content-Type(显示字符集的设定)<br>说明：设定页面使用的字符集。<br><code>&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=gb2312&quot;&gt;</code></p><p>G、content-Language（显示语言的设定）<br><code>&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-cn&quot;/&gt;</code></p><p>H、Cache-Control指定请求和响应遵循的缓存机制。<br>Cache-Control指定请求和响应遵循的缓存机制。<br>在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。<br>请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，<br>响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。<br>各个消息中的指令含义如下</p><blockquote><p>Public:指示响应可被任何缓存区缓存<br>Private:指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效<br>no-cache指示请求或响应消息不能缓存<br>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应<br>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应<br>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p></blockquote><p><strong>Meta标签使用技巧：</strong><br>Meta标签是用来描述网页属性的一种语言，标准的Meta标签可以便于搜索引擎排序，提高搜索引擎网站权重排名。要想网站做的更符合搜索引擎标准就必须了解meta标签，下面由Seoer惜缘于大家讲讲meta标签含义与使用方法：<br>1、META标签的keywords<br><code>&lt;meta name=&quot;Keywords&quot; content=&quot;信息参数&quot;/&gt;</code><br>meat标签的Keywords的的信息参数，代表说明网站的关键词是什么。</p><p>2、META标签的Description<br><code>&lt;meta name=&quot;Description&quot; content=&quot;信息参数&quot;/&gt;</code><br>meta标签的Description的信息参数，代表说明网站的主要内容，概况是什么。</p><p>3、META标签的http-equiv=Content-Typecontent=”text/html<br>http-equiv=Content-Type代表的是HTTP的头部协议，提示浏览器网页的信息，<br><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=信息参数&quot;/&gt;</code><br>meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文；<br>meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文；<br>meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码；</p><p>4、META标签的generator<br><code>&lt;meta name=&quot;generator&quot; content=&quot;信息参数&quot;/&gt;</code><br>meta标签的generator的信息参数，代表说明网站的采用的什么软件制作。</p><p>5、META标签的author<br><code>&lt;meta name=&quot;author&quot; content=&quot;信息参数&quot;&gt;</code><br>meta标签的author的信息参数，代表说明网页版权作者信息。</p><p>6、META标签的http-equiv=”Refresh”<br><code>&lt;Meta http-equiv=&quot;Refresh&quot; Content=&quot;时间;Url=网址参数&quot;&gt;</code><br>meta标签的Refresh代表多少时间网页自动刷新，加上Url中的网址参数就代表，多长时间自动链接其他网址。</p><p>7、META标签的http-equiv=”Pragma” CONTENT=”no-cache”<br><code>&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;</code><br>代表禁止浏览器从本地计算机的缓存中访问页面内容,这样设定，访问者将无法脱机浏览。</p><p>8、META标签的COPYRIGHT<br><code>&lt;META NAME=&quot;COPYRIGHT&quot; CONTENT=&quot;信息参数&quot;&gt;</code><br>meta标签的COPYRIGHT的信息参数，代表说明网站版权信息。</p><p>9、META标签的http-equiv=”imagetoolbar”<br><code>&lt;meta http-equiv=&quot;imagetoolbar&quot; content=&quot;false&quot;/&gt;</code><br>指定是否显示图片工具栏，当为false代表不显示，当为true代表显示。</p><p>10、META标签的Content-Script-Type<br><code>&lt;Meta http-equiv=&quot;Content-Script-Type&quot; Content=&quot;text/javascript&quot;&gt;</code><br>W3C网页规范，指明页面中脚本的类型。</p><p>11、META标签的revisit-after<br><code>&lt;META name=&quot;revisit-after&quot; CONTENT=&quot;7days&quot;&gt;</code><br>revisit-after代表网站重访,7days代表7天，依此类推。</p><p>12、META标签的Robots<br><code>&lt;meta name=&quot;Robots&quot; contect=&quot;信息参数&quot;&gt;</code><br>Robots代表告诉搜索引擎机器人抓取哪些页面</p><p>其中的属性说明如下：</p><blockquote><p>信息参数为all：文件将被检索，且页面上的链接可以被查询；<br>信息参数为none：文件将不被检索，且页面上的链接不可以被查询；<br>信息参数为index：文件将被检索；<br>信息参数为follow：页面上的链接可以被查询；<br>信息参数为noindex：文件将不被检索，但页面上的链接可以被查询；<br>信息参数为nofollow：文件将被检索，但页面上的链接不可以被查询；</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到一段 meta 标签的代码，&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;&lt;/code&gt;具体用意不太知道。&lt;br&gt;说明还是有每一行代码，每一个细节都是值得进一步了解的，话不多说，咱们开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jambo0624.github.io/categories/html/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="meta" scheme="https://jambo0624.github.io/tags/meta/"/>
    
      <category term="tag" scheme="https://jambo0624.github.io/tags/tag/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序知识点</title>
    <link href="https://jambo0624.github.io/2019-07-27-minipro.html"/>
    <id>https://jambo0624.github.io/2019-07-27-minipro.html</id>
    <published>2019-07-27T02:04:04.000Z</published>
    <updated>2020-10-13T10:46:44.734Z</updated>
    
    <content type="html"><![CDATA[<p>近期公司在做小程序，虽然暂时没有参与进去，但是学习的热情不能减。<br>下面就把学习过程中的一些笔记进行整理，作如下总结。我们开始吧。</p><a id="more"></a><h3 id="主体目录结构"><a href="#主体目录结构" class="headerlink" title="主体目录结构"></a>主体目录结构</h3><blockquote><p>pages   – 项目所有组件   index.wxml - xml文件(非常严格)<br>app.js   – 入口文件<br>app.json – 项目全配置文件(1)不能加注释 (2)内容严格<br>app.wxss – 全局样式文件   添加二个新功能:(1)单位  rpx (2) @import “x.wxss”</p></blockquote><h3 id="wxml——小程序wxml-是一种xml文件用于描述网页结构"><a href="#wxml——小程序wxml-是一种xml文件用于描述网页结构" class="headerlink" title="wxml——小程序wxml 是一种xml文件用于描述网页结构"></a>wxml——小程序wxml 是一种xml文件用于描述网页结构</h3><p>xml 格式要求非常严格，不是html<br><strong>一个xml文件必须有且只有一个根元素</strong><br><strong>所有标签有开始必须有结束</strong><br><strong>所有属性值必须双引号</strong>   <code>&lt;button name=&quot;btn&quot; &gt;</code><br>wxml常用标签</p><blockquote><p><code>&lt;view&gt;&lt;/view&gt;</code>            相当于  <code>&lt;div&gt;&lt;/div&gt;</code><br><code>&lt;text&gt;&lt;/text&gt;</code>             相当于 <code>&lt;span&gt;&lt;p&gt;</code><br><code>&lt;image&gt;&lt;/image&gt;</code>         相当于 <code>&lt;img src=&quot;&quot; /&gt;</code><br><code>&lt;navigator&gt;&lt;/navigator&gt;</code>    相当于 <code>&lt;a&gt;</code><br><code>&lt;form&gt;&lt;/form&gt;</code></p></blockquote><p><strong>修改显示组件顺序</strong><br>app.json  “pages”:[“pages/index/index”…]<br>哪个组件在第一位则默认显示哪个组件 </p><h3 id="wxss-样式文件"><a href="#wxss-样式文件" class="headerlink" title="wxss [样式文件]"></a>wxss [样式文件]</h3><p>  每一个组件中都有一个样式文件,每一个组件中都有一个js文件。默认样式文件和js文件自动加载wxml。不用手工引入(微信小程序平台自动操作)<br>  小程序对css文件封装操作 wxss—-#rpx     (r响应式)<br>  示例:</p><blockquote><p>iphone 6 设计图宽度(物理像素 750)     2x<br>(逻辑像素  375px) (逻辑像素 750rpx)<br>iphone 6 plus                    3x </p></blockquote><p>  注意:width:height 使用 rpx;font-size:12px; </p><p><strong>样式引入</strong><br>  @import “引入其它样式文件”<br>  小程序样式布局:弹性布局</p><h3 id="js-样式文件"><a href="#js-样式文件" class="headerlink" title="js [样式文件]"></a>js [样式文件]</h3><p>  小程序一个组件对应 .js 默认有一个对象<br>  Page:当前组件对象 <code>Page({data:{},onload:function()...})</code><br>  小程序js程序<br>  (1)ECMAScript<br>    基本数据类型 number;string;boolean;null;undefined<br>    引入         Object;Number;Date;RegExp;…<br>  (2)小程序没有 BOM/BOM概念<br>    widow;document;alert();….<br>  (3)小程序有一个顶级js对象  wx(类似window)</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>  轮播图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">""</span> &gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常见属性:<br>-autoplay 自动播放<br>-interval  间隔时间<br>-indicator-dots 指示点<br>-vertical   方向</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>   生命周期:一个组件从创建到销毁过程<br>   全局生命周期:app.js</p><blockquote><p>-onLaunch 当小程序运行只执行一次</p></blockquote><p>   局部生命周期(组件生命周期)</p><blockquote><p>-onLoad        组件加载时触发一个组件只会调用一次<br>    参数: options  不同组件之间传参数   a?id=10       b:options.id<br>    通常在此事件发送ajax请求,获取参数</p></blockquote><blockquote><p>-onReady  页面初次渲染完成触发,一个页面只会调用一次,代表页面己渲染结束可以进入交互操作<br>-onShow   页面显示或者切换前台时触发<br>-onHide    页面隐藏/切换后台触发<br>-onUnload 页面卸载时触发.通过程序跳转其它组件<br>                redirectTo();navigateBack()触发</p></blockquote><h3 id="组件事件处理函数"><a href="#组件事件处理函数" class="headerlink" title="组件事件处理函数"></a>组件事件处理函数</h3><blockquote><p>-onPullDownRefresh 监听用户下拉操作<br>    #默认小程序禁止用户下拉操作<br>    #在全局配置文件”window”<br>     enablePullDownRefresh:false   </p></blockquote><blockquote><p>-onReachBottom         监听用户上拉触底<br>-onPageScroll({})         监听用户滑动页面事件 </p></blockquote><blockquote><p> scrollTop         页面在垂直方向己经滚动距离</p></blockquote><h3 id="小程序配置"><a href="#小程序配置" class="headerlink" title="小程序配置"></a>小程序配置</h3><p>全局配置项局部配置项 app.json </p><blockquote><p>-pages:  array   页面路径列表,默认显示数组第一个组件内容</p></blockquote><blockquote><p>-window     窗口样式(渲染方式)<br> “navigationBarTextStyle”: “black”/“white”   颜色  “#f00” red 错误</p></blockquote><blockquote><p>-tabBar            兼容性差<br>    exam01/exam01.json 局部(就近原则)</p></blockquote><h3 id="小程序数据表现-wxml-WeiXin-Markup-Language-一套以xml为标准语言"><a href="#小程序数据表现-wxml-WeiXin-Markup-Language-一套以xml为标准语言" class="headerlink" title="小程序数据表现 wxml(WeiXin Markup Language) 一套以xml为标准语言"></a>小程序数据表现 wxml(WeiXin Markup Language) 一套以xml为标准语言</h3><blockquote><p><code>&lt;view&gt;&lt;view&gt;</code>    div<br><code>&lt;text&gt;&lt;/text&gt;</code>    只有text元素才能全选(复制)<br> <code>:selectable</code>     false  文本是否可以选中<br> <code>:decode</code>       false  是否解码</p></blockquote><blockquote><p><code>&lt;image src=&quot;x.jpg&quot; mode=&quot;aspectFill &quot; lazy-load&gt;&lt;/image&gt;</code><br> <code>:mode</code> :二个参数选项 “aspectFill”  “aspectFit” 缩放<br> <code>:lazy-load</code> :支持懒加载</p></blockquote><blockquote><p><code>&lt;navigator url=&quot;当前小程序跳转链接&quot;&gt;&lt;/navigator&gt;</code></p></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件:组件表示层(wxml)与业务逻辑层(js)交互手段<br>事件绑定:<code>&lt;view id=&quot;tapTest&quot; data-idx=&quot;10&quot; bindtap=&quot;函数&quot;&gt;Clike Me&lt;/view&gt;</code><br>事件类型:</p><blockquote><p>tap      :手指触摸后马上离开<br>longtap  :手指触摸后，超过 350ms再离开(长按钮) 旧<br>longpress :手指触摸后, 超过 350ms再离开         新 1.5.0</p></blockquote><p>绑定函数:在相应的Page对象定义事件处理函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  函数名:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 事件对象信息 ：</span></span><br><span class="line"><span class="comment">// -type:"tap"                           触发事件名称</span></span><br><span class="line"><span class="comment">// -target:&#123;id:" tapTest",dataset:&#123;"idx":19&#125;&#125;   触发事件元素</span></span><br><span class="line"><span class="comment">// -currentTarget&#123;&#125;                       当前元素</span></span><br><span class="line"><span class="comment">// -timeStamp:            页面打开到触发事件所经过毫秒数</span></span><br></pre></td></tr></table></figure><p>注意事项:<br>   (1) “longtap” event is deprecated. Please use “longpress” event instead.<br>    过期:不建议再使用，如果一定要用也可以正常使用<br>   (2)如果当前元素指定 longpress并绑定函数tap事件有可能不会触发<br>   事件传播方式分类<br>   (1)冒泡事件:当一个组件上的事件被触发后，该事件会向父节点传递<br>   (2)非冒泡事件:一个组件上的事件被触发后，该事件不向父节点传递<br>   小程序区别事件处理是否使用冒泡方式看前缀<br>   bind  冒泡事件    bindtap<br>   catch 非冒泡事件  catchtap</p><h3 id="获取不同类型参数跳转方式"><a href="#获取不同类型参数跳转方式" class="headerlink" title="获取不同类型参数跳转方式"></a>获取不同类型参数跳转方式</h3><p>   小程序参数:不推荐使用参数传递数值方式来将参数传递函数内<br>   解决方案: 自定义属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=<span class="string">"tapName"</span> data-idx=<span class="string">"39"</span> bindtap=<span class="string">"tapName"</span>&gt;&lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">Page(&#123;</span></span><br><span class="line"><span class="regexp">   tapName:function(event)&#123;</span></span><br><span class="line"><span class="regexp">    console.log(event.target.dataset.idx);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="小程序跳转与参数传递"><a href="#小程序跳转与参数传递" class="headerlink" title="小程序跳转与参数传递"></a>小程序跳转与参数传递</h3><p>   小程序不同组件之间跳转<br>   方式一:标签   <code>&lt;navigator url=&quot;组件路径&quot;&gt;&lt;/navigator&gt;</code> 注意:使用标签方式跳转还可后退<br>   方式二:编程</p><blockquote><p>-wx.navigateTo({});<br>      保留当前组件跳转到应用内容其它组件<br>      #要求:不能跳转 tabbar</p></blockquote><blockquote><p>-wx.navigateBack({url:组件路径})<br>      关闭当前页组件返回上一个组件或其它组件</p></blockquote><p>   新问题:获取参数值不能将数值显示模板<br>   解决问题:<br>   (1)在低版本小程序 this.data.id = id; 正确   2017 &lt;<br>   (2)新版本小程序  使用新方法解决 setData<br>       setData({data属性名:数值})<br>       setData将数据异步更新视图wxml同时改变 this.data值</p><blockquote><p>-wx.redirectTo({url:”组件路径”})<br>      关闭当组件跳转到应用内其它个组件，不允许跳转tabbar<br>      关闭当前组件<br>         1:关闭当前组件<br>         2:卸载组件 在卸载之前触发 onUnload</p></blockquote><blockquote><p>-wx.reLaunch({url:”组件路径”})<br>      关闭所有组件，打开到应用内某个组件<br>-wx.switchTab({url:”组件路径”})<br>      跳转到tabBar组件，并关闭所有非tabbar组件</p></blockquote><p>   小结:<br>    (1)不同组件之间跳转保留优先 wx.navigateTo()<br>    (2)如果当前组件定义tabbar   wx.reLaunch()</p><h3 id="AJAX请求"><a href="#AJAX请求" class="headerlink" title="AJAX请求"></a>AJAX请求</h3><p>小程序中显示数据依赖 AJAX获取服务器上数据,保存当前data属性在模板显示<br><code>wx.request({})</code>  小程序发送异步请求方法<br>常用属性和方法</p><blockquote><p>url            请求服务器程序地址<br>data string/object/array   请求参数<br>method         请求方法<br>header       请求header appliation/json<br>success          请求成功回调函数<br>fail          请求失败回调函数<br>complete     无论成功或失败都执行</p></blockquote><p>常见错误</p><blockquote><p>(1)工具菜单-&gt;项目详细-&gt;[*] 不校验合法域名<br>(2) this.setData is not a function;<br>   在请求处理函数this 指定当前 wx对象 wx没有 setData<br>   将this指定从 wx 修改 Page<br>   解决方案:使用箭头函数 </p></blockquote><blockquote><p>(3)参数传递失败 id;age<br>  解决方案:打开网络控制面板 network</p></blockquote><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><blockquote><p>-wx.showToast({});       显示消息提示框<br>      title:”..”   提示的内容<br>      icon:””    图标:默认值 “success”<br>      duration  延迟时间<br>      注意:title字数为了兼容性少于7个字<br>      注意:icon:”success” “loading” “none”</p></blockquote><blockquote><p>-wx.showModal({});      显示模态对话框<br>      title:””    标题<br>      content:”” 内容<br>      success: (res)=&gt;{<br>      }</p></blockquote><blockquote><p>-wx.showActionSheet({})  显示操作菜单<br>      itemList:[“”,””,””]<br>      itemColor:”#fff”<br>      success:(res)=&gt;{<br>       res.tapIndex 用户选中下标下标<br>      }</p></blockquote><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>局部(当前组件)数据存储<br><code>data:{}</code><br>全局(小程序生命周期)数据存储跨组件  -在app.js 定义全局共享数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  globalData:&#123;<span class="attr">LoginName</span>:<span class="string">""</span>,<span class="attr">list</span>:[]&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>-其它组件操作全局数据<br>(1)加载全局组件,小程序提供方法 getApp()       const app = getApp();<br>(2)读取数据       var uname = app.globalData.LoginName;<br>(3)操作数据       app.globalData.LoginName = “tom”</p><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>  小程序后台播放器播放音乐，对于微信客户端来说，只能同时<br>  有一个后台音乐在播放，当其它小程序占用音乐播放器，原有<br>  小程序音乐停止播放<br>    方法与事件<br>    (1)wx.playBackgroundAudio({})   播放背景音乐<br>     -datalist        音乐链接目前支持音频格式  mp3;wav;aac;m4a<br>     -title           音乐标题<br>     -convertImgUrl  封面<br>    (2)wx.pauseBackgroundAudio({})  暂停背景音乐<br>    (3)wx.stopBackgroundAudio({})   停止背景音乐<br>    (4)wx.onBackgroundAudioPlay    监听音乐播放事件<br>    (5)wx.onBackgroundAudioPause   监听音乐暂停播放事件<br>    (6)wx.onBackgroundAudioStop    监听音乐停止播放事件</p><p>  开发顺序<br>     -将音频文件保存服务器 node.js/public/bg.mp3<br>     -启动服务器<br>     -打开浏览器访问bg.mp3<br>     -index组件</p><p>   常见错误:音乐播放时闪退<br>   原因:音乐文件路径不正确或者服务器出错</p><h3 id="多媒体视频"><a href="#多媒体视频" class="headerlink" title="多媒体视频"></a>多媒体视频</h3><p>   1:通过video组件显示视频<br>    <code>&lt;video src=&quot;视频路径&quot;&gt;&lt;/video&gt;</code><br>    默认视频:300px 宽 225px 高<br>    常见属性 </p><blockquote><p>autoplay  自动播放<br>loop      循环<br>muted    静音<br>poster    广告图片<br>controls   控件 </p></blockquote><p>   2: 通过video组件显示视频(选择视频 相册 照相机)<br>     <code>&lt;video src=&quot;&quot;&gt;&lt;/video&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseVideo(&#123;                  <span class="comment">// 选择视频播放</span></span><br><span class="line">  sourceType:[<span class="string">"album"</span>,<span class="string">"camera"</span>],    <span class="comment">// 相册相机</span></span><br><span class="line">  maxDuration:<span class="number">60</span>,                 <span class="comment">// 视频长度上限</span></span><br><span class="line">  camera:[<span class="string">"front"</span>,<span class="string">"back"</span>],           <span class="comment">// 相册可以用前摄像头后</span></span><br><span class="line">  success:<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    result.tempFilePath;             <span class="comment">// 视频路径 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="tabbar"><a href="#tabbar" class="headerlink" title="tabbar"></a>tabbar</h3><p>小程序主页底层导航条，该导航条是通过配置文件创建<br>app.json<br>pages:[]    组件访问路径<br>windows:{} 组件配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tabBar:&#123;</span><br><span class="line">   <span class="string">"position"</span>:<span class="string">"bottom"</span>,     <span class="comment">// tabbar位置"top","bottom"</span></span><br><span class="line">   <span class="string">"list"</span>:[</span><br><span class="line">      &#123; </span><br><span class="line">      <span class="string">"pagePath"</span>:<span class="string">"pages/home/home"</span>,  <span class="comment">// 访问组件路径</span></span><br><span class="line">      <span class="string">"text"</span>:<span class="string">"首页"</span>,                   <span class="comment">// 当前文本</span></span><br><span class="line">      <span class="string">"iconPath"</span>:<span class="string">"assets/tabs/home.png"</span>, <span class="comment">// 图片路径</span></span><br><span class="line">      <span class="string">"selectedIconPath"</span>:<span class="string">"assets/tabs/home-action.png"</span> <span class="comment">//选中图片</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 注意1:图片本地保存<br> 注意2:最少二个对象</p><p> 1:常见错误:<br> tabBar.list[1].iconPath        文件不存在<br> tabBar.list[1].selectedIconPath 文件不存在<br> 2:常见错误:<br>  -点击某个组件  tabbar 消失<br>  -当前组需要显示tabbar必须将组配置<br>   tabbar:[pagePath]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期公司在做小程序，虽然暂时没有参与进去，但是学习的热情不能减。&lt;br&gt;下面就把学习过程中的一些笔记进行整理，作如下总结。我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="minipro" scheme="https://jambo0624.github.io/categories/minipro/"/>
    
    
      <category term="minipro" scheme="https://jambo0624.github.io/tags/minipro/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (中卷)--异步》</title>
    <link href="https://jambo0624.github.io/2019-07-07-dont-know-js-second2.html"/>
    <id>https://jambo0624.github.io/2019-07-07-dont-know-js-second2.html</id>
    <published>2019-07-07T09:43:29.000Z</published>
    <updated>2020-10-13T07:41:57.743Z</updated>
    
    <content type="html"><![CDATA[<p>读完《你不知道的javaScript》系列的中卷中类型和语法部分，发现对于基础知识的理解更加透彻了。<br>之前计划是将中卷的两部分内容全部记录完毕，最后发现内容实在太多。<br>所以不得不将中卷分成两部分记录，现在我们开始异步和性能部分。</p><a id="more"></a><h1 id="异步和性能"><a href="#异步和性能" class="headerlink" title="异步和性能"></a>异步和性能</h1><h2 id="异步：现在和将来"><a href="#异步：现在和将来" class="headerlink" title="异步：现在和将来"></a>异步：现在和将来</h2><h3 id="分块的程序"><a href="#分块的程序" class="headerlink" title="分块的程序"></a>分块的程序</h3><p>JavaScript程序最常见的块单位是函数。<br>任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。</p><p><strong>异步控制台</strong><br>如果在调试的过程中遇到对象在<code>console.log(..)</code>语句之后被修改，可你却看到了意料之外的结果，要意识到这可能是这种I/O的异步化造成的。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>首先通过一段极度简化的伪代码，来了解一下事件循环这个概念。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventLoop 是一个用作队列的数组</span></span><br><span class="line"><span class="comment">// (先进先出)</span></span><br><span class="line"><span class="keyword">let</span> eventLoop = []</span><br><span class="line"><span class="keyword">let</span> event</span><br><span class="line"></span><br><span class="line"><span class="comment">// '永远'执行</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="comment">// 一次 tick</span></span><br><span class="line">  <span class="keyword">if</span>( eventLoop.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 拿到队列中的下一个事件</span></span><br><span class="line">    event = eventLoop.shift()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在，执行下一个事件</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      event()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      repeatError(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h3><p>异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。<br><strong>完整运行</strong><br>由于JavaScript的单线程特性，foo()（以及bar()）中的代码具有原子性。<br>也就是说，一旦foo()开始运行，它的所有代码都会在bar()中的任意代码运行之前完成，或者相反。<br>这称为完整运行（run-to-completion）特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a++</span><br><span class="line">  b = b * a</span><br><span class="line">  a = b + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b--</span><br><span class="line">  a = <span class="number">8</span> + b</span><br><span class="line">  b = a * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>单线程事件循环是并发的一种形式<br><strong>非交互</strong><br>两个或多个“进程”在同一个程序内并发地交替运行它们的步骤/事件时，如果这些任务彼此不相关，就不一定需要交互。<br>如果进程间没有相互影响的话，不确定性是完全可以接受的。</p><p><strong>交互</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a,b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  a = x * <span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span>(a &amp;&amp; b)&#123;</span><br><span class="line">    baz()</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">  b = y * <span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span>(a &amp;&amp; b)&#123;</span><br><span class="line">    baz()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>包裹baz()调用的条件判断if (a &amp;&amp; b)传统上称为门（gate），我们虽然不能确定a和b到达的顺序，但是会等到它们两个都准备好再进一步打开门（调用baz()）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!a)&#123;</span><br><span class="line">    a = x * <span class="number">2</span></span><br><span class="line">    baz()</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!a)&#123;</span><br><span class="line">    b = y * <span class="number">2</span></span><br><span class="line">    baz()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>条件判断if (! a)使得只有foo()和bar()中的第一个可以通过，第二个（实际上是任何后续的）调用会被忽略。也就是说，第二名没有任何意义！</p><p><strong>协作</strong><br>如果有像1000万条记录的话，就可能需要运行相当一段时间了（在高性能笔记本上需要几秒钟，在移动设备上需要更长时间，等等）。<br>这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的response(..)调用或UI刷新，甚至是像滚动、输入、按钮点击这样的用户事件。这是相当痛苦的。</p><p>所以，要创建一个协作性更强更友好且不会霸占事件循环队列的并发系统，你可以异步地批处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 一次处理 1000 个</span></span><br><span class="line">  <span class="keyword">var</span> chunk = data.splice（<span class="number">0</span>，<span class="number">1000</span>）</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加到已有的 res 组</span></span><br><span class="line">  res = res.concat(</span><br><span class="line">    <span class="comment">// 创建一个新的数组把 chunk 中所有值加倍</span></span><br><span class="line">    chunk.map(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val*<span class="number">2</span></span><br><span class="line">    &#125;)  </span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 还有剩下的吗</span></span><br><span class="line">  <span class="keyword">if</span>(data.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 异步调度下一波处理</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      response(data)</span><br><span class="line">    &#125;,<span class="number">0</span>) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>任务队列就是，它是挂在事件循环队列的每个tick之后的一个队列。<br>在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick的任务队列末尾添加一个项目（一个任务）。</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><h3 id="continuation"><a href="#continuation" class="headerlink" title="continuation"></a>continuation</h3><p>“执行A，然后设定一个延时等待1000毫秒，到时后马上执行C”<br>“执行A，设定延时1000毫秒，然后执行B，然后定时到时后执行C”<br>尽管第二个版本更精确一些，但是在匹配大脑对这段代码的理解和代码对于JavaScript引擎的意义方面，两个版本对这段代码的解释都有不足。<br>这种不匹配既微妙又显著，也正是理解回调作为异步表达和管理方式的缺陷的关键所在。</p><h3 id="顺序的大脑"><a href="#顺序的大脑" class="headerlink" title="顺序的大脑"></a>顺序的大脑</h3><p><strong>执行与计划</strong><br>因为这并不是我们大脑进行计划的运作方式，所以精确编写和追踪使用回调的异步JavaScript代码如此之难</p><p><strong>嵌套回调与链式回调</strong><br>嵌套和缩进基本上只是转移注意力的枝节而已。<br>回调方式最主要的缺陷：对于它们在代码中表达异步的方式，我们的大脑需要努力才能同步得上。</p><h3 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h3><p>顺序的人脑计划和回调驱动的异步JavaScript代码之间的不匹配只是回调问题的一部分。<br>还有一些更深入的问题需要考虑。</p><p>实际上，这是回调驱动设计<strong>最严重</strong>（也是最微妙）的问题。<br>它以这样一个思路为中心：有时候ajax(..)（也就是你交付回调continuation的第三方）不是你编写的代码，也不在你的直接控制下。<br>多数情况下，它是某个第三方提供的工具。我们把这称为<strong>控制反转</strong>（inversion of control），也就是把自己程序一部分的执行控制交给某个第三方。<br>在你的代码和第三方工具（一组你希望有人维护的东西）之间有一份并没有明确表达的契约。</p><p><strong>不只是别人的代码</strong><br>回调不可靠，且回调并没有为我们提供任何东西来支持<strong>回调结果验证</strong>这一点。<br>我们不得不自己构建全部的机制，而且通常为每个异步回调重复这样的工作最后都成了负担。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><p><strong>未来值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">xPromise, yPromise</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([xPromise, yPromise]).then(<span class="function"><span class="keyword">function</span> (<span class="params">values</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> values[<span class="number">0</span>] + values[<span class="number">1</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">add(fetchX(), fetchY()).then(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过Promise，调用then(..)实际上可以接受两个函数，第一个用于完成情况（如前所示），第二个用于拒绝情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(fetchX(), fetchY()).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(sum)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125; </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>一旦Promise决议，它就<strong>永远保持在这个状态</strong>。此时它就成为了不变值（immutable value），可以根据需求多次查看。<br>Promise是一种封装和组合未来值的易于复用的机制。</p><p><strong>完成事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> listener</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> evt = foo(<span class="number">42</span>)</span><br><span class="line">evt.on(<span class="string">'completion'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">&#123;&#125;</span>))</span></span><br><span class="line"><span class="function"><span class="title">evt</span>.<span class="title">on</span>(<span class="params"><span class="string">'failure'</span>,function(</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>相对于面向回调的代码，这里的反转是显而易见的，而且这也是有意为之。<br>这里没有把回调传给foo(..)，而是返回一个名为evt的事件注册对象，由它来接受回调。</p><h3 id="具有then方法的鸭子类型"><a href="#具有then方法的鸭子类型" class="headerlink" title="具有then方法的鸭子类型"></a>具有then方法的鸭子类型</h3><p>识别Promise（或者行为类似于Promise的东西）就是定义某种称为thenable的东西，将其定义为任何具有then(..)方法的对象和函数。我们认为，任何这样的值就是Promise一致的thenable。<br>根据一个值的形态（具有哪些属性）对这个值的类型做出一些假定。这种类型检查（type check）一般用术语鸭子类型（duck typing）来表示——“如果它看起来像只鸭子，叫起来像只鸭子，那它一定就是只鸭子”（参见本书的“类型和语法”部分）。<br>于是，对thenable值的鸭子类型检测就大致类似于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(</span><br><span class="line">  p!==<span class="literal">null</span> &amp;&amp; </span><br><span class="line">  (<span class="keyword">typeof</span> p === <span class="string">'object'</span> || </span><br><span class="line">    <span class="keyword">typeof</span> p === <span class="string">'function'</span></span><br><span class="line">  ) &amp;&amp; </span><br><span class="line">  <span class="keyword">typeof</span> p.then === <span class="string">'function'</span></span><br><span class="line">)&#123;</span><br><span class="line">  <span class="comment">// 假定这是一个 thenable</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 不是 thenable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise信任问题"><a href="#Promise信任问题" class="headerlink" title="Promise信任问题"></a>Promise信任问题</h3><p><strong>调用过早</strong><br>即使是立即完成的Promise（类似于new Promise(function(resolve){ resolve(42); })）也无法被同步观察到。<br>也就是说，对一个Promise调用then(..)的时候，即使这个Promise已经决议，提供给then(..)的回调也总会被异步调用</p><p><strong>调用过晚</strong><br>一个Promise决议后，这个Promise上所有的通过then(..)注册的回调都会在下一个异步时机点上依次被立即调用。<br>这些回调中的任意一个都无法影响或延误对其他回调的调用</p><p><strong>回调未调用</strong><br>这个问题很常见，Promise可以通过几种途径解决。<br>首先，没有任何东西（甚至JavaScript错误）能阻止Promise向你通知它的决议（如果它决议了的话）。如果你对一个Promise注册了一个完成回调和一个拒绝回调，那么Promise在决议时总是会调用其中的一个。<br>当然，如果你的回调函数本身包含JavaScript错误，那可能就会看不到你期望的结果，但实际上回调还是被调用了。后面我们会介绍如何在回调出错时得到通知，因为就连这些错误也不会被吞掉。<br>但是，如果Promise本身永远不被决议呢？即使这样，Promise也提供了解决方案，其使用了一种称为竞态的高级抽象机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">'timeoout'</span>)</span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([foo(),timeoutPromise(<span class="number">3000</span>)]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p><strong>调用次数过少或过多</strong><br>回调被调用的正确次数应该是1。“过少”的情况就是调用0次，和前面解释过的“未被”调用是同一种情况。<br>“过多”的情况很容易解释。Promise将只会接受第一次决议，并默默地忽略任何后续调用。</p><p><strong>未能传递参数/环境值</strong><br>如果你没有用任何值显式决议，那么这个值就是undefined，这是JavaScript常见的处理方式。<br>但不管这个值是什么，无论当前或未来，它都会被传给所有注册的（且适当的完成或拒绝）回调</p><p><strong>吞掉错误或异常</strong><br>如果拒绝一个Promise并给出一个理由（也就是一个出错消息），这个值就会被传给拒绝回调。</p><p><strong>是可信任的Promise吗</strong><br>如果向Promise.resolve(..)传递一个非Promise、非thenable的立即值，就会得到一个用这个值填充的promise。下面这种情况下，promise p1和promise p2的行为是完全一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><p>而如果向Promise.resolve(..)传递一个真正的Promise，就只会返回同一个promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(p1)</span><br><span class="line"></span><br><span class="line">p1===p2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>更重要的是，如果向Promise.resolve(..)传递了一个非Promise的thenable值，前者就会试图展开这个值，而且展开过程会持续到提取出一个具体的非类Promise的最终值。</p><p>Promise.resolve(..)可以接受任何thenable，将其解封为它的非thenable值。从Promise. resolve(..)得到的是一个真正的Promise，是一个可以信任的值。<br>如果你传入的已经是真正的Promise，那么你得到的就是它本身，所以通过Promise.resolve(..)过滤来获得可信任性完全没有坏处。</p><p><strong>建立信任</strong><br>Promise这种模式通过可信任的语义把回调作为参数传递，使得这种行为更可靠更合理。<br>通过把回调的控制反转反转回来，我们把控制权放在了一个可信任的系统（Promise）中，这种系统的设计目的就是为了使异步编码更清晰。</p><h3 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h3><p>简单总结一下使链式流程控制可行的Promise固有特性。<br>• 调用Promise的then(..)会自动创建一个新的Promise从调用返回。<br>• 在完成或拒绝处理函数内部，如果返回一个值或抛出一个异常，新返回的（可链接的）Promise就相应地决议。<br>• 如果完成或拒绝处理函数返回一个Promise，它将会被展开，这样一来，不管它的决议值是什么，都会成为当前then(..)返回的链接Promise的决议值。</p><p><strong>术语：决议(resolve)、完成(fulfill)以及拒绝(reject)</strong></p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 数字没有 string 函数，所以会抛出错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase())</span><br><span class="line">  &#125;,<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 永远不会到达这里</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果msg.toLowerCase()合法地抛出一个错误（事实确实如此！），为什么我们的错误处理函数没有得到通知呢？正如前面解释过的，这是因为那个错误处理函数是为promise p准备的，而这个promise已经用值42填充了。<br>promise p是不可变的，所以唯一可以被通知这个错误的promise是从p.then(..)返回的那一个，但我们在此例中没有捕捉</p><p>一些开发者表示，Promise链的一个最佳实践就是最后总以一个catch(..)结束，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 数字没有 string 函数，所以会抛出错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line">).catch(handleErrors)</span><br></pre></td></tr></table></figure><p>进入p的错误以及p之后进入其决议（就像msg.toLowerCase()）的错误都会传递到最后的handleErrors(..)。<br>如果handleErrors(..)本身内部也有错误怎么办呢？谁来捕捉它？</p><p><strong>处理未捕获的情况</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 数字没有 string 函数，所以会抛出错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line">).done(<span class="literal">null</span>, handleErrors)</span><br></pre></td></tr></table></figure><h3 id="Promise模式"><a href="#Promise模式" class="headerlink" title="Promise模式"></a>Promise模式</h3><p><strong>Promise.all([ .. ])</strong><br><strong>Promise.race([ .. ])</strong><br><strong>all([ .. ])和race([ .. ])的变体</strong><br> • none([ .. ])<br> 这个模式类似于all([ .. ])，不过完成和拒绝的情况互换了。所有的Promise都要被拒绝，即拒绝转化为完成值，反之亦然。<br> • any([ .. ])<br> 这个模式与all([ .. ])类似，但是会忽略拒绝，所以只需要完成一个而不是全部。<br> • first([ .. ])<br> 这个模式类似于与any([ .. ])的竞争，即只要第一个Promise完成，它就会忽略后续的任何拒绝和完成。<br> • last([ .. ])<br> 这个模式类似于first([ .. ])，但却是只有最后一个完成胜出。</p><p><strong>并发迭代</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">21</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'Oops'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.map([p1, p2, p3], <span class="function"><span class="keyword">function</span>(<span class="params">pr, done</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(pr).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">      done(v * <span class="number">2</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 或者 map 到 promise 拒绝消息</span></span><br><span class="line">    done</span><br><span class="line">  )</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">vals</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(vals) <span class="comment">// [42, 84, 'Oops']</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-API-概述"><a href="#Promise-API-概述" class="headerlink" title="Promise API 概述"></a>Promise API 概述</h3><p><strong>new Promise(..)构造器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// resolve()</span></span><br><span class="line">  <span class="comment">// reject()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>reject(..)就是拒绝这个promise；但resolve(..)既可能完成promise，也可能拒绝，要根据传入参数而定。<br>如果传给resolve(..)的是一个非Promise、非thenable的立即值，这个promise就会用这个值完成。<br>但是，如果传给resolve(..)的是一个真正的Promise或thenable值，这个值就会被递归展开，并且（要构造的）promise将取用其最终决议值或状态。</p><p><strong>Promise.resolve(..)和Promise.reject(..)</strong><br>创建一个已被拒绝的Promise的快捷方式是使用Promise.reject(..)，所以以下两个promise是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="string">'Oops'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">'Oops'</span>)</span><br></pre></td></tr></table></figure><p>Promise.resolve(..)常用于创建一个已完成的Promise，使用方式与Promise.reject(..)类似。<br>但是，Promise.resolve(..)也会展开thenable值。<br>在这种情况下，返回的Promise采用传入的这个thenable的最终决议值，可能是完成，也可能是拒绝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fulfilledTh = &#123;</span><br><span class="line">  then:<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;cb(<span class="number">42</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rejectedTh = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">cb,errCb</span>)</span>&#123;</span><br><span class="line">    errCb(<span class="string">'Oops'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(fulfilledTh)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(rejectedTh)</span><br></pre></td></tr></table></figure><p>还要记住，如果传入的是真正的Promise, Promise.resolve(..)什么都不会做，只会直接把这个值返回。<br>所以，对你不了解属性的值调用Promise.resolve(..)，如果它恰好是一个真正的Promise，是不会有额外的开销的。</p><p><strong>then(..)和catch(..)</strong><br><strong>then(..)</strong> 接受一个或两个参数：第一个用于完成回调，第二个用于拒绝回调。<br>如果两者中的任何一个被省略或者作为非函数值传入的话，就会替换为相应的默认回调。<br>默认完成回调只是把消息传递下去，而默认拒绝回调则只是重新抛出（传播）其接收到的出错原因。</p><p><strong>catch(..)</strong> 只接受一个拒绝回调作为参数，并自动替换默认完成回调。换句话说，它等价于then(null, ..)：</p><p><strong>Promise.all([ .. ])和Promise.race([ .. ])</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'Oops'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg) <span class="comment">// 42</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err) <span class="comment">// Oops</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msgs) <span class="comment">// [42, 'hello world']</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h3 id="打破完整运行"><a href="#打破完整运行" class="headerlink" title="打破完整运行"></a>打破完整运行</h3><p><strong>输入和输出</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">var</span> res = it.next()</span><br><span class="line">res.value <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>1.迭代消息传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = x * (<span class="keyword">yield</span>)</span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">it.next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = it.next(<span class="number">7</span>)</span><br><span class="line">res.value <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>2.两个问题的故事<br>消息是双向传递的——yield.．作为一个表达式可以发出消息响应next(..)调用，next(..)也可以向暂停的yield表达式发送值</p><p><strong>多个迭代器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  z++</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span>(x*<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> z = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it1 = foo()</span><br><span class="line"><span class="keyword">var</span> it2 = foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> val1 = it1.next().value  <span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line"><span class="keyword">var</span> val2 = it2.next().value  <span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line"></span><br><span class="line">val1 = it1.next( val2 * <span class="number">10</span>).value  <span class="comment">// 40 &lt;-- x:20, z:2</span></span><br><span class="line">val2 = it2.next( val1 * <span class="number">5</span>).value  <span class="comment">// 600 &lt;-- x:200, z:3</span></span><br><span class="line"></span><br><span class="line">it1.next(val2/<span class="number">2</span>) <span class="comment">// y: 300  // 20 300 3</span></span><br><span class="line">it2.next(val1/<span class="number">4</span>) <span class="comment">// y: 10  // 200 10 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读完《你不知道的javaScript》系列的中卷中类型和语法部分，发现对于基础知识的理解更加透彻了。&lt;br&gt;之前计划是将中卷的两部分内容全部记录完毕，最后发现内容实在太多。&lt;br&gt;所以不得不将中卷分成两部分记录，现在我们开始异步和性能部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>ECharts 学习笔记</title>
    <link href="https://jambo0624.github.io/2019-06-22-echarts-example.html"/>
    <id>https://jambo0624.github.io/2019-06-22-echarts-example.html</id>
    <published>2019-06-22T00:14:40.000Z</published>
    <updated>2020-10-13T03:17:07.193Z</updated>
    
    <content type="html"><![CDATA[<p>最近在业务中遇到要应用 ECharts 展示数据的需求，没啥好说的，开始学呗。<br>下面我就不同图表的几个demo做如下记录，我们开始吧。</p><a id="more"></a><ul><li>基本示例</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ECharts<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 echarts.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/echarts/4.6.0/echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">style</span>=<span class="string">"width: 600px;height:400px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'main'</span>));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 指定图表的配置项和数据</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> option = &#123;</span></span><br><span class="line">        title: &#123;</span><br><span class="line"><span class="actionscript">          text: <span class="string">'ECharts 入门示例'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;&#125;,</span><br><span class="line">        legend: &#123;</span><br><span class="line"><span class="actionscript">          data:[<span class="string">'销量'</span>]</span></span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: &#123;</span><br><span class="line"><span class="actionscript">          data: [<span class="string">"衬衫"</span>,<span class="string">"羊毛衫"</span>,<span class="string">"雪纺衫"</span>,<span class="string">"裤子"</span>,<span class="string">"高跟鞋"</span>,<span class="string">"袜子"</span>]</span></span><br><span class="line">        &#125;,</span><br><span class="line">        yAxis: &#123;&#125;,</span><br><span class="line">        series: [&#123;</span><br><span class="line"><span class="actionscript">          name: <span class="string">'销量'</span>,</span></span><br><span class="line"><span class="actionscript">          type: <span class="string">'bar'</span>,</span></span><br><span class="line">          data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 使用刚指定的配置项和数据显示图表。</span></span></span><br><span class="line">      myChart.setOption(option);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/10/12/0RxkN9.png" alt="0RxkN9.png"></p><ul><li>接下来是入门示例的一些数据修改之后的样子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  title:&#123;<span class="attr">text</span>:<span class="string">"echarts 示例"</span>&#125;, <span class="comment">//标题</span></span><br><span class="line">  toolbox:&#123;<span class="attr">show</span>:<span class="literal">true</span>,<span class="attr">feature</span>:&#123;<span class="comment">//工具箱</span></span><br><span class="line">    saveAsImage: &#123;<span class="attr">show</span>:<span class="literal">true</span>&#125;<span class="comment">//保存图片</span></span><br><span class="line">  &#125;&#125;,</span><br><span class="line">  tooltip:&#123;&#125;,</span><br><span class="line">  legend:&#123;<span class="attr">data</span>:[<span class="string">"应气质"</span>]&#125;,  <span class="comment">//图例</span></span><br><span class="line">  xAxis:&#123;<span class="attr">data</span>:[<span class="string">"三只松鼠"</span>,<span class="string">"百果园"</span>,<span class="string">"植物园"</span>,<span class="string">"裤子码"</span>,<span class="string">"獭兔"</span>]&#125;, <span class="comment">//x轴内容</span></span><br><span class="line">  yAxis:&#123;&#125;, <span class="comment">//y轴空</span></span><br><span class="line">  series:[&#123;   <span class="comment">//显示数据</span></span><br><span class="line">    name:<span class="string">"应气质"</span>,<span class="attr">type</span>:<span class="string">"bar"</span>,<span class="attr">data</span>:[<span class="number">4</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;;</span><br><span class="line">myChart.setOption(option)</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2020/10/12/0RxAhR.png" alt="0RxAhR.png"></li><li>接下来是入门示例的一些设置修改之后的样子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option=&#123;</span><br><span class="line">  title:&#123;</span><br><span class="line">    text:<span class="string">"折线统计图"</span>,</span><br><span class="line">    show:<span class="literal">true</span>,</span><br><span class="line">    subtext:<span class="string">"库存统计图"</span>,</span><br><span class="line">    left:<span class="string">"left"</span>,<span class="comment">//标题位置 left center right</span></span><br><span class="line">    borderColor:<span class="string">"red"</span>,</span><br><span class="line">    borderWidth:<span class="number">3</span>,</span><br><span class="line">    textStyle:&#123;<span class="attr">fontSize</span>:<span class="number">20</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  toolbox:&#123;<span class="attr">show</span>:<span class="literal">true</span>,<span class="attr">feature</span>:&#123;</span><br><span class="line">    saveAsImage: &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    dataView:&#123;<span class="attr">show</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    restore:&#123;<span class="attr">show</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    dataZoom:&#123;<span class="attr">show</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    magicType: &#123;<span class="attr">type</span>:[<span class="string">"line"</span>,<span class="string">"bar"</span>]&#125;</span><br><span class="line">  &#125;&#125;,</span><br><span class="line">  legend:&#123;<span class="attr">data</span>:[<span class="string">"销量"</span>,<span class="string">"库存"</span>]&#125;,</span><br><span class="line">  xAxis:&#123;<span class="attr">data</span>:[<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>]&#125;,</span><br><span class="line">  yAxis:&#123;&#125;,</span><br><span class="line">  series:[</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">"销量"</span>,<span class="attr">type</span>:<span class="string">"line"</span>,<span class="attr">data</span>:[<span class="number">12</span>,<span class="number">21</span>,<span class="number">18</span>,<span class="number">29</span>,<span class="number">25</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">"库存"</span>,<span class="attr">type</span>:<span class="string">"bar"</span>,<span class="attr">data</span>:[<span class="number">122</span>,<span class="number">211</span>,<span class="number">118</span>,<span class="number">129</span>,<span class="number">125</span>]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2020/10/12/0RxV91.png" alt="0RxV91.png"></li><li>然后是仪表盘类型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option=&#123;</span><br><span class="line">  tooltip:&#123;&#125;,</span><br><span class="line">  toolbox:&#123;<span class="attr">feature</span>:&#123;<span class="attr">restore</span>:&#123;&#125;,<span class="attr">saveAsImage</span>:&#123;&#125;&#125;&#125;,</span><br><span class="line">  series:[&#123;<span class="attr">name</span>:<span class="string">"业务指标"</span>,<span class="attr">type</span>:<span class="string">"gauge"</span>,<span class="attr">data</span>:[&#123;<span class="attr">value</span>:<span class="number">32</span>,<span class="attr">name</span>:<span class="string">"完成率"</span>&#125;]&#125;]</span><br><span class="line">&#125;</span><br><span class="line">myChart.setOption(option)</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  option.series[<span class="number">0</span>].data[<span class="number">0</span>].value=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">100</span>)</span><br><span class="line">  myChart.setOption(option,<span class="literal">true</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2020/10/12/0Rxec6.png" alt="0Rxec6.png"></li><li>最后是饼状图<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option=&#123;</span><br><span class="line">  series:[&#123;</span><br><span class="line">    type:<span class="string">"pie"</span>,</span><br><span class="line">    radius:<span class="string">"70%"</span>,</span><br><span class="line">    center:[<span class="string">"50%"</span>,<span class="string">"50%"</span>],</span><br><span class="line">    data:[</span><br><span class="line">      &#123;<span class="attr">value</span>:<span class="number">335</span>,<span class="attr">name</span>:<span class="string">"视频广告"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">value</span>:<span class="number">135</span>,<span class="attr">name</span>:<span class="string">"搜索引擎"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">value</span>:<span class="number">125</span>,<span class="attr">name</span>:<span class="string">"邮件营销"</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">value</span>:<span class="number">115</span>,<span class="attr">name</span>:<span class="string">"直接访问"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2020/10/12/0RxZ1x.png" alt="0RxZ1x.png"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在业务中遇到要应用 ECharts 展示数据的需求，没啥好说的，开始学呗。&lt;br&gt;下面我就不同图表的几个demo做如下记录，我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="echarts" scheme="https://jambo0624.github.io/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>文件上传几种方法</title>
    <link href="https://jambo0624.github.io/2019-05-30-file-upload.html"/>
    <id>https://jambo0624.github.io/2019-05-30-file-upload.html</id>
    <published>2019-05-30T14:30:04.000Z</published>
    <updated>2020-10-13T07:49:55.140Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一个文件上传的问题，为了更好地解决问题。<br>自己也查阅了相关的各种资料，对文件上传的这些事有了更进一步的了解。<br>把这些知识点总结如下，我们开始吧。</p><a id="more"></a><h3 id="FileUpload-对象"><a href="#FileUpload-对象" class="headerlink" title="FileUpload 对象"></a>FileUpload 对象</h3><p>在网页上传文件，最核心元素就是这个HTML DOM的FileUpload对象了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就是他啊！其实在 HTML 文档中该标签每出现一次，一个 FileUpload 对象就会被创建。<br>该标签包含一个按钮，用来打开文件选择对话框，以及一段文字显示选中的文件名或提示没有文件被选中。</p><p>把这个标签放在<code>&lt;form&gt;</code>标签内，设置form的action为服务器目标上传地址，并点击submit按钮或通过JS调用form的submit()方法就可以实现最简单的文件上传了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"uploadForm"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"upload"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"myFile"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是我们现在要的都是页面无刷新上传！</p><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>我们现在使用的大都是XMLHttpRequest Level 2。</p><p>Level 1，有如下限制：</p><blockquote><p>仅支持文本数据传输, 无法传输二进制数据.<br>传输数据时, 没有进度信息提示, 只能提示是否完成.<br>受浏览器 同源策略 限制, 只能请求同域资源.<br>没有超时机制, 不方便掌控ajax请求节奏.</p></blockquote><p>而XMLHttpRequest Level 2针对这些缺陷做出了改进：</p><blockquote><p>支持二进制数据, 可以上传文件, 可以使用<code>FormData</code>对象管理表单.<br>提供进度提示, 可通过 <code>xhr.upload.onprogress</code> 事件回调方法获取传输进度.<br>依然受 <strong>同源策略</strong> 限制, 这个安全机制不会变. XHR2新提供 <code>Access-Control-Allow-Origin</code> 等headers, 设置为 * 时表示允许任何域名请求, 从而实现跨域<code>CORS访问</code><br>可以设置<code>timeout</code> 及 <code>ontimeout</code>, 方便设置超时时长和超时后续处理.</p></blockquote><p><strong>IE10以下是不支持XHR2的</strong></p><p>上面提到的FormData就是我们最常用的一种方式。通过在脚本里新建FormData对象，把File对象设置到表单项中，然后利用XMLHttpRequest异步上传到服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">"myFile"</span>);</span><br><span class="line"><span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">formdata.append(<span class="string">'myFile'</span>, file);</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">"POST"</span>, <span class="string">"/upload.php"</span>);</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="comment">//对请求成功的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.send(formData);</span><br><span class="line">xhr = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="上传进度"><a href="#上传进度" class="headerlink" title="上传进度"></a>上传进度</h3><p>XHR对象还有一个属性upload, 它返回一个XMLHttpRequestUpload 对象，这个对象拥有下列下列方法：</p><blockquote><p>onloadstart<br>onprogress<br>onabort<br>onerror<br>onload<br>ontimeout<br>onloadend</p></blockquote><p>这些方法在XHR对象中都存在同名版本，区别是后者是用于加载资源时，而前者用于资源上传时。<br>其中onprogress 事件回调方法可用于跟踪资源上传的进度，它的event参数对象包含两个重要的属性loaded和total。<br>分别代表当前已上传的字节数（number of bytes）和文件的总字节数。比如我们可以这样计算进度百分比：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">        <span class="keyword">var</span> percentComplete = (event.loaded / event.total) * <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 对进度进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中事件的lengthComputable属性代表文件总大小是否可知。<br>如果 lengthComputable 属性的值是 false，那么意味着总字节数是未知并且 total 的值为零。</p><p>如果是现代浏览器，可以直接配合HTML5提供的元素使用，方便快捷的显示进度条。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">id</span>=<span class="string">"myProgress"</span> <span class="attr">value</span>=<span class="string">"50"</span> <span class="attr">max</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其value属性绑定上面代码中的percentComplete的值即可。再进一步我们还可以对<code>&lt;progress&gt;</code>的样式统一调整，实现优雅降级方案，具体参见<a href="https://www.zhangxinxu.com/wordpress/2013/02/html5-progress-element-style-control/" target="_blank" rel="noopener">这篇文章</a>。</p><h3 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h3><p>普通的图片预览方式是待文件上传成功后，后台返回上传文件的url，然后把预览图片的img元素的src指向该url。这其实达不到预览的效果和目的。</p><p>此时现代浏览器又登场了：“使用HTML5的FileReader API吧！” 让我们直接上代码，直奔主题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleImageFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> previewArea = <span class="built_in">document</span>.getElementById(<span class="string">'previewArea'</span>);</span><br><span class="line">       <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">       <span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">"myFile"</span>);</span><br><span class="line">       <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">       img.file = file;</span><br><span class="line">       previewArea.appendChild(img);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">       reader.onload = (<span class="function"><span class="keyword">function</span>(<span class="params">aImg</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                 aImg.src = e.target.result;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;)(img);</span><br><span class="line">       reader.readAsDataURL(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用FileReader来处理图片的异步加载。<br>在创建新的FileReader对象之后，我们建立了onload函数，然后调用readAsDataURL()开始在后台进行读取操作。<br>当图像文件加载后，转换成一个 data: URL，并传递到onload回调函数中设置给img的src。</p><p>另外我们还可以通过使用对象URL来实现预览</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">img.src = <span class="built_in">window</span>.URL.createObjectURL(file);;</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 明确地通过调用释放</span></span><br><span class="line">    <span class="built_in">window</span>.URL.revokeObjectURL(<span class="keyword">this</span>.src);</span><br><span class="line">&#125;</span><br><span class="line">previewArea.appendChild(img);</span><br></pre></td></tr></table></figure><h3 id="多文件支持"><a href="#多文件支持" class="headerlink" title="多文件支持"></a>多文件支持</h3><p>文章一开头就登场的FileUpload对象，它有一个multiple属性。只要这样</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"myFile"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们就能在打开的文件选择对话框中选中多个文件了。<br>然后你在代码里拿到的FileUpload对象的files属性就是一个选中的多文件的数组了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">"myFile"</span>);</span><br><span class="line"><span class="keyword">var</span> files = fileInput.files;</span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = files[i];</span><br><span class="line">    formData.append(<span class="string">'files[]'</span>, file, file.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FormData</code>的<code>append</code>方法提供第三个可选参数用于指定文件名，这样就可以使用同一个表单项名，然后用文件名区分上传的多个文件。这样也方便前后台的循环操作。</p><h3 id="二进制上传"><a href="#二进制上传" class="headerlink" title="二进制上传"></a>二进制上传</h3><p>有了FileReader，其实我们还有一种上传的途径，读取文件内容后直接以二进制格式上传。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    xhr.sendAsBinary(<span class="keyword">this</span>.result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把从input里读取的文件内容，放到fileReader的result字段里</span></span><br><span class="line">reader.readAsBinaryString(file);</span><br></pre></td></tr></table></figure><p>不过chrome已经把XMLHttpRequest的sendAsBinary方法移除了。所以可能得自行实现一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest.prototype.sendAsBinary = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(text.length);</span><br><span class="line">    <span class="keyword">var</span> ui8a = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; text.length; i++)&#123; </span><br><span class="line">        ui8a[i] = (text.charCodeAt(i) &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.send(ui8a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将字符串转成8位无符号整型，然后存放到一个8位无符号整型数组里面，再把整个数组发送出去。</p><h3 id="拖拽的支持"><a href="#拖拽的支持" class="headerlink" title="拖拽的支持"></a>拖拽的支持</h3><p>利用HTML5的drag &amp; drop事件，我们可以很快实现对拖拽的支持。<br>首先我们可能需要确定一个允许拖放的区域，然后绑定相应的事件进行处理。看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dropArea;</span><br><span class="line"></span><br><span class="line">dropArea = <span class="built_in">document</span>.getElementById(<span class="string">"dropArea"</span>);</span><br><span class="line">dropArea.addEventListener(<span class="string">"dragenter"</span>, handleDragenter, <span class="literal">false</span>);</span><br><span class="line">dropArea.addEventListener(<span class="string">"dragover"</span>, handleDragover, <span class="literal">false</span>);</span><br><span class="line">dropArea.addEventListener(<span class="string">"drop"</span>, handleDrop, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻止dragenter和dragover的默认行为，这样才能使drop事件被触发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDragenter</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDragover</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDrop</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dt = e.dataTransfer;</span><br><span class="line">    <span class="keyword">var</span> files = dt.files;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle files ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以把通过事件对象的dataTransfer拿到的files数组和之前相同处理，以实现预览上传等功能。有了这些事件回调，我们也可以在不同的事件给我们UI元素添加不同的class来实现更好交互效果。</p><h3 id="借用iframe，实现IE10以下的浏览器如何实现无刷新上传"><a href="#借用iframe，实现IE10以下的浏览器如何实现无刷新上传" class="headerlink" title="借用iframe，实现IE10以下的浏览器如何实现无刷新上传"></a>借用iframe，实现IE10以下的浏览器如何实现无刷新上传</h3><p>之前说了要实现文件上传使用FileUpload对象即可。<br>这在低版本的IE里也是适用的。那我们为什么还要用iframe呢？</p><p>因为在现代浏览器中我们可以用XMLHttpRequest Level 2来支持二进制数据，异步文件上传，并且动态创建FormData。<br>而低版本的IE里的XMLHttpRequest是Level 1。所以我们通过XHR异步向服务器发上传请求的路走不通了。只能老老实实的用form的submit。</p><p>而form的submit会导致页面的刷新。原因分析好了，那么答案就近在咫尺了。我们能不能让form的submit不刷新整个页面呢？答案就是利用iframe。<br>把form的target指定到一个看不见的iframe，那么返回的数据就会被这个iframe接受，于是乎就只有这个iframe会刷新。而它又是看不见的，用户自然就感知不到了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.__iframeCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> hiddenframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line"><span class="keyword">var</span> frameName = <span class="string">"upload-iframe"</span> + ++<span class="built_in">window</span>.__iframeCount;</span><br><span class="line">hiddenframe.name = frameName;</span><br><span class="line">hiddenframe.id = frameName;</span><br><span class="line">hiddenframe.setAttribute(<span class="string">"style"</span>, <span class="string">"width:0;height:0;display:none"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(hiddenframe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line">form.target = frameName;</span><br></pre></td></tr></table></figure><p>然后响应iframe的onload事件，获取response</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hiddenframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取iframe的内容，即服务返回的数据</span></span><br><span class="line">    <span class="keyword">var</span> resData = <span class="keyword">this</span>.contentDocument.body.textContent || <span class="keyword">this</span>.contentWindow.document.body.textContent;</span><br><span class="line">    <span class="comment">// 处理数据 。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除iframe</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _frame = <span class="built_in">document</span>.getElementById(frameName);</span><br><span class="line">        _frame.parentNode.removeChild(_frame);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iframe的实现大致如此，但是如果文件上传的地址与当前页面不在同一个域下就会出现跨域问题。<br>导致iframe的onload回调里的访问服务返回的数据失败。</p><p>这时我们再祭出JSONP这把利剑，来解决跨域问题。<br>首先在上传之前注册一个全局的函数，把函数名发给服务器。<br>服务器需要配合在response里让浏览器直接调用这个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成全局函数名，避免冲突</span></span><br><span class="line"><span class="keyword">var</span> CALLBACK_NAME = <span class="string">'CALLBACK_NAME'</span>;</span><br><span class="line"><span class="keyword">var</span> genCallbackName = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CALLBACK_NAME + ++i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curCallbackName = genCallbackName();</span><br><span class="line"><span class="built_in">window</span>[curCallbackName] = <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理response 。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除iframe</span></span><br><span class="line">    <span class="keyword">var</span> _frame = <span class="built_in">document</span>.getElementById(frameName);</span><br><span class="line">    _frame.parentNode.removeChild(_frame);</span><br><span class="line">    <span class="comment">// 删除全局函数本身</span></span><br><span class="line">    <span class="built_in">window</span>[curCallbackName] = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已有其他参数，这里需要判断一下，改为拼接 &amp;callback=</span></span><br><span class="line">form.action = form.action + <span class="string">'?callback='</span> + curCallbackName;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到了一个文件上传的问题，为了更好地解决问题。&lt;br&gt;自己也查阅了相关的各种资料，对文件上传的这些事有了更进一步的了解。&lt;br&gt;把这些知识点总结如下，我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="file" scheme="https://jambo0624.github.io/tags/file/"/>
    
      <category term="upload" scheme="https://jambo0624.github.io/tags/upload/"/>
    
  </entry>
  
  <entry>
    <title>时间和日期的处理</title>
    <link href="https://jambo0624.github.io/2019-05-11-timeAndDate.html"/>
    <id>https://jambo0624.github.io/2019-05-11-timeAndDate.html</id>
    <published>2019-05-11T01:18:30.000Z</published>
    <updated>2020-10-12T09:50:58.005Z</updated>
    
    <content type="html"><![CDATA[<p>工作中遇到了一些需要对时间进行处理的场景。虽然在 utils 的 _kyt 对于时间的处理有了很好的封装<br>但是自己要想取得长足的进步，必须自己清楚底层的原理是为什么，尤其是要熟练掌握一些常用的处理。<br>下面我们开始吧</p><a id="more"></a><h3 id="标准时间"><a href="#标准时间" class="headerlink" title="标准时间"></a>标准时间</h3><p>GMT即「格林威治标准时间」(Greenwich Mean Time，简称G.M.T.)，指位于英国伦敦郊区的皇家格林威治天文台的标准时间，因为本初子午线被定义为通过那里的经线。然而由于地球的不规则自转，导致GMT时间有误差，因此目前已不被当作标准时间使用。<br>UTC是最主要的世界时间标准，是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间。<br>UTC比GMT来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。<br>不过日常使用中，GMT与UTC的功能与精确度是没有差别的。</p><h3 id="TimeZone-amp-UTC-Offsets-时区与偏移"><a href="#TimeZone-amp-UTC-Offsets-时区与偏移" class="headerlink" title="TimeZone&amp;UTC Offsets:时区与偏移"></a>TimeZone&amp;UTC Offsets:时区与偏移</h3><p>人们经常会把时区与UTC偏移量搞混，UTC偏移量代表了某个具体的时间值与UTC时间之间的差异，通常用HH:mm形式表述。<br>而TimeZone则表示某个地理区域，某个TimeZone中往往会包含多个偏移量，而多个时区可能在一年的某些时间有相同的偏移量。<br>譬如America/Chicago, America/Denver, 以及 America/Belize在一年中不同的时间都会包含 -06:00 这个偏移。</p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>Unix时间戳表示当前时间到1970年1月1日00:00:00 UTC对应的秒数。<br>注意，JavaScript内的时间戳指的是当前时间到1970年1月1日00:00:00 UTC对应的毫秒数，和unix时间戳不是一个概念，后者表示秒数，差了1000倍。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>JavaScript为我们提供了不是很好用的Date对象作为时间日期对象，Date()直接返回当前时间字符串，不管参数是number还是任何string。<br>而new Date()则是会根据参数来返回对应的值，无参数的时候，返回当前时间的字符串形式；有参数的时候返回参数所对应时间的字符串。<br>new Date()对参数不管是格式还是内容都要求,且只返回字符串。<br>标准的构造Date对象的方法有:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带new操作符，像一个函数一样调用。它将忽略所有传入的参数，并返回当前日期和时间的一个字符串表示。</span></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 可接受一个数字参数，该参数表示设定时间与1970年1月1日0点之间的毫秒数。</span></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line"><span class="comment">// 可接受一个字符串参数，参数形式类似于Date.parse()方法。但parse()方法返回的是一个数字，而Date()函数返回的是一个对象。</span></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Date</span>(dateString);</span><br><span class="line"><span class="comment">// 可接受参数形式类似于Date.UTC()方法的参数，但Date.UTC()方法返回是一个毫秒数，且是UTC时间，而Date()函数返回是一个对象，且是本地时间。</span></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Date</span>(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);</span><br><span class="line"><span class="comment">// year：四位年份，如果写成两位数，则加上1900</span></span><br><span class="line"><span class="comment">// month：表示月份，0表示一月，11表示12月</span></span><br><span class="line"><span class="comment">// date：表示日期，1到31</span></span><br><span class="line"><span class="comment">// hour：表示小时，0到23</span></span><br><span class="line"><span class="comment">// minute：表示分钟，0到59</span></span><br><span class="line"><span class="comment">// second：表示秒钟，0到59</span></span><br><span class="line"><span class="comment">// ms：表示毫秒，0到999</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，<strong>月份month参数，其计数方式从0开始，而天day参数，其计数方式从1开始。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">//Fri Aug 21 2015 15:51:55 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1293879600000</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2011-01-01T11:00:00'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2011/01/01 11:00:00'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'jan 01 2011,11 11:00:00'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Sat Jan 01 2011 11:00:00'</span>)</span><br><span class="line"><span class="comment">//Sat Jan 01 2011 11:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'sss'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2011/01/01T11:00:00'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2011-01-01-11:00:00'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1293879600000'</span>);</span><br><span class="line"><span class="comment">//Invalid Date</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2011-01-01T11:00:00'</span>)-<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1992/02/11 12:00:12'</span>)</span><br><span class="line"><span class="comment">//596069988000</span></span><br></pre></td></tr></table></figure><h3 id="Parse-解析"><a href="#Parse-解析" class="headerlink" title="Parse:解析"></a>Parse:解析</h3><p><strong>TimeStamp:时间戳</strong><br>如果需要从当前的时间对象获取其相应的时间戳，我们可以使用getTime或者valueOf()，返回距离1970年1月1日0点的毫秒数</p><p><strong>DateTimeString:时间日期字符串</strong><br>Date对象也有一个parse方法，用于解析一个日期字符串，参数是一个包含待解析的日期和时间的字符串，返回从1970年1月1日0点到给定日期的毫秒数。<br>该方法会根据日期时间字符串格式规则来解析字符串的格式，除了标准格式外，以下格式也支持。<br>如果字符串无法识别，将返回NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'6/13/2004'</span>);<span class="comment">//1087056000000</span></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'January 12,2004'</span>);<span class="comment">//1073836800000</span></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'Tue May 25 2004 00:00:00 GMT-0700'</span>);<span class="comment">//1085468400000</span></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'2004-05-25T00:00:00'</span>);<span class="comment">//1085443200000</span></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'2016'</span>);<span class="comment">//1451606400000</span></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'T00:00:00'</span>);<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Date</span>.parse();<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><h3 id="Manipulate-时间对象操作"><a href="#Manipulate-时间对象操作" class="headerlink" title="Manipulate:时间对象操作"></a>Manipulate:时间对象操作</h3><p><strong>Get &amp; Set</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d.getDate() <span class="comment">// 6</span></span><br><span class="line">d.getMonth() <span class="comment">// 0</span></span><br><span class="line">d.getYear() <span class="comment">// 113</span></span><br><span class="line">d.getFullYear() <span class="comment">// 2013</span></span><br><span class="line">d.getTimezoneOffset() <span class="comment">// -480</span></span><br></pre></td></tr></table></figure><p>同样的，Date对象还提供了一系列的Set方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d1.setDate(<span class="number">32</span>) <span class="comment">// 1359648000000</span></span><br><span class="line">d1 <span class="comment">// Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d.setDate(<span class="number">-1</span>) <span class="comment">// 1356796800000</span></span><br><span class="line">d <span class="comment">// Sun Dec</span></span><br></pre></td></tr></table></figure><p><strong>Add&amp;Subtract</strong><br>我们可以巧用Set方法的特性，set*方法的参数都会自动折算。<br>以setDate为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d1.setDate(<span class="number">32</span>) <span class="comment">// 1359648000000</span></span><br><span class="line">d1 <span class="comment">// Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d.setDate(<span class="number">-1</span>) <span class="comment">// 1356796800000</span></span><br><span class="line">d <span class="comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日期向后推1000天</span></span><br><span class="line">d.setDate( d.getDate() + <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间设为6小时后</span></span><br><span class="line">d.setHours(d.getHours() + <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将年份设为去年</span></span><br><span class="line">d.setFullYear(d.getFullYear() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>Diff:计算差值</strong><br>类型转换时，Date对象的实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。<br>所以，两个日期对象进行减法运算，返回的就是它们间隔的毫秒数；进行加法运算，返回的就是连接后的两个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d2 - d1</span><br><span class="line"><span class="comment">// 2678400000</span></span><br><span class="line">d2 + d1</span><br><span class="line"><span class="comment">// "Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)"</span></span><br></pre></td></tr></table></figure><h3 id="Display-时间展示"><a href="#Display-时间展示" class="headerlink" title="Display:时间展示"></a>Display:时间展示</h3><p><strong>Format:格式化</strong><br>Date对象提供了一系列的to*方法来支持从Date对象转化为字符串，具体的函数列表详见附录:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toString()</span><br><span class="line"><span class="comment">// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"</span></span><br><span class="line"></span><br><span class="line">d.toUTCString()</span><br><span class="line"><span class="comment">// "Mon, 31 Dec 2012 16:00:00 GMT"</span></span><br><span class="line"></span><br><span class="line">d.toISOString()</span><br><span class="line"><span class="comment">// "2012-12-31T16:00:00.000Z"</span></span><br><span class="line"></span><br><span class="line">d.toJSON()</span><br><span class="line"><span class="comment">// "2012-12-31T16:00:00.000Z"</span></span><br><span class="line"></span><br><span class="line">d.toDateString() <span class="comment">// "Tue Jan 01 2013"</span></span><br><span class="line"></span><br><span class="line">d.toTimeString() <span class="comment">// "00:00:00 GMT+0800 (CST)"</span></span><br><span class="line"></span><br><span class="line">d.toLocaleDateString()</span><br><span class="line"><span class="comment">// 中文版浏览器为"2013年1月1日"</span></span><br><span class="line"><span class="comment">// 英文版浏览器为"1/1/2013"</span></span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString()</span><br><span class="line"><span class="comment">// 中文版浏览器为"上午12:00:00"</span></span><br><span class="line"><span class="comment">// 英文版浏览器为"12:00:00 AM"</span></span><br></pre></td></tr></table></figure><p><strong>Durations:时长</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nMS = <span class="number">1320</span>; <span class="comment">//以毫秒单位表示的差值时间</span></span><br><span class="line"><span class="keyword">var</span> nD = <span class="built_in">Math</span>.floor(nMS/(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line"><span class="keyword">var</span> nH = <span class="built_in">Math</span>.floor(nMS/(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>)) % <span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> nM = <span class="built_in">Math</span>.floor(nMS/(<span class="number">1000</span>*<span class="number">60</span>)) % <span class="number">60</span>;</span><br><span class="line"><span class="keyword">var</span> nS = <span class="built_in">Math</span>.floor(nMS/<span class="number">1000</span>) % <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p><strong>i18n:国际化</strong></p><blockquote><p>浏览器获取当前用户所在的时区等信息只和系统的日期和时间设置里的时区以及时间有关。<br>区域和语言设置影响的是浏览器默认时间函数(Date.prototype.toLocaleString等)显示的格式，不会对时区等有影响。<br>Date有个Date.prototype.toLocaleString()方法可以将时间字符串返回用户本地字符串格式，这个方法还有两个子方法Date.prototype.toLocaleDateString和Date.prototype.toLocaleTimeString，这两个方法返回值分别表示日期和时间，加一起就是Date.prototype.toLocaleString的结果。<br>这个方法的默认参数会对时间字符串做一次转换，将其转换成用户当前所在时区的时间，并按照对应的系统设置时间格式返回字符串结果。<br>然而不同浏览器对用户本地所使用的语言格式的判断依据是不同的。</p></blockquote><ul><li><p>IE:获取系统当前的区域和语言-格式中设置的格式，依照其对应的格式来显示当前时间结果;IE浏览器实时查询该系统设置（即你在浏览器窗口打开后去更改系统设置也会引起返回格式变化）。假设系统语言为 ja-JP，系统unicode语言为zh-CN日期格式为nl-NL,浏览器语言设置（accept-language)为de,浏览器界面语言为en-US（其他条件不变，浏览器界面语言改为zh-CN的时候结果也是一样)，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.language</span><br><span class="line"><span class="comment">//"nl-NL"</span></span><br><span class="line"><span class="built_in">window</span>.navigator.systemLanguage</span><br><span class="line"><span class="comment">//"zh-CN"(设置中的非unicode程序所使用语言选项)</span></span><br><span class="line"><span class="built_in">window</span>.navigator.userLanguage</span><br><span class="line"><span class="comment">//"nl-NL"</span></span><br><span class="line"><span class="built_in">window</span>.navigator.browserLanguage</span><br><span class="line"><span class="comment">//"ja-JP"（系统菜单界面语言）</span></span><br><span class="line"><span class="built_in">window</span>.navigator.languages</span><br><span class="line"><span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li><li><p>FF：获取方式和结果与IE浏览器相同，区别在于FF只会在浏览器进程第一次启动的时候获取一次系统设置，中间不管怎么系统设置怎么变化，FF都无法获取到当前系统设置。除非重启FF浏览器。当浏览器界面语言为zh-CN,accept-language首位为en-US的时候：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.language</span><br><span class="line"><span class="comment">//'en-US'</span></span><br><span class="line"><span class="built_in">window</span>.navigator.languages</span><br><span class="line"><span class="comment">//["en-US", "zh-CN", "de", "zh", "en"]</span></span><br><span class="line"><span class="comment">//当界面语言改为"en-US",`accept-language`首位为`zh-CN`的时候</span></span><br><span class="line"><span class="built_in">window</span>.navigator.language</span><br><span class="line"><span class="comment">//'zh-CN'（`accept-language`首选值)</span></span><br><span class="line"><span class="built_in">window</span>.navigator.languages</span><br><span class="line"><span class="comment">//["zh-CN", "de", "zh", "en-US", "en"]</span></span><br></pre></td></tr></table></figure></li><li><p>Chrome:获取方式和以上两个都不同。chrome无视系统的区域和语言-格式格式，只依照自己浏览器的界面设置的菜单语言来处理。(比如英文界面则按系统’en-US’格式返回字符串，中文界面则按系统’zh-CN’格式返回结果)。当浏览器界面语言为zh-CN,accept-language首位为en-US的时候：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.language</span><br><span class="line"><span class="comment">//'zh-CN'</span></span><br><span class="line"><span class="built_in">window</span>.navigator.languages</span><br><span class="line"><span class="comment">//["en-US", "en", "zh-CN", "zh", "ja", "zh-TW", "de-LI", "de", "pl"]</span></span><br><span class="line"><span class="comment">//当界面语言改为"en-US"时</span></span><br><span class="line"><span class="built_in">window</span>.navigator.language</span><br><span class="line"><span class="comment">//'en-US'（浏览器界面语言)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Date-APIs"><a href="#Date-APIs" class="headerlink" title="Date APIs"></a>Date APIs</h2><p>Date 对象用于处理日期和时间。其核心的方法如下列表所示:</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Date()</td><td>返回当日的日期和时间。</td></tr><tr><td>getDate()</td><td>从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td></tr><tr><td>getDay()</td><td>从 Date 对象返回一周中的某一天 (0 ~ 6)。</td></tr><tr><td>getMonth()</td><td>从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td>getFullYear()</td><td>从 Date 对象以四位数字返回年份。</td></tr><tr><td>getYear()</td><td>请使用 getFullYear() 方法代替。</td></tr><tr><td>getHours()</td><td>返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td>getMinutes()</td><td>返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td>getSeconds()</td><td>返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td>getMilliseconds()</td><td>返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td>getTime()</td><td>返回 1970 年 1 月 1 日至今的毫秒数。</td></tr><tr><td>getTimezoneOffset()</td><td>返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td></tr><tr><td>getUTCDate()</td><td>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td></tr><tr><td>getUTCDay()</td><td>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td></tr><tr><td>getUTCMonth()</td><td>根据世界时从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td>getUTCFullYear()</td><td>根据世界时从 Date 对象返回四位数的年份。</td></tr><tr><td>getUTCHours()</td><td>根据世界时返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td>getUTCMinutes()</td><td>根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td>getUTCSeconds()</td><td>根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td></tr><tr><td>getUTCMilliseconds()</td><td>根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td>parse()</td><td>返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td></tr><tr><td>setDate()</td><td>设置 Date 对象中月的某一天 (1 ~ 31)。</td></tr><tr><td>setMonth()</td><td>设置 Date 对象中月份 (0 ~ 11)。</td></tr><tr><td>setFullYear()</td><td>设置 Date 对象中的年份（四位数字）。</td></tr><tr><td>setYear()</td><td>请使用 setFullYear() 方法代替。</td></tr><tr><td>setHours()</td><td>设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td>setMinutes()</td><td>设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td>setSeconds()</td><td>设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td>setMilliseconds()</td><td>设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td>setTime()</td><td>以毫秒设置 Date 对象。</td></tr><tr><td>setUTCDate()</td><td>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td></tr><tr><td>setUTCMonth()</td><td>根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td></tr><tr><td>setUTCFullYear()</td><td>根据世界时设置 Date 对象中的年份（四位数字）。</td></tr><tr><td>setUTCHours()</td><td>根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td>setUTCMinutes()</td><td>根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td>setUTCSeconds()</td><td>根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td>setUTCMilliseconds()</td><td>根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td>toSource()</td><td>返回该对象的源代码。</td></tr><tr><td>toString()</td><td>把 Date 对象转换为字符串。</td></tr><tr><td>toTimeString()</td><td>把 Date 对象的时间部分转换为字符串。</td></tr><tr><td>toDateString()</td><td>把 Date 对象的日期部分转换为字符串。</td></tr><tr><td>toGMTString()</td><td>请使用 toUTCString() 方法代替。</td></tr><tr><td>toUTCString()</td><td>根据世界时，把 Date 对象转换为字符串。</td></tr><tr><td>toLocaleString()</td><td>根据本地时间格式，把 Date 对象转换为字符串。</td></tr><tr><td>toLocaleTimeString()</td><td>根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td></tr><tr><td>toLocaleDateString()</td><td>根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td></tr><tr><td>UTC()</td><td>根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td></tr><tr><td>valueOf()</td><td>返回 Date 对象的原始值。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中遇到了一些需要对时间进行处理的场景。虽然在 utils 的 _kyt 对于时间的处理有了很好的封装&lt;br&gt;但是自己要想取得长足的进步，必须自己清楚底层的原理是为什么，尤其是要熟练掌握一些常用的处理。&lt;br&gt;下面我们开始吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="time" scheme="https://jambo0624.github.io/tags/time/"/>
    
      <category term="date" scheme="https://jambo0624.github.io/tags/date/"/>
    
  </entry>
  
  <entry>
    <title>数组API和字符串API区分对比</title>
    <link href="https://jambo0624.github.io/2019-05-02-arrayApi-vs-stringApi.html"/>
    <id>https://jambo0624.github.io/2019-05-02-arrayApi-vs-stringApi.html</id>
    <published>2019-05-02T10:22:23.000Z</published>
    <updated>2020-10-12T08:09:31.157Z</updated>
    
    <content type="html"><![CDATA[<p>之前的文章对于数组的 API 进行了整理，发现对于数组和字符串的 API 有了混淆<br>现在将两者都记录，并做一些比较。防止在使用中出现 bug </p><a id="more"></a><h3 id="对比数组API和字符串API"><a href="#对比数组API和字符串API" class="headerlink" title="对比数组API和字符串API"></a>对比数组API和字符串API</h3><p><strong>数组：</strong>    </p><blockquote><p><code>slice(start,end)</code>  截取数组元素, start表示开始，end表示结束(不包含end本身)  start ~ end-1;如果end为空，表示截取到最后[包左不包右]<br><code>splice(start,count,value...)</code> 删除数组元素，start表示开始，count表示删除的数量，value表示删除后替换的元素；如果count为空，表示删除到最后[返回的是被删除的元素][替换、添加、删除]</p></blockquote><p><strong>字符串：</strong>    </p><blockquote><p><code>slice(start, end)</code> 截取字符串，start开始的下标，end是结束的下标；范围start~end-1。如果end为空，从start到结尾；负数表示倒数第几个。<br><code>substring(start, end)</code> 和slice作用几乎一致，区别在于不支持负数写法，如果参数为负数，自动转成0。<br><code>split(参数)</code> 将字符串按照指定的字符转换为数组——切割字符串，参数指定的字符    </p></blockquote><p><strong>字符串API</strong><br>◆<code>charAt</code>：根据字符串位置的索引返回指定字符<br>◆<code>charCodeAt</code>：根据字符串位置的索引返回指定字符的十进制的unicode编码的数值。<br>◆<code>indexOf</code>：根据字符串的字符返回索引值， 从前往后搜索。<br>◆<code>lastIndexOf</code>：根据字符串的字符返回索引值，从后往前搜索<br>◆<code>encodeURIComponent</code>：对url地址进行uri编码，他是window对象的方法，方法参数是字符串。<br>◆<code>decodeURICompoent</code>：对uri编码后的url进行解码，他是window对象的方法，方法参数是字符串。<br>◆<code>concat</code>：连接两个字符串，+的底层用的就是这个方法<br>◆<code>slice</code>：截取划分，和数组的silce方法类似，也是指定起始索引和结束索引，来截取原字符串返回新字符串，也是截取时包括左边的索引不包括右边的索引，索引为负数则为字符串的长度加上这个负数索引，如果起始索引大于结束索引则会返回空字符串，如果只有一个起始索引则会截取到最后。<br>◆<code>substr</code>：截取，和数组的splice方法类似，只不过这个方法只有截取没有替换，指定起始索引和要截取的长度来截取字符串，长度过大就直接等于字符串的长度，长度为负数则为0，索引为负数则字符串的长度加上这个负数索引。<br>◆<code>substring</code>：截取划分，和字符串的slice方法类似，只不过不同的地方是，索引为负数，那么直接返回全部字符串，如果起始索引大于结束索引，就会智能替换，把小的索引作为起始索引，大的索引作为结束索引。<br>◆<code>trim</code>：去掉字符串开头部分与结束部分的空格(IE678不支持，但是可以自己封装)。<br>◆<code>replace</code>：替换原字符串返回新字符串，第一个参数是原字符串中的某一段字符串，第二个参数是替换掉原字符串中的某一段字符串的字符串，使用str.replace(/\s/gi,””)可以替换掉所有的空格，这种方式叫做正则表达式。<br>◆<code>join</code>与<code>split</code>方法，数组通过join方法变成字符串，字符串通过split方法变成数组<br>◆<code>str.toLowerCase()</code>;//将str变量中的字母无论大小写都变成小写的字母，这个方法会返回新的字符串。<br>◆<code>str.toUpperCase()</code>;//将str变量中的字母无论大小写都变成大写的字母，这个方法会返回新的字符串。<br>◆<code>anchor()</code>方法:    <code>&quot;我是一个锚点&quot;.anchor(&quot;mao&quot;)</code>等于<code>&lt;a name=&quot;mao&quot;&gt;我是一个锚点&lt;/a&gt;</code><br>◆<code>link()</code>方法:   <code>&quot;我是一个超链接&quot;.link(&quot;http://www.baidu.com&quot;)</code>等于<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;我是一个超链接&lt;/a&gt;</code>（记住这个） </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的文章对于数组的 API 进行了整理，发现对于数组和字符串的 API 有了混淆&lt;br&gt;现在将两者都记录，并做一些比较。防止在使用中出现 bug &lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="array" scheme="https://jambo0624.github.io/tags/array/"/>
    
      <category term="api" scheme="https://jambo0624.github.io/tags/api/"/>
    
      <category term="string" scheme="https://jambo0624.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>数组常用的API整理</title>
    <link href="https://jambo0624.github.io/2019-04-21-array-api.html"/>
    <id>https://jambo0624.github.io/2019-04-21-array-api.html</id>
    <published>2019-04-21T06:04:47.000Z</published>
    <updated>2020-10-12T07:59:29.915Z</updated>
    
    <content type="html"><![CDATA[<p>工作中的许多数据交换都是采取数组的形式，想要快速灵活高效的对数据进行操作，就要对于数组的API非常熟练。<br>这篇文章主要是对数组相关API进行整理，并作出详细对比。</p><a id="more"></a><ul><li><p>01、push()：将value添加到数组的最后，返回新数组的长度(改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.push(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)    <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(a)         <span class="comment">// [1, 2, 3, 4, 5, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">result = a.push(<span class="string">'a'</span>, <span class="string">'b'</span>)      <span class="comment">// 可一次添加多个值</span></span><br><span class="line"><span class="built_in">console</span>.log(result)            <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(a)                 <span class="comment">// [1, 2, 3, 4, 5, 1, 'a', 'b']</span></span><br></pre></td></tr></table></figure></li><li><p>02、unshift()：添加元素到数组的开头，返回新数组的长度(改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.unshift(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)        <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(a)             <span class="comment">// [1, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">result = a.unshift(<span class="string">'a'</span>, <span class="string">'b'</span>)  <span class="comment">// 可一次添加多个值</span></span><br><span class="line"><span class="built_in">console</span>.log(result)           <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(a)                <span class="comment">// ['a', 'b', 1, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>03、pop()：删除数组中最后一个元素，返回被删除的元素(改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.pop()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">result = a.pop()     <span class="comment">// 数组为空数组后，执行pop()方法，返回undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// []</span></span><br></pre></td></tr></table></figure></li><li><p>04、shift()：删除数组第一个元素，返回被删除的元素(改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.shift()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">result = a.shift()     <span class="comment">// 数组为空数组后，执行pop()方法，返回undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(result)    <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a)         <span class="comment">// []</span></span><br></pre></td></tr></table></figure></li><li><p>05、join(value)：将数组用value连接为字符串，返回被连接后的字符串(不改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.join()</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">result = a.join(<span class="string">''</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// 12345</span></span><br><span class="line">result = a.join(<span class="string">','</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">result = a.join(<span class="string">'&amp;'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// 1&amp;2&amp;3&amp;4&amp;5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'调用了toString()方法！'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line">&#125;,</span><br><span class="line">toValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'调用了toValue()方法！'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = a.join(obj)  <span class="comment">// 使用对象时会调用对象自身的toString方法，我们这里重写了toString</span></span><br><span class="line"><span class="comment">// 调用了toString()方法</span></span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 1a2a3a4a5</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中的join()方法相对的一个方法是字符串的split()方法</span></span><br><span class="line"><span class="built_in">console</span>.log(result.split(<span class="string">'a'</span>))  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>06、reverse()：反转数组，返回反转后的新数组(改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, ,<span class="number">3</span>, ,<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">//  [5, 4 ,3 ,2 ,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)        <span class="comment">//  [5, 4 ,3 ,2 ,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">result = a.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(result)   <span class="comment">// [[4, 5], [2, 3], 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)        <span class="comment">// [[4, 5], [2, 3], 1]</span></span><br><span class="line"><span class="comment">// 可以看到这里的反转只是基于数组的第一层，属于浅反转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的深反转需要使用递归实现</span></span><br><span class="line"><span class="keyword">const</span> deepReverse = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> temp = array.reverse()</span><br><span class="line">temp.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(v) === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">    deepReverse(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line">a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">result = deepReverse(a)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [[5, 4], [3, 2], 1]</span></span><br></pre></td></tr></table></figure></li><li><p>07、slice(start, end)：获取子数组，包含原数组索引start的值到索引end的值，不包含end，返回获取的子数组(不改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.slice(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)       <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">1</span>))       <span class="comment">// [2, 3, 4, 5]  只有一个参数且不小于0时，则从此索引开始截取到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">-1</span>))      <span class="comment">// [5]  只有一个参数且小于0时，则从倒数|start|位截取到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">-1</span>, <span class="number">1</span>))   <span class="comment">// []   反向截取，不合法，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">1</span>, <span class="number">-1</span>))   <span class="comment">// [2, 3, 4]  从第1位截取到倒数第1位</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">-1</span>, <span class="number">-2</span>))  <span class="comment">// []   反向截取，不合法，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">-2</span>, <span class="number">-1</span>))  <span class="comment">// [4]  倒数第2位截取到倒数第1位</span></span><br></pre></td></tr></table></figure></li><li><p>08、splice(index, count, value1, value2….)：从索引位index处删除count个元素，插入value1, value2等元素，返回被删除的元素组成的新数组(改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 0, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">-2</span>))  <span class="comment">// [4, 5]  当参数为单个且小于0时，将截取从倒数|index|位到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a)             <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">-1</span>))  <span class="comment">// [5]  当参数为单个且小于0时，将截取从倒数|index|位到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a)             <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">0</span>))  <span class="comment">// [1, 2, 3, 4, 5] 当参数为单个且不小于0时，将截取从index位到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a)            <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">1</span>))  <span class="comment">// [2, 3, 4, 5]  当参数为单个且不小于0时，将截取从index位到数组的末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(a)            <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">-1</span>, <span class="number">2</span>))   <span class="comment">// [5]  从倒数第1位开始截取两个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(a)                 <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>))  <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// ['a', 'b', 'c', 3, 4, 5]  截取后将value值依次填充到截取位置处，旧值被向后顺移</span></span><br></pre></td></tr></table></figure></li><li><p>09、sort()：对数组元素进行排序，返回排序后的新数组(改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">31</span>, <span class="number">22</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.sort()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [1, 22, 27, 31, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 22, 27, 31, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">a = [<span class="string">'c'</span>, <span class="string">'ac'</span>, <span class="string">'ab'</span>, <span class="string">'A1'</span>, <span class="string">'1c'</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="string">'13'</span>, <span class="string">'12'</span>, <span class="string">'3'</span>, <span class="string">'2'</span>, <span class="string">'1b'</span>, <span class="string">'1a'</span>, <span class="number">1</span>, <span class="string">'aa'</span>, <span class="string">'a'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [1, 12, "12", 13, "13", "1a", "1b", "1c", "2", 2, "3", 3, "A1", "a", "aa", "ab", "ac", "b", "c"]</span></span><br><span class="line"><span class="comment">// 可以看出sort排序是根据每个字符对应的ASCII码值进行排序的，而非值的大小。</span></span><br><span class="line"><span class="comment">// 先比较第一位的ASCII码值，如果第一位的ASCII码值相同，则开始比较第二位的ASCII码值，以此类推</span></span><br><span class="line"><span class="comment">// ASCII码表(http://tool.oschina.net/commons?type=4 + K)</span></span><br><span class="line">a = [<span class="number">31</span>, <span class="number">22</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br><span class="line">a.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 9, 22, 27, 31]  按数值大小正序排列</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">31</span>, <span class="number">22</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br><span class="line">a.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b - a</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [31, 27, 22, 9, 1]  按数值大小倒序排列</span></span><br></pre></td></tr></table></figure></li><li><p>10、toString()：将数组中的元素用逗号拼接成字符串，返回拼接后的字符串(不改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.toString()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 1,2,3,4,5</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了toString()方法之外，String()方法也可以将数组转换成字符串</span></span><br><span class="line">result = <span class="built_in">String</span>(a)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure></li><li><p>11、indexOf(value)：从索引为0开始，检查数组中是否包含有value，有则返回匹配到的第一个索引，没有则返回-1(不改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.indexOf(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">result = a.indexOf(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>12、lastIndexOf(value)：从最后的索引开始，检查数组找那个是否包含value，有则返回匹配到的第一个索引，没有返回-1(不改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = a.lastIndexOf(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">result = a.lastIndexOf(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>13、concat(value)：将数组和(或)值连接成新数组，返回新数组(不改变原数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>], b = [<span class="number">3</span>, <span class="number">4</span>], c = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> result = a.concat(b, c)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// More</span></span><br><span class="line">b = [<span class="number">3</span>, [<span class="number">4</span>]]</span><br><span class="line">result = a.concat(b, c) </span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// [1, 2, 3, [4], 5]  concat对于嵌套数组无法拉平</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure></li><li><p>14、forEach()：对数组进行遍历循环，对数组中每一项运行给定函数，参数都是function类型，默认有传参，参数分别为：遍历数组内容、对应的数组索引、数组本身。没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item + <span class="string">'|'</span> + index + <span class="string">'|'</span> + (a === <span class="literal">true</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// 1|0|true</span></span><br><span class="line"><span class="comment">// 2|1|true</span></span><br><span class="line"><span class="comment">// 3|2|true</span></span><br><span class="line"><span class="comment">// 4|3|true</span></span><br><span class="line"><span class="comment">// 5|4|true</span></span><br></pre></td></tr></table></figure></li><li><p>15、map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item * item</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></li><li><p>16、filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> index % <span class="number">3</span> === <span class="number">0</span> || item &gt;= <span class="number">8</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// [1, 4, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure></li><li><p>17、every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>18、some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &lt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> item &lt; <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>19、 reduce():接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值</p></li></ul><p><strong>语法:</strong> <code>array.reduce(function(previousValue, currentValue, currentIndex, arr), initialValue)</code><br>如果initialValue省略，则previousValue和currentValue分别为数组中的第一项元素和第二项元素；如果initialValue存在，则previousValue为initialValue，而currentValue为数组中的第一项<br><strong>注意:</strong> reduce() 对于空数组是不会执行回调函数的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = arr.reduce(<span class="function">(<span class="params">previousValue, currentValue, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue</span><br><span class="line">&#125;，<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result1:'</span>, result1) <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = arr.reduce(<span class="function">(<span class="params">previousValue, currentValue, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result2:'</span>, result2) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>综上可知，改变原数组的API如下：<br>   <code>push()、unshift()、pop()、shift()、reverse()、splice()、sort()</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中的许多数据交换都是采取数组的形式，想要快速灵活高效的对数据进行操作，就要对于数组的API非常熟练。&lt;br&gt;这篇文章主要是对数组相关API进行整理，并作出详细对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="array" scheme="https://jambo0624.github.io/tags/array/"/>
    
      <category term="api" scheme="https://jambo0624.github.io/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>一些常用正则表达式</title>
    <link href="https://jambo0624.github.io/2019-04-13-regExp-example.html"/>
    <id>https://jambo0624.github.io/2019-04-13-regExp-example.html</id>
    <published>2019-04-13T02:50:22.000Z</published>
    <updated>2020-10-12T07:41:00.511Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中经常会用到一些验证规则，但是对于正则表达式的熟练程度还不够。所以经常需要google，比较麻烦。<br>这篇文章整理了一些常用的正则表达式，以便查阅。</p><a id="more"></a><h3 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字</span></span><br><span class="line">^[<span class="number">0</span><span class="number">-9</span>]*$</span><br><span class="line"></span><br><span class="line"><span class="comment">// n位的数字</span></span><br><span class="line">^\d&#123;n&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至少n位的数字</span></span><br><span class="line">^\d&#123;n,&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// m-n位的数字</span></span><br><span class="line">^\d&#123;m,n&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 零和非零开头的数字</span></span><br><span class="line">^(<span class="number">0</span>|[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非零开头的最多带两位小数的数字</span></span><br><span class="line">^([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带1-2位小数的正数或负数</span></span><br><span class="line">^(\-)?\d+(\.\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正数、负数、和小数</span></span><br><span class="line">^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有两位小数的正实数</span></span><br><span class="line">^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有1~3位小数的正实数</span></span><br><span class="line">^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非零的正整数</span></span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\d*$ 或 ^([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;$ 或 ^\+?[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非零的负整数</span></span><br><span class="line">^\-[<span class="number">1</span><span class="number">-9</span>][]<span class="number">0</span><span class="number">-9</span>*$ 或 ^-[<span class="number">1</span><span class="number">-9</span>]\d*$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非负整数</span></span><br><span class="line">^\d+$ 或 ^[<span class="number">1</span><span class="number">-9</span>]\d*|<span class="number">0</span>$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非正整数</span></span><br><span class="line">^-[<span class="number">1</span><span class="number">-9</span>]\d*|<span class="number">0</span>$ 或 ^((-\d+)|(<span class="number">0</span>+))$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非负浮点数</span></span><br><span class="line">^\d+(\.\d+)?$ 或 ^[<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*|<span class="number">0</span>?\<span class="number">.0</span>+|<span class="number">0</span>$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非正浮点数</span></span><br><span class="line">^((-\d+(\.\d+)?)|(<span class="number">0</span>+(\<span class="number">.0</span>+)?))$ 或 ^(-([<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*))|<span class="number">0</span>?\<span class="number">.0</span>+|<span class="number">0</span>$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正浮点数</span></span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*$ 或 ^(([<span class="number">0</span><span class="number">-9</span>]+\.[<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)|([<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*\.[<span class="number">0</span><span class="number">-9</span>]+)|([<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*))$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负浮点数</span></span><br><span class="line">^-([<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*)$ 或 ^(-(([<span class="number">0</span><span class="number">-9</span>]+\.[<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)|([<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*\.[<span class="number">0</span><span class="number">-9</span>]+)|([<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)))$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line">^(-?\d+)(\.\d+)?$ 或 ^-?([<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*|<span class="number">0</span>?\<span class="number">.0</span>+|<span class="number">0</span>)$</span><br></pre></td></tr></table></figure><h3 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉字：</span></span><br><span class="line">^[\u4e00-\u9fa5]&#123;<span class="number">0</span>,&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 英文和数字：</span></span><br><span class="line">^[A-Za-z0<span class="number">-9</span>]+$ 或 ^[A-Za-z0<span class="number">-9</span>]&#123;<span class="number">4</span>,<span class="number">40</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为3-20的所有字符：</span></span><br><span class="line">^.&#123;<span class="number">3</span>,<span class="number">20</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由26个英文字母组成的字符串：</span></span><br><span class="line">^[A-Za-z]+$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由26个大写英文字母组成的字符串：</span></span><br><span class="line">^[A-Z]+$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由26个小写英文字母组成的字符串：</span></span><br><span class="line">^[a-z]+$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由数字和26个英文字母组成的字符串：</span></span><br><span class="line">^[A-Za-z0<span class="number">-9</span>]+$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由数字、26个英文字母或者下划线组成的字符串：</span></span><br><span class="line">^\w+$ 或 ^\w&#123;<span class="number">3</span>,<span class="number">20</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中文、英文、数字包括下划线：</span></span><br><span class="line">^[\u4E00-\u9FA5A-Za-z0<span class="number">-9</span>_]+$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中文、英文、数字但不包括下划线等符号：</span></span><br><span class="line">^[\u4E00-\u9FA5A-Za-z0<span class="number">-9</span>]+$ 或 ^[\u4E00-\u9FA5A-Za-z0<span class="number">-9</span>]&#123;<span class="number">2</span>,<span class="number">20</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以输入含有^%&amp;',;=?$\"等字符：</span></span><br><span class="line">[^%&amp;<span class="string">',;=?$\x22]+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 禁止输入含有~的字符：</span></span><br><span class="line"><span class="string">[^~\x22]+</span></span><br></pre></td></tr></table></figure><h3 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Email地址：</span></span><br><span class="line">^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 域名：</span></span><br><span class="line">[a-zA-Z0<span class="number">-9</span>][-a-zA-Z0<span class="number">-9</span>]&#123;<span class="number">0</span>,<span class="number">62</span>&#125;(<span class="regexp">/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/</span>.?</span><br><span class="line"></span><br><span class="line"><span class="comment">// InternetURL：</span></span><br><span class="line">[a-zA-z]+:<span class="comment">//[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机号码：</span></span><br><span class="line">^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">15</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">16</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">17</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">18</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">19</span>[<span class="number">0</span><span class="number">-9</span>])\d&#123;<span class="number">8</span>&#125;$ (由于工信部放号段不定时，所以建议使用泛解析 ^([<span class="number">1</span>][<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])\d&#123;<span class="number">9</span>&#125;$)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：</span></span><br><span class="line">^(\(\d&#123;<span class="number">3</span>,<span class="number">4</span>&#125;-)|\d&#123;<span class="number">3.4</span>&#125;-)?\d&#123;<span class="number">7</span>,<span class="number">8</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 国内电话号码(0511-4405222、021-87888822)：</span></span><br><span class="line">\d&#123;<span class="number">3</span>&#125;-\d&#123;<span class="number">8</span>&#125;|\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 18位身份证号码(数字、字母x结尾)：</span></span><br><span class="line">^((\d&#123;<span class="number">18</span>&#125;)|([<span class="number">0</span><span class="number">-9</span>x]&#123;<span class="number">18</span>&#125;)|([<span class="number">0</span><span class="number">-9</span>X]&#123;<span class="number">18</span>&#125;))$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：</span></span><br><span class="line">^[a-zA-Z][a-zA-Z0<span class="number">-9</span>_]&#123;<span class="number">4</span>,<span class="number">15</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：</span></span><br><span class="line">^[a-zA-Z]\w&#123;<span class="number">5</span>,<span class="number">17</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：</span></span><br><span class="line">^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;<span class="number">8</span>,<span class="number">10</span>&#125;$</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 日期格式：</span></span><br><span class="line">^\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一年的12个月(01～09和1～12)：</span></span><br><span class="line">^(<span class="number">0</span>?[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个月的31天(01～09和1～31)：</span></span><br><span class="line">^((<span class="number">0</span>?[<span class="number">1</span><span class="number">-9</span>])|((<span class="number">1</span>|<span class="number">2</span>)[<span class="number">0</span><span class="number">-9</span>])|<span class="number">30</span>|<span class="number">31</span>)$</span><br><span class="line"></span><br><span class="line"><span class="comment">// xml文件：</span></span><br><span class="line">^([a-zA-Z]+-?)+[a-zA-Z0<span class="number">-9</span>]+\\.[x|X][m|M][l|L]$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中文字符的正则表达式：</span></span><br><span class="line">[\u4e00-\u9fa5]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双字节字符：</span></span><br><span class="line">[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计<span class="number">2</span>，ASCII字符计<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空白行的正则表达式：</span></span><br><span class="line">\n\s*\r    (可以用来删除空白行)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML标记的正则表达式：</span></span><br><span class="line">&lt;(\S*?)[^&gt;]*&gt;.*?&lt;<span class="regexp">/\1&gt;|&lt;.*? /</span>&gt;    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首尾空白字符的正则表达式：</span></span><br><span class="line">^\s*|\s*$或(^\s*)|(\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 腾讯QQ号：</span></span><br><span class="line">[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">4</span>,&#125;    (腾讯QQ号从<span class="number">10000</span>开始)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中国邮政编码：</span></span><br><span class="line">[<span class="number">1</span><span class="number">-9</span>]\d&#123;<span class="number">5</span>&#125;(?!\d)    (中国邮政编码为<span class="number">6</span>位数字)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址：</span></span><br><span class="line">\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址：</span></span><br><span class="line">((?:(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\\d|[<span class="number">01</span>]?\\d?\\d)\\.)&#123;<span class="number">3</span>&#125;(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\\d|[<span class="number">01</span>]?\\d?\\d))</span><br></pre></td></tr></table></figure><h3 id="钱的输入格式："><a href="#钱的输入格式：" class="headerlink" title="钱的输入格式："></a>钱的输入格式：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：</span></span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：</span></span><br><span class="line">^(<span class="number">0</span>|[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：</span></span><br><span class="line">^(<span class="number">0</span>|-?[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：</span></span><br><span class="line">^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]+)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：</span></span><br><span class="line">^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：</span></span><br><span class="line">^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：</span></span><br><span class="line">^[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(,[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">3</span>&#125;)*(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：</span></span><br><span class="line">^([<span class="number">0</span><span class="number">-9</span>]+|[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(,[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">3</span>&#125;)*)(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)</span></span><br><span class="line"><span class="comment">// 最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作中经常会用到一些验证规则，但是对于正则表达式的熟练程度还不够。所以经常需要google，比较麻烦。&lt;br&gt;这篇文章整理了一些常用的正则表达式，以便查阅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="regExp" scheme="https://jambo0624.github.io/tags/regExp/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (中卷)》</title>
    <link href="https://jambo0624.github.io/2019-03-19-dont-know-js-second.html"/>
    <id>https://jambo0624.github.io/2019-03-19-dont-know-js-second.html</id>
    <published>2019-03-19T13:04:39.000Z</published>
    <updated>2020-10-12T07:01:07.333Z</updated>
    
    <content type="html"><![CDATA[<p>之前读了《你不知道的javaScript》系列的上卷，感觉对于理解 js 的核心概念十分有效。<br>最近又将中卷的部分读完了，下面对于中卷的内容进行一些记录。<br>中卷主要是分语法和类型，异步和性能两方面。下面我们开始。</p><a id="more"></a><h1 id="类型和语法"><a href="#类型和语法" class="headerlink" title="类型和语法"></a>类型和语法</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>JavaScript有七种内置类型：</p><blockquote><p>空值（null）<br>未定义（undefined）<br>布尔值（boolean）<br>数字（number）<br>字符串（string）<br>对象（object）<br>符号（symbol, ES6中新增）</p></blockquote><p>除对象之外，其他统称为“基本类型”。</p><h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>使用delete运算符可以将单元从数组中删除，但是请注意，<strong>单元删除后，数组的length属性并不会发生变化。</strong><br>如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line">a[<span class="string">'13'</span>] = <span class="number">42</span></span><br><span class="line">a.length <span class="comment">// 14</span></span><br></pre></td></tr></table></figure><p><strong>类数组</strong><br>例如，一些DOM查询操作会返回DOM元素列表，它们并非真正意义上的数组，但十分类似。<br>另一个例子是通过arguments对象（类数组）将函数的参数当作列表来访问（从ES6开始已废止）。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript中字符串是不可变的，而数组是可变的。<br>字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。<br>而数组的成员函数都是在其原始值上进行操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'foo'</span></span><br><span class="line">c = a.toUpperCase()</span><br><span class="line">a === c <span class="comment">// false</span></span><br><span class="line">a <span class="comment">// 'foo'</span></span><br><span class="line">c <span class="comment">// 'FOO'</span></span><br><span class="line"></span><br><span class="line">b.push(<span class="string">'! '</span>)</span><br><span class="line">b <span class="comment">// ['f', 'o', 'o', '! ']</span></span><br></pre></td></tr></table></figure><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>与大部分现代编程语言（包括几乎所有的脚本语言）一样，JavaScript中的数字类型是基于IEEE 754标准来实现的，该标准通常也被称为“浮点数”。<br>JavaScript使用的是<strong>双精度</strong>格式（即64位二进制）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效语法</span></span><br><span class="line"><span class="number">42.</span>toFixed( <span class="number">3</span> ) <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的语法都有效</span></span><br><span class="line">(<span class="number">42</span>).toFixed( <span class="number">3</span> )  <span class="comment">// '42.000'</span></span><br><span class="line"><span class="number">0.42</span>.toFixed( <span class="number">3</span> )  <span class="comment">// '0.420'</span></span><br><span class="line"><span class="number">42.</span>.toFixed( <span class="number">3</span> )  <span class="comment">// '42.000'</span></span><br></pre></td></tr></table></figure><p><strong>较小的数值</strong><br>二进制浮点数最大的问题（不仅JavaScript，所有遵循IEEE 754规范的语言都是如此），是会出现如下情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>简单来说，二进制浮点数中的0.1和0.2并不是十分精确，它们相加的结果并非刚好等于0.3，而是一个比较接近的数字0.30000000000000004，所以条件判断结果为false。<br>那么应该怎样来判断0.1 + 0.2和0.3是否相等呢？最常见的方法是设置一个误差范围值，通常称为“机器精度”（machineepsilon），对JavaScript的数字来说，这个值通常是2^-52</p><p><strong>特殊数值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line">+<span class="literal">Infinity</span></span><br><span class="line">-<span class="literal">Infinity</span></span><br><span class="line"><span class="number">-0</span></span><br></pre></td></tr></table></figure><p><strong>特殊等式</strong><br>NaN和-0在相等比较时的表现有些特别。<br>由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN(..)（或者polyfill）。<br>而-0等于0（对于===也是如此），因此我们必须使用isNegZero(..)这样的工具函数。</p><h3 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a><strong>值和引用</strong></h3><p>简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值/传递，包括null、undefined、字符串、数字、布尔和ES6中的symbol。<br>复合值（compound value）——对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来赋值/传递。</p><h2 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h2><p>String() / Number() / Boolean() / Array() / Object() / Function() / RegExp() / Date() / Error() / Symbol()<br>原生函数可以被当作构造函数来使用<br>通过构造函数（如new String(“abc”)）创建出来的是封装了基本类型值（如”abc”）的<strong>封装对象</strong></p><p><strong>内部属性[[class]]</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString().call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// '[object Array]'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString().call(<span class="regexp">/regex-literal/i</span>) <span class="comment">// '[object RegExp]'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString().call(<span class="string">'abc'</span>) <span class="comment">// '[object String]'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString().call(<span class="number">42</span>) <span class="comment">// '[object Number]'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString().call(<span class="literal">true</span>) <span class="comment">// '[object Boolean]'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString().call(<span class="literal">null</span>) <span class="comment">// '[object Null]'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString().call(<span class="literal">undefined</span>) <span class="comment">// '[object Undefined]'</span></span><br></pre></td></tr></table></figure><p><strong>封装对象包装</strong><br>就是隐式转换成复杂类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'abc'</span></span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase() <span class="comment">// 'ABC'</span></span><br></pre></td></tr></table></figure><p><strong>拆封</strong><br>就是转换成简单数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">a.valueOf() <span class="comment">// 'abc'</span></span><br><span class="line">b.valueOf() <span class="comment">// 42</span></span><br><span class="line">c.valueOf() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>原生函数作为构造函数</strong></p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况<br>隐式的情况称为强制类型转换（coercion）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> b = a + <span class="string">''</span>  <span class="comment">// 隐式强制类型转换</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="built_in">String</span>(a)  <span class="comment">// 显式强制类型转换</span></span><br></pre></td></tr></table></figure><h3 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h3><p><strong>ToString</strong></p><p>对普通对象来说，除非自行定义，否则toString()（<code>Object.prototype.toString()</code>）返回内部属性<code>[[Class]]</code>的值，如<code>&quot;[object Object]&quot;</code>。<br>数组的默认toString()方法经过了重新定义，将所有单元字符串化以后再用”, “连接起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1.07</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span></span><br><span class="line">a.toString() <span class="comment">// '1.07e21'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b.toString() <span class="comment">// '1,2,3'</span></span><br></pre></td></tr></table></figure><p><strong>ToNumber</strong></p><blockquote><p>true转换为1, false转换为0。undefined转换为NaN, null转换为0</p></blockquote><p><strong>ToBoolean</strong><br>假值（falsy value）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">false</span> </span><br><span class="line">+<span class="number">0</span></span><br><span class="line"><span class="number">-0</span></span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="string">""</span></span><br></pre></td></tr></table></figure><h3 id="显式强制类型转换"><a href="#显式强制类型转换" class="headerlink" title="显式强制类型转换"></a>显式强制类型转换</h3><p>1.字符串和数字之间的显式转换<br><strong>字符串和数字之间的显式转换</strong><br>主要是 + 运算符在这里的运用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> b = a.toString()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">'3.14'</span></span><br><span class="line"><span class="keyword">let</span> d = +c</span><br><span class="line"></span><br><span class="line">b <span class="comment">// '42'</span></span><br><span class="line">d <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><p><strong>奇特的~运算符</strong><br>~x大致等同于-(x+1)。很奇怪，但相对更容易说明问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">42</span> <span class="comment">// -(42+1) ==&gt; -43</span></span><br></pre></td></tr></table></figure><p>indexOf() 中 <code>&gt;= 0</code>和<code>== -1</code>这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实现细节，这里是指用-1作为失败时的返回值，这些细节应该被屏蔽掉。<br>现在我们终于明白<del>有什么用处了！</del>和indexOf()一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值</p><p><strong>字位截除</strong><br><code>~~</code> 和<code>！！</code>很相似<br>对<code>~~</code>我们要多加注意。首先它只适用于32位数字，更重要的是它对负数的处理与Math. floor(..)不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">-49.6</span>) <span class="comment">// 50</span></span><br><span class="line">~~<span class="number">-49.6</span> <span class="comment">// -49</span></span><br></pre></td></tr></table></figure><p>2.显式解析数字字符串<br>解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别。<br>解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'42'</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'42px'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(a) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">parseInt</span>(a) <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(b) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(b) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>3.显式转换为布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="number">0</span></span><br><span class="line">! d  <span class="comment">// true</span></span><br><span class="line">!! d <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> a = f ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h3><p>1.字符串和数字之间的隐式强制类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'42'</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'0'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> y = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a + b <span class="comment">// '420'</span></span><br><span class="line">c + d <span class="comment">// 42</span></span><br><span class="line">x + y <span class="comment">// '1,23,4'</span></span><br></pre></td></tr></table></figure><p>之前的文章中提到了<a href="https://jambo0624.github.io/2018-11-03-implicit-conversion.html">隐式转换</a>更详细的内容</p><p>2.布尔值到数字的隐式强制类型转换<br>3.隐式强制类型转换为布尔值<br>4.<code>||</code> 和 <code>&amp;&amp;</code><br>5.符号(Symbol)的强制类型转换<br>Symbol<strong>不能</strong>够被强制类型转换为<strong>数字</strong>（显式和隐式都会产生错误），但<strong>可以</strong>被强制类型转换为<strong>布尔值</strong>（显式和隐式结果都是true）</p><h3 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h3><p>宽松相等（loose equals）==和严格相等（strict equals）===都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上<br><strong>正确的解释是：“==允许在相等比较中进行强制类型转换，而===不允许。”</strong></p><p>1.两种相等比较的性能<br>如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用==，没有就用===，不用在乎性能。</p><p>2.抽象相等<br>2.1 字符串和数字之间的相等比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'42'</span></span><br><span class="line"></span><br><span class="line">a === b <span class="comment">//false</span></span><br><span class="line">a == b <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>具体怎么转换？是a从42转换为字符串，还是b从”42”转换为数字？<br>ES5规范11.9.3.4-5这样定义：<br>(1) 如果Type(x)是数字，Type(y)是字符串，则返回x == ToNumber(y)的结果。<br>(2) 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果。</p><p>2.2 其他类型和布尔类型之间的相等比较<br>规范11.9.3.6-7是这样说的：<br>(1) 如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果；<br>(2) 如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果。</p><p>2.3 null和undefined之间的相等比较<br>ES5规范11.9.3.2-3规定：<br>(1) 如果x为null, y为undefined，则结果为true。<br>(2) 如果x为undefined, y为null，则结果为true。</p><p>2.4 对象和非对象之间的相等比较<br>ES5规范11.9.3.8-9做如下规定：<br>(1) 如果Type(x)是字符串或数字，Type(y)是对象，则返回x == ToPrimitive(y)的结果；<br>(2) 如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPrimitive(x) == y的结果。</p><h3 id="比较少见的情况"><a href="#比较少见的情况" class="headerlink" title="比较少见的情况"></a>比较少见的情况</h3><p>1.返回其他数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">2</span> &amp;&amp; a==<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Yep, this happened.'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应该正确合理地运用强制类型转换，避免这些极端的情况。<br>2.假值的相等比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'0'</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'0'</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">''</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == [] <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">''</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">''</span> == [] <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == [] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>3.极端例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// [] == false</span></span><br></pre></td></tr></table></figure><p>4.完整性检查<br><strong>5.安全运用隐式强制类型转换</strong><br>我们要对==两边的值认真推敲，以下两个原则可以让我们有效地避免出错。<br>• 如果两边的值中有true或者false，千万不要使用==。<br>• 如果两边的值中有[]、””或者0，尽量不要使用==。<br>这时最好用===来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前读了《你不知道的javaScript》系列的上卷，感觉对于理解 js 的核心概念十分有效。&lt;br&gt;最近又将中卷的部分读完了，下面对于中卷的内容进行一些记录。&lt;br&gt;中卷主要是分语法和类型，异步和性能两方面。下面我们开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>读《图解 HTTP》 (三)</title>
    <link href="https://jambo0624.github.io/2019-03-01-iconography-http-3.html"/>
    <id>https://jambo0624.github.io/2019-03-01-iconography-http-3.html</id>
    <published>2019-03-01T12:38:09.000Z</published>
    <updated>2020-09-30T01:51:28.612Z</updated>
    
    <content type="html"><![CDATA[<p>读《图解HTTP》，现在将关于<strong>安全</strong>的部分整理一下，分享出来。内容如下：</p><a id="more"></a><h2 id="确保-Web-安全的HTTPS"><a href="#确保-Web-安全的HTTPS" class="headerlink" title="确保 Web 安全的HTTPS"></a>确保 Web 安全的HTTPS</h2><h3 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h3><blockquote><p>通信使用明文（不加密），内容可能会被窃听<br>不验证通信方的身份，因此有可能遭遇伪装<br>无法证明报文的完整性，所以有可能已遭篡改</p></blockquote><p><strong>使用明文可能会被窃听，加密处理防止被窃听</strong></p><p>一种手段是将通信加密。<br>HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全传输层协议）的组合使用，加密HTTP的通信内容。<br>用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。<br><strong>与SSL组合使用的HTTP</strong>被称为<strong>HTTPS</strong>（HTTP Secure，超文本传输安全协议）或HTTP overSSL。</p><p>另一种手段是<strong>对参与通信的内容本身加密</strong>的方式。</p><p><strong>不验证通信方的身份就可能遭遇伪装</strong></p><p>虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。<br>SSL不仅提供加密处理，而且还使用了一种被称为<strong>证书</strong>的手段，可用于确定方。</p><blockquote><p>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。<br>另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。<br>通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。<br>另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节。</p></blockquote><p><strong>无法证明报文完整性，可能已遭篡改</strong><br>换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的</p><h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP + 加密 + 认证 + 完整性保护 = HTTPS"></a><strong>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</strong></h3><p><strong>HTTPS是身披SSL外壳的HTTP</strong></p><p>HTTPS并非是应用层的一种新协议。<br>只是HTTP通信接口部分用SSL（SecureSocket Layer）和TLS（Transport Layer Security）协议代替而已。<br>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。<br>简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。<br>原来<code>HTTP=&gt;TCP=&gt;IP</code>,现在<code>HTTP=&gt;SSL=&gt;TCP=&gt;IP</code></p><p><strong>相互交换密钥的公开密钥加密技术</strong></p><blockquote><p>公开密钥加密使用一对非对称的密钥。一把叫做<strong>私有密钥（private key）</strong>，另一把叫做<strong>公开密钥（public key）</strong>。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。<br>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。<br>另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</p></blockquote><p>因为公开密钥加密与共享密钥加密相比，其处理速度要慢。所以HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。即在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p><p><strong>证明公开密钥正确性的证书</strong><br>遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥<br>为了解决上述问题，可以使用由数字证书认证机构（CA,Certificate Authority）和其相关机关颁发的公开密钥证书。</p><p><strong>HTTPS的安全通信机制</strong><br>HTTPS的通信步骤<br><img src="https://s1.ax1x.com/2020/09/27/0kA9Zd.jpg" alt="https.jpg"><br>步骤1： 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤2： 服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。<br>步骤3： 之后服务器发送Certificate报文。报文中包含公开密钥证书。<br>步骤4： 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。</p><p>步骤5: SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。<br>步骤6： 接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。<br>步骤7： 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p><p>步骤8： 服务器同样发送Change Cipher Spec报文。<br>步骤9： 服务器同样发送Finished报文。</p><p>步骤10： 服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</p><p>步骤11： 应用层协议通信，即发送HTTP响应。</p><p>步骤12： 最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。</p><h2 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h2><p>核对的信息通常是指以下这些。</p><blockquote><p>密码：只有本人才会知道的字符串信息。<br>动态令牌：仅限本人持有的设备内显示的一次性密码。<br>数字证书：仅限本人（终端）持有的信息。<br>生物认证：指纹和虹膜等本人的生理信息。<br>IC卡等：仅限本人持有的信息。   </p></blockquote><p><strong>服务端认证方式</strong>，比较常用的是<code>基于表单验证</code><br>基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。<br>就是<strong>Session管理及Cookie应用</strong></p><h2 id="Web-的攻击技术"><a href="#Web-的攻击技术" class="headerlink" title="Web 的攻击技术"></a>Web 的攻击技术</h2><p>针对Web应用的攻击模式</p><ul><li>主动攻击: SQL注入攻击和OS命令注入攻击等</li><li>被动攻击: 跨站脚本攻击和跨站点请求伪造等</li></ul><h2 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="headerlink" title="因输出值转义不完全引发的安全漏洞"></a>因输出值转义不完全引发的安全漏洞</h2><h3 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h3><p>跨站脚本攻击（Cross-Site Scripting,XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。<br>动态创建的HTML部分有可能隐藏着安全漏洞。(<strong>如script标签等</strong>)<br>就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。<br>危害:</p><ul><li>利用虚假输入表单骗取用户个人信息。<ul><li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li></ul></li><li>显示伪造的文章或图片。</li></ul><h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><p>SQL注入（SQL Injection）是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。<br>该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。(<strong>单双引号</strong>)<br>危害:</p><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务器业务关联的程序等</li></ul><h3 id="OS命令注入攻击"><a href="#OS命令注入攻击" class="headerlink" title="OS命令注入攻击"></a>OS命令注入攻击</h3><p>OS命令注入攻击（OS Command Injection）是指通过Web应用，执行非法的操作系统命令达到攻击的目的。<br>只要在能调用Shell函数的地方就有存在被攻击的风险。</p><h3 id="HTTP首部注入攻击"><a href="#HTTP首部注入攻击" class="headerlink" title="HTTP首部注入攻击"></a>HTTP首部注入攻击</h3><p>HTTP首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。<br>向首部主体内添加内容的攻击称为HTTP响应截断攻击（HTTP Response SplittingAttack）<br>危害:</p><ul><li>设置任何Cookie信息</li><li>重定向至任意URL</li><li>显示任意的主体（HTTP响应截断攻击）</li></ul><h2 id="因设置或设计上的缺陷引发的安全漏洞"><a href="#因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="因设置或设计上的缺陷引发的安全漏洞"></a>因设置或设计上的缺陷引发的安全漏洞</h2><h3 id="强制浏览"><a href="#强制浏览" class="headerlink" title="强制浏览"></a>强制浏览</h3><p>强制浏览（Forced Browsing）安全漏洞是指，从安置在Web服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。<br>危害:</p><ul><li>泄露顾客的个人信息等重要情报</li><li>泄露原本需要具有访问权限的用户才可查阅的信息内容</li><li>泄露未外连到外界的文件</li></ul><h3 id="不正确的错误消息处理"><a href="#不正确的错误消息处理" class="headerlink" title="不正确的错误消息处理"></a>不正确的错误消息处理</h3><p>不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web应用的错误信息内包含对攻击者有用的信息。</p><h3 id="开放重定向"><a href="#开放重定向" class="headerlink" title="开放重定向"></a>开放重定向</h3><p>开放重定向（Open Redirect）是一种对指定的任意URL作重定向跳转的功能。<br>而与此功能相关联的安全漏洞是指，假如指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导至那个Web网站。</p><h3 id="因会话管理疏忽引发的安全漏洞"><a href="#因会话管理疏忽引发的安全漏洞" class="headerlink" title="因会话管理疏忽引发的安全漏洞"></a>因会话管理疏忽引发的安全漏洞</h3><p>会话劫持会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击的目的。<br>途径:</p><ul><li>通过非正规的生成方法推测会话ID</li><li>通过窃听或XSS攻击盗取会话ID</li><li>通过会话固定攻击（Session Fixation）强行获取会话ID</li></ul><h3 id="会话固定攻击"><a href="#会话固定攻击" class="headerlink" title="会话固定攻击"></a>会话固定攻击</h3><p>对以窃取目标会话ID为主动攻击手段的会话劫持而言，会话固定攻击（SessionFixation）会强制用户使用攻击者指定的会话ID，属于被动攻击。</p><h3 id="跨站点请求伪造"><a href="#跨站点请求伪造" class="headerlink" title="跨站点请求伪造"></a>跨站点请求伪造</h3><p>跨站点请求伪造（Cross-Site Request Forgeries,CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。<br>危害:</p><ul><li>利用已通过认证的用户权限更新设定信息等</li><li>利用已通过认证的用户权限购买商品</li><li>利用已通过认证的用户权限在留言板上发表言论</li></ul><h3 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h3><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><p>DoS攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。<br>有时也叫做服务停止攻击或拒绝服务攻击。<br>DoS攻击的对象不仅限于Web网站，还包括网络设备及服务器等。(大量合法请求)</p><h3 id="后门程序"><a href="#后门程序" class="headerlink" title="后门程序"></a>后门程序</h3><p>后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。<br>利用后门程序就能够使用原本受限制的功能。<br>类别:</p><ul><li>开发阶段作为Debug调用的后门程序</li><li>开发者为了自身利益植入的后门程序</li><li>攻击者通过某种方法设置的后门程序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读《图解HTTP》，现在将关于&lt;strong&gt;安全&lt;/strong&gt;的部分整理一下，分享出来。内容如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="https://jambo0624.github.io/categories/http/"/>
    
    
      <category term="http" scheme="https://jambo0624.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题的处理</title>
    <link href="https://jambo0624.github.io/2019-02-20-cross-domain.html"/>
    <id>https://jambo0624.github.io/2019-02-20-cross-domain.html</id>
    <published>2019-02-20T04:04:40.000Z</published>
    <updated>2020-09-22T07:32:21.009Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下跨域问题处理的过程。</p><a id="more"></a><p>实际场景<br>需求主要是一个话题互动页面，在评论框中需满足能够上传图片的要求，需求看似平平常常，处理起来也没什么太大的问题，那就开干吧。</p><p>页面依赖的插件<br><code>zepto.js</code><br><code>plupload.js</code></p><p>实际场景的代码片段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 评论框中的 dom 结构</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-reply-modal-uploadimg j-post-reply-modal-uploadimg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"plupload-content j-plupload-content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"plupload-content-btn j-plupload-content-btn"</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span><span class="comment">&lt;!-- 上传的按钮dom --&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"plupload-content-success j-plupload-content-success"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"success-img j-success-img"</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"delete-img j-delete-img"</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 plupload 上传图片插件事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> uploader = <span class="keyword">new</span> plupload.Uploader(&#123;</span><br><span class="line">    runtimes: <span class="string">'html5,html4,flash,silverlight'</span>,</span><br><span class="line">    browse_button: $(<span class="string">'.j-plupload-content-btn'</span>),</span><br><span class="line">    url: uploadImgAPI,  <span class="comment">// 在本地选择文件后通过请求上传图片信息到服务器的url</span></span><br><span class="line">    flash_swf_url: <span class="string">'../assets/scripts/upload/moxie.swf'</span>,</span><br><span class="line">    silverlight_xap_url: <span class="string">'../assets/scripts/upload/moxie.xap'</span>,</span><br><span class="line">    headers: &#123;&#125;,</span><br><span class="line">    chunk_size: <span class="number">0</span>,</span><br><span class="line">    max_retries: <span class="number">1</span>,</span><br><span class="line">    file_data_name: <span class="string">'file'</span>,</span><br><span class="line">    multi_selection: <span class="literal">false</span>,</span><br><span class="line">    multipart: <span class="literal">true</span>,</span><br><span class="line">    required_features: &#123;</span><br><span class="line">      send_browser_cookies: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    filters: &#123;</span><br><span class="line">      mime_types: [</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">'Image files'</span>, <span class="attr">extensions</span>: <span class="string">'jpg,jpeg,png,gif'</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">      prevent_duplicates: <span class="literal">false</span>,</span><br><span class="line">      max_file_size: <span class="string">'10240kb'</span>,</span><br><span class="line">      max_file_count: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    init: &#123;</span><br><span class="line">      Init: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化执行的操作</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      FilesAdded: <span class="function">(<span class="params">up, files</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 上传队列数据加载完后执行start对数据进行上传</span></span><br><span class="line">        uploader.start();</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      FileUploaded: <span class="function">(<span class="params">up, files, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在数据通过接口上传完后处理当前数据在页面上的显示</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Error</span>: <span class="function">(<span class="params">up, err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 上传图片过程中出现错误可以在这里操作</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'---'</span>, up, err);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  uploader.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，结果报错。为什么上传图片到服务器不成功？<br>报错如下：<br><img src="https://s1.ax1x.com/2020/09/22/wLLoy6.jpg" alt="wLLoy6.jpg"></p><p>很明显，这是跨域的报错。<br>一个域名地址的组成：</p><table><thead><tr><th>http://</th><th>www.</th><th>xxx.com</th><th>:8080</th><th>files/filsname</th></tr></thead><tbody><tr><td>协议</td><td>子域名</td><td>主域名</td><td>端口号</td><td>请求资源地址</td></tr></tbody></table><p>当协议、子域名、主域名、端口号中任一不相同时都不能算做同域，在不同域之间互相请求资源时就算作‘跨域’</p><p>常见跨域处理<br><strong>1.常见的 jsonp 跨域</strong><br>虽然在页面上调用不同域的接口不被允许，但是调用不同域的资源(如js脚本)是被允许的，jsonp 则正是利用这个特性来进行跨域数据请求处理。<br>比如在 <code>a.html</code> 页面上，它里面的代码需要利用 ajax 获取不同域上的 json 数据，假设数据地址是 <code>http://b.com/data.php</code><br>那么 <code>a.html</code> 中的代码可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">jsonData</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理获取的 json 数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src='http:/</span><span class="regexp">/b.com/</span>data.php?jsonpcallback=doSomething<span class="string">'&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>因为后端代码是当做一个js文件来引入的，则它必须返回的是一个能执行的js文件，即后端代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;php?</span><br><span class="line">  $jsonpcallback = $_GET[<span class="string">'jsonpcallback'</span>];</span><br><span class="line">  $data = array(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line">  echo $jsonpcallback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>最终页面上会输出<code>doSomething([‘a’,’b’,’c’])</code>，即这样我们就可以通过jsonp获取跨域的请求数据了。</p><p><strong>2.XHR2(html5)处理跨域方式</strong><br>html5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能，这个功能就很方便，在所有的现代浏览器中基本上已经全部支持，如果是开发 h5 页面的话基本上不用考虑支持的问题<br>在使用的时候客户端不用做任何事情，只需要服务端修改支持跨域的几个请求头即可:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Credentials'</span>:<span class="string">'true'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Headers'</span>:<span class="string">'x-requested-with'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Methods'</span>:<span class="string">'POST, GET, OPTIONS, PUT, DELETE, HEAD'</span></span><br></pre></td></tr></table></figure><p>这些请求头设置可以根据自己的需要按需设置。</p><p>因为兼容性要求不高，自己直接采用了最新的XHR2跨域的处理方式，后端修改支持即可</p><p>但是由于奇葩的测试环境和线上环境，这里的跨域在当前梳理的时候一直不能成功，检查：<br>后端添加允许跨域已完成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'特定的网站地址'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Credentials'</span>:<span class="string">'true'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Headers'</span>:<span class="string">'x-requested-with'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Methods'</span>:<span class="string">'POST, GET, OPTIONS, PUT, DELETE, HEAD'</span></span><br></pre></td></tr></table></figure><p>正常情况，前端此时不需要做其他设置是能够成功发送请求的，但是这里就是不讲道理<br>和后端沟通后得知，请求已经成功，但是他们的验证用户是否登录是直接校验的请求带回的 cookie 中是否有用户标识</p><p>查看请求如下<br><img src="https://s1.ax1x.com/2020/09/22/wLv8hQ.jpg" alt="wLv8hQ.jpg"><br>cookie情况如下<br><img src="https://s1.ax1x.com/2020/09/22/wLvJpj.jpg" alt="wLvJpj.jpg"></p><p>从图中可见， cookie 存在，而 cookie 本来在请求是是会自动将值带上的，但是在域不同的时候肯定是不会自动将值加入<br>那么这里就是这个原因造成的，但是在js代码中处理了一波 cookie 的 domain 是允许跨域的地址后再次发起请求<br>问题依旧存在，请求如图：<br><img src="https://s1.ax1x.com/2020/09/22/wLzWFO.jpg" alt="wLzWFO.jpg"></p><p>option 请求简单理解：例如在接口发起post请求处于跨域情况下，首先会自动发送一个option请求到服务器进行确认<br>如果成功，就再发起一次本来是post请求到服务器且服务器返回成功信息<br>若服务器不允许，那么这里就拜拜咯，下面的操作仍然不能继续</p><p>这里有一个需要注意的点，这个时候前端是无能为力的，需要后端将option请求的操作进行一个处理，让此操作也能成功跨域，并且上图中的 origin 一定注意，也要设置成允许跨域的地址(允许所有就是*，特定某个地址就设置成具体的某个地址)</p><p>经过前后端共同努力，问题最终得到了解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下跨域问题处理的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="ajax" scheme="https://jambo0624.github.io/tags/ajax/"/>
    
      <category term="jsonp" scheme="https://jambo0624.github.io/tags/jsonp/"/>
    
      <category term="CORS" scheme="https://jambo0624.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>记录type为file的input要点击两次才弹出选择文件窗口</title>
    <link href="https://jambo0624.github.io/2019-01-17-input-file-bug.html"/>
    <id>https://jambo0624.github.io/2019-01-17-input-file-bug.html</id>
    <published>2019-01-17T11:04:40.000Z</published>
    <updated>2020-09-22T07:31:32.568Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下遇到的一个问题。<br>背景是这样的，工作中遇到了一个需要处理上传图片的场景。插件使用 plupload.js ，最先找官方网站代码参考了一番。</p><a id="more"></a><p>官网的测试代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"filelist"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"plupload-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"browse"</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>[点击上传文件]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span> -- <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"start-upload"</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>[Start Upload]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">"console"</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moxie.swf,moxie.xap这两个文件也是从官网下载</span></span><br><span class="line"><span class="keyword">var</span> uploader = <span class="keyword">new</span> plupload.Uploader(&#123;</span><br><span class="line">    runtimes : <span class="string">'html5,html4,flash,silverlight'</span>,</span><br><span class="line">    browse_button: <span class="string">'browse'</span>,</span><br><span class="line">    url: <span class="string">''</span>,</span><br><span class="line">    flash_swf_url: <span class="string">'../js/moxie.swf'</span>,</span><br><span class="line">    silverlight_xap_url: <span class="string">'../js/moxie.xap'</span>,</span><br><span class="line">    chunk_size: <span class="number">0</span>,</span><br><span class="line">    max_retries: <span class="number">1</span>,</span><br><span class="line">    multi_selection: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    filters: &#123;</span><br><span class="line">      mime_types : [],</span><br><span class="line">      prevent_duplicates: <span class="literal">true</span>,</span><br><span class="line">      max_file_size: <span class="string">'10240kb'</span>,</span><br><span class="line">      max_file_count: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">uploader.init();</span><br><span class="line"></span><br><span class="line">uploader.bind(<span class="string">'FilesAdded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">up, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html = <span class="string">''</span>;</span><br><span class="line">    plupload.each(files, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">      html += <span class="string">'&lt;li id="'</span> + file.id + <span class="string">'"&gt;'</span> + file.name + <span class="string">' ('</span> + plupload.formatSize(file.size) + <span class="string">') &lt;b&gt;&lt;/b&gt;&lt;/li&gt;'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'filelist'</span>).innerHTML += html;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">uploader.bind(<span class="string">'UploadProgress'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">up, file</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(file.id).getElementsByTagName(<span class="string">'b'</span>)[<span class="number">0</span>].innerHTML = <span class="string">'&lt;span&gt;'</span> + file.percent + <span class="string">"%&lt;/span&gt;"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">uploader.bind(<span class="string">'Error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">up, err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'console'</span>).innerHTML += <span class="string">"\nError #"</span> + err.code + <span class="string">": "</span> + err.message;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start-upload'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  uploader.start();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>实际使用</strong></p><ul><li>引入plupload.full.min.js并开始使用</li><li>在官网将此插件代码下载到本地，在项目中引入*.js，然后依次将测试中的代码复制到正式项目，启动运行</li><li>此时发现无论如何点击上传文件打开选择文件夹按钮始终没生效，点击没有任何反应</li><li>通过断点依次执行，OK，页面没有任何异常，该执行的都执行了，但是就是没有打开选择文件夹按钮</li><li>通过仔细观察发现，双击打开选择文件夹按钮就能成功打开当前选择文件夹</li><li>这是因为 plupload.js 文件有一个 browse_button 属性，它的作用是触发文件选择对话框的DOM元素，当点击该元素后便后弹出文件选择对话框。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"html5_1c14fq5te5gq90lpa1j2q8ip4_container"</span> <span class="attr">class</span>=<span class="string">"moxie-shim moxie-shim-html5"</span> <span class="attr">style</span>=<span class="string">"position: absolute;top: 0px;left: 0px;width: 100%;height: 100%;overflow: hidden;z-index: 1;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"html5_1c14fq5te5gq90lpa1j2q8ip4"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">style</span>=<span class="string">"font-size: 999px; opacity: 0; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;"</span> <span class="attr">accept</span>=<span class="string">""</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>发现此时的 div 已经浮动并且其width、height值都等于0，则input的width、height在此时100%的情况下也等于0，导致点击我们自己设置的上传按钮时不能够触发当前的file，就不会触发打开选择文件夹事件</li><li>简单有效的方法是给此 div 重置一个样式让其覆盖在我们自定义的点击按钮上，让其透明，不是真正的display:none，此时点击就没问题了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下遇到的一个问题。&lt;br&gt;背景是这样的，工作中遇到了一个需要处理上传图片的场景。插件使用 plupload.js ，最先找官方网站代码参考了一番。&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://jambo0624.github.io/categories/html/"/>
    
    
      <category term="html" scheme="https://jambo0624.github.io/tags/html/"/>
    
      <category term="input" scheme="https://jambo0624.github.io/tags/input/"/>
    
      <category term="file" scheme="https://jambo0624.github.io/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>读《图解 HTTP》 (二)</title>
    <link href="https://jambo0624.github.io/2018-12-02-iconography-http-2.html"/>
    <id>https://jambo0624.github.io/2018-12-02-iconography-http-2.html</id>
    <published>2018-12-02T07:22:09.000Z</published>
    <updated>2020-09-27T03:33:57.758Z</updated>
    
    <content type="html"><![CDATA[<p>图解系列书籍，是一系列简单易读的介绍计算机相关知识的书籍。<br>最近在读《图解HTTP》，之前写了一部分笔记，现在将剩下的一些感悟写完：</p><a id="more"></a><h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><h3 id="HTTP-报文首部"><a href="#HTTP-报文首部" class="headerlink" title="HTTP 报文首部"></a>HTTP 报文首部</h3><p><strong>HTTP请求报文</strong>由方法、URI、HTTP版本、HTTP首部字段等部分构成<br><strong>HTTP响应报文</strong>由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分构成</p><h3 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h3><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容</p><p>据实际用途可分四类：<br>通用首部字段</p><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存行为</td></tr><tr><td>Connection</td><td>逐跳首部、连接的管理</td></tr><tr><td>Date</td><td>创建报文的时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><p>请求首部字段</p><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Coding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的自然语言</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记(ETag)</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记(与 If-Match 相反)</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体Byte的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间(与 If-Modified-Since 相反)</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>对请求中URI的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><p>响应首部字段</p><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接收字节范围内请求</td></tr><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端定向至指定URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信心</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><p>实体首部字段</p><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的HTTP方法</td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小(单位: 字节)</td></tr><tr><td>Content-Location</td><td>替代对应资源的URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h3 id="End-to-end首部和Hop-by-hop首部"><a href="#End-to-end首部和Hop-by-hop首部" class="headerlink" title="End-to-end首部和Hop-by-hop首部"></a>End-to-end首部和Hop-by-hop首部</h3><p><strong>端到端首部（End-to-end Header）</strong>,会转发给请求/响应对应的最终接收目标<br><strong>逐跳首部（Hop-by-hop Header）</strong>,只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1和之后版本中，如果要使用hop-by-hop首部，需<strong>提供Connection首部字段</strong><br><strong>除</strong>这8个首部字段之外，其他所有字段都<strong>属于端到端首部</strong></p><blockquote><p>Connection<br>Keep-Alive<br>Proxy-Authenticate<br>Proxy-Authorization<br>Trailer<br>TE<br>Transfer-Encoding<br>Upgrade</p></blockquote><p><strong>使用以上字段要配合 Connection，一起使用</strong> </p><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p><code>Cache-control</code><br>应用HTTP/1.1版本的缓存服务器遇到同时存在Expires首部字段的情况时，会<strong>优先处理max-age</strong>指令，而忽略掉Expires首部字段。<br>而HTTP/1.0版本的缓存服务器的情况却相反，max-age指令会被忽略掉。</p><p><code>Connection</code><br>控制不再转发给代理的首部字段<br><img src="https://s1.ax1x.com/2020/09/27/0F2aLt.jpg" alt="connection.jpg"><br>管理持久连接: Connection: Keep-Alive</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图解系列书籍，是一系列简单易读的介绍计算机相关知识的书籍。&lt;br&gt;最近在读《图解HTTP》，之前写了一部分笔记，现在将剩下的一些感悟写完：&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="https://jambo0624.github.io/categories/http/"/>
    
    
      <category term="http" scheme="https://jambo0624.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>读《图解 HTTP》</title>
    <link href="https://jambo0624.github.io/2018-12-01-iconography-http.html"/>
    <id>https://jambo0624.github.io/2018-12-01-iconography-http.html</id>
    <published>2018-12-01T01:59:04.000Z</published>
    <updated>2020-09-26T05:17:22.445Z</updated>
    
    <content type="html"><![CDATA[<p>图解系列书籍，是一系列简单易读的介绍计算机相关知识的书籍。最近在读《图解HTTP》，下面是一些感悟：</p><a id="more"></a><h2 id="通过-HTTP-访问-web"><a href="#通过-HTTP-访问-web" class="headerlink" title="通过 HTTP 访问 web"></a>通过 HTTP 访问 web</h2><h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为<strong>协议（protocol）</strong></p><p>把与互联网相关联的协议集合起来总称为TCP/IP。也有说法认为，TCP/IP是指TCP和IP这两种协议。还有一种说法认为，TCP/IP是在IP协议的通信过程中，使用到的协议族的统称。</p><h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><p>TCP/IP协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层。</p><p>每层只要考虑分派给自己的任务，不需要弄清整个协议链路的细节。</p><p><strong>应用层</strong><br>应用层决定了<strong>向用户提供应用服务时</strong>通信的活动。TCP/IP协议族内预存了各类通用的应用服务。比如，FTP（File TransferProtocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。<strong>HTTP协议也处于该层。</strong></p><p><strong>传输层</strong><br>传输层对上层应用层，提供处于网络连接中的<strong>两台计算机之间</strong>的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。</p><p><strong>网络层</strong><br>网络层用来<strong>处理</strong>在网络上流动的<strong>数据包</strong>。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p><p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p><p><strong>链路层（又名数据链路层，网络接口层）</strong><br>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。<strong>硬件</strong>上的范畴均在链路层的作用范围之内。</p><p><img src="https://s1.ax1x.com/2020/09/26/0P14VU.jpg" alt="http.jpg"></p><h3 id="IP-TCP-DNS"><a href="#IP-TCP-DNS" class="headerlink" title="IP/TCP/DNS"></a>IP/TCP/DNS</h3><p><strong>负责传输的IP协议，在网络层</strong><br>IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址（Media AccessControl Address）</p><p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。</p><p>IP间的通信依赖MAC地址。在网络上，通信的双方需要多只传输才能把数据传到对方。此时通常会利用下一站中转设备的MAC地址来搜索下一个中转目标。此时会用到ARP，<strong>ARP协议<code>Address Resolution Protocol</code></strong>是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p><p><strong>确保可靠性的TCP协议，在传输层</strong><br>TCP协议为了更容易传送大数据才<strong>把数据分割</strong>，而且TCP协议能够确认数据最终是否送达到对方。</p><p>为了准确无误地将数据送达目标处，TCP协议采用了三次握手（three-wayhandshaking）策略。</p><p>即<code>SYN(synchronize, 同步) =&gt; SYN/ACK =&gt; ACK(acknowledgement，确认)</code></p><p><strong>负责域名解析的DNS服务，在应用层</strong><br>DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。</p><h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>标准的URI协议方案有30种左右,如 ftp、mailto、telnet、file等</p><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。</p><p><strong>URI格式</strong>如下图：<br><img src="https://s1.ax1x.com/2020/09/26/0PJCRJ.jpg" alt="URI.jpg"></p><h2 id="简单的-HTTP-协议"><a href="#简单的-HTTP-协议" class="headerlink" title="简单的 HTTP 协议"></a>简单的 HTTP 协议</h2><p>通常 HTTP 协议由客户端发起，服务端接收</p><p>我们常</p><blockquote><p>使用 GET 来获取资源<br>使用 POST 传输实体主题<br>使用 PUT 传输文件<br>使用 DELETE 删除文件<br>使用 OPTIONS 询问支持的方法（常常在跨域的场景中使用）<br>使用TRACE 获取访问路径<br>使用 CONNECT 用隧道协议链接代理</p></blockquote><p>http 协议是一种无状态协议，不会去记录上一次访问状态，这使得当我们要做类似于登录这样的公能的时候，需要通过 cookie 来进行状态的管理。</p><h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h3><p><strong>持久连接</strong>(HTTP keep-alive)的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。<br>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。<br>另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度也就相应提高了。</p><p><strong>管线化</strong>(pipelining)技术出现后，不用等待响应亦可直接发送下一个请求。</p><h3 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h3><p>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。<br>当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。<br>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><h2 id="HTTP-报文内的-HTTP-信息"><a href="#HTTP-报文内的-HTTP-信息" class="headerlink" title="HTTP 报文内的 HTTP 信息"></a>HTTP 报文内的 HTTP 信息</h2><p><img src="https://s1.ax1x.com/2020/09/26/0PUE1e.jpg" alt="0PUE1e.jpg"></p><h3 id="压缩传输的内容编码-gzip-compress–UNIX系统的标准压缩-deflate-identity–不进行编码"><a href="#压缩传输的内容编码-gzip-compress–UNIX系统的标准压缩-deflate-identity–不进行编码" class="headerlink" title="压缩传输的内容编码(gzip, compress–UNIX系统的标准压缩, deflate, identity–不进行编码)"></a>压缩传输的内容编码(gzip, compress–UNIX系统的标准压缩, deflate, identity–不进行编码)</h3><h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。<br>这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）</p><h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a><strong>发送多种数据的多部分对象集合</strong></h3><p>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上<code>Content-type</code></p><h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line"><span class="attribute">Range</span>: bytes=5001-10000</span><br><span class="line"><span class="attribute">Range</span>: bytes=5001-</span><br><span class="line"><span class="attribute">Range</span>: bytes=-3000, 5000-7000</span><br></pre></td></tr></table></figure><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p><img src="https://s1.ax1x.com/2020/09/26/0P0ibd.jpg" alt="http-code.jpg"></p><p>2XX系列</p><blockquote><p>200 OK<br>204 No Content 没返回内容。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。<br>206 Partial Content 响应报文中包含由Content-Range指定范围的实体内容。</p></blockquote><p>3XX 系列</p><blockquote><p>301 Moved Permanently 永久性重定向<br>302 Found 临时性重定向<br>303 See Other 303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别<br>304 Not Modified 资源未更改<br>307 Temporary Redirect 和302类似，但是307会遵照浏览器标准，不会从POST变成GET</p></blockquote><p>4XX系列</p><blockquote><p>400 Bad Request 请求报文语法错误<br>401 Unauthorized 表示需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息<br>403 Forbidden 权限不够<br>404 Not Found 资源未找到</p></blockquote><p>5XX系列</p><blockquote><p>500 Internal Server Error 执行请求遇到了错误<br>503 Server Unavailable 宕机或停机维护</p></blockquote><h2 id="与-HTTP-协作的-Web-服务器"><a href="#与-HTTP-协作的-Web-服务器" class="headerlink" title="与 HTTP 协作的 Web 服务器"></a>与 HTTP 协作的 Web 服务器</h2><h3 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h3><p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。</p><h3 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h3><p><strong>代理</strong><br>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。<br>代理<strong>不改变</strong>请求URI，会直接发送给前方持有资源的目标服务器。</p><p><strong>网关</strong><br>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器<strong>提供非HTTP协议服务</strong>。<br>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。</p><p><strong>隧道</strong><br>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。<br>隧道的目的是确保客户端能与服务器进行安全的通信。</p><h3 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h3><p>缓存是指<strong>代理服务器</strong>或<strong>客户端本地磁盘</strong>内保存的<strong>资源副本</strong>。<br>利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。缓存有时效性。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图解系列书籍，是一系列简单易读的介绍计算机相关知识的书籍。最近在读《图解HTTP》，下面是一些感悟：&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="https://jambo0624.github.io/categories/http/"/>
    
    
      <category term="http" scheme="https://jambo0624.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (上卷)--对象原型》</title>
    <link href="https://jambo0624.github.io/2018-11-18-dont-know-js-first2.html"/>
    <id>https://jambo0624.github.io/2018-11-18-dont-know-js-first2.html</id>
    <published>2018-11-18T02:33:20.000Z</published>
    <updated>2020-09-26T02:38:56.996Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《你不知道的javaScript》系列书籍，这里做一些记录。<br>上卷主要分两部分，分别是作用域和闭包，this 和 对象原型。<br>这篇文章主要介绍对象原型这部分。</p><a id="more"></a><h1 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象可以通过两种形式定义：声明（文字）形式和构造形式。</p><p>对象是JavaScript的基础。在JavaScript中一共有六种主要类型（术语是“语言类型”）：</p><blockquote><p>string<br>number<br>boolean<br>null<br>undefined<br>object  </p></blockquote><p><strong>ES6 新增基本类型 Symbol</strong><br>注意，简单基本类型（string、boolean、number、null和undefined）本身并不是对象。<br>null有时会被当作一种对象类型，但是这其实只是语言本身的一个bug，即对null执行typeof null时会返回字符串”object”。实际上，null本身是基本类型</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>有些内置对象的名字看起来和简单基础类型一样，不过实际上它们的关系更复杂</p><blockquote><p>String<br>Number<br>Boolean<br>Object<br>Function<br>Array<br>Date<br>RegExp<br>Error </p></blockquote><p>这些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class），比如Java中的String类。<br>但是在JavaScript中，它们实际上只是一些内置函数。<br>这些内置函数可以当作构造函数（由new产生的函数调用）来使用，从而可以构造一个对应子类型的新对象。<br>举例来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">'I am a string'</span></span><br><span class="line"><span class="keyword">typeof</span> strPrimitive <span class="comment">// 'string'</span></span><br><span class="line">strPrimitive <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'I am a string'</span>)</span><br><span class="line"><span class="keyword">typeof</span> strObject <span class="comment">// 'object'</span></span><br><span class="line">strObject <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 sub-type 对象</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(strObject) <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure><p>思考下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">'I am a string'</span></span><br><span class="line"><span class="built_in">console</span>.log(strPrimitive.length) <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(strPrimitive.charAt(<span class="number">3</span>)) <span class="comment">// 'm'</span></span><br></pre></td></tr></table></figure><p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为<strong>引擎自动把字面量转换成String对象</strong>，所以可以访问属性和方法。</p><h2 id="对象里的内容相关"><a href="#对象里的内容相关" class="headerlink" title="对象里的内容相关"></a>对象里的内容相关</h2><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>对于JSON安全（也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，有一种巧妙的复制方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(someObj))</span><br></pre></td></tr></table></figure><p>ES6还定义了<code>Object.assign(..)</code>方法来实现浅复制<br><code>Object.assign(..)</code>方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。<br>它会遍历一个或多个源对象的所有<strong>可枚举</strong>（enumerable）的<strong>自有键</strong>（owned key）并把它们复制（使用=操作符赋值）到目标对象，最后返回目标对象，就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> anotherObject = &#123; <span class="attr">c</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">var</span> anotherArray = []</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: anotherObject, <span class="comment">// 引用，不是副本</span></span><br><span class="line">  c: anotherArray, <span class="comment">// 另一个引用</span></span><br><span class="line">  d: anotherFunction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, myObject)</span><br><span class="line"></span><br><span class="line">newObj.a <span class="comment">// 2</span></span><br><span class="line">newObj.b === anotherObject <span class="comment">// true</span></span><br><span class="line">newObj.c === anotherArray <span class="comment">// true</span></span><br><span class="line">newObj.d === anotherFunction <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>但是需要注意的一点是，由于Object.assign(..)就是使用=操作符来赋值，所以源对象属性的一些特性（比如writable）不会被复制到目标对象。</strong></p><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   value: 2,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject,<span class="string">"a"</span>,&#123;</span><br><span class="line">  writable:<span class="literal">false</span>,</span><br><span class="line">  configurable:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多个</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(myObject,&#123;</span><br><span class="line">  id:&#123;</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  name:&#123;</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>configurable 是类似于其他两个状态的锁。把configurable修改成false是单向操作，无法撤销！<br>同时 configurable 为 false的话，也<strong>无法删除</strong>这个<strong>属性</strong><br>要注意有一个小小的例外：即便属性是configurable:false，我们还是可以把writable的状态由true改为false，但是无法由false改为true。</p><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>很重要的一点是，所有的方法创建的都是浅不变性，也就是说，它们只会影响目标对象和它的直接属性。<br>如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的：</p><p>1．对象常量<br>结合writable:false和configurable:false就可以创建一个真正的常量属性（不可修改、重定义或者删除）</p><p>2．禁止扩展<br>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(..)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(myObject)</span><br><span class="line"></span><br><span class="line">myObject.b = <span class="number">3</span></span><br><span class="line">myObject.b <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 在非严格模式下，创建属性b会静默失败。在严格模式下，将会抛出TypeError错误</span></span><br></pre></td></tr></table></figure><p>3．密封<br>Object.seal(..)会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..)并把所有现有属性标记为configurable:false。<br>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）</p><p>4．冻结<br>Object.freeze(..)会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..)并把所有“数据访问”属性标记为writable:false，这样就无法修改它们的值。<br>这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的</p><h3 id="get-和-set"><a href="#get-和-set" class="headerlink" title="get 和 set"></a>get 和 set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="keyword">get</span> a() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.a &#125;</span><br><span class="line">  <span class="keyword">set</span> a(val) &#123; <span class="keyword">this</span>.a = val*<span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.a = <span class="number">2</span></span><br><span class="line">myObject.a <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际的 get 和 set</span></span><br><span class="line"><span class="keyword">var</span> eric = &#123; <span class="attr">id</span>:<span class="number">1001</span>, <span class="attr">name</span>:<span class="string">"埃里克"</span>, <span class="attr">_age</span>:<span class="number">21</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(eric,&#123;</span><br><span class="line">    _age:&#123; <span class="attr">enumerable</span>:<span class="literal">false</span>, <span class="attr">configurable</span>:<span class="literal">false</span> &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"自动调用age的get()"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._age;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"自动调用age的set()"</span>);</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= <span class="number">18</span> &amp;&amp; value &lt;= <span class="number">65</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._age = value;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"年龄必须介于18~65之间"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(eric.age);</span><br><span class="line">eric.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(eric);</span><br><span class="line">eric.age = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p><strong>in &amp; <code>hasOwnProperty(..)</code></strong><br>in操作符 <strong>会检查</strong> 属性是否在对象及其原型链中<br>相比之下，<code>hasOwnProperty(..)</code>只会检查属性是否在myObject对象中，<strong>不会检查</strong> 原型链</p><p>看起来in操作符可以检查容器内是否有某个值，但是它实际上<strong>检查的是某个属性名</strong>是否存在。<br>对于数组来说这个区别非常重要，4 in [2, 4, 6]的结果并不是你期待的True，因为[2, 4, 6]这个数组中包含的属性名是0、1、2，没有4。</p><p><strong>可枚举</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">'a'</span>, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">'b'</span>, &#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line">myObject.b <span class="comment">// 3</span></span><br><span class="line">(<span class="string">'b'</span> <span class="keyword">in</span> myObject) <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">'b'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> myObject)&#123;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k, myObject[k])</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="comment">// 'a' 2  </span></span><br><span class="line"><span class="comment">// 没有b，因为 for in 只遍历可枚举属性</span></span><br></pre></td></tr></table></figure><p>在数组上应用for..in循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。<br>最好只在对象上应用for..in循环，如果要遍历数组就使用传统的for循环来遍历数值索引</p><p><strong>另外一些可枚举 API</strong><br>obj.propertyIsEnumerable(..)会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足enumerable:true</p><p>Object.keys(..)会返回一个数组，包含所有可枚举属性<br>Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举<br>Object.keys(..)和Object.getOwnPropertyNames(..)都只会查找对象直接包含的属性</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>非常重要的一点是，我们讨论的父类和子类并不是实例。<br>父类和子类的比喻容易造成一些误解，实际上我们应当把父类和子类称为父类DNA和子类DNA</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Enemy</span>(<span class="params">fname,speed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fname = fname;</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">&#125;</span><br><span class="line">Enemy.prototype.fly = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.fname&#125;</span>以时速<span class="subst">$&#123;<span class="keyword">this</span>.speed&#125;</span>飞行`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plane</span>(<span class="params">fname,speed,score</span>) </span>&#123;</span><br><span class="line">    Enemy.call(<span class="keyword">this</span>,fname,speed)</span><br><span class="line">    <span class="comment">// 下面这样写，会导致 log(undefined以时速undefined飞行)</span></span><br><span class="line">    <span class="comment">// Enemy(fname,speed)</span></span><br><span class="line">    <span class="keyword">this</span>.score = score</span><br><span class="line">&#125;</span><br><span class="line">Plane.prototype.getScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`击落<span class="subst">$&#123;<span class="keyword">this</span>.fname&#125;</span>得<span class="subst">$&#123;<span class="keyword">this</span>.score&#125;</span>分`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Plane.prototype, Enemy.prototype)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f16 = <span class="keyword">new</span> Plane(<span class="string">"F16"</span>,<span class="number">1000</span>,<span class="number">5</span>)</span><br><span class="line">f16.fly();</span><br><span class="line">f16.getScore();</span><br><span class="line"><span class="built_in">console</span>.log(f16);</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一个函数，不同情况下表现出不同的状态     </p><ol><li>重载: 根据传入参数的不同，会返回不同的结果     </li><li>重写(override): 如果子对象觉得从父对象继承来的成员不好用，可在子对象本地定义同名成员，来覆盖父对象的成员。<br>如：顶级对象的toString()和 数组的toString()实现不一样的效果     </li></ol><p><strong>笔试题目: 判断一个对象是不是数组，共有几种方法:</strong><br>typeof仅能区分原始类型和function，无法进一步区分每种对象的类型     </p><ol><li>判断原型对象:<br> <code>obj.__proto__==Array.prototype</code><br> <code>Array.prototype.isPrototypeOf(obj)</code>     </li><li>判断构造函数:<br> <code>obj.constructor==Array</code><br> <code>obj instanceof Array</code><br> obj(是)Array的一个实例吗？<br> 问题: 以上两种方式，检查不严格，可能被篡改     </li><li>判断隐藏的class属性:<br> <code>Object.prototype.toString.call(obj1)</code>  this-&gt;obj1.class     </li><li><code>Array.isArray(obj)</code><br> 直接返回bool值<br> 原理同方法3，也是严格的检查     </li></ol><p><strong>小结</strong><br>传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。<br>多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。<br>JavaScript并不会（像类那样）自动创建对象的副本。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。<br><strong>几乎</strong>所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值。</p><p>所有普通的[[Prototype]]链最终都会指向内置的Object.prototype</p><p>根据理解总结几点：</p><blockquote><p>1.原型链的尽头（root）是Object.prototype。所有对象均从Object.prototype继承属性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__  <span class="comment">// null</span></span><br></pre></td></tr></table></figure><blockquote><p>2.Function.prototype和Function.<strong>proto</strong>为同一对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>.__proto__  <span class="comment">// true  </span></span><br><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Object</span>.__proto__  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Array</span>.__proto__  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 这意味着： Object/Array/String等等构造函数本质上和Function一样，均继承于Function.prototype。</span></span><br></pre></td></tr></table></figure><blockquote><p>3.Function.prototype直接继承root（Object.prototype）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// </span></span><br><span class="line">   <span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">// false</span></span><br><span class="line">   <span class="comment">// 通过这点我们可以弄清继承的原型链：</span></span><br><span class="line">   <span class="comment">// Object.prototype(root)&lt;---Function.prototype&lt;---Function|Object|Array...</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">以上3点比较容易理解，或者说规范里就这样定义的。由以上3点导出我们最后的问题：`</span><span class="built_in">Object</span><span class="string">`和`</span><span class="built_in">Function</span><span class="string">`的鸡和蛋的问题。</span></span><br><span class="line"><span class="string">回答这个问题，必须首先更深入一层去理解`</span><span class="built_in">Function</span>.prototype<span class="string">`这个对象，因为它是导致`</span><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span><span class="string">`和`</span><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span><span class="string">`都为`</span><span class="literal">true</span><span class="string">`的原因。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">看 ES 规范，得出：</span></span><br><span class="line"><span class="string">+ `</span><span class="built_in">Function</span>.prototype<span class="string">`是个不同于一般函数（对象）的函数（对象）。</span></span><br><span class="line"><span class="string">   + `</span><span class="built_in">Function</span>.prototype<span class="string">`像普通函数一样可以调用，但总是返回`</span><span class="literal">undefined</span><span class="string">`。</span></span><br><span class="line"><span class="string">   + 普通函数实际上是`</span><span class="built_in">Function</span><span class="string">`的实例，即普通函数继承于`</span><span class="built_in">Function</span>.prototype<span class="string">`，也就是 `</span>func.__proto__ === <span class="built_in">Function</span>.prototype<span class="string">`</span></span><br><span class="line"><span class="string">   + `</span><span class="built_in">Function</span>.prototype<span class="string">`继承于`</span><span class="built_in">Object</span>.prototype<span class="string">`，并且**没有`</span>prototype<span class="string">`这个属性**。`</span>func.prototype<span class="string">`是普通对象，`</span><span class="built_in">Function</span>.prototype.prototype<span class="string">`是`</span><span class="literal">null</span><span class="string">`。</span></span><br><span class="line"><span class="string">   + 所以，`</span><span class="built_in">Function</span>.prototype<span class="string">`其实是个另类的函数，可以独立于/先于`</span><span class="built_in">Function</span><span class="string">`产生。</span></span><br><span class="line"><span class="string">+ `</span><span class="built_in">Object</span><span class="string">`本身是个（构造）函数，是`</span><span class="built_in">Function</span><span class="string">`的实例，即`</span><span class="built_in">Object</span>.__proto__<span class="string">`就是`</span><span class="built_in">Function</span>.prototype<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**最后总结：先有Object.prototype（原型链顶端），Function.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承Function.prototype而产生。**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 原型本质</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt; 对象之间并非从属关系，而是委托关系，js中委托关系正是通过`</span><span class="built_in">Object</span>.create()<span class="string">`完成</span></span><br><span class="line"><span class="string">&gt; `</span><span class="built_in">Object</span>.create()<span class="string">`方法创建一个新对象，使用现有的对象来提供新创建的对象的`</span>__proto__<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">下面放两段代码，方便比较**类**和**委托**思维模型</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// 类/继承模型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.me = who;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.identify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  Foo.call( <span class="keyword">this</span>, who );</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create( Foo.prototype );</span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar( <span class="string">"b1"</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar( <span class="string">"b2"</span> );</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 委托模型</span></span><br><span class="line">Foo = &#123;</span><br><span class="line">  init(who) &#123;</span><br><span class="line">    <span class="keyword">this</span>.me = who;</span><br><span class="line">  &#125;,</span><br><span class="line">  identify() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bar = <span class="built_in">Object</span>.create( Foo );</span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Object</span>.create( Bar );</span><br><span class="line">b1.init( <span class="string">"b1"</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Object</span>.create( Bar );</span><br><span class="line">b2.init( <span class="string">"b2"</span> );</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure><p>类风格的代码强调的是实体与实体之间的关系，委托风格的代码强调的是对象之间的关联关系；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看《你不知道的javaScript》系列书籍，这里做一些记录。&lt;br&gt;上卷主要分两部分，分别是作用域和闭包，this 和 对象原型。&lt;br&gt;这篇文章主要介绍对象原型这部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>读《你不知道的js (上卷)》</title>
    <link href="https://jambo0624.github.io/2018-11-17-dont-know-js-first.html"/>
    <id>https://jambo0624.github.io/2018-11-17-dont-know-js-first.html</id>
    <published>2018-11-17T13:03:27.000Z</published>
    <updated>2020-09-26T02:38:56.999Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《你不知道的javaScript》系列书籍，这里做一些记录。<br>上卷主要分两部分，分别是作用域和闭包，this 和 对象原型。<br>下面我就分别介绍这两部分的内容。</p><a id="more"></a><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h2><p><strong>作用域</strong>是为了存储变量，并且之后可以方便地找到这些变量所设计的一套良好的规则；也可以说是根据名称查找变量的一套规则。</p><h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>当你看见var a = 2；这段程序时，很可能认为这是一句声明。<br>事实上编译器会进行如下处理。</p><ul><li>遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。</li><li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（查看1.3节）。如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会举手示意并抛出一个异常！</li></ul><p><strong>总结</strong>：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p><h3 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h3><p>查找变量的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。<br>当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。<br>下面有一个示例来具体分清 LHS 和 RHS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> a </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c= foo(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>1．找出所有的LHS查询（这里有3处！）<br><code>c=.. a=1 b=..</code><br>2．找出所有的RHS查询（这里有4处！）<br><code>foo(2..  =a  a.. ..b</code></p><h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p>当一个块或函数嵌套在另一个块或函数中时，就发生了<strong>作用域的嵌套</strong>。因此，在<strong>当前</strong>作用域中无法找到某个变量时，引擎就会在<strong>外层</strong>嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是<strong>全局</strong>作用域）为止。也就是所谓的<strong>作用域链</strong>。</p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作<strong>遮蔽效应</strong>（内部的标识符“遮蔽”了外部的标识符）</p><p><strong>欺骗词法作用域</strong>下面两种方法不提倡使用</p><blockquote><p>eval函数，修改词法作用域<br>with关键字，创建词法作用域</p></blockquote><h2 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h2><p>函数的块级作用域是从最小特权原则中引申出来的，也叫最小授权或<strong>最小暴露原则</strong>。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。<br>另一个好处就是可以<strong>规避冲突</strong>。“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。</p><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><blockquote><p>let 的「创建」过程被提升了，但是初始化没有提升。所以 let 会有暂时死区<br>var 的「创建」和「初始化」都被提升了。<br>function 的「创建」「初始化」和「赋值」都被提升了。所以同名时，函数权重最重</p></blockquote><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包，有权访问另外一个函数的变量标识符的函数。<br>比较常见的一个闭包问题，就是for循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现每一次输出的都是6。是因为所有的回调函数回在循环结束后才会执行（event loop）</p><p>解决办法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// IIFE 闭包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, j*<span class="number">1000</span>);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6 let 闭包 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(i);</span><br><span class="line">   &#125;, i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码的 mdn 解释</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">let</span> j = i;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(j);</span><br><span class="line">   &#125;, j*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个闭包常用的场景，就是<strong>模块暴露</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coolModule</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">'cool'</span></span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(another.join(<span class="string">' ! '</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doAnother: doAnother</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = coolModule()</span><br><span class="line"></span><br><span class="line">foo.doSomething() <span class="comment">// cool</span></span><br><span class="line">foo.doAnother() <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure><h1 id="this-和-对象原型"><a href="#this-和-对象原型" class="headerlink" title="this 和 对象原型"></a>this 和 对象原型</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。<br>找到之后就可以顺序应用下面这四条规则来判断this的绑定对象。优先级由低到高<br>1．由new调用？绑定到新创建的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bar.a)<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>2．由call或者apply（或者bind）调用？绑定到指定的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.call(obj)</span><br><span class="line">&#125;</span><br><span class="line">bar()<span class="comment">// 2</span></span><br><span class="line">setTimeout(bar, <span class="number">100</span>)<span class="comment">// 2</span></span><br><span class="line">bar.call(<span class="built_in">window</span>)<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>3．由上下文对象调用？绑定到那个上下文对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a:<span class="number">42</span>,</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  obj2: obj2</span><br><span class="line">&#125;</span><br><span class="line">obj1.obj2.foo()</span><br></pre></td></tr></table></figure><p>4．默认：在严格模式下绑定到undefined，否则绑定到全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo();<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">2</span></span><br><span class="line">foo2() <span class="comment">// typeerror</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  foo3()<span class="comment">// 2</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>一定要注意，有些调用可能在无意中使用默认绑定规则。<br>ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的this绑定（无论this绑定到什么）。<br>这其实和ES6之前代码中的self = this机制一样。</p><p>今天先到这里，还有原型对象的部分，下一篇文章在写。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看《你不知道的javaScript》系列书籍，这里做一些记录。&lt;br&gt;上卷主要分两部分，分别是作用域和闭包，this 和 对象原型。&lt;br&gt;下面我就分别介绍这两部分的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="core" scheme="https://jambo0624.github.io/tags/core/"/>
    
      <category term="reading-notes" scheme="https://jambo0624.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="https://jambo0624.github.io/2018-11-04-longest-substring-without-repeating-characters.html"/>
    <id>https://jambo0624.github.io/2018-11-04-longest-substring-without-repeating-characters.html</id>
    <published>2018-11-04T06:39:04.000Z</published>
    <updated>2020-09-23T11:11:48.126Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录在 freeCodeCamp 遇到的一些问题和解法。</p><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>longest-substring-without-repeating-characters<br>题目：给定一个字符串，找出不含有重复字符的最长子串的长度。<br>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入： "abcabcbb"</span></span><br><span class="line"><span class="comment">// 输出： 3</span></span><br><span class="line"><span class="comment">// 原因： 无重复字符的最长子串是 "abc"，其长度为 3</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>一、暴力解法<br>逐个检查所有子字符串，判断是否含有重复的字符；<br>就通过逐个检查就能想到这个方法肯定有很多层循环，还是一个一个的判断很消耗时间，虽然最终也能拿到正确的值，但是其时间复杂度很大。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断给定的子串是否包含重复字符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUnique</span>(<span class="params">str, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> chars = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = str[i];</span><br><span class="line">    <span class="keyword">if</span>(chars.indexOf(char) !== <span class="number">-1</span>) &#123; <span class="comment">// 字符已存在，本字符串不符合条件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chars.push(char); <span class="comment">// 添加字符</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串最长子串长度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt;= s.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(isUnique(s, i, j)) &#123; <span class="comment">// 判断子串是否唯一</span></span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, j - i); <span class="comment">// j - i 为当前子串长度</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: O(n^3)<br>i循环，j循环，isUnquie中的循环，3次循还嵌套<br>时间复杂度很高，容易超时</p><p>二、滑动窗口解法<br>滑动窗口，通过字面意思猜出一个大概，应该是把一个空间类似为窗口的移动，一段一段的进行操作；<br>其具体的说法是：</p><blockquote><p>滑动窗口是数组/字符串问题中常用的抽象概念；<br>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）；<br>而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j) 向右滑动1个元素，则它将变为 [i+1, j+1)（左闭，右开）。</p></blockquote><p>回到问题：<br>通过找到定义字符到索引的映射，当我们找到重复的字符时，我们可以立即跳过该窗口。<br>也就是说，如果 s[j] 在 [i, j) 范围内有与 j有重复的字符，我们不需要逐渐增加 i 。 我们可以直接跳过 [i，j) 范围内的所有元素，并将 i 变为 j + 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childStrMaxLenNumEvent</span>(<span class="params">strData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strLen = strData.length,</span><br><span class="line">      childStrMaxLen = <span class="number">0</span>,</span><br><span class="line">      storeChildStrObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; strLen; j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> curStr = strData.charAt(j);</span><br><span class="line">    <span class="keyword">if</span> (storeChildStrObj.hasOwnProperty(curStr)) &#123;</span><br><span class="line">      i = <span class="built_in">Math</span>.max(storeChildStrObj[curStr], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    childStrMaxLen = <span class="built_in">Math</span>.max(childStrMaxLen, j - i + <span class="number">1</span>);</span><br><span class="line">    storeChildStrObj[curStr] = j + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> childStrMaxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度： O(n)，只有索引 j 迭代了一遍，比暴力法好多了</p><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>之前在其他地方，看到了这样的一道题目</p><p>题目描述：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><blockquote><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p></blockquote><p>示例 2：</p><blockquote><p>输入: “cbbd”<br>输出: “bb”</p></blockquote><p>回文是在回文中心两侧互为镜像，因此，可以从它的中心展开，并且2n-1个中心。使用中心扩展法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longestPalindrome</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">    <span class="keyword">const</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> len = <span class="built_in">Math</span>.max(len1, len2);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">      start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      end = i + len / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expandAroundCenter</span>(<span class="params">s, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> L = left, R = right;</span><br><span class="line">  <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">    L--;</span><br><span class="line">    R++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录在 freeCodeCamp 遇到的一些问题和解法。&lt;/p&gt;
&lt;h3 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h3&gt;&lt;p&gt;longest-substring-without-repeating-characters&lt;br&gt;题目：给定一个字符串，找出不含有重复字符的最长子串的长度。&lt;br&gt;示例&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输入： &quot;abcabcbb&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出： 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 原因： 无重复字符的最长子串是 &quot;abc&quot;，其长度为 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://jambo0624.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://jambo0624.github.io/tags/js/"/>
    
      <category term="arithmetic" scheme="https://jambo0624.github.io/tags/arithmetic/"/>
    
  </entry>
  
</feed>
